(() => {
  var HF = Object.create;
  var od = Object.defineProperty,
    $F = Object.defineProperties,
    WF = Object.getOwnPropertyDescriptor,
    qF = Object.getOwnPropertyDescriptors,
    jF = Object.getOwnPropertyNames,
    PS = Object.getOwnPropertySymbols,
    XF = Object.getPrototypeOf,
    IS = Object.prototype.hasOwnProperty,
    YF = Object.prototype.propertyIsEnumerable;
  var Vs = Math.pow,
    DS = (n, e, t) =>
      e in n
        ? od(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
        : (n[e] = t),
    Ki = (n, e) => {
      for (var t in e || (e = {})) IS.call(e, t) && DS(n, t, e[t]);
      if (PS) for (var t of PS(e)) YF.call(e, t) && DS(n, t, e[t]);
      return n;
    },
    s0 = (n, e) => $F(n, qF(e));
  var jt = (n, e) => () => (
      e || n((e = { exports: {} }).exports, e), e.exports
    ),
    ld = (n, e) => {
      for (var t in e) od(n, t, { get: e[t], enumerable: !0 });
    },
    r0 = (n, e, t, i) => {
      if ((e && typeof e == "object") || typeof e == "function")
        for (let r of jF(e))
          !IS.call(n, r) &&
            r !== t &&
            od(n, r, {
              get: () => e[r],
              enumerable: !(i = WF(e, r)) || i.enumerable,
            });
      return n;
    },
    qi = (n, e, t) => (r0(n, e, "default"), t && r0(t, e, "default")),
    bn = (n, e, t) => (
      (t = n != null ? HF(XF(n)) : {}),
      r0(
        e || !n || !n.__esModule
          ? od(t, "default", { value: n, enumerable: !0 })
          : t,
        n
      )
    );
  var Fr = (n, e, t) =>
    new Promise((i, r) => {
      var s = (l) => {
          try {
            o(t.next(l));
          } catch (c) {
            r(c);
          }
        },
        a = (l) => {
          try {
            o(t.throw(l));
          } catch (c) {
            r(c);
          }
        },
        o = (l) => (l.done ? i(l.value) : Promise.resolve(l.value).then(s, a));
      o((t = t.apply(n, e)).next());
    });
  var Yu = jt((mv, gv) => {
    (function (n, e) {
      typeof mv == "object" && typeof gv != "undefined"
        ? (gv.exports = e())
        : typeof define == "function" && define.amd
        ? define(e)
        : ((n = n || self).barba = e());
    })(mv, function () {
      function n(q, j) {
        for (var A = 0; A < j.length; A++) {
          var D = j[A];
          (D.enumerable = D.enumerable || !1),
            (D.configurable = !0),
            "value" in D && (D.writable = !0),
            Object.defineProperty(q, D.key, D);
        }
      }
      function e(q, j, A) {
        return j && n(q.prototype, j), A && n(q, A), q;
      }
      function t() {
        return (t =
          Object.assign ||
          function (q) {
            for (var j = 1; j < arguments.length; j++) {
              var A = arguments[j];
              for (var D in A)
                Object.prototype.hasOwnProperty.call(A, D) && (q[D] = A[D]);
            }
            return q;
          }).apply(this, arguments);
      }
      function i(q, j) {
        (q.prototype = Object.create(j.prototype)),
          (q.prototype.constructor = q),
          (q.__proto__ = j);
      }
      function r(q) {
        return (r = Object.setPrototypeOf
          ? Object.getPrototypeOf
          : function (j) {
              return j.__proto__ || Object.getPrototypeOf(j);
            })(q);
      }
      function s(q, j) {
        return (s =
          Object.setPrototypeOf ||
          function (A, D) {
            return (A.__proto__ = D), A;
          })(q, j);
      }
      function a(q, j, A) {
        return (a = (function () {
          if (
            typeof Reflect == "undefined" ||
            !Reflect.construct ||
            Reflect.construct.sham
          )
            return !1;
          if (typeof Proxy == "function") return !0;
          try {
            return (
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              ),
              !0
            );
          } catch (D) {
            return !1;
          }
        })()
          ? Reflect.construct
          : function (D, V, Q) {
              var ee = [null];
              ee.push.apply(ee, V);
              var _e = new (Function.bind.apply(D, ee))();
              return Q && s(_e, Q.prototype), _e;
            }).apply(null, arguments);
      }
      function o(q) {
        var j = typeof Map == "function" ? new Map() : void 0;
        return (o = function (A) {
          if (
            A === null ||
            Function.toString.call(A).indexOf("[native code]") === -1
          )
            return A;
          if (typeof A != "function")
            throw new TypeError(
              "Super expression must either be null or a function"
            );
          if (j !== void 0) {
            if (j.has(A)) return j.get(A);
            j.set(A, D);
          }
          function D() {
            return a(A, arguments, r(this).constructor);
          }
          return (
            (D.prototype = Object.create(A.prototype, {
              constructor: {
                value: D,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })),
            s(D, A)
          );
        })(q);
      }
      function l(q, j) {
        try {
          var A = q();
        } catch (D) {
          return j(D);
        }
        return A && A.then ? A.then(void 0, j) : A;
      }
      typeof Symbol != "undefined" &&
        (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))),
        typeof Symbol != "undefined" &&
          (Symbol.asyncIterator ||
            (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
      var c,
        u = "2.9.7",
        f = function () {};
      (function (q) {
        (q[(q.off = 0)] = "off"),
          (q[(q.error = 1)] = "error"),
          (q[(q.warning = 2)] = "warning"),
          (q[(q.info = 3)] = "info"),
          (q[(q.debug = 4)] = "debug");
      })(c || (c = {}));
      var d = c.off,
        m = (function () {
          function q(A) {
            this.t = A;
          }
          (q.getLevel = function () {
            return d;
          }),
            (q.setLevel = function (A) {
              return (d = c[A]);
            });
          var j = q.prototype;
          return (
            (j.error = function () {
              for (
                var A = arguments.length, D = new Array(A), V = 0;
                V < A;
                V++
              )
                D[V] = arguments[V];
              this.i(console.error, c.error, D);
            }),
            (j.warn = function () {
              for (
                var A = arguments.length, D = new Array(A), V = 0;
                V < A;
                V++
              )
                D[V] = arguments[V];
              this.i(console.warn, c.warning, D);
            }),
            (j.info = function () {
              for (
                var A = arguments.length, D = new Array(A), V = 0;
                V < A;
                V++
              )
                D[V] = arguments[V];
              this.i(console.info, c.info, D);
            }),
            (j.debug = function () {
              for (
                var A = arguments.length, D = new Array(A), V = 0;
                V < A;
                V++
              )
                D[V] = arguments[V];
              this.i(console.log, c.debug, D);
            }),
            (j.i = function (A, D, V) {
              D <= q.getLevel() &&
                A.apply(console, ["[" + this.t + "] "].concat(V));
            }),
            q
          );
        })(),
        x = X,
        y = L,
        g = P,
        b = I,
        _ = U,
        E = "/",
        w = new RegExp(
          [
            "(\\\\.)",
            "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?",
          ].join("|"),
          "g"
        );
      function P(q, j) {
        for (
          var A,
            D = [],
            V = 0,
            Q = 0,
            ee = "",
            _e = (j && j.delimiter) || E,
            Re = (j && j.whitelist) || void 0,
            Ee = !1;
          (A = w.exec(q)) !== null;

        ) {
          var Se = A[0],
            st = A[1],
            Z = A.index;
          if (((ee += q.slice(Q, Z)), (Q = Z + Se.length), st))
            (ee += st[1]), (Ee = !0);
          else {
            var fe = "",
              Le = A[2],
              qe = A[3],
              ot = A[4],
              Ct = A[5];
            if (!Ee && ee.length) {
              var zt = ee.length - 1,
                gi = ee[zt];
              (!Re || Re.indexOf(gi) > -1) &&
                ((fe = gi), (ee = ee.slice(0, zt)));
            }
            ee && (D.push(ee), (ee = ""), (Ee = !1));
            var Ni = qe || ot,
              Pt = fe || _e;
            D.push({
              name: Le || V++,
              prefix: fe,
              delimiter: Pt,
              optional: Ct === "?" || Ct === "*",
              repeat: Ct === "+" || Ct === "*",
              pattern: Ni ? R(Ni) : "[^" + M(Pt === _e ? Pt : Pt + _e) + "]+?",
            });
          }
        }
        return (ee || Q < q.length) && D.push(ee + q.substr(Q)), D;
      }
      function L(q, j) {
        return function (A, D) {
          var V = q.exec(A);
          if (!V) return !1;
          for (
            var Q = V[0],
              ee = V.index,
              _e = {},
              Re = (D && D.decode) || decodeURIComponent,
              Ee = 1;
            Ee < V.length;
            Ee++
          )
            if (V[Ee] !== void 0) {
              var Se = j[Ee - 1];
              _e[Se.name] = Se.repeat
                ? V[Ee].split(Se.delimiter).map(function (st) {
                    return Re(st, Se);
                  })
                : Re(V[Ee], Se);
            }
          return { path: Q, index: ee, params: _e };
        };
      }
      function I(q, j) {
        for (var A = new Array(q.length), D = 0; D < q.length; D++)
          typeof q[D] == "object" &&
            (A[D] = new RegExp("^(?:" + q[D].pattern + ")$", O(j)));
        return function (V, Q) {
          for (
            var ee = "",
              _e = (Q && Q.encode) || encodeURIComponent,
              Re = !Q || Q.validate !== !1,
              Ee = 0;
            Ee < q.length;
            Ee++
          ) {
            var Se = q[Ee];
            if (typeof Se != "string") {
              var st,
                Z = V ? V[Se.name] : void 0;
              if (Array.isArray(Z)) {
                if (!Se.repeat)
                  throw new TypeError(
                    'Expected "' + Se.name + '" to not repeat, but got array'
                  );
                if (Z.length === 0) {
                  if (Se.optional) continue;
                  throw new TypeError(
                    'Expected "' + Se.name + '" to not be empty'
                  );
                }
                for (var fe = 0; fe < Z.length; fe++) {
                  if (((st = _e(Z[fe], Se)), Re && !A[Ee].test(st)))
                    throw new TypeError(
                      'Expected all "' +
                        Se.name +
                        '" to match "' +
                        Se.pattern +
                        '"'
                    );
                  ee += (fe === 0 ? Se.prefix : Se.delimiter) + st;
                }
              } else if (
                typeof Z != "string" &&
                typeof Z != "number" &&
                typeof Z != "boolean"
              ) {
                if (!Se.optional)
                  throw new TypeError(
                    'Expected "' +
                      Se.name +
                      '" to be ' +
                      (Se.repeat ? "an array" : "a string")
                  );
              } else {
                if (((st = _e(String(Z), Se)), Re && !A[Ee].test(st)))
                  throw new TypeError(
                    'Expected "' +
                      Se.name +
                      '" to match "' +
                      Se.pattern +
                      '", but got "' +
                      st +
                      '"'
                  );
                ee += Se.prefix + st;
              }
            } else ee += Se;
          }
          return ee;
        };
      }
      function M(q) {
        return q.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
      }
      function R(q) {
        return q.replace(/([=!:$/()])/g, "\\$1");
      }
      function O(q) {
        return q && q.sensitive ? "" : "i";
      }
      function U(q, j, A) {
        for (
          var D = (A = A || {}).strict,
            V = A.start !== !1,
            Q = A.end !== !1,
            ee = A.delimiter || E,
            _e = []
              .concat(A.endsWith || [])
              .map(M)
              .concat("$")
              .join("|"),
            Re = V ? "^" : "",
            Ee = 0;
          Ee < q.length;
          Ee++
        ) {
          var Se = q[Ee];
          if (typeof Se == "string") Re += M(Se);
          else {
            var st = Se.repeat
              ? "(?:" +
                Se.pattern +
                ")(?:" +
                M(Se.delimiter) +
                "(?:" +
                Se.pattern +
                "))*"
              : Se.pattern;
            j && j.push(Se),
              (Re += Se.optional
                ? Se.prefix
                  ? "(?:" + M(Se.prefix) + "(" + st + "))?"
                  : "(" + st + ")?"
                : M(Se.prefix) + "(" + st + ")");
          }
        }
        if (Q)
          D || (Re += "(?:" + M(ee) + ")?"),
            (Re += _e === "$" ? "$" : "(?=" + _e + ")");
        else {
          var Z = q[q.length - 1],
            fe = typeof Z == "string" ? Z[Z.length - 1] === ee : Z === void 0;
          D || (Re += "(?:" + M(ee) + "(?=" + _e + "))?"),
            fe || (Re += "(?=" + M(ee) + "|" + _e + ")");
        }
        return new RegExp(Re, O(A));
      }
      function X(q, j, A) {
        return q instanceof RegExp
          ? (function (D, V) {
              if (!V) return D;
              var Q = D.source.match(/\((?!\?)/g);
              if (Q)
                for (var ee = 0; ee < Q.length; ee++)
                  V.push({
                    name: ee,
                    prefix: null,
                    delimiter: null,
                    optional: !1,
                    repeat: !1,
                    pattern: null,
                  });
              return D;
            })(q, j)
          : Array.isArray(q)
          ? (function (D, V, Q) {
              for (var ee = [], _e = 0; _e < D.length; _e++)
                ee.push(X(D[_e], V, Q).source);
              return new RegExp("(?:" + ee.join("|") + ")", O(Q));
            })(q, j, A)
          : (function (D, V, Q) {
              return U(P(D, Q), V, Q);
            })(q, j, A);
      }
      (x.match = function (q, j) {
        var A = [];
        return L(X(q, A, j), A);
      }),
        (x.regexpToFunction = y),
        (x.parse = g),
        (x.compile = function (q, j) {
          return I(P(q, j), j);
        }),
        (x.tokensToFunction = b),
        (x.tokensToRegExp = _);
      var $ = {
          container: "container",
          history: "history",
          namespace: "namespace",
          prefix: "data-barba",
          prevent: "prevent",
          wrapper: "wrapper",
        },
        W = new ((function () {
          function q() {
            (this.o = $), (this.u = new DOMParser());
          }
          var j = q.prototype;
          return (
            (j.toString = function (A) {
              return A.outerHTML;
            }),
            (j.toDocument = function (A) {
              return this.u.parseFromString(A, "text/html");
            }),
            (j.toElement = function (A) {
              var D = document.createElement("div");
              return (D.innerHTML = A), D;
            }),
            (j.getHtml = function (A) {
              return (
                A === void 0 && (A = document), this.toString(A.documentElement)
              );
            }),
            (j.getWrapper = function (A) {
              return (
                A === void 0 && (A = document),
                A.querySelector(
                  "[" + this.o.prefix + '="' + this.o.wrapper + '"]'
                )
              );
            }),
            (j.getContainer = function (A) {
              return (
                A === void 0 && (A = document),
                A.querySelector(
                  "[" + this.o.prefix + '="' + this.o.container + '"]'
                )
              );
            }),
            (j.removeContainer = function (A) {
              document.body.contains(A) && A.parentNode.removeChild(A);
            }),
            (j.addContainer = function (A, D) {
              var V = this.getContainer();
              V ? this.s(A, V) : D.appendChild(A);
            }),
            (j.getNamespace = function (A) {
              A === void 0 && (A = document);
              var D = A.querySelector(
                "[" + this.o.prefix + "-" + this.o.namespace + "]"
              );
              return D
                ? D.getAttribute(this.o.prefix + "-" + this.o.namespace)
                : null;
            }),
            (j.getHref = function (A) {
              if (A.tagName && A.tagName.toLowerCase() === "a") {
                if (typeof A.href == "string") return A.href;
                var D = A.getAttribute("href") || A.getAttribute("xlink:href");
                if (D) return this.resolveUrl(D.baseVal || D);
              }
              return null;
            }),
            (j.resolveUrl = function () {
              for (
                var A = arguments.length, D = new Array(A), V = 0;
                V < A;
                V++
              )
                D[V] = arguments[V];
              var Q = D.length;
              if (Q === 0)
                throw new Error(
                  "resolveUrl requires at least one argument; got none."
                );
              var ee = document.createElement("base");
              if (((ee.href = arguments[0]), Q === 1)) return ee.href;
              var _e = document.getElementsByTagName("head")[0];
              _e.insertBefore(ee, _e.firstChild);
              for (
                var Re, Ee = document.createElement("a"), Se = 1;
                Se < Q;
                Se++
              )
                (Ee.href = arguments[Se]), (ee.href = Re = Ee.href);
              return _e.removeChild(ee), Re;
            }),
            (j.s = function (A, D) {
              D.parentNode.insertBefore(A, D.nextSibling);
            }),
            q
          );
        })())(),
        ue = new ((function () {
          function q() {
            (this.h = []), (this.v = -1);
          }
          var j = q.prototype;
          return (
            (j.init = function (A, D) {
              this.l = "barba";
              var V = {
                ns: D,
                scroll: { x: window.scrollX, y: window.scrollY },
                url: A,
              };
              this.h.push(V), (this.v = 0);
              var Q = { from: this.l, index: 0, states: [].concat(this.h) };
              window.history && window.history.replaceState(Q, "", A);
            }),
            (j.change = function (A, D, V) {
              if (V && V.state) {
                var Q = V.state,
                  ee = Q.index;
                (D = this.m(this.v - ee)),
                  this.replace(Q.states),
                  (this.v = ee);
              } else this.add(A, D);
              return D;
            }),
            (j.add = function (A, D) {
              var V = this.size,
                Q = this.p(D),
                ee = {
                  ns: "tmp",
                  scroll: { x: window.scrollX, y: window.scrollY },
                  url: A,
                };
              this.h.push(ee), (this.v = V);
              var _e = { from: this.l, index: V, states: [].concat(this.h) };
              switch (Q) {
                case "push":
                  window.history && window.history.pushState(_e, "", A);
                  break;
                case "replace":
                  window.history && window.history.replaceState(_e, "", A);
              }
            }),
            (j.update = function (A, D) {
              var V = D || this.v,
                Q = t({}, this.get(V), {}, A);
              this.set(V, Q);
            }),
            (j.remove = function (A) {
              A ? this.h.splice(A, 1) : this.h.pop(), this.v--;
            }),
            (j.clear = function () {
              (this.h = []), (this.v = -1);
            }),
            (j.replace = function (A) {
              this.h = A;
            }),
            (j.get = function (A) {
              return this.h[A];
            }),
            (j.set = function (A, D) {
              return (this.h[A] = D);
            }),
            (j.p = function (A) {
              var D = "push",
                V = A,
                Q = $.prefix + "-" + $.history;
              return (
                V.hasAttribute && V.hasAttribute(Q) && (D = V.getAttribute(Q)),
                D
              );
            }),
            (j.m = function (A) {
              return Math.abs(A) > 1
                ? A > 0
                  ? "forward"
                  : "back"
                : A === 0
                ? "popstate"
                : A > 0
                ? "back"
                : "forward";
            }),
            e(q, [
              {
                key: "current",
                get: function () {
                  return this.h[this.v];
                },
              },
              {
                key: "state",
                get: function () {
                  return this.h[this.h.length - 1];
                },
              },
              {
                key: "previous",
                get: function () {
                  return this.v < 1 ? null : this.h[this.v - 1];
                },
              },
              {
                key: "size",
                get: function () {
                  return this.h.length;
                },
              },
            ]),
            q
          );
        })())(),
        ae = function (q, j) {
          try {
            var A = (function () {
              if (!j.next.html)
                return Promise.resolve(q).then(function (D) {
                  var V = j.next;
                  if (D) {
                    var Q = W.toElement(D);
                    (V.namespace = W.getNamespace(Q)),
                      (V.container = W.getContainer(Q)),
                      (V.html = D),
                      ue.update({ ns: V.namespace });
                    var ee = W.toDocument(D);
                    document.title = ee.title;
                  }
                });
            })();
            return Promise.resolve(
              A && A.then ? A.then(function () {}) : void 0
            );
          } catch (D) {
            return Promise.reject(D);
          }
        },
        he = x,
        ce = {
          __proto__: null,
          update: ae,
          nextTick: function () {
            return new Promise(function (q) {
              window.requestAnimationFrame(q);
            });
          },
          pathToRegexp: he,
        },
        te = function () {
          return window.location.origin;
        },
        Me = function (q) {
          return q === void 0 && (q = window.location.href), ge(q).port;
        },
        ge = function (q) {
          var j,
            A = q.match(/:\d+/);
          if (A === null)
            /^http/.test(q) && (j = 80), /^https/.test(q) && (j = 443);
          else {
            var D = A[0].substring(1);
            j = parseInt(D, 10);
          }
          var V,
            Q = q.replace(te(), ""),
            ee = {},
            _e = Q.indexOf("#");
          _e >= 0 && ((V = Q.slice(_e + 1)), (Q = Q.slice(0, _e)));
          var Re = Q.indexOf("?");
          return (
            Re >= 0 && ((ee = pe(Q.slice(Re + 1))), (Q = Q.slice(0, Re))),
            { hash: V, path: Q, port: j, query: ee }
          );
        },
        pe = function (q) {
          return q.split("&").reduce(function (j, A) {
            var D = A.split("=");
            return (j[D[0]] = D[1]), j;
          }, {});
        },
        We = function (q) {
          return (
            q === void 0 && (q = window.location.href),
            q.replace(/(\/#.*|\/|#.*)$/, "")
          );
        },
        Fe = {
          __proto__: null,
          getHref: function () {
            return window.location.href;
          },
          getOrigin: te,
          getPort: Me,
          getPath: function (q) {
            return q === void 0 && (q = window.location.href), ge(q).path;
          },
          parse: ge,
          parseQuery: pe,
          clean: We,
        };
      function Be(q, j, A) {
        return (
          j === void 0 && (j = 2e3),
          new Promise(function (D, V) {
            var Q = new XMLHttpRequest();
            (Q.onreadystatechange = function () {
              if (Q.readyState === XMLHttpRequest.DONE) {
                if (Q.status === 200) D(Q.responseText);
                else if (Q.status) {
                  var ee = { status: Q.status, statusText: Q.statusText };
                  A(q, ee), V(ee);
                }
              }
            }),
              (Q.ontimeout = function () {
                var ee = new Error("Timeout error [" + j + "]");
                A(q, ee), V(ee);
              }),
              (Q.onerror = function () {
                var ee = new Error("Fetch error");
                A(q, ee), V(ee);
              }),
              Q.open("GET", q),
              (Q.timeout = j),
              Q.setRequestHeader(
                "Accept",
                "text/html,application/xhtml+xml,application/xml"
              ),
              Q.setRequestHeader("x-barba", "yes"),
              Q.send();
          })
        );
      }
      var be = function (q) {
        return (
          !!q &&
          (typeof q == "object" || typeof q == "function") &&
          typeof q.then == "function"
        );
      };
      function ut(q, j) {
        return (
          j === void 0 && (j = {}),
          function () {
            for (var A = arguments.length, D = new Array(A), V = 0; V < A; V++)
              D[V] = arguments[V];
            var Q = !1,
              ee = new Promise(function (_e, Re) {
                j.async = function () {
                  return (
                    (Q = !0),
                    function (Se, st) {
                      Se ? Re(Se) : _e(st);
                    }
                  );
                };
                var Ee = q.apply(j, D);
                Q || (be(Ee) ? Ee.then(_e, Re) : _e(Ee));
              });
            return ee;
          }
        );
      }
      var Ye = new ((function (q) {
          function j() {
            var D;
            return (
              ((D = q.call(this) || this).logger = new m("@barba/core")),
              (D.all = [
                "ready",
                "page",
                "reset",
                "currentAdded",
                "currentRemoved",
                "nextAdded",
                "nextRemoved",
                "beforeOnce",
                "once",
                "afterOnce",
                "before",
                "beforeLeave",
                "leave",
                "afterLeave",
                "beforeEnter",
                "enter",
                "afterEnter",
                "after",
              ]),
              (D.registered = new Map()),
              D.init(),
              D
            );
          }
          i(j, q);
          var A = j.prototype;
          return (
            (A.init = function () {
              var D = this;
              this.registered.clear(),
                this.all.forEach(function (V) {
                  D[V] ||
                    (D[V] = function (Q, ee) {
                      D.registered.has(V) || D.registered.set(V, new Set()),
                        D.registered.get(V).add({ ctx: ee || {}, fn: Q });
                    });
                });
            }),
            (A.do = function (D) {
              for (
                var V = this,
                  Q = arguments.length,
                  ee = new Array(Q > 1 ? Q - 1 : 0),
                  _e = 1;
                _e < Q;
                _e++
              )
                ee[_e - 1] = arguments[_e];
              if (this.registered.has(D)) {
                var Re = Promise.resolve();
                return (
                  this.registered.get(D).forEach(function (Ee) {
                    Re = Re.then(function () {
                      return ut(Ee.fn, Ee.ctx).apply(void 0, ee);
                    });
                  }),
                  Re.catch(function (Ee) {
                    V.logger.debug("Hook error [" + D + "]"),
                      V.logger.error(Ee);
                  })
                );
              }
              return Promise.resolve();
            }),
            (A.clear = function () {
              var D = this;
              this.all.forEach(function (V) {
                delete D[V];
              }),
                this.init();
            }),
            (A.help = function () {
              this.logger.info("Available hooks: " + this.all.join(","));
              var D = [];
              this.registered.forEach(function (V, Q) {
                return D.push(Q);
              }),
                this.logger.info("Registered hooks: " + D.join(","));
            }),
            j
          );
        })(f))(),
        _t = (function () {
          function q(j) {
            if (((this.P = []), typeof j == "boolean")) this.g = j;
            else {
              var A = Array.isArray(j) ? j : [j];
              this.P = A.map(function (D) {
                return he(D);
              });
            }
          }
          return (
            (q.prototype.checkHref = function (j) {
              if (typeof this.g == "boolean") return this.g;
              var A = ge(j).path;
              return this.P.some(function (D) {
                return D.exec(A) !== null;
              });
            }),
            q
          );
        })(),
        Ze = (function (q) {
          function j(D) {
            var V;
            return ((V = q.call(this, D) || this).k = new Map()), V;
          }
          i(j, q);
          var A = j.prototype;
          return (
            (A.set = function (D, V, Q) {
              return (
                this.k.set(D, { action: Q, request: V }),
                { action: Q, request: V }
              );
            }),
            (A.get = function (D) {
              return this.k.get(D);
            }),
            (A.getRequest = function (D) {
              return this.k.get(D).request;
            }),
            (A.getAction = function (D) {
              return this.k.get(D).action;
            }),
            (A.has = function (D) {
              return !this.checkHref(D) && this.k.has(D);
            }),
            (A.delete = function (D) {
              return this.k.delete(D);
            }),
            (A.update = function (D, V) {
              var Q = t({}, this.k.get(D), {}, V);
              return this.k.set(D, Q), Q;
            }),
            j
          );
        })(_t),
        kt = function () {
          return !window.history.pushState;
        },
        Et = function (q) {
          return !q.el || !q.href;
        },
        Y = function (q) {
          var j = q.event;
          return (
            j.which > 1 || j.metaKey || j.ctrlKey || j.shiftKey || j.altKey
          );
        },
        ie = function (q) {
          var j = q.el;
          return j.hasAttribute("target") && j.target === "_blank";
        },
        ye = function (q) {
          var j = q.el;
          return (
            (j.protocol !== void 0 &&
              window.location.protocol !== j.protocol) ||
            (j.hostname !== void 0 && window.location.hostname !== j.hostname)
          );
        },
        Pe = function (q) {
          var j = q.el;
          return j.port !== void 0 && Me() !== Me(j.href);
        },
        De = function (q) {
          var j = q.el;
          return (
            j.getAttribute && typeof j.getAttribute("download") == "string"
          );
        },
        Ie = function (q) {
          return q.el.hasAttribute($.prefix + "-" + $.prevent);
        },
        Ue = function (q) {
          return Boolean(
            q.el.closest("[" + $.prefix + "-" + $.prevent + '="all"]')
          );
        },
        Ve = function (q) {
          var j = q.href;
          return We(j) === We() && Me(j) === Me();
        },
        He = (function (q) {
          function j(D) {
            var V;
            return (
              ((V = q.call(this, D) || this).suite = []),
              (V.tests = new Map()),
              V.init(),
              V
            );
          }
          i(j, q);
          var A = j.prototype;
          return (
            (A.init = function () {
              this.add("pushState", kt),
                this.add("exists", Et),
                this.add("newTab", Y),
                this.add("blank", ie),
                this.add("corsDomain", ye),
                this.add("corsPort", Pe),
                this.add("download", De),
                this.add("preventSelf", Ie),
                this.add("preventAll", Ue),
                this.add("sameUrl", Ve, !1);
            }),
            (A.add = function (D, V, Q) {
              Q === void 0 && (Q = !0),
                this.tests.set(D, V),
                Q && this.suite.push(D);
            }),
            (A.run = function (D, V, Q, ee) {
              return this.tests.get(D)({ el: V, event: Q, href: ee });
            }),
            (A.checkLink = function (D, V, Q) {
              var ee = this;
              return this.suite.some(function (_e) {
                return ee.run(_e, D, V, Q);
              });
            }),
            j
          );
        })(_t),
        B = (function (q) {
          function j(A, D) {
            var V;
            D === void 0 && (D = "Barba error");
            for (
              var Q = arguments.length,
                ee = new Array(Q > 2 ? Q - 2 : 0),
                _e = 2;
              _e < Q;
              _e++
            )
              ee[_e - 2] = arguments[_e];
            return (
              ((V = q.call.apply(q, [this].concat(ee)) || this).error = A),
              (V.label = D),
              Error.captureStackTrace &&
                Error.captureStackTrace(
                  (function (Re) {
                    if (Re === void 0)
                      throw new ReferenceError(
                        "this hasn't been initialised - super() hasn't been called"
                      );
                    return Re;
                  })(V),
                  j
                ),
              (V.name = "BarbaError"),
              V
            );
          }
          return i(j, q), j;
        })(o(Error)),
        F = (function () {
          function q(A) {
            A === void 0 && (A = []),
              (this.logger = new m("@barba/core")),
              (this.all = []),
              (this.page = []),
              (this.once = []),
              (this.A = [
                { name: "namespace", type: "strings" },
                { name: "custom", type: "function" },
              ]),
              A && (this.all = this.all.concat(A)),
              this.update();
          }
          var j = q.prototype;
          return (
            (j.add = function (A, D) {
              switch (A) {
                case "rule":
                  this.A.splice(D.position || 0, 0, D.value);
                  break;
                case "transition":
                default:
                  this.all.push(D);
              }
              this.update();
            }),
            (j.resolve = function (A, D) {
              var V = this;
              D === void 0 && (D = {});
              var Q = D.once ? this.once : this.page;
              Q = Q.filter(
                D.self
                  ? function (Z) {
                      return Z.name && Z.name === "self";
                    }
                  : function (Z) {
                      return !Z.name || Z.name !== "self";
                    }
              );
              var ee = new Map(),
                _e = Q.find(function (Z) {
                  var fe = !0,
                    Le = {};
                  return (
                    !(!D.self || Z.name !== "self") ||
                    (V.A.reverse().forEach(function (qe) {
                      fe &&
                        ((fe = V.R(Z, qe, A, Le)),
                        Z.from &&
                          Z.to &&
                          (fe =
                            V.R(Z, qe, A, Le, "from") &&
                            V.R(Z, qe, A, Le, "to")),
                        Z.from && !Z.to && (fe = V.R(Z, qe, A, Le, "from")),
                        !Z.from && Z.to && (fe = V.R(Z, qe, A, Le, "to")));
                    }),
                    ee.set(Z, Le),
                    fe)
                  );
                }),
                Re = ee.get(_e),
                Ee = [];
              if (
                (Ee.push(D.once ? "once" : "page"),
                D.self && Ee.push("self"),
                Re)
              ) {
                var Se,
                  st = [_e];
                Object.keys(Re).length > 0 && st.push(Re),
                  (Se = this.logger).info.apply(
                    Se,
                    ["Transition found [" + Ee.join(",") + "]"].concat(st)
                  );
              } else
                this.logger.info("No transition found [" + Ee.join(",") + "]");
              return _e;
            }),
            (j.update = function () {
              var A = this;
              (this.all = this.all
                .map(function (D) {
                  return A.T(D);
                })
                .sort(function (D, V) {
                  return D.priority - V.priority;
                })
                .reverse()
                .map(function (D) {
                  return delete D.priority, D;
                })),
                (this.page = this.all.filter(function (D) {
                  return D.leave !== void 0 || D.enter !== void 0;
                })),
                (this.once = this.all.filter(function (D) {
                  return D.once !== void 0;
                }));
            }),
            (j.R = function (A, D, V, Q, ee) {
              var _e = !0,
                Re = !1,
                Ee = A,
                Se = D.name,
                st = Se,
                Z = Se,
                fe = Se,
                Le = ee ? Ee[ee] : Ee,
                qe = ee === "to" ? V.next : V.current;
              if (ee ? Le && Le[Se] : Le[Se]) {
                switch (D.type) {
                  case "strings":
                  default:
                    var ot = Array.isArray(Le[st]) ? Le[st] : [Le[st]];
                    qe[st] && ot.indexOf(qe[st]) !== -1 && (Re = !0),
                      ot.indexOf(qe[st]) === -1 && (_e = !1);
                    break;
                  case "object":
                    var Ct = Array.isArray(Le[Z]) ? Le[Z] : [Le[Z]];
                    qe[Z]
                      ? (qe[Z].name &&
                          Ct.indexOf(qe[Z].name) !== -1 &&
                          (Re = !0),
                        Ct.indexOf(qe[Z].name) === -1 && (_e = !1))
                      : (_e = !1);
                    break;
                  case "function":
                    Le[fe](V) ? (Re = !0) : (_e = !1);
                }
                Re &&
                  (ee
                    ? ((Q[ee] = Q[ee] || {}), (Q[ee][Se] = Ee[ee][Se]))
                    : (Q[Se] = Ee[Se]));
              }
              return _e;
            }),
            (j.O = function (A, D, V) {
              var Q = 0;
              return (
                (A[D] || (A.from && A.from[D]) || (A.to && A.to[D])) &&
                  ((Q += Math.pow(10, V)),
                  A.from && A.from[D] && (Q += 1),
                  A.to && A.to[D] && (Q += 2)),
                Q
              );
            }),
            (j.T = function (A) {
              var D = this;
              A.priority = 0;
              var V = 0;
              return (
                this.A.forEach(function (Q, ee) {
                  V += D.O(A, Q.name, ee + 1);
                }),
                (A.priority = V),
                A
              );
            }),
            q
          );
        })(),
        re = (function () {
          function q(A) {
            A === void 0 && (A = []),
              (this.logger = new m("@barba/core")),
              (this.S = !1),
              (this.store = new F(A));
          }
          var j = q.prototype;
          return (
            (j.get = function (A, D) {
              return this.store.resolve(A, D);
            }),
            (j.doOnce = function (A) {
              var D = A.data,
                V = A.transition;
              try {
                var Q = function () {
                    ee.S = !1;
                  },
                  ee = this,
                  _e = V || {};
                ee.S = !0;
                var Re = l(
                  function () {
                    return Promise.resolve(ee.j("beforeOnce", D, _e)).then(
                      function () {
                        return Promise.resolve(ee.once(D, _e)).then(
                          function () {
                            return Promise.resolve(
                              ee.j("afterOnce", D, _e)
                            ).then(function () {});
                          }
                        );
                      }
                    );
                  },
                  function (Ee) {
                    (ee.S = !1),
                      ee.logger.debug("Transition error [before/after/once]"),
                      ee.logger.error(Ee);
                  }
                );
                return Promise.resolve(Re && Re.then ? Re.then(Q) : Q());
              } catch (Ee) {
                return Promise.reject(Ee);
              }
            }),
            (j.doPage = function (A) {
              var D = A.data,
                V = A.transition,
                Q = A.page,
                ee = A.wrapper;
              try {
                var _e = function (fe) {
                    if (Re) return fe;
                    Ee.S = !1;
                  },
                  Re = !1,
                  Ee = this,
                  Se = V || {},
                  st = Se.sync === !0 || !1;
                Ee.S = !0;
                var Z = l(
                  function () {
                    function fe() {
                      return Promise.resolve(Ee.j("before", D, Se)).then(
                        function () {
                          var qe = !1;
                          function ot(zt) {
                            return qe
                              ? zt
                              : Promise.resolve(Ee.remove(D)).then(function () {
                                  return Promise.resolve(
                                    Ee.j("after", D, Se)
                                  ).then(function () {});
                                });
                          }
                          var Ct = (function () {
                            if (st)
                              return l(
                                function () {
                                  return Promise.resolve(Ee.add(D, ee)).then(
                                    function () {
                                      return Promise.resolve(
                                        Ee.j("beforeLeave", D, Se)
                                      ).then(function () {
                                        return Promise.resolve(
                                          Ee.j("beforeEnter", D, Se)
                                        ).then(function () {
                                          return Promise.resolve(
                                            Promise.all([
                                              Ee.leave(D, Se),
                                              Ee.enter(D, Se),
                                            ])
                                          ).then(function () {
                                            return Promise.resolve(
                                              Ee.j("afterLeave", D, Se)
                                            ).then(function () {
                                              return Promise.resolve(
                                                Ee.j("afterEnter", D, Se)
                                              ).then(function () {});
                                            });
                                          });
                                        });
                                      });
                                    }
                                  );
                                },
                                function (Pt) {
                                  if (Ee.M(Pt))
                                    throw new B(Pt, "Transition error [sync]");
                                }
                              );
                            var zt = function (Pt) {
                                return qe
                                  ? Pt
                                  : l(
                                      function () {
                                        var Xi = (function () {
                                          if (gi !== !1)
                                            return Promise.resolve(
                                              Ee.add(D, ee)
                                            ).then(function () {
                                              return Promise.resolve(
                                                Ee.j("beforeEnter", D, Se)
                                              ).then(function () {
                                                return Promise.resolve(
                                                  Ee.enter(D, Se, gi)
                                                ).then(function () {
                                                  return Promise.resolve(
                                                    Ee.j("afterEnter", D, Se)
                                                  ).then(function () {});
                                                });
                                              });
                                            });
                                        })();
                                        if (Xi && Xi.then)
                                          return Xi.then(function () {});
                                      },
                                      function (Xi) {
                                        if (Ee.M(Xi))
                                          throw new B(
                                            Xi,
                                            "Transition error [before/after/enter]"
                                          );
                                      }
                                    );
                              },
                              gi = !1,
                              Ni = l(
                                function () {
                                  return Promise.resolve(
                                    Ee.j("beforeLeave", D, Se)
                                  ).then(function () {
                                    return Promise.resolve(
                                      Promise.all([
                                        Ee.leave(D, Se),
                                        ae(Q, D),
                                      ]).then(function (Pt) {
                                        return Pt[0];
                                      })
                                    ).then(function (Pt) {
                                      return (
                                        (gi = Pt),
                                        Promise.resolve(
                                          Ee.j("afterLeave", D, Se)
                                        ).then(function () {})
                                      );
                                    });
                                  });
                                },
                                function (Pt) {
                                  if (Ee.M(Pt))
                                    throw new B(
                                      Pt,
                                      "Transition error [before/after/leave]"
                                    );
                                }
                              );
                            return Ni && Ni.then ? Ni.then(zt) : zt(Ni);
                          })();
                          return Ct && Ct.then ? Ct.then(ot) : ot(Ct);
                        }
                      );
                    }
                    var Le = (function () {
                      if (st)
                        return Promise.resolve(ae(Q, D)).then(function () {});
                    })();
                    return Le && Le.then ? Le.then(fe) : fe();
                  },
                  function (fe) {
                    throw (
                      ((Ee.S = !1),
                      fe.name && fe.name === "BarbaError"
                        ? (Ee.logger.debug(fe.label),
                          Ee.logger.error(fe.error),
                          fe)
                        : (Ee.logger.debug("Transition error [page]"),
                          Ee.logger.error(fe),
                          fe))
                    );
                  }
                );
                return Promise.resolve(Z && Z.then ? Z.then(_e) : _e(Z));
              } catch (fe) {
                return Promise.reject(fe);
              }
            }),
            (j.once = function (A, D) {
              try {
                return Promise.resolve(Ye.do("once", A, D)).then(function () {
                  return D.once ? ut(D.once, D)(A) : Promise.resolve();
                });
              } catch (V) {
                return Promise.reject(V);
              }
            }),
            (j.leave = function (A, D) {
              try {
                return Promise.resolve(Ye.do("leave", A, D)).then(function () {
                  return D.leave ? ut(D.leave, D)(A) : Promise.resolve();
                });
              } catch (V) {
                return Promise.reject(V);
              }
            }),
            (j.enter = function (A, D, V) {
              try {
                return Promise.resolve(Ye.do("enter", A, D)).then(function () {
                  return D.enter ? ut(D.enter, D)(A, V) : Promise.resolve();
                });
              } catch (Q) {
                return Promise.reject(Q);
              }
            }),
            (j.add = function (A, D) {
              try {
                return (
                  W.addContainer(A.next.container, D),
                  Ye.do("nextAdded", A),
                  Promise.resolve()
                );
              } catch (V) {
                return Promise.reject(V);
              }
            }),
            (j.remove = function (A) {
              try {
                return (
                  W.removeContainer(A.current.container),
                  Ye.do("currentRemoved", A),
                  Promise.resolve()
                );
              } catch (D) {
                return Promise.reject(D);
              }
            }),
            (j.M = function (A) {
              return A.message
                ? !/Timeout error|Fetch error/.test(A.message)
                : !A.status;
            }),
            (j.j = function (A, D, V) {
              try {
                return Promise.resolve(Ye.do(A, D, V)).then(function () {
                  return V[A] ? ut(V[A], V)(D) : Promise.resolve();
                });
              } catch (Q) {
                return Promise.reject(Q);
              }
            }),
            e(q, [
              {
                key: "isRunning",
                get: function () {
                  return this.S;
                },
                set: function (A) {
                  this.S = A;
                },
              },
              {
                key: "hasOnce",
                get: function () {
                  return this.store.once.length > 0;
                },
              },
              {
                key: "hasSelf",
                get: function () {
                  return this.store.all.some(function (A) {
                    return A.name === "self";
                  });
                },
              },
              {
                key: "shouldWait",
                get: function () {
                  return this.store.all.some(function (A) {
                    return (A.to && !A.to.route) || A.sync;
                  });
                },
              },
            ]),
            q
          );
        })(),
        ve = (function () {
          function q(j) {
            var A = this;
            (this.names = [
              "beforeLeave",
              "afterLeave",
              "beforeEnter",
              "afterEnter",
            ]),
              (this.byNamespace = new Map()),
              j.length !== 0 &&
                (j.forEach(function (D) {
                  A.byNamespace.set(D.namespace, D);
                }),
                this.names.forEach(function (D) {
                  Ye[D](A.L(D));
                }));
          }
          return (
            (q.prototype.L = function (j) {
              var A = this;
              return function (D) {
                var V = j.match(/enter/i) ? D.next : D.current,
                  Q = A.byNamespace.get(V.namespace);
                return Q && Q[j] ? ut(Q[j], Q)(D) : Promise.resolve();
              };
            }),
            q
          );
        })();
      Element.prototype.matches ||
        (Element.prototype.matches =
          Element.prototype.msMatchesSelector ||
          Element.prototype.webkitMatchesSelector),
        Element.prototype.closest ||
          (Element.prototype.closest = function (q) {
            var j = this;
            do {
              if (j.matches(q)) return j;
              j = j.parentElement || j.parentNode;
            } while (j !== null && j.nodeType === 1);
            return null;
          });
      var Te = {
        container: null,
        html: "",
        namespace: "",
        url: { hash: "", href: "", path: "", port: null, query: {} },
      };
      return new ((function () {
        function q() {
          (this.version = u),
            (this.schemaPage = Te),
            (this.Logger = m),
            (this.logger = new m("@barba/core")),
            (this.plugins = []),
            (this.hooks = Ye),
            (this.dom = W),
            (this.helpers = ce),
            (this.history = ue),
            (this.request = Be),
            (this.url = Fe);
        }
        var j = q.prototype;
        return (
          (j.use = function (A, D) {
            var V = this.plugins;
            V.indexOf(A) > -1
              ? this.logger.warn("Plugin [" + A.name + "] already installed.")
              : typeof A.install == "function"
              ? (A.install(this, D), V.push(A))
              : this.logger.warn(
                  "Plugin [" + A.name + '] has no "install" method.'
                );
          }),
          (j.init = function (A) {
            var D = A === void 0 ? {} : A,
              V = D.transitions,
              Q = V === void 0 ? [] : V,
              ee = D.views,
              _e = ee === void 0 ? [] : ee,
              Re = D.schema,
              Ee = Re === void 0 ? $ : Re,
              Se = D.requestError,
              st = D.timeout,
              Z = st === void 0 ? 2e3 : st,
              fe = D.cacheIgnore,
              Le = fe !== void 0 && fe,
              qe = D.prefetchIgnore,
              ot = qe !== void 0 && qe,
              Ct = D.preventRunning,
              zt = Ct !== void 0 && Ct,
              gi = D.prevent,
              Ni = gi === void 0 ? null : gi,
              Pt = D.debug,
              Xi = D.logLevel;
            if (
              (m.setLevel(
                (Pt !== void 0 && Pt) === !0
                  ? "debug"
                  : Xi === void 0
                  ? "off"
                  : Xi
              ),
              this.logger.info(this.version),
              Object.keys(Ee).forEach(function (fr) {
                $[fr] && ($[fr] = Ee[fr]);
              }),
              (this.$ = Se),
              (this.timeout = Z),
              (this.cacheIgnore = Le),
              (this.prefetchIgnore = ot),
              (this.preventRunning = zt),
              (this._ = this.dom.getWrapper()),
              !this._)
            )
              throw new Error("[@barba/core] No Barba wrapper found");
            this._.setAttribute("aria-live", "polite"), this.q();
            var xn = this.data.current;
            if (!xn.container)
              throw new Error("[@barba/core] No Barba container found");
            if (
              ((this.cache = new Ze(Le)),
              (this.prevent = new He(ot)),
              (this.transitions = new re(Q)),
              (this.views = new ve(_e)),
              Ni !== null)
            ) {
              if (typeof Ni != "function")
                throw new Error("[@barba/core] Prevent should be a function");
              this.prevent.add("preventCustom", Ni);
            }
            this.history.init(xn.url.href, xn.namespace),
              (this.B = this.B.bind(this)),
              (this.U = this.U.bind(this)),
              (this.D = this.D.bind(this)),
              this.F(),
              this.plugins.forEach(function (fr) {
                return fr.init();
              });
            var Rr = this.data;
            (Rr.trigger = "barba"),
              (Rr.next = Rr.current),
              (Rr.current = t({}, this.schemaPage)),
              this.hooks.do("ready", Rr),
              this.once(Rr),
              this.q();
          }),
          (j.destroy = function () {
            this.q(),
              this.H(),
              this.history.clear(),
              this.hooks.clear(),
              (this.plugins = []);
          }),
          (j.force = function (A) {
            window.location.assign(A);
          }),
          (j.go = function (A, D, V) {
            var Q;
            if ((D === void 0 && (D = "barba"), this.transitions.isRunning))
              this.force(A);
            else if (
              !(Q =
                D === "popstate"
                  ? this.history.current &&
                    this.url.getPath(this.history.current.url) ===
                      this.url.getPath(A)
                  : this.prevent.run("sameUrl", null, null, A)) ||
              this.transitions.hasSelf
            )
              return (
                (D = this.history.change(A, D, V)),
                V && (V.stopPropagation(), V.preventDefault()),
                this.page(A, D, Q)
              );
          }),
          (j.once = function (A) {
            try {
              var D = this;
              return Promise.resolve(D.hooks.do("beforeEnter", A)).then(
                function () {
                  function V() {
                    return Promise.resolve(D.hooks.do("afterEnter", A)).then(
                      function () {}
                    );
                  }
                  var Q = (function () {
                    if (D.transitions.hasOnce) {
                      var ee = D.transitions.get(A, { once: !0 });
                      return Promise.resolve(
                        D.transitions.doOnce({ transition: ee, data: A })
                      ).then(function () {});
                    }
                  })();
                  return Q && Q.then ? Q.then(V) : V();
                }
              );
            } catch (V) {
              return Promise.reject(V);
            }
          }),
          (j.page = function (A, D, V) {
            try {
              var Q = function () {
                  var Ee = ee.data;
                  return Promise.resolve(ee.hooks.do("page", Ee)).then(
                    function () {
                      var Se = l(
                        function () {
                          var st = ee.transitions.get(Ee, {
                            once: !1,
                            self: V,
                          });
                          return Promise.resolve(
                            ee.transitions.doPage({
                              data: Ee,
                              page: _e,
                              transition: st,
                              wrapper: ee._,
                            })
                          ).then(function () {
                            ee.q();
                          });
                        },
                        function () {
                          m.getLevel() === 0 && ee.force(Ee.current.url.href);
                        }
                      );
                      if (Se && Se.then) return Se.then(function () {});
                    }
                  );
                },
                ee = this;
              (ee.data.next.url = t({ href: A }, ee.url.parse(A))),
                (ee.data.trigger = D);
              var _e = ee.cache.has(A)
                  ? ee.cache.update(A, { action: "click" }).request
                  : ee.cache.set(
                      A,
                      ee.request(A, ee.timeout, ee.onRequestError.bind(ee, D)),
                      "click"
                    ).request,
                Re = (function () {
                  if (ee.transitions.shouldWait)
                    return Promise.resolve(ae(_e, ee.data)).then(
                      function () {}
                    );
                })();
              return Promise.resolve(Re && Re.then ? Re.then(Q) : Q());
            } catch (Ee) {
              return Promise.reject(Ee);
            }
          }),
          (j.onRequestError = function (A) {
            this.transitions.isRunning = !1;
            for (
              var D = arguments.length, V = new Array(D > 1 ? D - 1 : 0), Q = 1;
              Q < D;
              Q++
            )
              V[Q - 1] = arguments[Q];
            var ee = V[0],
              _e = V[1],
              Re = this.cache.getAction(ee);
            return (
              this.cache.delete(ee),
              !(
                (this.$ && this.$(A, Re, ee, _e) === !1) ||
                (Re === "click" && this.force(ee), 1)
              )
            );
          }),
          (j.prefetch = function (A) {
            var D = this;
            this.cache.has(A) ||
              this.cache.set(
                A,
                this.request(
                  A,
                  this.timeout,
                  this.onRequestError.bind(this, "barba")
                ).catch(function (V) {
                  D.logger.error(V);
                }),
                "prefetch"
              );
          }),
          (j.F = function () {
            this.prefetchIgnore !== !0 &&
              (document.addEventListener("mouseover", this.B),
              document.addEventListener("touchstart", this.B)),
              document.addEventListener("click", this.U),
              window.addEventListener("popstate", this.D);
          }),
          (j.H = function () {
            this.prefetchIgnore !== !0 &&
              (document.removeEventListener("mouseover", this.B),
              document.removeEventListener("touchstart", this.B)),
              document.removeEventListener("click", this.U),
              window.removeEventListener("popstate", this.D);
          }),
          (j.B = function (A) {
            var D = this,
              V = this.I(A);
            if (V) {
              var Q = this.dom.getHref(V);
              this.prevent.checkHref(Q) ||
                this.cache.has(Q) ||
                this.cache.set(
                  Q,
                  this.request(
                    Q,
                    this.timeout,
                    this.onRequestError.bind(this, V)
                  ).catch(function (ee) {
                    D.logger.error(ee);
                  }),
                  "enter"
                );
            }
          }),
          (j.U = function (A) {
            var D = this.I(A);
            if (D)
              return this.transitions.isRunning && this.preventRunning
                ? (A.preventDefault(), void A.stopPropagation())
                : void this.go(this.dom.getHref(D), D, A);
          }),
          (j.D = function (A) {
            this.go(this.url.getHref(), "popstate", A);
          }),
          (j.I = function (A) {
            for (var D = A.target; D && !this.dom.getHref(D); )
              D = D.parentNode;
            if (D && !this.prevent.checkLink(D, A, this.dom.getHref(D)))
              return D;
          }),
          (j.q = function () {
            var A = this.url.getHref(),
              D = {
                container: this.dom.getContainer(),
                html: this.dom.getHtml(),
                namespace: this.dom.getNamespace(),
                url: t({ href: A }, this.url.parse(A)),
              };
            (this.C = {
              current: D,
              next: t({}, this.schemaPage),
              trigger: void 0,
            }),
              this.hooks.do("reset", this.data);
          }),
          e(q, [
            {
              key: "data",
              get: function () {
                return this.C;
              },
            },
            {
              key: "wrapper",
              get: function () {
                return this._;
              },
            },
          ]),
          q
        );
      })())();
    });
  });
  var RP = jt((dt) => {
    "use strict";
    Object.defineProperty(dt, "__esModule", { value: !0 });
    function Kr(n, e) {
      let t = Object.create(null),
        i = n.split(",");
      for (let r = 0; r < i.length; r++) t[i[r]] = !0;
      return e ? (r) => !!t[r.toLowerCase()] : (r) => !!t[r];
    }
    var nH = {
        [1]: "TEXT",
        [2]: "CLASS",
        [4]: "STYLE",
        [8]: "PROPS",
        [16]: "FULL_PROPS",
        [32]: "HYDRATE_EVENTS",
        [64]: "STABLE_FRAGMENT",
        [128]: "KEYED_FRAGMENT",
        [256]: "UNKEYED_FRAGMENT",
        [512]: "NEED_PATCH",
        [1024]: "DYNAMIC_SLOTS",
        [2048]: "DEV_ROOT_FRAGMENT",
        [-1]: "HOISTED",
        [-2]: "BAIL",
      },
      rH = { [1]: "STABLE", [2]: "DYNAMIC", [3]: "FORWARDED" },
      sH =
        "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt",
      aH = Kr(sH),
      EP = 2;
    function oH(n, e = 0, t = n.length) {
      let i = n.split(/(\r?\n)/),
        r = i.filter((o, l) => l % 2 === 1);
      i = i.filter((o, l) => l % 2 === 0);
      let s = 0,
        a = [];
      for (let o = 0; o < i.length; o++)
        if (((s += i[o].length + ((r[o] && r[o].length) || 0)), s >= e)) {
          for (let l = o - EP; l <= o + EP || t > s; l++) {
            if (l < 0 || l >= i.length) continue;
            let c = l + 1;
            a.push(
              `${c}${" ".repeat(Math.max(3 - String(c).length, 0))}|  ${i[l]}`
            );
            let u = i[l].length,
              f = (r[l] && r[l].length) || 0;
            if (l === o) {
              let d = e - (s - (u + f)),
                m = Math.max(1, t > s ? u - d : t - e);
              a.push("   |  " + " ".repeat(d) + "^".repeat(m));
            } else if (l > o) {
              if (t > s) {
                let d = Math.max(Math.min(t - s, u), 1);
                a.push("   |  " + "^".repeat(d));
              }
              s += u + f;
            }
          }
          break;
        }
      return a.join(`
`);
    }
    var SP =
        "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
      lH = Kr(SP),
      cH = Kr(
        SP +
          ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"
      );
    function uH(n) {
      return !!n || n === "";
    }
    var hH = /[>/="'\u0009\u000a\u000c\u0020]/,
      qx = {};
    function fH(n) {
      if (qx.hasOwnProperty(n)) return qx[n];
      let e = hH.test(n);
      return e && console.error(`unsafe attribute name: ${n}`), (qx[n] = !e);
    }
    var dH = {
        acceptCharset: "accept-charset",
        className: "class",
        htmlFor: "for",
        httpEquiv: "http-equiv",
      },
      wP = Kr(
        "animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width"
      ),
      pH = Kr(
        "accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"
      ),
      mH = Kr(
        "xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"
      );
    function Yx(n) {
      if (yl(n)) {
        let e = {};
        for (let t = 0; t < n.length; t++) {
          let i = n[t],
            r = fa(i) ? MP(i) : Yx(i);
          if (r) for (let s in r) e[s] = r[s];
        }
        return e;
      } else {
        if (fa(n)) return n;
        if (oo(n)) return n;
      }
    }
    var gH = /;(?![^(]*\))/g,
      yH = /:(.+)/;
    function MP(n) {
      let e = {};
      return (
        n.split(gH).forEach((t) => {
          if (t) {
            let i = t.split(yH);
            i.length > 1 && (e[i[0].trim()] = i[1].trim());
          }
        }),
        e
      );
    }
    function vH(n) {
      let e = "";
      if (!n || fa(n)) return e;
      for (let t in n) {
        let i = n[t],
          r = t.startsWith("--") ? t : IP(t);
        (fa(i) || (typeof i == "number" && wP(r))) && (e += `${r}:${i};`);
      }
      return e;
    }
    function Kx(n) {
      let e = "";
      if (fa(n)) e = n;
      else if (yl(n))
        for (let t = 0; t < n.length; t++) {
          let i = Kx(n[t]);
          i && (e += i + " ");
        }
      else if (oo(n)) for (let t in n) n[t] && (e += t + " ");
      return e.trim();
    }
    function xH(n) {
      if (!n) return null;
      let { class: e, style: t } = n;
      return e && !fa(e) && (n.class = Kx(e)), t && (n.style = Yx(t)), n;
    }
    var bH =
        "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot",
      _H =
        "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view",
      EH =
        "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr",
      TH = Kr(bH),
      SH = Kr(_H),
      wH = Kr(EH),
      MH = /["'&<>]/;
    function AH(n) {
      let e = "" + n,
        t = MH.exec(e);
      if (!t) return e;
      let i = "",
        r,
        s,
        a = 0;
      for (s = t.index; s < e.length; s++) {
        switch (e.charCodeAt(s)) {
          case 34:
            r = "&quot;";
            break;
          case 38:
            r = "&amp;";
            break;
          case 39:
            r = "&#39;";
            break;
          case 60:
            r = "&lt;";
            break;
          case 62:
            r = "&gt;";
            break;
          default:
            continue;
        }
        a !== s && (i += e.slice(a, s)), (a = s + 1), (i += r);
      }
      return a !== s ? i + e.slice(a, s) : i;
    }
    var CH = /^-?>|<!--|-->|--!>|<!-$/g;
    function PH(n) {
      return n.replace(CH, "");
    }
    function DH(n, e) {
      if (n.length !== e.length) return !1;
      let t = !0;
      for (let i = 0; t && i < n.length; i++) t = Pp(n[i], e[i]);
      return t;
    }
    function Pp(n, e) {
      if (n === e) return !0;
      let t = jx(n),
        i = jx(e);
      if (t || i) return t && i ? n.getTime() === e.getTime() : !1;
      if (((t = Xx(n)), (i = Xx(e)), t || i)) return n === e;
      if (((t = yl(n)), (i = yl(e)), t || i)) return t && i ? DH(n, e) : !1;
      if (((t = oo(n)), (i = oo(e)), t || i)) {
        if (!t || !i) return !1;
        let r = Object.keys(n).length,
          s = Object.keys(e).length;
        if (r !== s) return !1;
        for (let a in n) {
          let o = n.hasOwnProperty(a),
            l = e.hasOwnProperty(a);
          if ((o && !l) || (!o && l) || !Pp(n[a], e[a])) return !1;
        }
      }
      return String(n) === String(e);
    }
    function IH(n, e) {
      return n.findIndex((t) => Pp(t, e));
    }
    var LH = (n) =>
        fa(n)
          ? n
          : n == null
          ? ""
          : yl(n) || (oo(n) && (n.toString === Jx || !Cp(n.toString)))
          ? JSON.stringify(n, AP, 2)
          : String(n),
      AP = (n, e) =>
        e && e.__v_isRef
          ? AP(n, e.value)
          : CP(e)
          ? {
              [`Map(${e.size})`]: [...e.entries()].reduce(
                (t, [i, r]) => ((t[`${i} =>`] = r), t),
                {}
              ),
            }
          : PP(e)
          ? { [`Set(${e.size})`]: [...e.values()] }
          : oo(e) && !yl(e) && !DP(e)
          ? String(e)
          : e,
      RH = {},
      OH = [],
      NH = () => {},
      kH = () => !1,
      FH = /^on[^a-z]/,
      BH = (n) => FH.test(n),
      zH = (n) => n.startsWith("onUpdate:"),
      UH = Object.assign,
      VH = (n, e) => {
        let t = n.indexOf(e);
        t > -1 && n.splice(t, 1);
      },
      GH = Object.prototype.hasOwnProperty,
      HH = (n, e) => GH.call(n, e),
      yl = Array.isArray,
      CP = (n) => Uc(n) === "[object Map]",
      PP = (n) => Uc(n) === "[object Set]",
      jx = (n) => Uc(n) === "[object Date]",
      Cp = (n) => typeof n == "function",
      fa = (n) => typeof n == "string",
      Xx = (n) => typeof n == "symbol",
      oo = (n) => n !== null && typeof n == "object",
      $H = (n) => oo(n) && Cp(n.then) && Cp(n.catch),
      Jx = Object.prototype.toString,
      Uc = (n) => Jx.call(n),
      WH = (n) => Uc(n).slice(8, -1),
      DP = (n) => Uc(n) === "[object Object]",
      qH = (n) =>
        fa(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n,
      jH = Kr(
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
      ),
      XH = Kr(
        "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
      ),
      Dp = (n) => {
        let e = Object.create(null);
        return (t) => e[t] || (e[t] = n(t));
      },
      YH = /-(\w)/g,
      KH = Dp((n) => n.replace(YH, (e, t) => (t ? t.toUpperCase() : ""))),
      JH = /\B([A-Z])/g,
      IP = Dp((n) => n.replace(JH, "-$1").toLowerCase()),
      LP = Dp((n) => n.charAt(0).toUpperCase() + n.slice(1)),
      ZH = Dp((n) => (n ? `on${LP(n)}` : "")),
      QH = (n, e) => !Object.is(n, e),
      e$ = (n, e) => {
        for (let t = 0; t < n.length; t++) n[t](e);
      },
      t$ = (n, e, t) => {
        Object.defineProperty(n, e, {
          configurable: !0,
          enumerable: !1,
          value: t,
        });
      },
      i$ = (n) => {
        let e = parseFloat(n);
        return isNaN(e) ? n : e;
      },
      TP,
      n$ = () =>
        TP ||
        (TP =
          typeof globalThis != "undefined"
            ? globalThis
            : typeof self != "undefined"
            ? self
            : typeof window != "undefined"
            ? window
            : typeof global != "undefined"
            ? global
            : {}),
      r$ = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
    function s$(n) {
      return r$.test(n) ? `__props.${n}` : `__props[${JSON.stringify(n)}]`;
    }
    dt.EMPTY_ARR = OH;
    dt.EMPTY_OBJ = RH;
    dt.NO = kH;
    dt.NOOP = NH;
    dt.PatchFlagNames = nH;
    dt.camelize = KH;
    dt.capitalize = LP;
    dt.def = t$;
    dt.escapeHtml = AH;
    dt.escapeHtmlComment = PH;
    dt.extend = UH;
    dt.genPropsAccessExp = s$;
    dt.generateCodeFrame = oH;
    dt.getGlobalThis = n$;
    dt.hasChanged = QH;
    dt.hasOwn = HH;
    dt.hyphenate = IP;
    dt.includeBooleanAttr = uH;
    dt.invokeArrayFns = e$;
    dt.isArray = yl;
    dt.isBooleanAttr = cH;
    dt.isBuiltInDirective = XH;
    dt.isDate = jx;
    dt.isFunction = Cp;
    dt.isGloballyWhitelisted = aH;
    dt.isHTMLTag = TH;
    dt.isIntegerKey = qH;
    dt.isKnownHtmlAttr = pH;
    dt.isKnownSvgAttr = mH;
    dt.isMap = CP;
    dt.isModelListener = zH;
    dt.isNoUnitNumericStyleProp = wP;
    dt.isObject = oo;
    dt.isOn = BH;
    dt.isPlainObject = DP;
    dt.isPromise = $H;
    dt.isReservedProp = jH;
    dt.isSSRSafeAttrName = fH;
    dt.isSVGTag = SH;
    dt.isSet = PP;
    dt.isSpecialBooleanAttr = lH;
    dt.isString = fa;
    dt.isSymbol = Xx;
    dt.isVoidTag = wH;
    dt.looseEqual = Pp;
    dt.looseIndexOf = IH;
    dt.makeMap = Kr;
    dt.normalizeClass = Kx;
    dt.normalizeProps = xH;
    dt.normalizeStyle = Yx;
    dt.objectToString = Jx;
    dt.parseStringStyle = MP;
    dt.propsToAttrMap = dH;
    dt.remove = VH;
    dt.slotFlagsText = rH;
    dt.stringifyStyle = vH;
    dt.toDisplayString = LH;
    dt.toHandlerKey = ZH;
    dt.toNumber = i$;
    dt.toRawType = WH;
    dt.toTypeString = Uc;
  });
  var lo = jt((ose, OP) => {
    "use strict";
    OP.exports = RP();
  });
  var hD = jt((ei) => {
    "use strict";
    Object.defineProperty(ei, "__esModule", { value: !0 });
    var Xt = lo(),
      _r,
      nb = class {
        constructor(e = !1) {
          (this.active = !0),
            (this.effects = []),
            (this.cleanups = []),
            !e &&
              _r &&
              ((this.parent = _r),
              (this.index = (_r.scopes || (_r.scopes = [])).push(this) - 1));
        }
        run(e) {
          if (this.active) {
            let t = _r;
            try {
              return (_r = this), e();
            } finally {
              _r = t;
            }
          }
        }
        on() {
          _r = this;
        }
        off() {
          _r = this.parent;
        }
        stop(e) {
          if (this.active) {
            let t, i;
            for (t = 0, i = this.effects.length; t < i; t++)
              this.effects[t].stop();
            for (t = 0, i = this.cleanups.length; t < i; t++)
              this.cleanups[t]();
            if (this.scopes)
              for (t = 0, i = this.scopes.length; t < i; t++)
                this.scopes[t].stop(!0);
            if (this.parent && !e) {
              let r = this.parent.scopes.pop();
              r &&
                r !== this &&
                ((this.parent.scopes[this.index] = r), (r.index = this.index));
            }
            this.active = !1;
          }
        }
      };
    function a$(n) {
      return new nb(n);
    }
    function GP(n, e = _r) {
      e && e.active && e.effects.push(n);
    }
    function o$() {
      return _r;
    }
    function l$(n) {
      _r && _r.cleanups.push(n);
    }
    var rb = (n) => {
        let e = new Set(n);
        return (e.w = 0), (e.n = 0), e;
      },
      HP = (n) => (n.w & ho) > 0,
      $P = (n) => (n.n & ho) > 0,
      c$ = ({ deps: n }) => {
        if (n.length) for (let e = 0; e < n.length; e++) n[e].w |= ho;
      },
      u$ = (n) => {
        let { deps: e } = n;
        if (e.length) {
          let t = 0;
          for (let i = 0; i < e.length; i++) {
            let r = e[i];
            HP(r) && !$P(r) ? r.delete(n) : (e[t++] = r),
              (r.w &= ~ho),
              (r.n &= ~ho);
          }
          e.length = t;
        }
      },
      Zx = new WeakMap(),
      Rh = 0,
      ho = 1,
      Qx = 30,
      ms,
      uo = Symbol(""),
      eb = Symbol(""),
      Nh = class {
        constructor(e, t = null, i) {
          (this.fn = e),
            (this.scheduler = t),
            (this.active = !0),
            (this.deps = []),
            (this.parent = void 0),
            GP(this, i);
        }
        run() {
          if (!this.active) return this.fn();
          let e = ms,
            t = Is;
          for (; e; ) {
            if (e === this) return;
            e = e.parent;
          }
          try {
            return (
              (this.parent = ms),
              (ms = this),
              (Is = !0),
              (ho = 1 << ++Rh),
              Rh <= Qx ? c$(this) : NP(this),
              this.fn()
            );
          } finally {
            Rh <= Qx && u$(this),
              (ho = 1 << --Rh),
              (ms = this.parent),
              (Is = t),
              (this.parent = void 0),
              this.deferStop && this.stop();
          }
        }
        stop() {
          ms === this
            ? (this.deferStop = !0)
            : this.active &&
              (NP(this), this.onStop && this.onStop(), (this.active = !1));
        }
      };
    function NP(n) {
      let { deps: e } = n;
      if (e.length) {
        for (let t = 0; t < e.length; t++) e[t].delete(n);
        e.length = 0;
      }
    }
    function h$(n, e) {
      n.effect && (n = n.effect.fn);
      let t = new Nh(n);
      e && (Xt.extend(t, e), e.scope && GP(t, e.scope)),
        (!e || !e.lazy) && t.run();
      let i = t.run.bind(t);
      return (i.effect = t), i;
    }
    function f$(n) {
      n.effect.stop();
    }
    var Is = !0,
      sb = [];
    function WP() {
      sb.push(Is), (Is = !1);
    }
    function d$() {
      sb.push(Is), (Is = !0);
    }
    function qP() {
      let n = sb.pop();
      Is = n === void 0 ? !0 : n;
    }
    function Jr(n, e, t) {
      if (Is && ms) {
        let i = Zx.get(n);
        i || Zx.set(n, (i = new Map()));
        let r = i.get(t);
        r || i.set(t, (r = rb())), jP(r);
      }
    }
    function jP(n, e) {
      let t = !1;
      Rh <= Qx ? $P(n) || ((n.n |= ho), (t = !HP(n))) : (t = !n.has(ms)),
        t && (n.add(ms), ms.deps.push(n));
    }
    function da(n, e, t, i, r, s) {
      let a = Zx.get(n);
      if (!a) return;
      let o = [];
      if (e === "clear") o = [...a.values()];
      else if (t === "length" && Xt.isArray(n))
        a.forEach((l, c) => {
          (c === "length" || c >= i) && o.push(l);
        });
      else
        switch ((t !== void 0 && o.push(a.get(t)), e)) {
          case "add":
            Xt.isArray(n)
              ? Xt.isIntegerKey(t) && o.push(a.get("length"))
              : (o.push(a.get(uo)), Xt.isMap(n) && o.push(a.get(eb)));
            break;
          case "delete":
            Xt.isArray(n) ||
              (o.push(a.get(uo)), Xt.isMap(n) && o.push(a.get(eb)));
            break;
          case "set":
            Xt.isMap(n) && o.push(a.get(uo));
            break;
        }
      if (o.length === 1) o[0] && tb(o[0]);
      else {
        let l = [];
        for (let c of o) c && l.push(...c);
        tb(rb(l));
      }
    }
    function tb(n, e) {
      let t = Xt.isArray(n) ? n : [...n];
      for (let i of t) i.computed && kP(i);
      for (let i of t) i.computed || kP(i);
    }
    function kP(n, e) {
      (n !== ms || n.allowRecurse) && (n.scheduler ? n.scheduler() : n.run());
    }
    var p$ = Xt.makeMap("__proto__,__v_isRef,__isVue"),
      XP = new Set(
        Object.getOwnPropertyNames(Symbol)
          .filter((n) => n !== "arguments" && n !== "caller")
          .map((n) => Symbol[n])
          .filter(Xt.isSymbol)
      ),
      m$ = Fp(),
      g$ = Fp(!1, !0),
      y$ = Fp(!0),
      v$ = Fp(!0, !0),
      FP = x$();
    function x$() {
      let n = {};
      return (
        ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
          n[e] = function (...t) {
            let i = bi(this);
            for (let s = 0, a = this.length; s < a; s++) Jr(i, "get", s + "");
            let r = i[e](...t);
            return r === -1 || r === !1 ? i[e](...t.map(bi)) : r;
          };
        }),
        ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
          n[e] = function (...t) {
            WP();
            let i = bi(this)[e].apply(this, t);
            return qP(), i;
          };
        }),
        n
      );
    }
    function Fp(n = !1, e = !1) {
      return function (i, r, s) {
        if (r === "__v_isReactive") return !n;
        if (r === "__v_isReadonly") return n;
        if (r === "__v_isShallow") return e;
        if (r === "__v_raw" && s === (n ? (e ? tD : eD) : e ? QP : ZP).get(i))
          return i;
        let a = Xt.isArray(i);
        if (!n && a && Xt.hasOwn(FP, r)) return Reflect.get(FP, r, s);
        let o = Reflect.get(i, r, s);
        return (Xt.isSymbol(r) ? XP.has(r) : p$(r)) || (n || Jr(i, "get", r), e)
          ? o
          : gs(o)
          ? a && Xt.isIntegerKey(r)
            ? o
            : o.value
          : Xt.isObject(o)
          ? n
            ? lb(o)
            : ob(o)
          : o;
      };
    }
    var b$ = YP(),
      _$ = YP(!0);
    function YP(n = !1) {
      return function (t, i, r, s) {
        let a = t[i];
        if (Vc(a) && gs(a) && !gs(r)) return !1;
        if (
          !n &&
          !Vc(r) &&
          (iD(r) || ((r = bi(r)), (a = bi(a))),
          !Xt.isArray(t) && gs(a) && !gs(r))
        )
          return (a.value = r), !0;
        let o =
            Xt.isArray(t) && Xt.isIntegerKey(i)
              ? Number(i) < t.length
              : Xt.hasOwn(t, i),
          l = Reflect.set(t, i, r, s);
        return (
          t === bi(s) &&
            (o
              ? Xt.hasChanged(r, a) && da(t, "set", i, r)
              : da(t, "add", i, r)),
          l
        );
      };
    }
    function E$(n, e) {
      let t = Xt.hasOwn(n, e);
      n[e];
      let i = Reflect.deleteProperty(n, e);
      return i && t && da(n, "delete", e, void 0), i;
    }
    function T$(n, e) {
      let t = Reflect.has(n, e);
      return (!Xt.isSymbol(e) || !XP.has(e)) && Jr(n, "has", e), t;
    }
    function S$(n) {
      return (
        Jr(n, "iterate", Xt.isArray(n) ? "length" : uo), Reflect.ownKeys(n)
      );
    }
    var KP = { get: m$, set: b$, deleteProperty: E$, has: T$, ownKeys: S$ },
      JP = {
        get: y$,
        set(n, e) {
          return !0;
        },
        deleteProperty(n, e) {
          return !0;
        },
      },
      w$ = Xt.extend({}, KP, { get: g$, set: _$ }),
      M$ = Xt.extend({}, JP, { get: v$ }),
      ab = (n) => n,
      Bp = (n) => Reflect.getPrototypeOf(n);
    function Ip(n, e, t = !1, i = !1) {
      n = n.__v_raw;
      let r = bi(n),
        s = bi(e);
      t || (e !== s && Jr(r, "get", e), Jr(r, "get", s));
      let { has: a } = Bp(r),
        o = i ? ab : t ? cb : Oh;
      if (a.call(r, e)) return o(n.get(e));
      if (a.call(r, s)) return o(n.get(s));
      n !== r && n.get(e);
    }
    function Lp(n, e = !1) {
      let t = this.__v_raw,
        i = bi(t),
        r = bi(n);
      return (
        e || (n !== r && Jr(i, "has", n), Jr(i, "has", r)),
        n === r ? t.has(n) : t.has(n) || t.has(r)
      );
    }
    function Rp(n, e = !1) {
      return (
        (n = n.__v_raw),
        !e && Jr(bi(n), "iterate", uo),
        Reflect.get(n, "size", n)
      );
    }
    function BP(n) {
      n = bi(n);
      let e = bi(this);
      return Bp(e).has.call(e, n) || (e.add(n), da(e, "add", n, n)), this;
    }
    function zP(n, e) {
      e = bi(e);
      let t = bi(this),
        { has: i, get: r } = Bp(t),
        s = i.call(t, n);
      s || ((n = bi(n)), (s = i.call(t, n)));
      let a = r.call(t, n);
      return (
        t.set(n, e),
        s ? Xt.hasChanged(e, a) && da(t, "set", n, e) : da(t, "add", n, e),
        this
      );
    }
    function UP(n) {
      let e = bi(this),
        { has: t, get: i } = Bp(e),
        r = t.call(e, n);
      r || ((n = bi(n)), (r = t.call(e, n))), i && i.call(e, n);
      let s = e.delete(n);
      return r && da(e, "delete", n, void 0), s;
    }
    function VP() {
      let n = bi(this),
        e = n.size !== 0,
        t = n.clear();
      return e && da(n, "clear", void 0, void 0), t;
    }
    function Op(n, e) {
      return function (i, r) {
        let s = this,
          a = s.__v_raw,
          o = bi(a),
          l = e ? ab : n ? cb : Oh;
        return (
          !n && Jr(o, "iterate", uo),
          a.forEach((c, u) => i.call(r, l(c), l(u), s))
        );
      };
    }
    function Np(n, e, t) {
      return function (...i) {
        let r = this.__v_raw,
          s = bi(r),
          a = Xt.isMap(s),
          o = n === "entries" || (n === Symbol.iterator && a),
          l = n === "keys" && a,
          c = r[n](...i),
          u = t ? ab : e ? cb : Oh;
        return (
          !e && Jr(s, "iterate", l ? eb : uo),
          {
            next() {
              let { value: f, done: d } = c.next();
              return d
                ? { value: f, done: d }
                : { value: o ? [u(f[0]), u(f[1])] : u(f), done: d };
            },
            [Symbol.iterator]() {
              return this;
            },
          }
        );
      };
    }
    function co(n) {
      return function (...e) {
        return n === "delete" ? !1 : this;
      };
    }
    function A$() {
      let n = {
          get(s) {
            return Ip(this, s);
          },
          get size() {
            return Rp(this);
          },
          has: Lp,
          add: BP,
          set: zP,
          delete: UP,
          clear: VP,
          forEach: Op(!1, !1),
        },
        e = {
          get(s) {
            return Ip(this, s, !1, !0);
          },
          get size() {
            return Rp(this);
          },
          has: Lp,
          add: BP,
          set: zP,
          delete: UP,
          clear: VP,
          forEach: Op(!1, !0),
        },
        t = {
          get(s) {
            return Ip(this, s, !0);
          },
          get size() {
            return Rp(this, !0);
          },
          has(s) {
            return Lp.call(this, s, !0);
          },
          add: co("add"),
          set: co("set"),
          delete: co("delete"),
          clear: co("clear"),
          forEach: Op(!0, !1),
        },
        i = {
          get(s) {
            return Ip(this, s, !0, !0);
          },
          get size() {
            return Rp(this, !0);
          },
          has(s) {
            return Lp.call(this, s, !0);
          },
          add: co("add"),
          set: co("set"),
          delete: co("delete"),
          clear: co("clear"),
          forEach: Op(!0, !0),
        };
      return (
        ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
          (n[s] = Np(s, !1, !1)),
            (t[s] = Np(s, !0, !1)),
            (e[s] = Np(s, !1, !0)),
            (i[s] = Np(s, !0, !0));
        }),
        [n, t, e, i]
      );
    }
    var [C$, P$, D$, I$] = A$();
    function zp(n, e) {
      let t = e ? (n ? I$ : D$) : n ? P$ : C$;
      return (i, r, s) =>
        r === "__v_isReactive"
          ? !n
          : r === "__v_isReadonly"
          ? n
          : r === "__v_raw"
          ? i
          : Reflect.get(Xt.hasOwn(t, r) && r in i ? t : i, r, s);
    }
    var L$ = { get: zp(!1, !1) },
      R$ = { get: zp(!1, !0) },
      O$ = { get: zp(!0, !1) },
      N$ = { get: zp(!0, !0) },
      ZP = new WeakMap(),
      QP = new WeakMap(),
      eD = new WeakMap(),
      tD = new WeakMap();
    function k$(n) {
      switch (n) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function F$(n) {
      return n.__v_skip || !Object.isExtensible(n) ? 0 : k$(Xt.toRawType(n));
    }
    function ob(n) {
      return Vc(n) ? n : Up(n, !1, KP, L$, ZP);
    }
    function B$(n) {
      return Up(n, !1, w$, R$, QP);
    }
    function lb(n) {
      return Up(n, !0, JP, O$, eD);
    }
    function z$(n) {
      return Up(n, !0, M$, N$, tD);
    }
    function Up(n, e, t, i, r) {
      if (!Xt.isObject(n) || (n.__v_raw && !(e && n.__v_isReactive))) return n;
      let s = r.get(n);
      if (s) return s;
      let a = F$(n);
      if (a === 0) return n;
      let o = new Proxy(n, a === 2 ? i : t);
      return r.set(n, o), o;
    }
    function Vp(n) {
      return Vc(n) ? Vp(n.__v_raw) : !!(n && n.__v_isReactive);
    }
    function Vc(n) {
      return !!(n && n.__v_isReadonly);
    }
    function iD(n) {
      return !!(n && n.__v_isShallow);
    }
    function U$(n) {
      return Vp(n) || Vc(n);
    }
    function bi(n) {
      let e = n && n.__v_raw;
      return e ? bi(e) : n;
    }
    function V$(n) {
      return Xt.def(n, "__v_skip", !0), n;
    }
    var Oh = (n) => (Xt.isObject(n) ? ob(n) : n),
      cb = (n) => (Xt.isObject(n) ? lb(n) : n);
    function Gp(n) {
      Is && ms && ((n = bi(n)), jP(n.dep || (n.dep = rb())));
    }
    function kh(n, e) {
      (n = bi(n)), n.dep && tb(n.dep);
    }
    function gs(n) {
      return !!(n && n.__v_isRef === !0);
    }
    function G$(n) {
      return nD(n, !1);
    }
    function H$(n) {
      return nD(n, !0);
    }
    function nD(n, e) {
      return gs(n) ? n : new rD(n, e);
    }
    var rD = class {
      constructor(e, t) {
        (this.__v_isShallow = t),
          (this.dep = void 0),
          (this.__v_isRef = !0),
          (this._rawValue = t ? e : bi(e)),
          (this._value = t ? e : Oh(e));
      }
      get value() {
        return Gp(this), this._value;
      }
      set value(e) {
        (e = this.__v_isShallow ? e : bi(e)),
          Xt.hasChanged(e, this._rawValue) &&
            ((this._rawValue = e),
            (this._value = this.__v_isShallow ? e : Oh(e)),
            kh(this));
      }
    };
    function $$(n) {
      kh(n);
    }
    function sD(n) {
      return gs(n) ? n.value : n;
    }
    var W$ = {
      get: (n, e, t) => sD(Reflect.get(n, e, t)),
      set: (n, e, t, i) => {
        let r = n[e];
        return gs(r) && !gs(t) ? ((r.value = t), !0) : Reflect.set(n, e, t, i);
      },
    };
    function q$(n) {
      return Vp(n) ? n : new Proxy(n, W$);
    }
    var aD = class {
      constructor(e) {
        (this.dep = void 0), (this.__v_isRef = !0);
        let { get: t, set: i } = e(
          () => Gp(this),
          () => kh(this)
        );
        (this._get = t), (this._set = i);
      }
      get value() {
        return this._get();
      }
      set value(e) {
        this._set(e);
      }
    };
    function j$(n) {
      return new aD(n);
    }
    function X$(n) {
      let e = Xt.isArray(n) ? new Array(n.length) : {};
      for (let t in n) e[t] = lD(n, t);
      return e;
    }
    var oD = class {
      constructor(e, t, i) {
        (this._object = e),
          (this._key = t),
          (this._defaultValue = i),
          (this.__v_isRef = !0);
      }
      get value() {
        let e = this._object[this._key];
        return e === void 0 ? this._defaultValue : e;
      }
      set value(e) {
        this._object[this._key] = e;
      }
    };
    function lD(n, e, t) {
      let i = n[e];
      return gs(i) ? i : new oD(n, e, t);
    }
    var cD = class {
      constructor(e, t, i, r) {
        (this._setter = t),
          (this.dep = void 0),
          (this.__v_isRef = !0),
          (this._dirty = !0),
          (this.effect = new Nh(e, () => {
            this._dirty || ((this._dirty = !0), kh(this));
          })),
          (this.effect.computed = this),
          (this.effect.active = this._cacheable = !r),
          (this.__v_isReadonly = i);
      }
      get value() {
        let e = bi(this);
        return (
          Gp(e),
          (e._dirty || !e._cacheable) &&
            ((e._dirty = !1), (e._value = e.effect.run())),
          e._value
        );
      }
      set value(e) {
        this._setter(e);
      }
    };
    function Y$(n, e, t = !1) {
      let i,
        r,
        s = Xt.isFunction(n);
      return (
        s ? ((i = n), (r = Xt.NOOP)) : ((i = n.get), (r = n.set)),
        new cD(i, r, s || !r, t)
      );
    }
    var uD,
      K$ = Promise.resolve(),
      kp = [],
      ib = !1,
      J$ = (n) => {
        kp.push(n), ib || ((ib = !0), K$.then(Z$));
      },
      Z$ = () => {
        for (let n = 0; n < kp.length; n++) kp[n]();
        (kp.length = 0), (ib = !1);
      },
      Hp = class {
        constructor(e) {
          (this.dep = void 0),
            (this._dirty = !0),
            (this.__v_isRef = !0),
            (this[uD] = !0);
          let t,
            i = !1,
            r = !1;
          (this.effect = new Nh(e, (s) => {
            if (this.dep) {
              if (s) (t = this._value), (i = !0);
              else if (!r) {
                let a = i ? t : this._value;
                (r = !0),
                  (i = !1),
                  J$(() => {
                    this.effect.active && this._get() !== a && kh(this),
                      (r = !1);
                  });
              }
              for (let a of this.dep)
                a.computed instanceof Hp && a.scheduler(!0);
            }
            this._dirty = !0;
          })),
            (this.effect.computed = this);
        }
        _get() {
          return this._dirty
            ? ((this._dirty = !1), (this._value = this.effect.run()))
            : this._value;
        }
        get value() {
          return Gp(this), bi(this)._get();
        }
      };
    uD = "__v_isReadonly";
    function Q$(n) {
      return new Hp(n);
    }
    ei.EffectScope = nb;
    ei.ITERATE_KEY = uo;
    ei.ReactiveEffect = Nh;
    ei.computed = Y$;
    ei.customRef = j$;
    ei.deferredComputed = Q$;
    ei.effect = h$;
    ei.effectScope = a$;
    ei.enableTracking = d$;
    ei.getCurrentScope = o$;
    ei.isProxy = U$;
    ei.isReactive = Vp;
    ei.isReadonly = Vc;
    ei.isRef = gs;
    ei.isShallow = iD;
    ei.markRaw = V$;
    ei.onScopeDispose = l$;
    ei.pauseTracking = WP;
    ei.proxyRefs = q$;
    ei.reactive = ob;
    ei.readonly = lb;
    ei.ref = G$;
    ei.resetTracking = qP;
    ei.shallowReactive = B$;
    ei.shallowReadonly = z$;
    ei.shallowRef = H$;
    ei.stop = f$;
    ei.toRaw = bi;
    ei.toRef = lD;
    ei.toRefs = X$;
    ei.track = Jr;
    ei.trigger = da;
    ei.triggerRef = $$;
    ei.unref = sD;
  });
  var dD = jt((cse, fD) => {
    "use strict";
    fD.exports = hD();
  });
  var SI = jt((we) => {
    "use strict";
    Object.defineProperty(we, "__esModule", { value: !0 });
    var Qe = dD(),
      J = lo(),
      zh = [];
    function MD(n, ...e) {
      Qe.pauseTracking();
      let t = zh.length ? zh[zh.length - 1].component : null,
        i = t && t.appContext.config.warnHandler,
        r = e9();
      if (i)
        Os(i, t, 11, [
          n + e.join(""),
          t && t.proxy,
          r.map(({ vnode: s }) => `at <${vI(t, s.type)}>`).join(`
`),
          r,
        ]);
      else {
        let s = [`[Vue warn]: ${n}`, ...e];
        r.length &&
          s.push(
            `
`,
            ...t9(r)
          ),
          console.warn(...s);
      }
      Qe.resetTracking();
    }
    function e9() {
      let n = zh[zh.length - 1];
      if (!n) return [];
      let e = [];
      for (; n; ) {
        let t = e[0];
        t && t.vnode === n
          ? t.recurseCount++
          : e.push({ vnode: n, recurseCount: 0 });
        let i = n.component && n.component.parent;
        n = i && i.vnode;
      }
      return e;
    }
    function t9(n) {
      let e = [];
      return (
        n.forEach((t, i) => {
          e.push(
            ...(i === 0
              ? []
              : [
                  `
`,
                ]),
            ...i9(t)
          );
        }),
        e
      );
    }
    function i9({ vnode: n, recurseCount: e }) {
      let t = e > 0 ? `... (${e} recursive calls)` : "",
        i = n.component ? n.component.parent == null : !1,
        r = ` at <${vI(n.component, n.type, i)}`,
        s = ">" + t;
      return n.props ? [r, ...n9(n.props), s] : [r + s];
    }
    function n9(n) {
      let e = [],
        t = Object.keys(n);
      return (
        t.slice(0, 3).forEach((i) => {
          e.push(...AD(i, n[i]));
        }),
        t.length > 3 && e.push(" ..."),
        e
      );
    }
    function AD(n, e, t) {
      return J.isString(e)
        ? ((e = JSON.stringify(e)), t ? e : [`${n}=${e}`])
        : typeof e == "number" || typeof e == "boolean" || e == null
        ? t
          ? e
          : [`${n}=${e}`]
        : Qe.isRef(e)
        ? ((e = AD(n, Qe.toRaw(e.value), !0)), t ? e : [`${n}=Ref<`, e, ">"])
        : J.isFunction(e)
        ? [`${n}=fn${e.name ? `<${e.name}>` : ""}`]
        : ((e = Qe.toRaw(e)), t ? e : [`${n}=`, e]);
    }
    function Os(n, e, t, i) {
      let r;
      try {
        r = i ? n(...i) : n();
      } catch (s) {
        Tl(s, e, t);
      }
      return r;
    }
    function Qr(n, e, t, i) {
      if (J.isFunction(n)) {
        let s = Os(n, e, t, i);
        return (
          s &&
            J.isPromise(s) &&
            s.catch((a) => {
              Tl(a, e, t);
            }),
          s
        );
      }
      let r = [];
      for (let s = 0; s < n.length; s++) r.push(Qr(n[s], e, t, i));
      return r;
    }
    function Tl(n, e, t, i = !0) {
      let r = e ? e.vnode : null;
      if (e) {
        let s = e.parent,
          a = e.proxy,
          o = t;
        for (; s; ) {
          let c = s.ec;
          if (c) {
            for (let u = 0; u < c.length; u++) if (c[u](n, a, o) === !1) return;
          }
          s = s.parent;
        }
        let l = e.appContext.config.errorHandler;
        if (l) {
          Os(l, null, 10, [n, a, o]);
          return;
        }
      }
      r9(n, t, r, i);
    }
    function r9(n, e, t, i = !0) {
      console.error(n);
    }
    var Kp = !1,
      pb = !1,
      Tr = [],
      pa = 0,
      Uh = [],
      Fh = null,
      Gc = 0,
      Vh = [],
      po = null,
      Hc = 0,
      CD = Promise.resolve(),
      wb = null,
      mb = null;
    function PD(n) {
      let e = wb || CD;
      return n ? e.then(this ? n.bind(this) : n) : e;
    }
    function s9(n) {
      let e = pa + 1,
        t = Tr.length;
      for (; e < t; ) {
        let i = (e + t) >>> 1;
        qh(Tr[i]) < n ? (e = i + 1) : (t = i);
      }
      return e;
    }
    function Mb(n) {
      (!Tr.length || !Tr.includes(n, Kp && n.allowRecurse ? pa + 1 : pa)) &&
        n !== mb &&
        (n.id == null ? Tr.push(n) : Tr.splice(s9(n.id), 0, n), DD());
    }
    function DD() {
      !Kp && !pb && ((pb = !0), (wb = CD.then(LD)));
    }
    function a9(n) {
      let e = Tr.indexOf(n);
      e > pa && Tr.splice(e, 1);
    }
    function ID(n, e, t, i) {
      J.isArray(n)
        ? t.push(...n)
        : (!e || !e.includes(n, n.allowRecurse ? i + 1 : i)) && t.push(n),
        DD();
    }
    function o9(n) {
      ID(n, Fh, Uh, Gc);
    }
    function Ab(n) {
      ID(n, po, Vh, Hc);
    }
    function rm(n, e = null) {
      if (Uh.length) {
        for (
          mb = e, Fh = [...new Set(Uh)], Uh.length = 0, Gc = 0;
          Gc < Fh.length;
          Gc++
        )
          Fh[Gc]();
        (Fh = null), (Gc = 0), (mb = null), rm(n, e);
      }
    }
    function Jp(n) {
      if ((rm(), Vh.length)) {
        let e = [...new Set(Vh)];
        if (((Vh.length = 0), po)) {
          po.push(...e);
          return;
        }
        for (
          po = e, po.sort((t, i) => qh(t) - qh(i)), Hc = 0;
          Hc < po.length;
          Hc++
        )
          po[Hc]();
        (po = null), (Hc = 0);
      }
    }
    var qh = (n) => (n.id == null ? 1 / 0 : n.id);
    function LD(n) {
      (pb = !1), (Kp = !0), rm(n), Tr.sort((t, i) => qh(t) - qh(i));
      let e = J.NOOP;
      try {
        for (pa = 0; pa < Tr.length; pa++) {
          let t = Tr[pa];
          t && t.active !== !1 && Os(t, null, 14);
        }
      } finally {
        (pa = 0),
          (Tr.length = 0),
          Jp(),
          (Kp = !1),
          (wb = null),
          (Tr.length || Uh.length || Vh.length) && LD(n);
      }
    }
    var $p = [];
    function RD(n, e) {
      var t, i;
      (we.devtools = n),
        we.devtools
          ? ((we.devtools.enabled = !0),
            $p.forEach(({ event: r, args: s }) => we.devtools.emit(r, ...s)),
            ($p = []))
          : typeof window != "undefined" &&
            window.HTMLElement &&
            !(
              !(
                (i =
                  (t = window.navigator) === null || t === void 0
                    ? void 0
                    : t.userAgent) === null || i === void 0
              ) && i.includes("jsdom")
            )
          ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ =
              e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((s) => {
              RD(s, e);
            }),
            setTimeout(() => {
              we.devtools ||
                ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null), ($p = []));
            }, 3e3))
          : ($p = []);
    }
    function l9(n, e, ...t) {
      if (n.isUnmounted) return;
      let i = n.vnode.props || J.EMPTY_OBJ,
        r = t,
        s = e.startsWith("update:"),
        a = s && e.slice(7);
      if (a && a in i) {
        let u = `${a === "modelValue" ? "model" : a}Modifiers`,
          { number: f, trim: d } = i[u] || J.EMPTY_OBJ;
        d && (r = t.map((m) => m.trim())), f && (r = t.map(J.toNumber));
      }
      let o,
        l =
          i[(o = J.toHandlerKey(e))] || i[(o = J.toHandlerKey(J.camelize(e)))];
      !l && s && (l = i[(o = J.toHandlerKey(J.hyphenate(e)))]),
        l && Qr(l, n, 6, r);
      let c = i[o + "Once"];
      if (c) {
        if (!n.emitted) n.emitted = {};
        else if (n.emitted[o]) return;
        (n.emitted[o] = !0), Qr(c, n, 6, r);
      }
    }
    function OD(n, e, t = !1) {
      let i = e.emitsCache,
        r = i.get(n);
      if (r !== void 0) return r;
      let s = n.emits,
        a = {},
        o = !1;
      if (!J.isFunction(n)) {
        let l = (c) => {
          let u = OD(c, e, !0);
          u && ((o = !0), J.extend(a, u));
        };
        !t && e.mixins.length && e.mixins.forEach(l),
          n.extends && l(n.extends),
          n.mixins && n.mixins.forEach(l);
      }
      return !s && !o
        ? (i.set(n, null), null)
        : (J.isArray(s) ? s.forEach((l) => (a[l] = null)) : J.extend(a, s),
          i.set(n, a),
          a);
    }
    function sm(n, e) {
      return !n || !J.isOn(e)
        ? !1
        : ((e = e.slice(2).replace(/Once$/, "")),
          J.hasOwn(n, e[0].toLowerCase() + e.slice(1)) ||
            J.hasOwn(n, J.hyphenate(e)) ||
            J.hasOwn(n, e));
    }
    var Ln = null,
      am = null;
    function jh(n) {
      let e = Ln;
      return (Ln = n), (am = (n && n.type.__scopeId) || null), e;
    }
    function c9(n) {
      am = n;
    }
    function u9() {
      am = null;
    }
    var h9 = (n) => Cb;
    function Cb(n, e = Ln, t) {
      if (!e || n._n) return n;
      let i = (...r) => {
        i._d && Eb(-1);
        let s = jh(e),
          a = n(...r);
        return jh(s), i._d && Eb(1), a;
      };
      return (i._n = !0), (i._c = !0), (i._d = !0), i;
    }
    function Xp(n) {
      let {
          type: e,
          vnode: t,
          proxy: i,
          withProxy: r,
          props: s,
          propsOptions: [a],
          slots: o,
          attrs: l,
          emit: c,
          render: u,
          renderCache: f,
          data: d,
          setupState: m,
          ctx: x,
          inheritAttrs: y,
        } = n,
        g,
        b,
        _ = jh(n);
      try {
        if (t.shapeFlag & 4) {
          let w = r || i;
          (g = Er(u.call(w, w, f, s, m, d, x))), (b = l);
        } else {
          let w = e;
          (g = Er(
            w.length > 1 ? w(s, { attrs: l, slots: o, emit: c }) : w(s, null)
          )),
            (b = e.props ? l : d9(l));
        }
      } catch (w) {
        (Wh.length = 0), Tl(w, n, 1), (g = Bi(Rn));
      }
      let E = g;
      if (b && y !== !1) {
        let w = Object.keys(b),
          { shapeFlag: P } = E;
        w.length &&
          P & 7 &&
          (a && w.some(J.isModelListener) && (b = p9(b, a)), (E = Ns(E, b)));
      }
      return (
        t.dirs &&
          ((E = Ns(E)), (E.dirs = E.dirs ? E.dirs.concat(t.dirs) : t.dirs)),
        t.transition && (E.transition = t.transition),
        (g = E),
        jh(_),
        g
      );
    }
    function f9(n) {
      let e;
      for (let t = 0; t < n.length; t++) {
        let i = n[t];
        if (yo(i)) {
          if (i.type !== Rn || i.children === "v-if") {
            if (e) return;
            e = i;
          }
        } else return;
      }
      return e;
    }
    var d9 = (n) => {
        let e;
        for (let t in n)
          (t === "class" || t === "style" || J.isOn(t)) &&
            ((e || (e = {}))[t] = n[t]);
        return e;
      },
      p9 = (n, e) => {
        let t = {};
        for (let i in n)
          (!J.isModelListener(i) || !(i.slice(9) in e)) && (t[i] = n[i]);
        return t;
      };
    function m9(n, e, t) {
      let { props: i, children: r, component: s } = n,
        { props: a, children: o, patchFlag: l } = e,
        c = s.emitsOptions;
      if (e.dirs || e.transition) return !0;
      if (t && l >= 0) {
        if (l & 1024) return !0;
        if (l & 16) return i ? pD(i, a, c) : !!a;
        if (l & 8) {
          let u = e.dynamicProps;
          for (let f = 0; f < u.length; f++) {
            let d = u[f];
            if (a[d] !== i[d] && !sm(c, d)) return !0;
          }
        }
      } else
        return (r || o) && (!o || !o.$stable)
          ? !0
          : i === a
          ? !1
          : i
          ? a
            ? pD(i, a, c)
            : !0
          : !!a;
      return !1;
    }
    function pD(n, e, t) {
      let i = Object.keys(e);
      if (i.length !== Object.keys(n).length) return !0;
      for (let r = 0; r < i.length; r++) {
        let s = i[r];
        if (e[s] !== n[s] && !sm(t, s)) return !0;
      }
      return !1;
    }
    function Pb({ vnode: n, parent: e }, t) {
      for (; e && e.subTree === n; ) ((n = e.vnode).el = t), (e = e.parent);
    }
    var ND = (n) => n.__isSuspense,
      g9 = {
        name: "Suspense",
        __isSuspense: !0,
        process(n, e, t, i, r, s, a, o, l, c) {
          n == null
            ? v9(e, t, i, r, s, a, o, l, c)
            : x9(n, e, t, i, r, a, o, l, c);
        },
        hydrate: b9,
        create: Db,
        normalize: _9,
      },
      y9 = g9;
    function Xh(n, e) {
      let t = n.props && n.props[e];
      J.isFunction(t) && t();
    }
    function v9(n, e, t, i, r, s, a, o, l) {
      let {
          p: c,
          o: { createElement: u },
        } = l,
        f = u("div"),
        d = (n.suspense = Db(n, r, i, e, f, t, s, a, o, l));
      c(null, (d.pendingBranch = n.ssContent), f, null, i, d, s, a),
        d.deps > 0
          ? (Xh(n, "onPending"),
            Xh(n, "onFallback"),
            c(null, n.ssFallback, e, t, i, null, s, a),
            $c(d, n.ssFallback))
          : d.resolve();
    }
    function x9(
      n,
      e,
      t,
      i,
      r,
      s,
      a,
      o,
      { p: l, um: c, o: { createElement: u } }
    ) {
      let f = (e.suspense = n.suspense);
      (f.vnode = e), (e.el = n.el);
      let d = e.ssContent,
        m = e.ssFallback,
        {
          activeBranch: x,
          pendingBranch: y,
          isInFallback: g,
          isHydrating: b,
        } = f;
      if (y)
        (f.pendingBranch = d),
          Rs(d, y)
            ? (l(y, d, f.hiddenContainer, null, r, f, s, a, o),
              f.deps <= 0
                ? f.resolve()
                : g && (l(x, m, t, i, r, null, s, a, o), $c(f, m)))
            : (f.pendingId++,
              b ? ((f.isHydrating = !1), (f.activeBranch = y)) : c(y, r, f),
              (f.deps = 0),
              (f.effects.length = 0),
              (f.hiddenContainer = u("div")),
              g
                ? (l(null, d, f.hiddenContainer, null, r, f, s, a, o),
                  f.deps <= 0
                    ? f.resolve()
                    : (l(x, m, t, i, r, null, s, a, o), $c(f, m)))
                : x && Rs(d, x)
                ? (l(x, d, t, i, r, f, s, a, o), f.resolve(!0))
                : (l(null, d, f.hiddenContainer, null, r, f, s, a, o),
                  f.deps <= 0 && f.resolve()));
      else if (x && Rs(d, x)) l(x, d, t, i, r, f, s, a, o), $c(f, d);
      else if (
        (Xh(e, "onPending"),
        (f.pendingBranch = d),
        f.pendingId++,
        l(null, d, f.hiddenContainer, null, r, f, s, a, o),
        f.deps <= 0)
      )
        f.resolve();
      else {
        let { timeout: _, pendingId: E } = f;
        _ > 0
          ? setTimeout(() => {
              f.pendingId === E && f.fallback(m);
            }, _)
          : _ === 0 && f.fallback(m);
      }
    }
    function Db(n, e, t, i, r, s, a, o, l, c, u = !1) {
      let {
          p: f,
          m: d,
          um: m,
          n: x,
          o: { parentNode: y, remove: g },
        } = c,
        b = J.toNumber(n.props && n.props.timeout),
        _ = {
          vnode: n,
          parent: e,
          parentComponent: t,
          isSVG: a,
          container: i,
          hiddenContainer: r,
          anchor: s,
          deps: 0,
          pendingId: 0,
          timeout: typeof b == "number" ? b : -1,
          activeBranch: null,
          pendingBranch: null,
          isInFallback: !0,
          isHydrating: u,
          isUnmounted: !1,
          effects: [],
          resolve(E = !1) {
            let {
              vnode: w,
              activeBranch: P,
              pendingBranch: L,
              pendingId: I,
              effects: M,
              parentComponent: R,
              container: O,
            } = _;
            if (_.isHydrating) _.isHydrating = !1;
            else if (!E) {
              let $ = P && L.transition && L.transition.mode === "out-in";
              $ &&
                (P.transition.afterLeave = () => {
                  I === _.pendingId && d(L, O, W, 0);
                });
              let { anchor: W } = _;
              P && ((W = x(P)), m(P, R, _, !0)), $ || d(L, O, W, 0);
            }
            $c(_, L), (_.pendingBranch = null), (_.isInFallback = !1);
            let U = _.parent,
              X = !1;
            for (; U; ) {
              if (U.pendingBranch) {
                U.effects.push(...M), (X = !0);
                break;
              }
              U = U.parent;
            }
            X || Ab(M), (_.effects = []), Xh(w, "onResolve");
          },
          fallback(E) {
            if (!_.pendingBranch) return;
            let {
              vnode: w,
              activeBranch: P,
              parentComponent: L,
              container: I,
              isSVG: M,
            } = _;
            Xh(w, "onFallback");
            let R = x(P),
              O = () => {
                !_.isInFallback ||
                  (f(null, E, I, R, L, null, M, o, l), $c(_, E));
              },
              U = E.transition && E.transition.mode === "out-in";
            U && (P.transition.afterLeave = O),
              (_.isInFallback = !0),
              m(P, L, null, !0),
              U || O();
          },
          move(E, w, P) {
            _.activeBranch && d(_.activeBranch, E, w, P), (_.container = E);
          },
          next() {
            return _.activeBranch && x(_.activeBranch);
          },
          registerDep(E, w) {
            let P = !!_.pendingBranch;
            P && _.deps++;
            let L = E.vnode.el;
            E.asyncDep
              .catch((I) => {
                Tl(I, E, 0);
              })
              .then((I) => {
                if (
                  E.isUnmounted ||
                  _.isUnmounted ||
                  _.pendingId !== E.suspenseId
                )
                  return;
                E.asyncResolved = !0;
                let { vnode: M } = E;
                Tb(E, I, !1), L && (M.el = L);
                let R = !L && E.subTree.el;
                w(E, M, y(L || E.subTree.el), L ? null : x(E.subTree), _, a, l),
                  R && g(R),
                  Pb(E, M.el),
                  P && --_.deps === 0 && _.resolve();
              });
          },
          unmount(E, w) {
            (_.isUnmounted = !0),
              _.activeBranch && m(_.activeBranch, t, E, w),
              _.pendingBranch && m(_.pendingBranch, t, E, w);
          },
        };
      return _;
    }
    function b9(n, e, t, i, r, s, a, o, l) {
      let c = (e.suspense = Db(
          e,
          i,
          t,
          n.parentNode,
          document.createElement("div"),
          null,
          r,
          s,
          a,
          o,
          !0
        )),
        u = l(n, (c.pendingBranch = e.ssContent), t, c, s, a);
      return c.deps === 0 && c.resolve(), u;
    }
    function _9(n) {
      let { shapeFlag: e, children: t } = n,
        i = e & 32;
      (n.ssContent = mD(i ? t.default : t)),
        (n.ssFallback = i ? mD(t.fallback) : Bi(Rn));
    }
    function mD(n) {
      let e;
      if (J.isFunction(n)) {
        let t = El && n._c;
        t && ((n._d = !1), um()), (n = n()), t && ((n._d = !0), (e = lr), lI());
      }
      return (
        J.isArray(n) && (n = f9(n)),
        (n = Er(n)),
        e &&
          !n.dynamicChildren &&
          (n.dynamicChildren = e.filter((t) => t !== n)),
        n
      );
    }
    function kD(n, e) {
      e && e.pendingBranch
        ? J.isArray(n)
          ? e.effects.push(...n)
          : e.effects.push(n)
        : Ab(n);
    }
    function $c(n, e) {
      n.activeBranch = e;
      let { vnode: t, parentComponent: i } = n,
        r = (t.el = e.el);
      i && i.subTree === t && ((i.vnode.el = r), Pb(i, r));
    }
    function FD(n, e) {
      if (pn) {
        let t = pn.provides,
          i = pn.parent && pn.parent.provides;
        i === t && (t = pn.provides = Object.create(i)), (t[n] = e);
      }
    }
    function Gh(n, e, t = !1) {
      let i = pn || Ln;
      if (i) {
        let r =
          i.parent == null
            ? i.vnode.appContext && i.vnode.appContext.provides
            : i.parent.provides;
        if (r && n in r) return r[n];
        if (arguments.length > 1)
          return t && J.isFunction(e) ? e.call(i.proxy) : e;
      }
    }
    function E9(n, e) {
      return Kh(n, null, e);
    }
    function T9(n, e) {
      return Kh(n, null, { flush: "post" });
    }
    function S9(n, e) {
      return Kh(n, null, { flush: "sync" });
    }
    var gD = {};
    function Hh(n, e, t) {
      return Kh(n, e, t);
    }
    function Kh(
      n,
      e,
      {
        immediate: t,
        deep: i,
        flush: r,
        onTrack: s,
        onTrigger: a,
      } = J.EMPTY_OBJ
    ) {
      let o = pn,
        l,
        c = !1,
        u = !1;
      if (
        (Qe.isRef(n)
          ? ((l = () => n.value), (c = Qe.isShallow(n)))
          : Qe.isReactive(n)
          ? ((l = () => n), (i = !0))
          : J.isArray(n)
          ? ((u = !0),
            (c = n.some((b) => Qe.isReactive(b) || Qe.isShallow(b))),
            (l = () =>
              n.map((b) => {
                if (Qe.isRef(b)) return b.value;
                if (Qe.isReactive(b)) return bl(b);
                if (J.isFunction(b)) return Os(b, o, 2);
              })))
          : J.isFunction(n)
          ? e
            ? (l = () => Os(n, o, 2))
            : (l = () => {
                if (!(o && o.isUnmounted)) return f && f(), Qr(n, o, 3, [d]);
              })
          : (l = J.NOOP),
        e && i)
      ) {
        let b = l;
        l = () => bl(b());
      }
      let f,
        d = (b) => {
          f = g.onStop = () => {
            Os(b, o, 4);
          };
        };
      if (jc)
        return (
          (d = J.NOOP),
          e ? t && Qr(e, o, 3, [l(), u ? [] : void 0, d]) : l(),
          J.NOOP
        );
      let m = u ? [] : gD,
        x = () => {
          if (!!g.active)
            if (e) {
              let b = g.run();
              (i ||
                c ||
                (u
                  ? b.some((_, E) => J.hasChanged(_, m[E]))
                  : J.hasChanged(b, m))) &&
                (f && f(), Qr(e, o, 3, [b, m === gD ? void 0 : m, d]), (m = b));
            } else g.run();
        };
      x.allowRecurse = !!e;
      let y;
      r === "sync"
        ? (y = x)
        : r === "post"
        ? (y = () => Tn(x, o && o.suspense))
        : (y = () => o9(x));
      let g = new Qe.ReactiveEffect(l, y);
      return (
        e
          ? t
            ? x()
            : (m = g.run())
          : r === "post"
          ? Tn(g.run.bind(g), o && o.suspense)
          : g.run(),
        () => {
          g.stop(), o && o.scope && J.remove(o.scope.effects, g);
        }
      );
    }
    function w9(n, e, t) {
      let i = this.proxy,
        r = J.isString(n)
          ? n.includes(".")
            ? BD(i, n)
            : () => i[n]
          : n.bind(i, i),
        s;
      J.isFunction(e) ? (s = e) : ((s = e.handler), (t = e));
      let a = pn;
      vo(this);
      let o = Kh(r, s.bind(i), t);
      return a ? vo(a) : go(), o;
    }
    function BD(n, e) {
      let t = e.split(".");
      return () => {
        let i = n;
        for (let r = 0; r < t.length && i; r++) i = i[t[r]];
        return i;
      };
    }
    function bl(n, e) {
      if (!J.isObject(n) || n.__v_skip || ((e = e || new Set()), e.has(n)))
        return n;
      if ((e.add(n), Qe.isRef(n))) bl(n.value, e);
      else if (J.isArray(n)) for (let t = 0; t < n.length; t++) bl(n[t], e);
      else if (J.isSet(n) || J.isMap(n))
        n.forEach((t) => {
          bl(t, e);
        });
      else if (J.isPlainObject(n)) for (let t in n) bl(n[t], e);
      return n;
    }
    function zD() {
      let n = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map(),
      };
      return (
        lm(() => {
          n.isMounted = !0;
        }),
        cm(() => {
          n.isUnmounting = !0;
        }),
        n
      );
    }
    var Zr = [Function, Array],
      M9 = {
        name: "BaseTransition",
        props: {
          mode: String,
          appear: Boolean,
          persisted: Boolean,
          onBeforeEnter: Zr,
          onEnter: Zr,
          onAfterEnter: Zr,
          onEnterCancelled: Zr,
          onBeforeLeave: Zr,
          onLeave: Zr,
          onAfterLeave: Zr,
          onLeaveCancelled: Zr,
          onBeforeAppear: Zr,
          onAppear: Zr,
          onAfterAppear: Zr,
          onAppearCancelled: Zr,
        },
        setup(n, { slots: e }) {
          let t = Zh(),
            i = zD(),
            r;
          return () => {
            let s = e.default && Ib(e.default(), !0);
            if (!s || !s.length) return;
            let a = s[0];
            if (s.length > 1) {
              for (let y of s)
                if (y.type !== Rn) {
                  a = y;
                  break;
                }
            }
            let o = Qe.toRaw(n),
              { mode: l } = o;
            if (i.isLeaving) return ub(a);
            let c = yD(a);
            if (!c) return ub(a);
            let u = Zp(c, o, i, t);
            Yh(c, u);
            let f = t.subTree,
              d = f && yD(f),
              m = !1,
              { getTransitionKey: x } = c.type;
            if (x) {
              let y = x();
              r === void 0 ? (r = y) : y !== r && ((r = y), (m = !0));
            }
            if (d && d.type !== Rn && (!Rs(c, d) || m)) {
              let y = Zp(d, o, i, t);
              if ((Yh(d, y), l === "out-in"))
                return (
                  (i.isLeaving = !0),
                  (y.afterLeave = () => {
                    (i.isLeaving = !1), t.update();
                  }),
                  ub(a)
                );
              l === "in-out" &&
                c.type !== Rn &&
                (y.delayLeave = (g, b, _) => {
                  let E = UD(i, d);
                  (E[String(d.key)] = d),
                    (g._leaveCb = () => {
                      b(), (g._leaveCb = void 0), delete u.delayedLeave;
                    }),
                    (u.delayedLeave = _);
                });
            }
            return a;
          };
        },
      },
      A9 = M9;
    function UD(n, e) {
      let { leavingVNodes: t } = n,
        i = t.get(e.type);
      return i || ((i = Object.create(null)), t.set(e.type, i)), i;
    }
    function Zp(n, e, t, i) {
      let {
          appear: r,
          mode: s,
          persisted: a = !1,
          onBeforeEnter: o,
          onEnter: l,
          onAfterEnter: c,
          onEnterCancelled: u,
          onBeforeLeave: f,
          onLeave: d,
          onAfterLeave: m,
          onLeaveCancelled: x,
          onBeforeAppear: y,
          onAppear: g,
          onAfterAppear: b,
          onAppearCancelled: _,
        } = e,
        E = String(n.key),
        w = UD(t, n),
        P = (M, R) => {
          M && Qr(M, i, 9, R);
        },
        L = (M, R) => {
          let O = R[1];
          P(M, R),
            J.isArray(M)
              ? M.every((U) => U.length <= 1) && O()
              : M.length <= 1 && O();
        },
        I = {
          mode: s,
          persisted: a,
          beforeEnter(M) {
            let R = o;
            if (!t.isMounted)
              if (r) R = y || o;
              else return;
            M._leaveCb && M._leaveCb(!0);
            let O = w[E];
            O && Rs(n, O) && O.el._leaveCb && O.el._leaveCb(), P(R, [M]);
          },
          enter(M) {
            let R = l,
              O = c,
              U = u;
            if (!t.isMounted)
              if (r) (R = g || l), (O = b || c), (U = _ || u);
              else return;
            let X = !1,
              $ = (M._enterCb = (W) => {
                X ||
                  ((X = !0),
                  W ? P(U, [M]) : P(O, [M]),
                  I.delayedLeave && I.delayedLeave(),
                  (M._enterCb = void 0));
              });
            R ? L(R, [M, $]) : $();
          },
          leave(M, R) {
            let O = String(n.key);
            if ((M._enterCb && M._enterCb(!0), t.isUnmounting)) return R();
            P(f, [M]);
            let U = !1,
              X = (M._leaveCb = ($) => {
                U ||
                  ((U = !0),
                  R(),
                  $ ? P(x, [M]) : P(m, [M]),
                  (M._leaveCb = void 0),
                  w[O] === n && delete w[O]);
              });
            (w[O] = n), d ? L(d, [M, X]) : X();
          },
          clone(M) {
            return Zp(M, e, t, i);
          },
        };
      return I;
    }
    function ub(n) {
      if (Jh(n)) return (n = Ns(n)), (n.children = null), n;
    }
    function yD(n) {
      return Jh(n) ? (n.children ? n.children[0] : void 0) : n;
    }
    function Yh(n, e) {
      n.shapeFlag & 6 && n.component
        ? Yh(n.component.subTree, e)
        : n.shapeFlag & 128
        ? ((n.ssContent.transition = e.clone(n.ssContent)),
          (n.ssFallback.transition = e.clone(n.ssFallback)))
        : (n.transition = e);
    }
    function Ib(n, e = !1, t) {
      let i = [],
        r = 0;
      for (let s = 0; s < n.length; s++) {
        let a = n[s],
          o = t == null ? a.key : String(t) + String(a.key != null ? a.key : s);
        a.type === Xn
          ? (a.patchFlag & 128 && r++, (i = i.concat(Ib(a.children, e, o))))
          : (e || a.type !== Rn) && i.push(o != null ? Ns(a, { key: o }) : a);
      }
      if (r > 1) for (let s = 0; s < i.length; s++) i[s].patchFlag = -2;
      return i;
    }
    function VD(n) {
      return J.isFunction(n) ? { setup: n, name: n.name } : n;
    }
    var _l = (n) => !!n.type.__asyncLoader;
    function C9(n) {
      J.isFunction(n) && (n = { loader: n });
      let {
          loader: e,
          loadingComponent: t,
          errorComponent: i,
          delay: r = 200,
          timeout: s,
          suspensible: a = !0,
          onError: o,
        } = n,
        l = null,
        c,
        u = 0,
        f = () => (u++, (l = null), d()),
        d = () => {
          let m;
          return (
            l ||
            (m = l =
              e()
                .catch((x) => {
                  if (((x = x instanceof Error ? x : new Error(String(x))), o))
                    return new Promise((y, g) => {
                      o(
                        x,
                        () => y(f()),
                        () => g(x),
                        u + 1
                      );
                    });
                  throw x;
                })
                .then((x) =>
                  m !== l && l
                    ? l
                    : (x &&
                        (x.__esModule || x[Symbol.toStringTag] === "Module") &&
                        (x = x.default),
                      (c = x),
                      x)
                ))
          );
        };
      return VD({
        name: "AsyncComponentWrapper",
        __asyncLoader: d,
        get __asyncResolved() {
          return c;
        },
        setup() {
          let m = pn;
          if (c) return () => hb(c, m);
          let x = (_) => {
            (l = null), Tl(_, m, 13, !i);
          };
          if ((a && m.suspense) || jc)
            return d()
              .then((_) => () => hb(_, m))
              .catch((_) => (x(_), () => (i ? Bi(i, { error: _ }) : null)));
          let y = Qe.ref(!1),
            g = Qe.ref(),
            b = Qe.ref(!!r);
          return (
            r &&
              setTimeout(() => {
                b.value = !1;
              }, r),
            s != null &&
              setTimeout(() => {
                if (!y.value && !g.value) {
                  let _ = new Error(`Async component timed out after ${s}ms.`);
                  x(_), (g.value = _);
                }
              }, s),
            d()
              .then(() => {
                (y.value = !0),
                  m.parent && Jh(m.parent.vnode) && Mb(m.parent.update);
              })
              .catch((_) => {
                x(_), (g.value = _);
              }),
            () => {
              if (y.value && c) return hb(c, m);
              if (g.value && i) return Bi(i, { error: g.value });
              if (t && !b.value) return Bi(t);
            }
          );
        },
      });
    }
    function hb(
      n,
      { vnode: { ref: e, props: t, children: i, shapeFlag: r }, parent: s }
    ) {
      let a = Bi(n, t, i);
      return (a.ref = e), a;
    }
    var Jh = (n) => n.type.__isKeepAlive,
      P9 = {
        name: "KeepAlive",
        __isKeepAlive: !0,
        props: {
          include: [String, RegExp, Array],
          exclude: [String, RegExp, Array],
          max: [String, Number],
        },
        setup(n, { slots: e }) {
          let t = Zh(),
            i = t.ctx;
          if (!i.renderer)
            return () => {
              let _ = e.default && e.default();
              return _ && _.length === 1 ? _[0] : _;
            };
          let r = new Map(),
            s = new Set(),
            a = null,
            o = t.suspense,
            {
              renderer: {
                p: l,
                m: c,
                um: u,
                o: { createElement: f },
              },
            } = i,
            d = f("div");
          (i.activate = (_, E, w, P, L) => {
            let I = _.component;
            c(_, E, w, 0, o),
              l(I.vnode, _, E, w, I, o, P, _.slotScopeIds, L),
              Tn(() => {
                (I.isDeactivated = !1), I.a && J.invokeArrayFns(I.a);
                let M = _.props && _.props.onVnodeMounted;
                M && or(M, I.parent, _);
              }, o);
          }),
            (i.deactivate = (_) => {
              let E = _.component;
              c(_, d, null, 1, o),
                Tn(() => {
                  E.da && J.invokeArrayFns(E.da);
                  let w = _.props && _.props.onVnodeUnmounted;
                  w && or(w, E.parent, _), (E.isDeactivated = !0);
                }, o);
            });
          function m(_) {
            fb(_), u(_, t, o, !0);
          }
          function x(_) {
            r.forEach((E, w) => {
              let P = nm(E.type);
              P && (!_ || !_(P)) && y(w);
            });
          }
          function y(_) {
            let E = r.get(_);
            !a || E.type !== a.type ? m(E) : a && fb(a),
              r.delete(_),
              s.delete(_);
          }
          Hh(
            () => [n.include, n.exclude],
            ([_, E]) => {
              _ && x((w) => Bh(_, w)), E && x((w) => !Bh(E, w));
            },
            { flush: "post", deep: !0 }
          );
          let g = null,
            b = () => {
              g != null && r.set(g, db(t.subTree));
            };
          return (
            lm(b),
            Lb(b),
            cm(() => {
              r.forEach((_) => {
                let { subTree: E, suspense: w } = t,
                  P = db(E);
                if (_.type === P.type) {
                  fb(P);
                  let L = P.component.da;
                  L && Tn(L, w);
                  return;
                }
                m(_);
              });
            }),
            () => {
              if (((g = null), !e.default)) return null;
              let _ = e.default(),
                E = _[0];
              if (_.length > 1) return (a = null), _;
              if (!yo(E) || (!(E.shapeFlag & 4) && !(E.shapeFlag & 128)))
                return (a = null), E;
              let w = db(E),
                P = w.type,
                L = nm(_l(w) ? w.type.__asyncResolved || {} : P),
                { include: I, exclude: M, max: R } = n;
              if ((I && (!L || !Bh(I, L))) || (M && L && Bh(M, L)))
                return (a = w), E;
              let O = w.key == null ? P : w.key,
                U = r.get(O);
              return (
                w.el && ((w = Ns(w)), E.shapeFlag & 128 && (E.ssContent = w)),
                (g = O),
                U
                  ? ((w.el = U.el),
                    (w.component = U.component),
                    w.transition && Yh(w, w.transition),
                    (w.shapeFlag |= 512),
                    s.delete(O),
                    s.add(O))
                  : (s.add(O),
                    R &&
                      s.size > parseInt(R, 10) &&
                      y(s.values().next().value)),
                (w.shapeFlag |= 256),
                (a = w),
                ND(E.type) ? E : w
              );
            }
          );
        },
      },
      D9 = P9;
    function Bh(n, e) {
      return J.isArray(n)
        ? n.some((t) => Bh(t, e))
        : J.isString(n)
        ? n.split(",").includes(e)
        : n.test
        ? n.test(e)
        : !1;
    }
    function GD(n, e) {
      $D(n, "a", e);
    }
    function HD(n, e) {
      $D(n, "da", e);
    }
    function $D(n, e, t = pn) {
      let i =
        n.__wdc ||
        (n.__wdc = () => {
          let r = t;
          for (; r; ) {
            if (r.isDeactivated) return;
            r = r.parent;
          }
          return n();
        });
      if ((om(e, i, t), t)) {
        let r = t.parent;
        for (; r && r.parent; )
          Jh(r.parent.vnode) && I9(i, e, t, r), (r = r.parent);
      }
    }
    function I9(n, e, t, i) {
      let r = om(e, n, i, !0);
      Rb(() => {
        J.remove(i[e], r);
      }, t);
    }
    function fb(n) {
      let e = n.shapeFlag;
      e & 256 && (e -= 256), e & 512 && (e -= 512), (n.shapeFlag = e);
    }
    function db(n) {
      return n.shapeFlag & 128 ? n.ssContent : n;
    }
    function om(n, e, t = pn, i = !1) {
      if (t) {
        let r = t[n] || (t[n] = []),
          s =
            e.__weh ||
            (e.__weh = (...a) => {
              if (t.isUnmounted) return;
              Qe.pauseTracking(), vo(t);
              let o = Qr(e, t, n, a);
              return go(), Qe.resetTracking(), o;
            });
        return i ? r.unshift(s) : r.push(s), s;
      }
    }
    var ma =
        (n) =>
        (e, t = pn) =>
          (!jc || n === "sp") && om(n, e, t),
      WD = ma("bm"),
      lm = ma("m"),
      qD = ma("bu"),
      Lb = ma("u"),
      cm = ma("bum"),
      Rb = ma("um"),
      jD = ma("sp"),
      XD = ma("rtg"),
      YD = ma("rtc");
    function KD(n, e = pn) {
      om("ec", n, e);
    }
    function L9(n, e) {
      let t = Ln;
      if (t === null) return n;
      let i = fm(t) || t.proxy,
        r = n.dirs || (n.dirs = []);
      for (let s = 0; s < e.length; s++) {
        let [a, o, l, c = J.EMPTY_OBJ] = e[s];
        J.isFunction(a) && (a = { mounted: a, updated: a }),
          a.deep && bl(o),
          r.push({
            dir: a,
            instance: i,
            value: o,
            oldValue: void 0,
            arg: l,
            modifiers: c,
          });
      }
      return n;
    }
    function Ls(n, e, t, i) {
      let r = n.dirs,
        s = e && e.dirs;
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        s && (o.oldValue = s[a].value);
        let l = o.dir[i];
        l &&
          (Qe.pauseTracking(),
          Qr(l, t, 8, [n.el, o, n, e]),
          Qe.resetTracking());
      }
    }
    var Ob = "components",
      R9 = "directives";
    function O9(n, e) {
      return Nb(Ob, n, !0, e) || n;
    }
    var JD = Symbol();
    function N9(n) {
      return J.isString(n) ? Nb(Ob, n, !1) || n : n || JD;
    }
    function k9(n) {
      return Nb(R9, n);
    }
    function Nb(n, e, t = !0, i = !1) {
      let r = Ln || pn;
      if (r) {
        let s = r.type;
        if (n === Ob) {
          let o = nm(s, !1);
          if (
            o &&
            (o === e ||
              o === J.camelize(e) ||
              o === J.capitalize(J.camelize(e)))
          )
            return s;
        }
        let a = vD(r[n] || s[n], e) || vD(r.appContext[n], e);
        return !a && i ? s : a;
      }
    }
    function vD(n, e) {
      return n && (n[e] || n[J.camelize(e)] || n[J.capitalize(J.camelize(e))]);
    }
    function F9(n, e, t, i) {
      let r,
        s = t && t[i];
      if (J.isArray(n) || J.isString(n)) {
        r = new Array(n.length);
        for (let a = 0, o = n.length; a < o; a++)
          r[a] = e(n[a], a, void 0, s && s[a]);
      } else if (typeof n == "number") {
        r = new Array(n);
        for (let a = 0; a < n; a++) r[a] = e(a + 1, a, void 0, s && s[a]);
      } else if (J.isObject(n))
        if (n[Symbol.iterator])
          r = Array.from(n, (a, o) => e(a, o, void 0, s && s[o]));
        else {
          let a = Object.keys(n);
          r = new Array(a.length);
          for (let o = 0, l = a.length; o < l; o++) {
            let c = a[o];
            r[o] = e(n[c], c, o, s && s[o]);
          }
        }
      else r = [];
      return t && (t[i] = r), r;
    }
    function B9(n, e) {
      for (let t = 0; t < e.length; t++) {
        let i = e[t];
        if (J.isArray(i))
          for (let r = 0; r < i.length; r++) n[i[r].name] = i[r].fn;
        else i && (n[i.name] = i.fn);
      }
      return n;
    }
    function z9(n, e, t = {}, i, r) {
      if (Ln.isCE || (Ln.parent && _l(Ln.parent) && Ln.parent.isCE))
        return Bi("slot", e === "default" ? null : { name: e }, i && i());
      let s = n[e];
      s && s._c && (s._d = !1), um();
      let a = s && ZD(s(t)),
        o = Bb(
          Xn,
          { key: t.key || `_${e}` },
          a || (i ? i() : []),
          a && n._ === 1 ? 64 : -2
        );
      return (
        !r && o.scopeId && (o.slotScopeIds = [o.scopeId + "-s"]),
        s && s._c && (s._d = !0),
        o
      );
    }
    function ZD(n) {
      return n.some((e) =>
        yo(e) ? !(e.type === Rn || (e.type === Xn && !ZD(e.children))) : !0
      )
        ? n
        : null;
    }
    function U9(n) {
      let e = {};
      for (let t in n) e[J.toHandlerKey(t)] = n[t];
      return e;
    }
    var gb = (n) => (n ? (pI(n) ? fm(n) || n.proxy : gb(n.parent)) : null),
      Qp = J.extend(Object.create(null), {
        $: (n) => n,
        $el: (n) => n.vnode.el,
        $data: (n) => n.data,
        $props: (n) => n.props,
        $attrs: (n) => n.attrs,
        $slots: (n) => n.slots,
        $refs: (n) => n.refs,
        $parent: (n) => gb(n.parent),
        $root: (n) => gb(n.root),
        $emit: (n) => n.emit,
        $options: (n) => eI(n),
        $forceUpdate: (n) => n.f || (n.f = () => Mb(n.update)),
        $nextTick: (n) => n.n || (n.n = PD.bind(n.proxy)),
        $watch: (n) => w9.bind(n),
      }),
      yb = {
        get({ _: n }, e) {
          let {
              ctx: t,
              setupState: i,
              data: r,
              props: s,
              accessCache: a,
              type: o,
              appContext: l,
            } = n,
            c;
          if (e[0] !== "$") {
            let m = a[e];
            if (m !== void 0)
              switch (m) {
                case 1:
                  return i[e];
                case 2:
                  return r[e];
                case 4:
                  return t[e];
                case 3:
                  return s[e];
              }
            else {
              if (i !== J.EMPTY_OBJ && J.hasOwn(i, e)) return (a[e] = 1), i[e];
              if (r !== J.EMPTY_OBJ && J.hasOwn(r, e)) return (a[e] = 2), r[e];
              if ((c = n.propsOptions[0]) && J.hasOwn(c, e))
                return (a[e] = 3), s[e];
              if (t !== J.EMPTY_OBJ && J.hasOwn(t, e)) return (a[e] = 4), t[e];
              vb && (a[e] = 0);
            }
          }
          let u = Qp[e],
            f,
            d;
          if (u) return e === "$attrs" && Qe.track(n, "get", e), u(n);
          if ((f = o.__cssModules) && (f = f[e])) return f;
          if (t !== J.EMPTY_OBJ && J.hasOwn(t, e)) return (a[e] = 4), t[e];
          if (((d = l.config.globalProperties), J.hasOwn(d, e))) return d[e];
        },
        set({ _: n }, e, t) {
          let { data: i, setupState: r, ctx: s } = n;
          return r !== J.EMPTY_OBJ && J.hasOwn(r, e)
            ? ((r[e] = t), !0)
            : i !== J.EMPTY_OBJ && J.hasOwn(i, e)
            ? ((i[e] = t), !0)
            : J.hasOwn(n.props, e) || (e[0] === "$" && e.slice(1) in n)
            ? !1
            : ((s[e] = t), !0);
        },
        has(
          {
            _: {
              data: n,
              setupState: e,
              accessCache: t,
              ctx: i,
              appContext: r,
              propsOptions: s,
            },
          },
          a
        ) {
          let o;
          return (
            !!t[a] ||
            (n !== J.EMPTY_OBJ && J.hasOwn(n, a)) ||
            (e !== J.EMPTY_OBJ && J.hasOwn(e, a)) ||
            ((o = s[0]) && J.hasOwn(o, a)) ||
            J.hasOwn(i, a) ||
            J.hasOwn(Qp, a) ||
            J.hasOwn(r.config.globalProperties, a)
          );
        },
        defineProperty(n, e, t) {
          return (
            t.get != null
              ? (n._.accessCache[e] = 0)
              : J.hasOwn(t, "value") && this.set(n, e, t.value, null),
            Reflect.defineProperty(n, e, t)
          );
        },
      },
      V9 = J.extend({}, yb, {
        get(n, e) {
          if (e !== Symbol.unscopables) return yb.get(n, e, n);
        },
        has(n, e) {
          return e[0] !== "_" && !J.isGloballyWhitelisted(e);
        },
      }),
      vb = !0;
    function G9(n) {
      let e = eI(n),
        t = n.proxy,
        i = n.ctx;
      (vb = !1), e.beforeCreate && xD(e.beforeCreate, n, "bc");
      let {
        data: r,
        computed: s,
        methods: a,
        watch: o,
        provide: l,
        inject: c,
        created: u,
        beforeMount: f,
        mounted: d,
        beforeUpdate: m,
        updated: x,
        activated: y,
        deactivated: g,
        beforeDestroy: b,
        beforeUnmount: _,
        destroyed: E,
        unmounted: w,
        render: P,
        renderTracked: L,
        renderTriggered: I,
        errorCaptured: M,
        serverPrefetch: R,
        expose: O,
        inheritAttrs: U,
        components: X,
        directives: $,
        filters: W,
      } = e;
      if ((c && H9(c, i, null, n.appContext.config.unwrapInjectedRef), a))
        for (let he in a) {
          let ce = a[he];
          J.isFunction(ce) && (i[he] = ce.bind(t));
        }
      if (r) {
        let he = r.call(t, t);
        J.isObject(he) && (n.data = Qe.reactive(he));
      }
      if (((vb = !0), s))
        for (let he in s) {
          let ce = s[he],
            te = J.isFunction(ce)
              ? ce.bind(t, t)
              : J.isFunction(ce.get)
              ? ce.get.bind(t, t)
              : J.NOOP,
            Me =
              !J.isFunction(ce) && J.isFunction(ce.set)
                ? ce.set.bind(t)
                : J.NOOP,
            ge = xI({ get: te, set: Me });
          Object.defineProperty(i, he, {
            enumerable: !0,
            configurable: !0,
            get: () => ge.value,
            set: (pe) => (ge.value = pe),
          });
        }
      if (o) for (let he in o) QD(o[he], i, t, he);
      if (l) {
        let he = J.isFunction(l) ? l.call(t) : l;
        Reflect.ownKeys(he).forEach((ce) => {
          FD(ce, he[ce]);
        });
      }
      u && xD(u, n, "c");
      function ae(he, ce) {
        J.isArray(ce)
          ? ce.forEach((te) => he(te.bind(t)))
          : ce && he(ce.bind(t));
      }
      if (
        (ae(WD, f),
        ae(lm, d),
        ae(qD, m),
        ae(Lb, x),
        ae(GD, y),
        ae(HD, g),
        ae(KD, M),
        ae(YD, L),
        ae(XD, I),
        ae(cm, _),
        ae(Rb, w),
        ae(jD, R),
        J.isArray(O))
      )
        if (O.length) {
          let he = n.exposed || (n.exposed = {});
          O.forEach((ce) => {
            Object.defineProperty(he, ce, {
              get: () => t[ce],
              set: (te) => (t[ce] = te),
            });
          });
        } else n.exposed || (n.exposed = {});
      P && n.render === J.NOOP && (n.render = P),
        U != null && (n.inheritAttrs = U),
        X && (n.components = X),
        $ && (n.directives = $);
    }
    function H9(n, e, t = J.NOOP, i = !1) {
      J.isArray(n) && (n = xb(n));
      for (let r in n) {
        let s = n[r],
          a;
        J.isObject(s)
          ? "default" in s
            ? (a = Gh(s.from || r, s.default, !0))
            : (a = Gh(s.from || r))
          : (a = Gh(s)),
          Qe.isRef(a) && i
            ? Object.defineProperty(e, r, {
                enumerable: !0,
                configurable: !0,
                get: () => a.value,
                set: (o) => (a.value = o),
              })
            : (e[r] = a);
      }
    }
    function xD(n, e, t) {
      Qr(J.isArray(n) ? n.map((i) => i.bind(e.proxy)) : n.bind(e.proxy), e, t);
    }
    function QD(n, e, t, i) {
      let r = i.includes(".") ? BD(t, i) : () => t[i];
      if (J.isString(n)) {
        let s = e[n];
        J.isFunction(s) && Hh(r, s);
      } else if (J.isFunction(n)) Hh(r, n.bind(t));
      else if (J.isObject(n))
        if (J.isArray(n)) n.forEach((s) => QD(s, e, t, i));
        else {
          let s = J.isFunction(n.handler) ? n.handler.bind(t) : e[n.handler];
          J.isFunction(s) && Hh(r, s, n);
        }
    }
    function eI(n) {
      let e = n.type,
        { mixins: t, extends: i } = e,
        {
          mixins: r,
          optionsCache: s,
          config: { optionMergeStrategies: a },
        } = n.appContext,
        o = s.get(e),
        l;
      return (
        o
          ? (l = o)
          : !r.length && !t && !i
          ? (l = e)
          : ((l = {}),
            r.length && r.forEach((c) => em(l, c, a, !0)),
            em(l, e, a)),
        s.set(e, l),
        l
      );
    }
    function em(n, e, t, i = !1) {
      let { mixins: r, extends: s } = e;
      s && em(n, s, t, !0), r && r.forEach((a) => em(n, a, t, !0));
      for (let a in e)
        if (!(i && a === "expose")) {
          let o = $9[a] || (t && t[a]);
          n[a] = o ? o(n[a], e[a]) : e[a];
        }
      return n;
    }
    var $9 = {
      data: bD,
      props: xl,
      emits: xl,
      methods: xl,
      computed: xl,
      beforeCreate: jn,
      created: jn,
      beforeMount: jn,
      mounted: jn,
      beforeUpdate: jn,
      updated: jn,
      beforeDestroy: jn,
      beforeUnmount: jn,
      destroyed: jn,
      unmounted: jn,
      activated: jn,
      deactivated: jn,
      errorCaptured: jn,
      serverPrefetch: jn,
      components: xl,
      directives: xl,
      watch: q9,
      provide: bD,
      inject: W9,
    };
    function bD(n, e) {
      return e
        ? n
          ? function () {
              return J.extend(
                J.isFunction(n) ? n.call(this, this) : n,
                J.isFunction(e) ? e.call(this, this) : e
              );
            }
          : e
        : n;
    }
    function W9(n, e) {
      return xl(xb(n), xb(e));
    }
    function xb(n) {
      if (J.isArray(n)) {
        let e = {};
        for (let t = 0; t < n.length; t++) e[n[t]] = n[t];
        return e;
      }
      return n;
    }
    function jn(n, e) {
      return n ? [...new Set([].concat(n, e))] : e;
    }
    function xl(n, e) {
      return n ? J.extend(J.extend(Object.create(null), n), e) : e;
    }
    function q9(n, e) {
      if (!n) return e;
      if (!e) return n;
      let t = J.extend(Object.create(null), n);
      for (let i in e) t[i] = jn(n[i], e[i]);
      return t;
    }
    function j9(n, e, t, i = !1) {
      let r = {},
        s = {};
      J.def(s, hm, 1), (n.propsDefaults = Object.create(null)), tI(n, e, r, s);
      for (let a in n.propsOptions[0]) a in r || (r[a] = void 0);
      t
        ? (n.props = i ? r : Qe.shallowReactive(r))
        : n.type.props
        ? (n.props = r)
        : (n.props = s),
        (n.attrs = s);
    }
    function X9(n, e, t, i) {
      let {
          props: r,
          attrs: s,
          vnode: { patchFlag: a },
        } = n,
        o = Qe.toRaw(r),
        [l] = n.propsOptions,
        c = !1;
      if ((i || a > 0) && !(a & 16)) {
        if (a & 8) {
          let u = n.vnode.dynamicProps;
          for (let f = 0; f < u.length; f++) {
            let d = u[f];
            if (sm(n.emitsOptions, d)) continue;
            let m = e[d];
            if (l)
              if (J.hasOwn(s, d)) m !== s[d] && ((s[d] = m), (c = !0));
              else {
                let x = J.camelize(d);
                r[x] = bb(l, o, x, m, n, !1);
              }
            else m !== s[d] && ((s[d] = m), (c = !0));
          }
        }
      } else {
        tI(n, e, r, s) && (c = !0);
        let u;
        for (let f in o)
          (!e ||
            (!J.hasOwn(e, f) &&
              ((u = J.hyphenate(f)) === f || !J.hasOwn(e, u)))) &&
            (l
              ? t &&
                (t[f] !== void 0 || t[u] !== void 0) &&
                (r[f] = bb(l, o, f, void 0, n, !0))
              : delete r[f]);
        if (s !== o)
          for (let f in s)
            (!e || (!J.hasOwn(e, f) && !0)) && (delete s[f], (c = !0));
      }
      c && Qe.trigger(n, "set", "$attrs");
    }
    function tI(n, e, t, i) {
      let [r, s] = n.propsOptions,
        a = !1,
        o;
      if (e)
        for (let l in e) {
          if (J.isReservedProp(l)) continue;
          let c = e[l],
            u;
          r && J.hasOwn(r, (u = J.camelize(l)))
            ? !s || !s.includes(u)
              ? (t[u] = c)
              : ((o || (o = {}))[u] = c)
            : sm(n.emitsOptions, l) ||
              ((!(l in i) || c !== i[l]) && ((i[l] = c), (a = !0)));
        }
      if (s) {
        let l = Qe.toRaw(t),
          c = o || J.EMPTY_OBJ;
        for (let u = 0; u < s.length; u++) {
          let f = s[u];
          t[f] = bb(r, l, f, c[f], n, !J.hasOwn(c, f));
        }
      }
      return a;
    }
    function bb(n, e, t, i, r, s) {
      let a = n[t];
      if (a != null) {
        let o = J.hasOwn(a, "default");
        if (o && i === void 0) {
          let l = a.default;
          if (a.type !== Function && J.isFunction(l)) {
            let { propsDefaults: c } = r;
            t in c ? (i = c[t]) : (vo(r), (i = c[t] = l.call(null, e)), go());
          } else i = l;
        }
        a[0] &&
          (s && !o
            ? (i = !1)
            : a[1] && (i === "" || i === J.hyphenate(t)) && (i = !0));
      }
      return i;
    }
    function iI(n, e, t = !1) {
      let i = e.propsCache,
        r = i.get(n);
      if (r) return r;
      let s = n.props,
        a = {},
        o = [],
        l = !1;
      if (!J.isFunction(n)) {
        let u = (f) => {
          l = !0;
          let [d, m] = iI(f, e, !0);
          J.extend(a, d), m && o.push(...m);
        };
        !t && e.mixins.length && e.mixins.forEach(u),
          n.extends && u(n.extends),
          n.mixins && n.mixins.forEach(u);
      }
      if (!s && !l) return i.set(n, J.EMPTY_ARR), J.EMPTY_ARR;
      if (J.isArray(s))
        for (let u = 0; u < s.length; u++) {
          let f = J.camelize(s[u]);
          _D(f) && (a[f] = J.EMPTY_OBJ);
        }
      else if (s)
        for (let u in s) {
          let f = J.camelize(u);
          if (_D(f)) {
            let d = s[u],
              m = (a[f] = J.isArray(d) || J.isFunction(d) ? { type: d } : d);
            if (m) {
              let x = SD(Boolean, m.type),
                y = SD(String, m.type);
              (m[0] = x > -1),
                (m[1] = y < 0 || x < y),
                (x > -1 || J.hasOwn(m, "default")) && o.push(f);
            }
          }
        }
      let c = [a, o];
      return i.set(n, c), c;
    }
    function _D(n) {
      return n[0] !== "$";
    }
    function ED(n) {
      let e = n && n.toString().match(/^\s*function (\w+)/);
      return e ? e[1] : n === null ? "null" : "";
    }
    function TD(n, e) {
      return ED(n) === ED(e);
    }
    function SD(n, e) {
      return J.isArray(e)
        ? e.findIndex((t) => TD(t, n))
        : J.isFunction(e) && TD(e, n)
        ? 0
        : -1;
    }
    var nI = (n) => n[0] === "_" || n === "$stable",
      kb = (n) => (J.isArray(n) ? n.map(Er) : [Er(n)]),
      Y9 = (n, e, t) => {
        if (e._n) return e;
        let i = Cb((...r) => kb(e(...r)), t);
        return (i._c = !1), i;
      },
      rI = (n, e, t) => {
        let i = n._ctx;
        for (let r in n) {
          if (nI(r)) continue;
          let s = n[r];
          if (J.isFunction(s)) e[r] = Y9(r, s, i);
          else if (s != null) {
            let a = kb(s);
            e[r] = () => a;
          }
        }
      },
      sI = (n, e) => {
        let t = kb(e);
        n.slots.default = () => t;
      },
      K9 = (n, e) => {
        if (n.vnode.shapeFlag & 32) {
          let t = e._;
          t
            ? ((n.slots = Qe.toRaw(e)), J.def(e, "_", t))
            : rI(e, (n.slots = {}));
        } else (n.slots = {}), e && sI(n, e);
        J.def(n.slots, hm, 1);
      },
      J9 = (n, e, t) => {
        let { vnode: i, slots: r } = n,
          s = !0,
          a = J.EMPTY_OBJ;
        if (i.shapeFlag & 32) {
          let o = e._;
          o
            ? t && o === 1
              ? (s = !1)
              : (J.extend(r, e), !t && o === 1 && delete r._)
            : ((s = !e.$stable), rI(e, r)),
            (a = e);
        } else e && (sI(n, e), (a = { default: 1 }));
        if (s) for (let o in r) !nI(o) && !(o in a) && delete r[o];
      };
    function aI() {
      return {
        app: null,
        config: {
          isNativeTag: J.NO,
          performance: !1,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {},
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap(),
      };
    }
    var Z9 = 0;
    function Q9(n, e) {
      return function (i, r = null) {
        J.isFunction(i) || (i = Ki({}, i)),
          r != null && !J.isObject(r) && (r = null);
        let s = aI(),
          a = new Set(),
          o = !1,
          l = (s.app = {
            _uid: Z9++,
            _component: i,
            _props: r,
            _container: null,
            _context: s,
            _instance: null,
            version: TI,
            get config() {
              return s.config;
            },
            set config(c) {},
            use(c, ...u) {
              return (
                a.has(c) ||
                  (c && J.isFunction(c.install)
                    ? (a.add(c), c.install(l, ...u))
                    : J.isFunction(c) && (a.add(c), c(l, ...u))),
                l
              );
            },
            mixin(c) {
              return s.mixins.includes(c) || s.mixins.push(c), l;
            },
            component(c, u) {
              return u ? ((s.components[c] = u), l) : s.components[c];
            },
            directive(c, u) {
              return u ? ((s.directives[c] = u), l) : s.directives[c];
            },
            mount(c, u, f) {
              if (!o) {
                let d = Bi(i, r);
                return (
                  (d.appContext = s),
                  u && e ? e(d, c) : n(d, c, f),
                  (o = !0),
                  (l._container = c),
                  (c.__vue_app__ = l),
                  fm(d.component) || d.component.proxy
                );
              }
            },
            unmount() {
              o && (n(null, l._container), delete l._container.__vue_app__);
            },
            provide(c, u) {
              return (s.provides[c] = u), l;
            },
          });
        return l;
      };
    }
    function tm(n, e, t, i, r = !1) {
      if (J.isArray(n)) {
        n.forEach((d, m) => tm(d, e && (J.isArray(e) ? e[m] : e), t, i, r));
        return;
      }
      if (_l(i) && !r) return;
      let s = i.shapeFlag & 4 ? fm(i.component) || i.component.proxy : i.el,
        a = r ? null : s,
        { i: o, r: l } = n,
        c = e && e.r,
        u = o.refs === J.EMPTY_OBJ ? (o.refs = {}) : o.refs,
        f = o.setupState;
      if (
        (c != null &&
          c !== l &&
          (J.isString(c)
            ? ((u[c] = null), J.hasOwn(f, c) && (f[c] = null))
            : Qe.isRef(c) && (c.value = null)),
        J.isFunction(l))
      )
        Os(l, o, 12, [a, u]);
      else {
        let d = J.isString(l),
          m = Qe.isRef(l);
        if (d || m) {
          let x = () => {
            if (n.f) {
              let y = d ? u[l] : l.value;
              r
                ? J.isArray(y) && J.remove(y, s)
                : J.isArray(y)
                ? y.includes(s) || y.push(s)
                : d
                ? ((u[l] = [s]), J.hasOwn(f, l) && (f[l] = u[l]))
                : ((l.value = [s]), n.k && (u[n.k] = l.value));
            } else
              d
                ? ((u[l] = a), J.hasOwn(f, l) && (f[l] = a))
                : m && ((l.value = a), n.k && (u[n.k] = a));
          };
          a ? ((x.id = -1), Tn(x, t)) : x();
        }
      }
    }
    var fo = !1,
      Wp = (n) => /svg/.test(n.namespaceURI) && n.tagName !== "foreignObject",
      qp = (n) => n.nodeType === 8;
    function eW(n) {
      let {
          mt: e,
          p: t,
          o: {
            patchProp: i,
            createText: r,
            nextSibling: s,
            parentNode: a,
            remove: o,
            insert: l,
            createComment: c,
          },
        } = n,
        u = (b, _) => {
          if (!_.hasChildNodes()) {
            t(null, b, _), Jp(), (_._vnode = b);
            return;
          }
          (fo = !1),
            f(_.firstChild, b, null, null, null),
            Jp(),
            (_._vnode = b),
            fo && console.error("Hydration completed but contains mismatches.");
        },
        f = (b, _, E, w, P, L = !1) => {
          let I = qp(b) && b.data === "[",
            M = () => y(b, _, E, w, P, I),
            { type: R, ref: O, shapeFlag: U, patchFlag: X } = _,
            $ = b.nodeType;
          (_.el = b), X === -2 && ((L = !1), (_.dynamicChildren = null));
          let W = null;
          switch (R) {
            case qc:
              $ !== 3
                ? _.children === ""
                  ? (l((_.el = r("")), a(b), b), (W = b))
                  : (W = M())
                : (b.data !== _.children && ((fo = !0), (b.data = _.children)),
                  (W = s(b)));
              break;
            case Rn:
              $ !== 8 || I ? (W = M()) : (W = s(b));
              break;
            case Wc:
              if ($ !== 1 && $ !== 3) W = M();
              else {
                W = b;
                let ue = !_.children.length;
                for (let ae = 0; ae < _.staticCount; ae++)
                  ue && (_.children += W.nodeType === 1 ? W.outerHTML : W.data),
                    ae === _.staticCount - 1 && (_.anchor = W),
                    (W = s(W));
                return W;
              }
              break;
            case Xn:
              I ? (W = x(b, _, E, w, P, L)) : (W = M());
              break;
            default:
              if (U & 1)
                $ !== 1 || _.type.toLowerCase() !== b.tagName.toLowerCase()
                  ? (W = M())
                  : (W = d(b, _, E, w, P, L));
              else if (U & 6) {
                _.slotScopeIds = P;
                let ue = a(b);
                if (
                  (e(_, ue, null, E, w, Wp(ue), L),
                  (W = I ? g(b) : s(b)),
                  W && qp(W) && W.data === "teleport end" && (W = s(W)),
                  _l(_))
                ) {
                  let ae;
                  I
                    ? ((ae = Bi(Xn)),
                      (ae.anchor = W ? W.previousSibling : ue.lastChild))
                    : (ae = b.nodeType === 3 ? Ub("") : Bi("div")),
                    (ae.el = b),
                    (_.component.subTree = ae);
                }
              } else
                U & 64
                  ? $ !== 8
                    ? (W = M())
                    : (W = _.type.hydrate(b, _, E, w, P, L, n, m))
                  : U & 128 &&
                    (W = _.type.hydrate(b, _, E, w, Wp(a(b)), P, L, n, f));
          }
          return O != null && tm(O, null, w, _), W;
        },
        d = (b, _, E, w, P, L) => {
          L = L || !!_.dynamicChildren;
          let { type: I, props: M, patchFlag: R, shapeFlag: O, dirs: U } = _,
            X = (I === "input" && U) || I === "option";
          if (X || R !== -1) {
            if ((U && Ls(_, null, E, "created"), M))
              if (X || !L || R & 48)
                for (let W in M)
                  ((X && W.endsWith("value")) ||
                    (J.isOn(W) && !J.isReservedProp(W))) &&
                    i(b, W, null, M[W], !1, void 0, E);
              else M.onClick && i(b, "onClick", null, M.onClick, !1, void 0, E);
            let $;
            if (
              (($ = M && M.onVnodeBeforeMount) && or($, E, _),
              U && Ls(_, null, E, "beforeMount"),
              (($ = M && M.onVnodeMounted) || U) &&
                kD(() => {
                  $ && or($, E, _), U && Ls(_, null, E, "mounted");
                }, w),
              O & 16 && !(M && (M.innerHTML || M.textContent)))
            ) {
              let W = m(b.firstChild, _, b, E, w, P, L);
              for (; W; ) {
                fo = !0;
                let ue = W;
                (W = W.nextSibling), o(ue);
              }
            } else
              O & 8 &&
                b.textContent !== _.children &&
                ((fo = !0), (b.textContent = _.children));
          }
          return b.nextSibling;
        },
        m = (b, _, E, w, P, L, I) => {
          I = I || !!_.dynamicChildren;
          let M = _.children,
            R = M.length;
          for (let O = 0; O < R; O++) {
            let U = I ? M[O] : (M[O] = Er(M[O]));
            if (b) b = f(b, U, w, P, L, I);
            else {
              if (U.type === qc && !U.children) continue;
              (fo = !0), t(null, U, E, null, w, P, Wp(E), L);
            }
          }
          return b;
        },
        x = (b, _, E, w, P, L) => {
          let { slotScopeIds: I } = _;
          I && (P = P ? P.concat(I) : I);
          let M = a(b),
            R = m(s(b), _, M, E, w, P, L);
          return R && qp(R) && R.data === "]"
            ? s((_.anchor = R))
            : ((fo = !0), l((_.anchor = c("]")), M, R), R);
        },
        y = (b, _, E, w, P, L) => {
          if (((fo = !0), (_.el = null), L)) {
            let R = g(b);
            for (;;) {
              let O = s(b);
              if (O && O !== R) o(O);
              else break;
            }
          }
          let I = s(b),
            M = a(b);
          return o(b), t(null, _, M, I, E, w, Wp(M), P), I;
        },
        g = (b) => {
          let _ = 0;
          for (; b; )
            if (
              ((b = s(b)),
              b && qp(b) && (b.data === "[" && _++, b.data === "]"))
            ) {
              if (_ === 0) return s(b);
              _--;
            }
          return b;
        };
      return [u, f];
    }
    var Tn = kD;
    function tW(n) {
      return oI(n);
    }
    function iW(n) {
      return oI(n, eW);
    }
    function oI(n, e) {
      let t = J.getGlobalThis();
      t.__VUE__ = !0;
      let {
          insert: i,
          remove: r,
          patchProp: s,
          createElement: a,
          createText: o,
          createComment: l,
          setText: c,
          setElementText: u,
          parentNode: f,
          nextSibling: d,
          setScopeId: m = J.NOOP,
          cloneNode: x,
          insertStaticContent: y,
        } = n,
        g = (
          Y,
          ie,
          ye,
          Pe = null,
          De = null,
          Ie = null,
          Ue = !1,
          Ve = null,
          He = !!ie.dynamicChildren
        ) => {
          if (Y === ie) return;
          Y && !Rs(Y, ie) && ((Pe = Ye(Y)), We(Y, De, Ie, !0), (Y = null)),
            ie.patchFlag === -2 && ((He = !1), (ie.dynamicChildren = null));
          let { type: B, ref: F, shapeFlag: re } = ie;
          switch (B) {
            case qc:
              b(Y, ie, ye, Pe);
              break;
            case Rn:
              _(Y, ie, ye, Pe);
              break;
            case Wc:
              Y == null && E(ie, ye, Pe, Ue);
              break;
            case Xn:
              $(Y, ie, ye, Pe, De, Ie, Ue, Ve, He);
              break;
            default:
              re & 1
                ? L(Y, ie, ye, Pe, De, Ie, Ue, Ve, He)
                : re & 6
                ? W(Y, ie, ye, Pe, De, Ie, Ue, Ve, He)
                : (re & 64 || re & 128) &&
                  B.process(Y, ie, ye, Pe, De, Ie, Ue, Ve, He, Ze);
          }
          F != null && De && tm(F, Y && Y.ref, Ie, ie || Y, !ie);
        },
        b = (Y, ie, ye, Pe) => {
          if (Y == null) i((ie.el = o(ie.children)), ye, Pe);
          else {
            let De = (ie.el = Y.el);
            ie.children !== Y.children && c(De, ie.children);
          }
        },
        _ = (Y, ie, ye, Pe) => {
          Y == null
            ? i((ie.el = l(ie.children || "")), ye, Pe)
            : (ie.el = Y.el);
        },
        E = (Y, ie, ye, Pe) => {
          [Y.el, Y.anchor] = y(Y.children, ie, ye, Pe, Y.el, Y.anchor);
        },
        w = ({ el: Y, anchor: ie }, ye, Pe) => {
          let De;
          for (; Y && Y !== ie; ) (De = d(Y)), i(Y, ye, Pe), (Y = De);
          i(ie, ye, Pe);
        },
        P = ({ el: Y, anchor: ie }) => {
          let ye;
          for (; Y && Y !== ie; ) (ye = d(Y)), r(Y), (Y = ye);
          r(ie);
        },
        L = (Y, ie, ye, Pe, De, Ie, Ue, Ve, He) => {
          (Ue = Ue || ie.type === "svg"),
            Y == null
              ? I(ie, ye, Pe, De, Ie, Ue, Ve, He)
              : O(Y, ie, De, Ie, Ue, Ve, He);
        },
        I = (Y, ie, ye, Pe, De, Ie, Ue, Ve) => {
          let He,
            B,
            {
              type: F,
              props: re,
              shapeFlag: ve,
              transition: Te,
              patchFlag: q,
              dirs: j,
            } = Y;
          if (Y.el && x !== void 0 && q === -1) He = Y.el = x(Y.el);
          else {
            if (
              ((He = Y.el = a(Y.type, Ie, re && re.is, re)),
              ve & 8
                ? u(He, Y.children)
                : ve & 16 &&
                  R(
                    Y.children,
                    He,
                    null,
                    Pe,
                    De,
                    Ie && F !== "foreignObject",
                    Ue,
                    Ve
                  ),
              j && Ls(Y, null, Pe, "created"),
              re)
            ) {
              for (let D in re)
                D !== "value" &&
                  !J.isReservedProp(D) &&
                  s(He, D, null, re[D], Ie, Y.children, Pe, De, ut);
              "value" in re && s(He, "value", null, re.value),
                (B = re.onVnodeBeforeMount) && or(B, Pe, Y);
            }
            M(He, Y, Y.scopeId, Ue, Pe);
          }
          j && Ls(Y, null, Pe, "beforeMount");
          let A = (!De || (De && !De.pendingBranch)) && Te && !Te.persisted;
          A && Te.beforeEnter(He),
            i(He, ie, ye),
            ((B = re && re.onVnodeMounted) || A || j) &&
              Tn(() => {
                B && or(B, Pe, Y),
                  A && Te.enter(He),
                  j && Ls(Y, null, Pe, "mounted");
              }, De);
        },
        M = (Y, ie, ye, Pe, De) => {
          if ((ye && m(Y, ye), Pe))
            for (let Ie = 0; Ie < Pe.length; Ie++) m(Y, Pe[Ie]);
          if (De) {
            let Ie = De.subTree;
            if (ie === Ie) {
              let Ue = De.vnode;
              M(Y, Ue, Ue.scopeId, Ue.slotScopeIds, De.parent);
            }
          }
        },
        R = (Y, ie, ye, Pe, De, Ie, Ue, Ve, He = 0) => {
          for (let B = He; B < Y.length; B++) {
            let F = (Y[B] = Ve ? mo(Y[B]) : Er(Y[B]));
            g(null, F, ie, ye, Pe, De, Ie, Ue, Ve);
          }
        },
        O = (Y, ie, ye, Pe, De, Ie, Ue) => {
          let Ve = (ie.el = Y.el),
            { patchFlag: He, dynamicChildren: B, dirs: F } = ie;
          He |= Y.patchFlag & 16;
          let re = Y.props || J.EMPTY_OBJ,
            ve = ie.props || J.EMPTY_OBJ,
            Te;
          ye && vl(ye, !1),
            (Te = ve.onVnodeBeforeUpdate) && or(Te, ye, ie, Y),
            F && Ls(ie, Y, ye, "beforeUpdate"),
            ye && vl(ye, !0);
          let q = De && ie.type !== "foreignObject";
          if (
            (B
              ? U(Y.dynamicChildren, B, Ve, ye, Pe, q, Ie)
              : Ue || te(Y, ie, Ve, null, ye, Pe, q, Ie, !1),
            He > 0)
          ) {
            if (He & 16) X(Ve, ie, re, ve, ye, Pe, De);
            else if (
              (He & 2 &&
                re.class !== ve.class &&
                s(Ve, "class", null, ve.class, De),
              He & 4 && s(Ve, "style", re.style, ve.style, De),
              He & 8)
            ) {
              let j = ie.dynamicProps;
              for (let A = 0; A < j.length; A++) {
                let D = j[A],
                  V = re[D],
                  Q = ve[D];
                (Q !== V || D === "value") &&
                  s(Ve, D, V, Q, De, Y.children, ye, Pe, ut);
              }
            }
            He & 1 && Y.children !== ie.children && u(Ve, ie.children);
          } else !Ue && B == null && X(Ve, ie, re, ve, ye, Pe, De);
          ((Te = ve.onVnodeUpdated) || F) &&
            Tn(() => {
              Te && or(Te, ye, ie, Y), F && Ls(ie, Y, ye, "updated");
            }, Pe);
        },
        U = (Y, ie, ye, Pe, De, Ie, Ue) => {
          for (let Ve = 0; Ve < ie.length; Ve++) {
            let He = Y[Ve],
              B = ie[Ve],
              F =
                He.el && (He.type === Xn || !Rs(He, B) || He.shapeFlag & 70)
                  ? f(He.el)
                  : ye;
            g(He, B, F, null, Pe, De, Ie, Ue, !0);
          }
        },
        X = (Y, ie, ye, Pe, De, Ie, Ue) => {
          if (ye !== Pe) {
            for (let Ve in Pe) {
              if (J.isReservedProp(Ve)) continue;
              let He = Pe[Ve],
                B = ye[Ve];
              He !== B &&
                Ve !== "value" &&
                s(Y, Ve, B, He, Ue, ie.children, De, Ie, ut);
            }
            if (ye !== J.EMPTY_OBJ)
              for (let Ve in ye)
                !J.isReservedProp(Ve) &&
                  !(Ve in Pe) &&
                  s(Y, Ve, ye[Ve], null, Ue, ie.children, De, Ie, ut);
            "value" in Pe && s(Y, "value", ye.value, Pe.value);
          }
        },
        $ = (Y, ie, ye, Pe, De, Ie, Ue, Ve, He) => {
          let B = (ie.el = Y ? Y.el : o("")),
            F = (ie.anchor = Y ? Y.anchor : o("")),
            { patchFlag: re, dynamicChildren: ve, slotScopeIds: Te } = ie;
          Te && (Ve = Ve ? Ve.concat(Te) : Te),
            Y == null
              ? (i(B, ye, Pe),
                i(F, ye, Pe),
                R(ie.children, ye, F, De, Ie, Ue, Ve, He))
              : re > 0 && re & 64 && ve && Y.dynamicChildren
              ? (U(Y.dynamicChildren, ve, ye, De, Ie, Ue, Ve),
                (ie.key != null || (De && ie === De.subTree)) && Fb(Y, ie, !0))
              : te(Y, ie, ye, F, De, Ie, Ue, Ve, He);
        },
        W = (Y, ie, ye, Pe, De, Ie, Ue, Ve, He) => {
          (ie.slotScopeIds = Ve),
            Y == null
              ? ie.shapeFlag & 512
                ? De.ctx.activate(ie, ye, Pe, Ue, He)
                : ue(ie, ye, Pe, De, Ie, Ue, He)
              : ae(Y, ie, He);
        },
        ue = (Y, ie, ye, Pe, De, Ie, Ue) => {
          let Ve = (Y.component = dI(Y, Pe, De));
          if ((Jh(Y) && (Ve.ctx.renderer = Ze), mI(Ve), Ve.asyncDep)) {
            if ((De && De.registerDep(Ve, he), !Y.el)) {
              let He = (Ve.subTree = Bi(Rn));
              _(null, He, ie, ye);
            }
            return;
          }
          he(Ve, Y, ie, ye, De, Ie, Ue);
        },
        ae = (Y, ie, ye) => {
          let Pe = (ie.component = Y.component);
          if (m9(Y, ie, ye))
            if (Pe.asyncDep && !Pe.asyncResolved) {
              ce(Pe, ie, ye);
              return;
            } else (Pe.next = ie), a9(Pe.update), Pe.update();
          else (ie.el = Y.el), (Pe.vnode = ie);
        },
        he = (Y, ie, ye, Pe, De, Ie, Ue) => {
          let Ve = () => {
              if (Y.isMounted) {
                let { next: F, bu: re, u: ve, parent: Te, vnode: q } = Y,
                  j = F,
                  A;
                vl(Y, !1),
                  F ? ((F.el = q.el), ce(Y, F, Ue)) : (F = q),
                  re && J.invokeArrayFns(re),
                  (A = F.props && F.props.onVnodeBeforeUpdate) &&
                    or(A, Te, F, q),
                  vl(Y, !0);
                let D = Xp(Y),
                  V = Y.subTree;
                (Y.subTree = D),
                  g(V, D, f(V.el), Ye(V), Y, De, Ie),
                  (F.el = D.el),
                  j === null && Pb(Y, D.el),
                  ve && Tn(ve, De),
                  (A = F.props && F.props.onVnodeUpdated) &&
                    Tn(() => or(A, Te, F, q), De);
              } else {
                let F,
                  { el: re, props: ve } = ie,
                  { bm: Te, m: q, parent: j } = Y,
                  A = _l(ie);
                if (
                  (vl(Y, !1),
                  Te && J.invokeArrayFns(Te),
                  !A && (F = ve && ve.onVnodeBeforeMount) && or(F, j, ie),
                  vl(Y, !0),
                  re && Et)
                ) {
                  let D = () => {
                    (Y.subTree = Xp(Y)), Et(re, Y.subTree, Y, De, null);
                  };
                  A
                    ? ie.type.__asyncLoader().then(() => !Y.isUnmounted && D())
                    : D();
                } else {
                  let D = (Y.subTree = Xp(Y));
                  g(null, D, ye, Pe, Y, De, Ie), (ie.el = D.el);
                }
                if ((q && Tn(q, De), !A && (F = ve && ve.onVnodeMounted))) {
                  let D = ie;
                  Tn(() => or(F, j, D), De);
                }
                (ie.shapeFlag & 256 ||
                  (j && _l(j.vnode) && j.vnode.shapeFlag & 256)) &&
                  Y.a &&
                  Tn(Y.a, De),
                  (Y.isMounted = !0),
                  (ie = ye = Pe = null);
              }
            },
            He = (Y.effect = new Qe.ReactiveEffect(Ve, () => Mb(B), Y.scope)),
            B = (Y.update = () => He.run());
          (B.id = Y.uid), vl(Y, !0), B();
        },
        ce = (Y, ie, ye) => {
          ie.component = Y;
          let Pe = Y.vnode.props;
          (Y.vnode = ie),
            (Y.next = null),
            X9(Y, ie.props, Pe, ye),
            J9(Y, ie.children, ye),
            Qe.pauseTracking(),
            rm(void 0, Y.update),
            Qe.resetTracking();
        },
        te = (Y, ie, ye, Pe, De, Ie, Ue, Ve, He = !1) => {
          let B = Y && Y.children,
            F = Y ? Y.shapeFlag : 0,
            re = ie.children,
            { patchFlag: ve, shapeFlag: Te } = ie;
          if (ve > 0) {
            if (ve & 128) {
              ge(B, re, ye, Pe, De, Ie, Ue, Ve, He);
              return;
            } else if (ve & 256) {
              Me(B, re, ye, Pe, De, Ie, Ue, Ve, He);
              return;
            }
          }
          Te & 8
            ? (F & 16 && ut(B, De, Ie), re !== B && u(ye, re))
            : F & 16
            ? Te & 16
              ? ge(B, re, ye, Pe, De, Ie, Ue, Ve, He)
              : ut(B, De, Ie, !0)
            : (F & 8 && u(ye, ""),
              Te & 16 && R(re, ye, Pe, De, Ie, Ue, Ve, He));
        },
        Me = (Y, ie, ye, Pe, De, Ie, Ue, Ve, He) => {
          (Y = Y || J.EMPTY_ARR), (ie = ie || J.EMPTY_ARR);
          let B = Y.length,
            F = ie.length,
            re = Math.min(B, F),
            ve;
          for (ve = 0; ve < re; ve++) {
            let Te = (ie[ve] = He ? mo(ie[ve]) : Er(ie[ve]));
            g(Y[ve], Te, ye, null, De, Ie, Ue, Ve, He);
          }
          B > F
            ? ut(Y, De, Ie, !0, !1, re)
            : R(ie, ye, Pe, De, Ie, Ue, Ve, He, re);
        },
        ge = (Y, ie, ye, Pe, De, Ie, Ue, Ve, He) => {
          let B = 0,
            F = ie.length,
            re = Y.length - 1,
            ve = F - 1;
          for (; B <= re && B <= ve; ) {
            let Te = Y[B],
              q = (ie[B] = He ? mo(ie[B]) : Er(ie[B]));
            if (Rs(Te, q)) g(Te, q, ye, null, De, Ie, Ue, Ve, He);
            else break;
            B++;
          }
          for (; B <= re && B <= ve; ) {
            let Te = Y[re],
              q = (ie[ve] = He ? mo(ie[ve]) : Er(ie[ve]));
            if (Rs(Te, q)) g(Te, q, ye, null, De, Ie, Ue, Ve, He);
            else break;
            re--, ve--;
          }
          if (B > re) {
            if (B <= ve) {
              let Te = ve + 1,
                q = Te < F ? ie[Te].el : Pe;
              for (; B <= ve; )
                g(
                  null,
                  (ie[B] = He ? mo(ie[B]) : Er(ie[B])),
                  ye,
                  q,
                  De,
                  Ie,
                  Ue,
                  Ve,
                  He
                ),
                  B++;
            }
          } else if (B > ve) for (; B <= re; ) We(Y[B], De, Ie, !0), B++;
          else {
            let Te = B,
              q = B,
              j = new Map();
            for (B = q; B <= ve; B++) {
              let Ee = (ie[B] = He ? mo(ie[B]) : Er(ie[B]));
              Ee.key != null && j.set(Ee.key, B);
            }
            let A,
              D = 0,
              V = ve - q + 1,
              Q = !1,
              ee = 0,
              _e = new Array(V);
            for (B = 0; B < V; B++) _e[B] = 0;
            for (B = Te; B <= re; B++) {
              let Ee = Y[B];
              if (D >= V) {
                We(Ee, De, Ie, !0);
                continue;
              }
              let Se;
              if (Ee.key != null) Se = j.get(Ee.key);
              else
                for (A = q; A <= ve; A++)
                  if (_e[A - q] === 0 && Rs(Ee, ie[A])) {
                    Se = A;
                    break;
                  }
              Se === void 0
                ? We(Ee, De, Ie, !0)
                : ((_e[Se - q] = B + 1),
                  Se >= ee ? (ee = Se) : (Q = !0),
                  g(Ee, ie[Se], ye, null, De, Ie, Ue, Ve, He),
                  D++);
            }
            let Re = Q ? nW(_e) : J.EMPTY_ARR;
            for (A = Re.length - 1, B = V - 1; B >= 0; B--) {
              let Ee = q + B,
                Se = ie[Ee],
                st = Ee + 1 < F ? ie[Ee + 1].el : Pe;
              _e[B] === 0
                ? g(null, Se, ye, st, De, Ie, Ue, Ve, He)
                : Q && (A < 0 || B !== Re[A] ? pe(Se, ye, st, 2) : A--);
            }
          }
        },
        pe = (Y, ie, ye, Pe, De = null) => {
          let {
            el: Ie,
            type: Ue,
            transition: Ve,
            children: He,
            shapeFlag: B,
          } = Y;
          if (B & 6) {
            pe(Y.component.subTree, ie, ye, Pe);
            return;
          }
          if (B & 128) {
            Y.suspense.move(ie, ye, Pe);
            return;
          }
          if (B & 64) {
            Ue.move(Y, ie, ye, Ze);
            return;
          }
          if (Ue === Xn) {
            i(Ie, ie, ye);
            for (let re = 0; re < He.length; re++) pe(He[re], ie, ye, Pe);
            i(Y.anchor, ie, ye);
            return;
          }
          if (Ue === Wc) {
            w(Y, ie, ye);
            return;
          }
          if (Pe !== 2 && B & 1 && Ve)
            if (Pe === 0)
              Ve.beforeEnter(Ie), i(Ie, ie, ye), Tn(() => Ve.enter(Ie), De);
            else {
              let { leave: re, delayLeave: ve, afterLeave: Te } = Ve,
                q = () => i(Ie, ie, ye),
                j = () => {
                  re(Ie, () => {
                    q(), Te && Te();
                  });
                };
              ve ? ve(Ie, q, j) : j();
            }
          else i(Ie, ie, ye);
        },
        We = (Y, ie, ye, Pe = !1, De = !1) => {
          let {
            type: Ie,
            props: Ue,
            ref: Ve,
            children: He,
            dynamicChildren: B,
            shapeFlag: F,
            patchFlag: re,
            dirs: ve,
          } = Y;
          if ((Ve != null && tm(Ve, null, ye, Y, !0), F & 256)) {
            ie.ctx.deactivate(Y);
            return;
          }
          let Te = F & 1 && ve,
            q = !_l(Y),
            j;
          if ((q && (j = Ue && Ue.onVnodeBeforeUnmount) && or(j, ie, Y), F & 6))
            be(Y.component, ye, Pe);
          else {
            if (F & 128) {
              Y.suspense.unmount(ye, Pe);
              return;
            }
            Te && Ls(Y, null, ie, "beforeUnmount"),
              F & 64
                ? Y.type.remove(Y, ie, ye, De, Ze, Pe)
                : B && (Ie !== Xn || (re > 0 && re & 64))
                ? ut(B, ie, ye, !1, !0)
                : ((Ie === Xn && re & 384) || (!De && F & 16)) &&
                  ut(He, ie, ye),
              Pe && Fe(Y);
          }
          ((q && (j = Ue && Ue.onVnodeUnmounted)) || Te) &&
            Tn(() => {
              j && or(j, ie, Y), Te && Ls(Y, null, ie, "unmounted");
            }, ye);
        },
        Fe = (Y) => {
          let { type: ie, el: ye, anchor: Pe, transition: De } = Y;
          if (ie === Xn) {
            Be(ye, Pe);
            return;
          }
          if (ie === Wc) {
            P(Y);
            return;
          }
          let Ie = () => {
            r(ye), De && !De.persisted && De.afterLeave && De.afterLeave();
          };
          if (Y.shapeFlag & 1 && De && !De.persisted) {
            let { leave: Ue, delayLeave: Ve } = De,
              He = () => Ue(ye, Ie);
            Ve ? Ve(Y.el, Ie, He) : He();
          } else Ie();
        },
        Be = (Y, ie) => {
          let ye;
          for (; Y !== ie; ) (ye = d(Y)), r(Y), (Y = ye);
          r(ie);
        },
        be = (Y, ie, ye) => {
          let { bum: Pe, scope: De, update: Ie, subTree: Ue, um: Ve } = Y;
          Pe && J.invokeArrayFns(Pe),
            De.stop(),
            Ie && ((Ie.active = !1), We(Ue, Y, ie, ye)),
            Ve && Tn(Ve, ie),
            Tn(() => {
              Y.isUnmounted = !0;
            }, ie),
            ie &&
              ie.pendingBranch &&
              !ie.isUnmounted &&
              Y.asyncDep &&
              !Y.asyncResolved &&
              Y.suspenseId === ie.pendingId &&
              (ie.deps--, ie.deps === 0 && ie.resolve());
        },
        ut = (Y, ie, ye, Pe = !1, De = !1, Ie = 0) => {
          for (let Ue = Ie; Ue < Y.length; Ue++) We(Y[Ue], ie, ye, Pe, De);
        },
        Ye = (Y) =>
          Y.shapeFlag & 6
            ? Ye(Y.component.subTree)
            : Y.shapeFlag & 128
            ? Y.suspense.next()
            : d(Y.anchor || Y.el),
        _t = (Y, ie, ye) => {
          Y == null
            ? ie._vnode && We(ie._vnode, null, null, !0)
            : g(ie._vnode || null, Y, ie, null, null, null, ye),
            Jp(),
            (ie._vnode = Y);
        },
        Ze = {
          p: g,
          um: We,
          m: pe,
          r: Fe,
          mt: ue,
          mc: R,
          pc: te,
          pbc: U,
          n: Ye,
          o: n,
        },
        kt,
        Et;
      return (
        e && ([kt, Et] = e(Ze)),
        { render: _t, hydrate: kt, createApp: Q9(_t, kt) }
      );
    }
    function vl({ effect: n, update: e }, t) {
      n.allowRecurse = e.allowRecurse = t;
    }
    function Fb(n, e, t = !1) {
      let i = n.children,
        r = e.children;
      if (J.isArray(i) && J.isArray(r))
        for (let s = 0; s < i.length; s++) {
          let a = i[s],
            o = r[s];
          o.shapeFlag & 1 &&
            !o.dynamicChildren &&
            ((o.patchFlag <= 0 || o.patchFlag === 32) &&
              ((o = r[s] = mo(r[s])), (o.el = a.el)),
            t || Fb(a, o));
        }
    }
    function nW(n) {
      let e = n.slice(),
        t = [0],
        i,
        r,
        s,
        a,
        o,
        l = n.length;
      for (i = 0; i < l; i++) {
        let c = n[i];
        if (c !== 0) {
          if (((r = t[t.length - 1]), n[r] < c)) {
            (e[i] = r), t.push(i);
            continue;
          }
          for (s = 0, a = t.length - 1; s < a; )
            (o = (s + a) >> 1), n[t[o]] < c ? (s = o + 1) : (a = o);
          c < n[t[s]] && (s > 0 && (e[i] = t[s - 1]), (t[s] = i));
        }
      }
      for (s = t.length, a = t[s - 1]; s-- > 0; ) (t[s] = a), (a = e[a]);
      return t;
    }
    var rW = (n) => n.__isTeleport,
      $h = (n) => n && (n.disabled || n.disabled === ""),
      wD = (n) => typeof SVGElement != "undefined" && n instanceof SVGElement,
      _b = (n, e) => {
        let t = n && n.to;
        return J.isString(t) ? (e ? e(t) : null) : t;
      },
      sW = {
        __isTeleport: !0,
        process(n, e, t, i, r, s, a, o, l, c) {
          let {
              mc: u,
              pc: f,
              pbc: d,
              o: {
                insert: m,
                querySelector: x,
                createText: y,
                createComment: g,
              },
            } = c,
            b = $h(e.props),
            { shapeFlag: _, children: E, dynamicChildren: w } = e;
          if (n == null) {
            let P = (e.el = y("")),
              L = (e.anchor = y(""));
            m(P, t, i), m(L, t, i);
            let I = (e.target = _b(e.props, x)),
              M = (e.targetAnchor = y(""));
            I && (m(M, I), (a = a || wD(I)));
            let R = (O, U) => {
              _ & 16 && u(E, O, U, r, s, a, o, l);
            };
            b ? R(t, L) : I && R(I, M);
          } else {
            e.el = n.el;
            let P = (e.anchor = n.anchor),
              L = (e.target = n.target),
              I = (e.targetAnchor = n.targetAnchor),
              M = $h(n.props),
              R = M ? t : L,
              O = M ? P : I;
            if (
              ((a = a || wD(L)),
              w
                ? (d(n.dynamicChildren, w, R, r, s, a, o), Fb(n, e, !0))
                : l || f(n, e, R, O, r, s, a, o, !1),
              b)
            )
              M || jp(e, t, P, c, 1);
            else if ((e.props && e.props.to) !== (n.props && n.props.to)) {
              let U = (e.target = _b(e.props, x));
              U && jp(e, U, null, c, 0);
            } else M && jp(e, L, I, c, 1);
          }
        },
        remove(n, e, t, i, { um: r, o: { remove: s } }, a) {
          let {
            shapeFlag: o,
            children: l,
            anchor: c,
            targetAnchor: u,
            target: f,
            props: d,
          } = n;
          if ((f && s(u), (a || !$h(d)) && (s(c), o & 16)))
            for (let m = 0; m < l.length; m++) {
              let x = l[m];
              r(x, e, t, !0, !!x.dynamicChildren);
            }
        },
        move: jp,
        hydrate: aW,
      };
    function jp(n, e, t, { o: { insert: i }, m: r }, s = 2) {
      s === 0 && i(n.targetAnchor, e, t);
      let { el: a, anchor: o, shapeFlag: l, children: c, props: u } = n,
        f = s === 2;
      if ((f && i(a, e, t), (!f || $h(u)) && l & 16))
        for (let d = 0; d < c.length; d++) r(c[d], e, t, 2);
      f && i(o, e, t);
    }
    function aW(
      n,
      e,
      t,
      i,
      r,
      s,
      { o: { nextSibling: a, parentNode: o, querySelector: l } },
      c
    ) {
      let u = (e.target = _b(e.props, l));
      if (u) {
        let f = u._lpa || u.firstChild;
        if (e.shapeFlag & 16)
          if ($h(e.props))
            (e.anchor = c(a(n), e, o(n), t, i, r, s)), (e.targetAnchor = f);
          else {
            e.anchor = a(n);
            let d = f;
            for (; d; )
              if (
                ((d = a(d)),
                d && d.nodeType === 8 && d.data === "teleport anchor")
              ) {
                (e.targetAnchor = d),
                  (u._lpa = e.targetAnchor && a(e.targetAnchor));
                break;
              }
            c(f, e, u, t, i, r, s);
          }
      }
      return e.anchor && a(e.anchor);
    }
    var oW = sW,
      Xn = Symbol(void 0),
      qc = Symbol(void 0),
      Rn = Symbol(void 0),
      Wc = Symbol(void 0),
      Wh = [],
      lr = null;
    function um(n = !1) {
      Wh.push((lr = n ? null : []));
    }
    function lI() {
      Wh.pop(), (lr = Wh[Wh.length - 1] || null);
    }
    var El = 1;
    function Eb(n) {
      El += n;
    }
    function cI(n) {
      return (
        (n.dynamicChildren = El > 0 ? lr || J.EMPTY_ARR : null),
        lI(),
        El > 0 && lr && lr.push(n),
        n
      );
    }
    function lW(n, e, t, i, r, s) {
      return cI(zb(n, e, t, i, r, s, !0));
    }
    function Bb(n, e, t, i, r) {
      return cI(Bi(n, e, t, i, r, !0));
    }
    function yo(n) {
      return n ? n.__v_isVNode === !0 : !1;
    }
    function Rs(n, e) {
      return n.type === e.type && n.key === e.key;
    }
    function cW(n) {}
    var hm = "__vInternal",
      uI = ({ key: n }) => (n != null ? n : null),
      Yp = ({ ref: n, ref_key: e, ref_for: t }) =>
        n != null
          ? J.isString(n) || Qe.isRef(n) || J.isFunction(n)
            ? { i: Ln, r: n, k: e, f: !!t }
            : n
          : null;
    function zb(
      n,
      e = null,
      t = null,
      i = 0,
      r = null,
      s = n === Xn ? 0 : 1,
      a = !1,
      o = !1
    ) {
      let l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: n,
        props: e,
        key: e && uI(e),
        ref: e && Yp(e),
        scopeId: am,
        slotScopeIds: null,
        children: t,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: i,
        dynamicProps: r,
        dynamicChildren: null,
        appContext: null,
      };
      return (
        o
          ? (Vb(l, t), s & 128 && n.normalize(l))
          : t && (l.shapeFlag |= J.isString(t) ? 8 : 16),
        El > 0 &&
          !a &&
          lr &&
          (l.patchFlag > 0 || s & 6) &&
          l.patchFlag !== 32 &&
          lr.push(l),
        l
      );
    }
    var Bi = uW;
    function uW(n, e = null, t = null, i = 0, r = null, s = !1) {
      if (((!n || n === JD) && (n = Rn), yo(n))) {
        let o = Ns(n, e, !0);
        return (
          t && Vb(o, t),
          El > 0 &&
            !s &&
            lr &&
            (o.shapeFlag & 6 ? (lr[lr.indexOf(n)] = o) : lr.push(o)),
          (o.patchFlag |= -2),
          o
        );
      }
      if ((_W(n) && (n = n.__vccOpts), e)) {
        e = hI(e);
        let { class: o, style: l } = e;
        o && !J.isString(o) && (e.class = J.normalizeClass(o)),
          J.isObject(l) &&
            (Qe.isProxy(l) && !J.isArray(l) && (l = J.extend({}, l)),
            (e.style = J.normalizeStyle(l)));
      }
      let a = J.isString(n)
        ? 1
        : ND(n)
        ? 128
        : rW(n)
        ? 64
        : J.isObject(n)
        ? 4
        : J.isFunction(n)
        ? 2
        : 0;
      return zb(n, e, t, i, r, a, s, !0);
    }
    function hI(n) {
      return n ? (Qe.isProxy(n) || hm in n ? J.extend({}, n) : n) : null;
    }
    function Ns(n, e, t = !1) {
      let { props: i, ref: r, patchFlag: s, children: a } = n,
        o = e ? fI(i || {}, e) : i;
      return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: n.type,
        props: o,
        key: o && uI(o),
        ref:
          e && e.ref
            ? t && r
              ? J.isArray(r)
                ? r.concat(Yp(e))
                : [r, Yp(e)]
              : Yp(e)
            : r,
        scopeId: n.scopeId,
        slotScopeIds: n.slotScopeIds,
        children: a,
        target: n.target,
        targetAnchor: n.targetAnchor,
        staticCount: n.staticCount,
        shapeFlag: n.shapeFlag,
        patchFlag: e && n.type !== Xn ? (s === -1 ? 16 : s | 16) : s,
        dynamicProps: n.dynamicProps,
        dynamicChildren: n.dynamicChildren,
        appContext: n.appContext,
        dirs: n.dirs,
        transition: n.transition,
        component: n.component,
        suspense: n.suspense,
        ssContent: n.ssContent && Ns(n.ssContent),
        ssFallback: n.ssFallback && Ns(n.ssFallback),
        el: n.el,
        anchor: n.anchor,
      };
    }
    function Ub(n = " ", e = 0) {
      return Bi(qc, null, n, e);
    }
    function hW(n, e) {
      let t = Bi(Wc, null, n);
      return (t.staticCount = e), t;
    }
    function fW(n = "", e = !1) {
      return e ? (um(), Bb(Rn, null, n)) : Bi(Rn, null, n);
    }
    function Er(n) {
      return n == null || typeof n == "boolean"
        ? Bi(Rn)
        : J.isArray(n)
        ? Bi(Xn, null, n.slice())
        : typeof n == "object"
        ? mo(n)
        : Bi(qc, null, String(n));
    }
    function mo(n) {
      return n.el === null || n.memo ? n : Ns(n);
    }
    function Vb(n, e) {
      let t = 0,
        { shapeFlag: i } = n;
      if (e == null) e = null;
      else if (J.isArray(e)) t = 16;
      else if (typeof e == "object")
        if (i & 65) {
          let r = e.default;
          r && (r._c && (r._d = !1), Vb(n, r()), r._c && (r._d = !0));
          return;
        } else {
          t = 32;
          let r = e._;
          !r && !(hm in e)
            ? (e._ctx = Ln)
            : r === 3 &&
              Ln &&
              (Ln.slots._ === 1
                ? (e._ = 1)
                : ((e._ = 2), (n.patchFlag |= 1024)));
        }
      else
        J.isFunction(e)
          ? ((e = { default: e, _ctx: Ln }), (t = 32))
          : ((e = String(e)), i & 64 ? ((t = 16), (e = [Ub(e)])) : (t = 8));
      (n.children = e), (n.shapeFlag |= t);
    }
    function fI(...n) {
      let e = {};
      for (let t = 0; t < n.length; t++) {
        let i = n[t];
        for (let r in i)
          if (r === "class")
            e.class !== i.class &&
              (e.class = J.normalizeClass([e.class, i.class]));
          else if (r === "style")
            e.style = J.normalizeStyle([e.style, i.style]);
          else if (J.isOn(r)) {
            let s = e[r],
              a = i[r];
            a &&
              s !== a &&
              !(J.isArray(s) && s.includes(a)) &&
              (e[r] = s ? [].concat(s, a) : a);
          } else r !== "" && (e[r] = i[r]);
      }
      return e;
    }
    function or(n, e, t, i = null) {
      Qr(n, e, 7, [t, i]);
    }
    var dW = aI(),
      pW = 0;
    function dI(n, e, t) {
      let i = n.type,
        r = (e ? e.appContext : n.appContext) || dW,
        s = {
          uid: pW++,
          vnode: n,
          type: i,
          parent: e,
          appContext: r,
          root: null,
          next: null,
          subTree: null,
          effect: null,
          update: null,
          scope: new Qe.EffectScope(!0),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: e ? e.provides : Object.create(r.provides),
          accessCache: null,
          renderCache: [],
          components: null,
          directives: null,
          propsOptions: iI(i, r),
          emitsOptions: OD(i, r),
          emit: null,
          emitted: null,
          propsDefaults: J.EMPTY_OBJ,
          inheritAttrs: i.inheritAttrs,
          ctx: J.EMPTY_OBJ,
          data: J.EMPTY_OBJ,
          props: J.EMPTY_OBJ,
          attrs: J.EMPTY_OBJ,
          slots: J.EMPTY_OBJ,
          refs: J.EMPTY_OBJ,
          setupState: J.EMPTY_OBJ,
          setupContext: null,
          suspense: t,
          suspenseId: t ? t.pendingId : 0,
          asyncDep: null,
          asyncResolved: !1,
          isMounted: !1,
          isUnmounted: !1,
          isDeactivated: !1,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null,
        };
      return (
        (s.ctx = { _: s }),
        (s.root = e ? e.root : s),
        (s.emit = l9.bind(null, s)),
        n.ce && n.ce(s),
        s
      );
    }
    var pn = null,
      Zh = () => pn || Ln,
      vo = (n) => {
        (pn = n), n.scope.on();
      },
      go = () => {
        pn && pn.scope.off(), (pn = null);
      };
    function pI(n) {
      return n.vnode.shapeFlag & 4;
    }
    var jc = !1;
    function mI(n, e = !1) {
      jc = e;
      let { props: t, children: i } = n.vnode,
        r = pI(n);
      j9(n, t, r, e), K9(n, i);
      let s = r ? mW(n, e) : void 0;
      return (jc = !1), s;
    }
    function mW(n, e) {
      let t = n.type;
      (n.accessCache = Object.create(null)),
        (n.proxy = Qe.markRaw(new Proxy(n.ctx, yb)));
      let { setup: i } = t;
      if (i) {
        let r = (n.setupContext = i.length > 1 ? yI(n) : null);
        vo(n), Qe.pauseTracking();
        let s = Os(i, n, 0, [n.props, r]);
        if ((Qe.resetTracking(), go(), J.isPromise(s))) {
          if ((s.then(go, go), e))
            return s
              .then((a) => {
                Tb(n, a, e);
              })
              .catch((a) => {
                Tl(a, n, 0);
              });
          n.asyncDep = s;
        } else Tb(n, s, e);
      } else gI(n, e);
    }
    function Tb(n, e, t) {
      J.isFunction(e)
        ? n.type.__ssrInlineRender
          ? (n.ssrRender = e)
          : (n.render = e)
        : J.isObject(e) && (n.setupState = Qe.proxyRefs(e)),
        gI(n, t);
    }
    var im, Sb;
    function gW(n) {
      (im = n),
        (Sb = (e) => {
          e.render._rc && (e.withProxy = new Proxy(e.ctx, V9));
        });
    }
    var yW = () => !im;
    function gI(n, e, t) {
      let i = n.type;
      if (!n.render) {
        if (!e && im && !i.render) {
          let r = i.template;
          if (r) {
            let { isCustomElement: s, compilerOptions: a } =
                n.appContext.config,
              { delimiters: o, compilerOptions: l } = i,
              c = J.extend(
                J.extend({ isCustomElement: s, delimiters: o }, a),
                l
              );
            i.render = im(r, c);
          }
        }
        (n.render = i.render || J.NOOP), Sb && Sb(n);
      }
      vo(n), Qe.pauseTracking(), G9(n), Qe.resetTracking(), go();
    }
    function vW(n) {
      return new Proxy(n.attrs, {
        get(e, t) {
          return Qe.track(n, "get", "$attrs"), e[t];
        },
      });
    }
    function yI(n) {
      let e = (i) => {
          n.exposed = i || {};
        },
        t;
      return {
        get attrs() {
          return t || (t = vW(n));
        },
        slots: n.slots,
        emit: n.emit,
        expose: e,
      };
    }
    function fm(n) {
      if (n.exposed)
        return (
          n.exposeProxy ||
          (n.exposeProxy = new Proxy(Qe.proxyRefs(Qe.markRaw(n.exposed)), {
            get(e, t) {
              if (t in e) return e[t];
              if (t in Qp) return Qp[t](n);
            },
          }))
        );
    }
    var xW = /(?:^|[-_])(\w)/g,
      bW = (n) => n.replace(xW, (e) => e.toUpperCase()).replace(/[-_]/g, "");
    function nm(n, e = !0) {
      return J.isFunction(n)
        ? n.displayName || n.name
        : n.name || (e && n.__name);
    }
    function vI(n, e, t = !1) {
      let i = nm(e);
      if (!i && e.__file) {
        let r = e.__file.match(/([^/\\]+)\.\w+$/);
        r && (i = r[1]);
      }
      if (!i && n && n.parent) {
        let r = (s) => {
          for (let a in s) if (s[a] === e) return a;
        };
        i =
          r(n.components || n.parent.type.components) ||
          r(n.appContext.components);
      }
      return i ? bW(i) : t ? "App" : "Anonymous";
    }
    function _W(n) {
      return J.isFunction(n) && "__vccOpts" in n;
    }
    var xI = (n, e) => Qe.computed(n, e, jc);
    function EW() {
      return null;
    }
    function TW() {
      return null;
    }
    function SW(n) {}
    function wW(n, e) {
      return null;
    }
    function MW() {
      return bI().slots;
    }
    function AW() {
      return bI().attrs;
    }
    function bI() {
      let n = Zh();
      return n.setupContext || (n.setupContext = yI(n));
    }
    function CW(n, e) {
      let t = J.isArray(n) ? n.reduce((i, r) => ((i[r] = {}), i), {}) : n;
      for (let i in e) {
        let r = t[i];
        r
          ? J.isArray(r) || J.isFunction(r)
            ? (t[i] = { type: r, default: e[i] })
            : (r.default = e[i])
          : r === null && (t[i] = { default: e[i] });
      }
      return t;
    }
    function PW(n, e) {
      let t = {};
      for (let i in n)
        e.includes(i) ||
          Object.defineProperty(t, i, { enumerable: !0, get: () => n[i] });
      return t;
    }
    function DW(n) {
      let e = Zh(),
        t = n();
      return (
        go(),
        J.isPromise(t) &&
          (t = t.catch((i) => {
            throw (vo(e), i);
          })),
        [t, () => vo(e)]
      );
    }
    function IW(n, e, t) {
      let i = arguments.length;
      return i === 2
        ? J.isObject(e) && !J.isArray(e)
          ? yo(e)
            ? Bi(n, null, [e])
            : Bi(n, e)
          : Bi(n, null, e)
        : (i > 3
            ? (t = Array.prototype.slice.call(arguments, 2))
            : i === 3 && yo(t) && (t = [t]),
          Bi(n, e, t));
    }
    var _I = Symbol(""),
      LW = () => {
        {
          let n = Gh(_I);
          return (
            n ||
              MD(
                "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
              ),
            n
          );
        }
      };
    function RW() {}
    function OW(n, e, t, i) {
      let r = t[i];
      if (r && EI(r, n)) return r;
      let s = e();
      return (s.memo = n.slice()), (t[i] = s);
    }
    function EI(n, e) {
      let t = n.memo;
      if (t.length != e.length) return !1;
      for (let i = 0; i < t.length; i++)
        if (J.hasChanged(t[i], e[i])) return !1;
      return El > 0 && lr && lr.push(n), !0;
    }
    var TI = "3.2.37",
      NW = {
        createComponentInstance: dI,
        setupComponent: mI,
        renderComponentRoot: Xp,
        setCurrentRenderingInstance: jh,
        isVNode: yo,
        normalizeVNode: Er,
      },
      kW = NW,
      FW = null,
      BW = null;
    we.EffectScope = Qe.EffectScope;
    we.ReactiveEffect = Qe.ReactiveEffect;
    we.customRef = Qe.customRef;
    we.effect = Qe.effect;
    we.effectScope = Qe.effectScope;
    we.getCurrentScope = Qe.getCurrentScope;
    we.isProxy = Qe.isProxy;
    we.isReactive = Qe.isReactive;
    we.isReadonly = Qe.isReadonly;
    we.isRef = Qe.isRef;
    we.isShallow = Qe.isShallow;
    we.markRaw = Qe.markRaw;
    we.onScopeDispose = Qe.onScopeDispose;
    we.proxyRefs = Qe.proxyRefs;
    we.reactive = Qe.reactive;
    we.readonly = Qe.readonly;
    we.ref = Qe.ref;
    we.shallowReactive = Qe.shallowReactive;
    we.shallowReadonly = Qe.shallowReadonly;
    we.shallowRef = Qe.shallowRef;
    we.stop = Qe.stop;
    we.toRaw = Qe.toRaw;
    we.toRef = Qe.toRef;
    we.toRefs = Qe.toRefs;
    we.triggerRef = Qe.triggerRef;
    we.unref = Qe.unref;
    we.camelize = J.camelize;
    we.capitalize = J.capitalize;
    we.normalizeClass = J.normalizeClass;
    we.normalizeProps = J.normalizeProps;
    we.normalizeStyle = J.normalizeStyle;
    we.toDisplayString = J.toDisplayString;
    we.toHandlerKey = J.toHandlerKey;
    we.BaseTransition = A9;
    we.Comment = Rn;
    we.Fragment = Xn;
    we.KeepAlive = D9;
    we.Static = Wc;
    we.Suspense = y9;
    we.Teleport = oW;
    we.Text = qc;
    we.callWithAsyncErrorHandling = Qr;
    we.callWithErrorHandling = Os;
    we.cloneVNode = Ns;
    we.compatUtils = BW;
    we.computed = xI;
    we.createBlock = Bb;
    we.createCommentVNode = fW;
    we.createElementBlock = lW;
    we.createElementVNode = zb;
    we.createHydrationRenderer = iW;
    we.createPropsRestProxy = PW;
    we.createRenderer = tW;
    we.createSlots = B9;
    we.createStaticVNode = hW;
    we.createTextVNode = Ub;
    we.createVNode = Bi;
    we.defineAsyncComponent = C9;
    we.defineComponent = VD;
    we.defineEmits = TW;
    we.defineExpose = SW;
    we.defineProps = EW;
    we.getCurrentInstance = Zh;
    we.getTransitionRawChildren = Ib;
    we.guardReactiveProps = hI;
    we.h = IW;
    we.handleError = Tl;
    we.initCustomFormatter = RW;
    we.inject = Gh;
    we.isMemoSame = EI;
    we.isRuntimeOnly = yW;
    we.isVNode = yo;
    we.mergeDefaults = CW;
    we.mergeProps = fI;
    we.nextTick = PD;
    we.onActivated = GD;
    we.onBeforeMount = WD;
    we.onBeforeUnmount = cm;
    we.onBeforeUpdate = qD;
    we.onDeactivated = HD;
    we.onErrorCaptured = KD;
    we.onMounted = lm;
    we.onRenderTracked = YD;
    we.onRenderTriggered = XD;
    we.onServerPrefetch = jD;
    we.onUnmounted = Rb;
    we.onUpdated = Lb;
    we.openBlock = um;
    we.popScopeId = u9;
    we.provide = FD;
    we.pushScopeId = c9;
    we.queuePostFlushCb = Ab;
    we.registerRuntimeCompiler = gW;
    we.renderList = F9;
    we.renderSlot = z9;
    we.resolveComponent = O9;
    we.resolveDirective = k9;
    we.resolveDynamicComponent = N9;
    we.resolveFilter = FW;
    we.resolveTransitionHooks = Zp;
    we.setBlockTracking = Eb;
    we.setDevtoolsHook = RD;
    we.setTransitionHooks = Yh;
    we.ssrContextKey = _I;
    we.ssrUtils = kW;
    we.toHandlers = U9;
    we.transformVNodeArgs = cW;
    we.useAttrs = AW;
    we.useSSRContext = LW;
    we.useSlots = MW;
    we.useTransitionState = zD;
    we.version = TI;
    we.warn = MD;
    we.watch = Hh;
    we.watchEffect = E9;
    we.watchPostEffect = T9;
    we.watchSyncEffect = S9;
    we.withAsyncContext = DW;
    we.withCtx = Cb;
    we.withDefaults = wW;
    we.withDirectives = L9;
    we.withMemo = OW;
    we.withScopeId = h9;
  });
  var MI = jt((hse, wI) => {
    "use strict";
    wI.exports = SI();
  });
  var o2 = jt((zi) => {
    "use strict";
    Object.defineProperty(zi, "__esModule", { value: !0 });
    var Ri = MI(),
      vt = lo(),
      zW = "http://www.w3.org/2000/svg",
      wl = typeof document != "undefined" ? document : null,
      AI = wl && wl.createElement("template"),
      UW = {
        insert: (n, e, t) => {
          e.insertBefore(n, t || null);
        },
        remove: (n) => {
          let e = n.parentNode;
          e && e.removeChild(n);
        },
        createElement: (n, e, t, i) => {
          let r = e
            ? wl.createElementNS(zW, n)
            : wl.createElement(n, t ? { is: t } : void 0);
          return (
            n === "select" &&
              i &&
              i.multiple != null &&
              r.setAttribute("multiple", i.multiple),
            r
          );
        },
        createText: (n) => wl.createTextNode(n),
        createComment: (n) => wl.createComment(n),
        setText: (n, e) => {
          n.nodeValue = e;
        },
        setElementText: (n, e) => {
          n.textContent = e;
        },
        parentNode: (n) => n.parentNode,
        nextSibling: (n) => n.nextSibling,
        querySelector: (n) => wl.querySelector(n),
        setScopeId(n, e) {
          n.setAttribute(e, "");
        },
        cloneNode(n) {
          let e = n.cloneNode(!0);
          return "_value" in n && (e._value = n._value), e;
        },
        insertStaticContent(n, e, t, i, r, s) {
          let a = t ? t.previousSibling : e.lastChild;
          if (r && (r === s || r.nextSibling))
            for (
              ;
              e.insertBefore(r.cloneNode(!0), t),
                !(r === s || !(r = r.nextSibling));

            );
          else {
            AI.innerHTML = i ? `<svg>${n}</svg>` : n;
            let o = AI.content;
            if (i) {
              let l = o.firstChild;
              for (; l.firstChild; ) o.appendChild(l.firstChild);
              o.removeChild(l);
            }
            e.insertBefore(o, t);
          }
          return [
            a ? a.nextSibling : e.firstChild,
            t ? t.previousSibling : e.lastChild,
          ];
        },
      };
    function VW(n, e, t) {
      let i = n._vtc;
      i && (e = (e ? [e, ...i] : [...i]).join(" ")),
        e == null
          ? n.removeAttribute("class")
          : t
          ? n.setAttribute("class", e)
          : (n.className = e);
    }
    function GW(n, e, t) {
      let i = n.style,
        r = vt.isString(t);
      if (t && !r) {
        for (let s in t) $b(i, s, t[s]);
        if (e && !vt.isString(e)) for (let s in e) t[s] == null && $b(i, s, "");
      } else {
        let s = i.display;
        r ? e !== t && (i.cssText = t) : e && n.removeAttribute("style"),
          "_vod" in n && (i.display = s);
      }
    }
    var CI = /\s*!important$/;
    function $b(n, e, t) {
      if (vt.isArray(t)) t.forEach((i) => $b(n, e, i));
      else if ((t == null && (t = ""), e.startsWith("--"))) n.setProperty(e, t);
      else {
        let i = HW(n, e);
        CI.test(t)
          ? n.setProperty(vt.hyphenate(i), t.replace(CI, ""), "important")
          : (n[i] = t);
      }
    }
    var PI = ["Webkit", "Moz", "ms"],
      Gb = {};
    function HW(n, e) {
      let t = Gb[e];
      if (t) return t;
      let i = Ri.camelize(e);
      if (i !== "filter" && i in n) return (Gb[e] = i);
      i = vt.capitalize(i);
      for (let r = 0; r < PI.length; r++) {
        let s = PI[r] + i;
        if (s in n) return (Gb[e] = s);
      }
      return e;
    }
    var DI = "http://www.w3.org/1999/xlink";
    function $W(n, e, t, i, r) {
      if (i && e.startsWith("xlink:"))
        t == null
          ? n.removeAttributeNS(DI, e.slice(6, e.length))
          : n.setAttributeNS(DI, e, t);
      else {
        let s = vt.isSpecialBooleanAttr(e);
        t == null || (s && !vt.includeBooleanAttr(t))
          ? n.removeAttribute(e)
          : n.setAttribute(e, s ? "" : t);
      }
    }
    function WW(n, e, t, i, r, s, a) {
      if (e === "innerHTML" || e === "textContent") {
        i && a(i, r, s), (n[e] = t == null ? "" : t);
        return;
      }
      if (
        e === "value" &&
        n.tagName !== "PROGRESS" &&
        !n.tagName.includes("-")
      ) {
        n._value = t;
        let l = t == null ? "" : t;
        (n.value !== l || n.tagName === "OPTION") && (n.value = l),
          t == null && n.removeAttribute(e);
        return;
      }
      let o = !1;
      if (t === "" || t == null) {
        let l = typeof n[e];
        l === "boolean"
          ? (t = vt.includeBooleanAttr(t))
          : t == null && l === "string"
          ? ((t = ""), (o = !0))
          : l === "number" && ((t = 0), (o = !0));
      }
      try {
        n[e] = t;
      } catch (l) {}
      o && n.removeAttribute(e);
    }
    var [HI, qW] = (() => {
        let n = Date.now,
          e = !1;
        if (typeof window != "undefined") {
          Date.now() > document.createEvent("Event").timeStamp &&
            (n = performance.now.bind(performance));
          let t = navigator.userAgent.match(/firefox\/(\d+)/i);
          e = !!(t && Number(t[1]) <= 53);
        }
        return [n, e];
      })(),
      Wb = 0,
      jW = Promise.resolve(),
      XW = () => {
        Wb = 0;
      },
      YW = () => Wb || (jW.then(XW), (Wb = HI()));
    function ya(n, e, t, i) {
      n.addEventListener(e, t, i);
    }
    function KW(n, e, t, i) {
      n.removeEventListener(e, t, i);
    }
    function JW(n, e, t, i, r = null) {
      let s = n._vei || (n._vei = {}),
        a = s[e];
      if (i && a) a.value = i;
      else {
        let [o, l] = ZW(e);
        if (i) {
          let c = (s[e] = QW(i, r));
          ya(n, o, c, l);
        } else a && (KW(n, o, a, l), (s[e] = void 0));
      }
    }
    var II = /(?:Once|Passive|Capture)$/;
    function ZW(n) {
      let e;
      if (II.test(n)) {
        e = {};
        let t;
        for (; (t = n.match(II)); )
          (n = n.slice(0, n.length - t[0].length)),
            (e[t[0].toLowerCase()] = !0);
      }
      return [vt.hyphenate(n.slice(2)), e];
    }
    function QW(n, e) {
      let t = (i) => {
        let r = i.timeStamp || HI();
        (qW || r >= t.attached - 1) &&
          Ri.callWithAsyncErrorHandling(e7(i, t.value), e, 5, [i]);
      };
      return (t.value = n), (t.attached = YW()), t;
    }
    function e7(n, e) {
      if (vt.isArray(e)) {
        let t = n.stopImmediatePropagation;
        return (
          (n.stopImmediatePropagation = () => {
            t.call(n), (n._stopped = !0);
          }),
          e.map((i) => (r) => !r._stopped && i && i(r))
        );
      } else return e;
    }
    var LI = /^on[a-z]/,
      t7 = (n, e, t, i, r = !1, s, a, o, l) => {
        e === "class"
          ? VW(n, i, r)
          : e === "style"
          ? GW(n, t, i)
          : vt.isOn(e)
          ? vt.isModelListener(e) || JW(n, e, t, i, a)
          : (
              e[0] === "."
                ? ((e = e.slice(1)), !0)
                : e[0] === "^"
                ? ((e = e.slice(1)), !1)
                : i7(n, e, i, r)
            )
          ? WW(n, e, i, s, a, o, l)
          : (e === "true-value"
              ? (n._trueValue = i)
              : e === "false-value" && (n._falseValue = i),
            $W(n, e, i, r));
      };
    function i7(n, e, t, i) {
      return i
        ? !!(
            e === "innerHTML" ||
            e === "textContent" ||
            (e in n && LI.test(e) && vt.isFunction(t))
          )
        : e === "spellcheck" ||
          e === "draggable" ||
          e === "translate" ||
          e === "form" ||
          (e === "list" && n.tagName === "INPUT") ||
          (e === "type" && n.tagName === "TEXTAREA") ||
          (LI.test(e) && vt.isString(t))
        ? !1
        : e in n;
    }
    function $I(n, e) {
      let t = Ri.defineComponent(n);
      class i extends nf {
        constructor(s) {
          super(t, s, e);
        }
      }
      return (i.def = t), i;
    }
    var n7 = (n) => $I(n, s2),
      r7 = typeof HTMLElement != "undefined" ? HTMLElement : class {},
      nf = class extends r7 {
        constructor(e, t = {}, i) {
          super();
          (this._def = e),
            (this._props = t),
            (this._instance = null),
            (this._connected = !1),
            (this._resolved = !1),
            (this._numberProps = null),
            this.shadowRoot && i
              ? i(this._createVNode(), this.shadowRoot)
              : this.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          (this._connected = !0), this._instance || this._resolveDef();
        }
        disconnectedCallback() {
          (this._connected = !1),
            Ri.nextTick(() => {
              this._connected ||
                (qb(null, this.shadowRoot), (this._instance = null));
            });
        }
        _resolveDef() {
          if (this._resolved) return;
          this._resolved = !0;
          for (let i = 0; i < this.attributes.length; i++)
            this._setAttr(this.attributes[i].name);
          new MutationObserver((i) => {
            for (let r of i) this._setAttr(r.attributeName);
          }).observe(this, { attributes: !0 });
          let e = (i) => {
              let { props: r, styles: s } = i,
                a = !vt.isArray(r),
                o = r ? (a ? Object.keys(r) : r) : [],
                l;
              if (a)
                for (let c in this._props) {
                  let u = r[c];
                  (u === Number || (u && u.type === Number)) &&
                    ((this._props[c] = vt.toNumber(this._props[c])),
                    ((l || (l = Object.create(null)))[c] = !0));
                }
              this._numberProps = l;
              for (let c of Object.keys(this))
                c[0] !== "_" && this._setProp(c, this[c], !0, !1);
              for (let c of o.map(vt.camelize))
                Object.defineProperty(this, c, {
                  get() {
                    return this._getProp(c);
                  },
                  set(u) {
                    this._setProp(c, u);
                  },
                });
              this._applyStyles(s), this._update();
            },
            t = this._def.__asyncLoader;
          t ? t().then(e) : e(this._def);
        }
        _setAttr(e) {
          let t = this.getAttribute(e);
          this._numberProps && this._numberProps[e] && (t = vt.toNumber(t)),
            this._setProp(vt.camelize(e), t, !1);
        }
        _getProp(e) {
          return this._props[e];
        }
        _setProp(e, t, i = !0, r = !0) {
          t !== this._props[e] &&
            ((this._props[e] = t),
            r && this._instance && this._update(),
            i &&
              (t === !0
                ? this.setAttribute(vt.hyphenate(e), "")
                : typeof t == "string" || typeof t == "number"
                ? this.setAttribute(vt.hyphenate(e), t + "")
                : t || this.removeAttribute(vt.hyphenate(e))));
        }
        _update() {
          qb(this._createVNode(), this.shadowRoot);
        }
        _createVNode() {
          let e = Ri.createVNode(this._def, vt.extend({}, this._props));
          return (
            this._instance ||
              (e.ce = (t) => {
                (this._instance = t),
                  (t.isCE = !0),
                  (t.emit = (r, ...s) => {
                    this.dispatchEvent(new CustomEvent(r, { detail: s }));
                  });
                let i = this;
                for (; (i = i && (i.parentNode || i.host)); )
                  if (i instanceof nf) {
                    t.parent = i._instance;
                    break;
                  }
              }),
            e
          );
        }
        _applyStyles(e) {
          e &&
            e.forEach((t) => {
              let i = document.createElement("style");
              (i.textContent = t), this.shadowRoot.appendChild(i);
            });
        }
      };
    function s7(n = "$style") {
      {
        let e = Ri.getCurrentInstance();
        if (!e) return vt.EMPTY_OBJ;
        let t = e.type.__cssModules;
        if (!t) return vt.EMPTY_OBJ;
        let i = t[n];
        return i || vt.EMPTY_OBJ;
      }
    }
    function a7(n) {}
    var xo = "transition",
      Qh = "animation",
      jb = (n, { slots: e }) => Ri.h(Ri.BaseTransition, qI(n), e);
    jb.displayName = "Transition";
    var WI = {
        name: String,
        type: String,
        css: { type: Boolean, default: !0 },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String,
      },
      o7 = (jb.props = vt.extend({}, Ri.BaseTransition.props, WI)),
      Sl = (n, e = []) => {
        vt.isArray(n) ? n.forEach((t) => t(...e)) : n && n(...e);
      },
      RI = (n) =>
        n ? (vt.isArray(n) ? n.some((e) => e.length > 1) : n.length > 1) : !1;
    function qI(n) {
      let e = {};
      for (let X in n) X in WI || (e[X] = n[X]);
      if (n.css === !1) return e;
      let {
          name: t = "v",
          type: i,
          duration: r,
          enterFromClass: s = `${t}-enter-from`,
          enterActiveClass: a = `${t}-enter-active`,
          enterToClass: o = `${t}-enter-to`,
          appearFromClass: l = s,
          appearActiveClass: c = a,
          appearToClass: u = o,
          leaveFromClass: f = `${t}-leave-from`,
          leaveActiveClass: d = `${t}-leave-active`,
          leaveToClass: m = `${t}-leave-to`,
        } = n,
        x = l7(r),
        y = x && x[0],
        g = x && x[1],
        {
          onBeforeEnter: b,
          onEnter: _,
          onEnterCancelled: E,
          onLeave: w,
          onLeaveCancelled: P,
          onBeforeAppear: L = b,
          onAppear: I = _,
          onAppearCancelled: M = E,
        } = e,
        R = (X, $, W) => {
          bo(X, $ ? u : o), bo(X, $ ? c : a), W && W();
        },
        O = (X, $) => {
          (X._isLeaving = !1), bo(X, f), bo(X, m), bo(X, d), $ && $();
        },
        U = (X) => ($, W) => {
          let ue = X ? I : _,
            ae = () => R($, X, W);
          Sl(ue, [$, ae]),
            OI(() => {
              bo($, X ? l : s), ga($, X ? u : o), RI(ue) || NI($, i, y, ae);
            });
        };
      return vt.extend(e, {
        onBeforeEnter(X) {
          Sl(b, [X]), ga(X, s), ga(X, a);
        },
        onBeforeAppear(X) {
          Sl(L, [X]), ga(X, l), ga(X, c);
        },
        onEnter: U(!1),
        onAppear: U(!0),
        onLeave(X, $) {
          X._isLeaving = !0;
          let W = () => O(X, $);
          ga(X, f),
            XI(),
            ga(X, d),
            OI(() => {
              !X._isLeaving || (bo(X, f), ga(X, m), RI(w) || NI(X, i, g, W));
            }),
            Sl(w, [X, W]);
        },
        onEnterCancelled(X) {
          R(X, !1), Sl(E, [X]);
        },
        onAppearCancelled(X) {
          R(X, !0), Sl(M, [X]);
        },
        onLeaveCancelled(X) {
          O(X), Sl(P, [X]);
        },
      });
    }
    function l7(n) {
      if (n == null) return null;
      if (vt.isObject(n)) return [Hb(n.enter), Hb(n.leave)];
      {
        let e = Hb(n);
        return [e, e];
      }
    }
    function Hb(n) {
      return vt.toNumber(n);
    }
    function ga(n, e) {
      e.split(/\s+/).forEach((t) => t && n.classList.add(t)),
        (n._vtc || (n._vtc = new Set())).add(e);
    }
    function bo(n, e) {
      e.split(/\s+/).forEach((i) => i && n.classList.remove(i));
      let { _vtc: t } = n;
      t && (t.delete(e), t.size || (n._vtc = void 0));
    }
    function OI(n) {
      requestAnimationFrame(() => {
        requestAnimationFrame(n);
      });
    }
    var c7 = 0;
    function NI(n, e, t, i) {
      let r = (n._endId = ++c7),
        s = () => {
          r === n._endId && i();
        };
      if (t) return setTimeout(s, t);
      let { type: a, timeout: o, propCount: l } = jI(n, e);
      if (!a) return i();
      let c = a + "end",
        u = 0,
        f = () => {
          n.removeEventListener(c, d), s();
        },
        d = (m) => {
          m.target === n && ++u >= l && f();
        };
      setTimeout(() => {
        u < l && f();
      }, o + 1),
        n.addEventListener(c, d);
    }
    function jI(n, e) {
      let t = window.getComputedStyle(n),
        i = (x) => (t[x] || "").split(", "),
        r = i(xo + "Delay"),
        s = i(xo + "Duration"),
        a = kI(r, s),
        o = i(Qh + "Delay"),
        l = i(Qh + "Duration"),
        c = kI(o, l),
        u = null,
        f = 0,
        d = 0;
      e === xo
        ? a > 0 && ((u = xo), (f = a), (d = s.length))
        : e === Qh
        ? c > 0 && ((u = Qh), (f = c), (d = l.length))
        : ((f = Math.max(a, c)),
          (u = f > 0 ? (a > c ? xo : Qh) : null),
          (d = u ? (u === xo ? s.length : l.length) : 0));
      let m = u === xo && /\b(transform|all)(,|$)/.test(t[xo + "Property"]);
      return { type: u, timeout: f, propCount: d, hasTransform: m };
    }
    function kI(n, e) {
      for (; n.length < e.length; ) n = n.concat(n);
      return Math.max(...e.map((t, i) => FI(t) + FI(n[i])));
    }
    function FI(n) {
      return Number(n.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function XI() {
      return document.body.offsetHeight;
    }
    var YI = new WeakMap(),
      KI = new WeakMap(),
      u7 = {
        name: "TransitionGroup",
        props: vt.extend({}, o7, { tag: String, moveClass: String }),
        setup(n, { slots: e }) {
          let t = Ri.getCurrentInstance(),
            i = Ri.useTransitionState(),
            r,
            s;
          return (
            Ri.onUpdated(() => {
              if (!r.length) return;
              let a = n.moveClass || `${n.name || "v"}-move`;
              if (!m7(r[0].el, t.vnode.el, a)) return;
              r.forEach(f7), r.forEach(d7);
              let o = r.filter(p7);
              XI(),
                o.forEach((l) => {
                  let c = l.el,
                    u = c.style;
                  ga(c, a),
                    (u.transform =
                      u.webkitTransform =
                      u.transitionDuration =
                        "");
                  let f = (c._moveCb = (d) => {
                    (d && d.target !== c) ||
                      ((!d || /transform$/.test(d.propertyName)) &&
                        (c.removeEventListener("transitionend", f),
                        (c._moveCb = null),
                        bo(c, a)));
                  });
                  c.addEventListener("transitionend", f);
                });
            }),
            () => {
              let a = Ri.toRaw(n),
                o = qI(a),
                l = a.tag || Ri.Fragment;
              (r = s),
                (s = e.default ? Ri.getTransitionRawChildren(e.default()) : []);
              for (let c = 0; c < s.length; c++) {
                let u = s[c];
                u.key != null &&
                  Ri.setTransitionHooks(
                    u,
                    Ri.resolveTransitionHooks(u, o, i, t)
                  );
              }
              if (r)
                for (let c = 0; c < r.length; c++) {
                  let u = r[c];
                  Ri.setTransitionHooks(
                    u,
                    Ri.resolveTransitionHooks(u, o, i, t)
                  ),
                    YI.set(u, u.el.getBoundingClientRect());
                }
              return Ri.createVNode(l, null, s);
            }
          );
        },
      },
      h7 = u7;
    function f7(n) {
      let e = n.el;
      e._moveCb && e._moveCb(), e._enterCb && e._enterCb();
    }
    function d7(n) {
      KI.set(n, n.el.getBoundingClientRect());
    }
    function p7(n) {
      let e = YI.get(n),
        t = KI.get(n),
        i = e.left - t.left,
        r = e.top - t.top;
      if (i || r) {
        let s = n.el.style;
        return (
          (s.transform = s.webkitTransform = `translate(${i}px,${r}px)`),
          (s.transitionDuration = "0s"),
          n
        );
      }
    }
    function m7(n, e, t) {
      let i = n.cloneNode();
      n._vtc &&
        n._vtc.forEach((a) => {
          a.split(/\s+/).forEach((o) => o && i.classList.remove(o));
        }),
        t.split(/\s+/).forEach((a) => a && i.classList.add(a)),
        (i.style.display = "none");
      let r = e.nodeType === 1 ? e : e.parentNode;
      r.appendChild(i);
      let { hasTransform: s } = jI(i);
      return r.removeChild(i), s;
    }
    var _o = (n) => {
      let e = n.props["onUpdate:modelValue"] || !1;
      return vt.isArray(e) ? (t) => vt.invokeArrayFns(e, t) : e;
    };
    function g7(n) {
      n.target.composing = !0;
    }
    function BI(n) {
      let e = n.target;
      e.composing && ((e.composing = !1), e.dispatchEvent(new Event("input")));
    }
    var pm = {
        created(n, { modifiers: { lazy: e, trim: t, number: i } }, r) {
          n._assign = _o(r);
          let s = i || (r.props && r.props.type === "number");
          ya(n, e ? "change" : "input", (a) => {
            if (a.target.composing) return;
            let o = n.value;
            t && (o = o.trim()), s && (o = vt.toNumber(o)), n._assign(o);
          }),
            t &&
              ya(n, "change", () => {
                n.value = n.value.trim();
              }),
            e ||
              (ya(n, "compositionstart", g7),
              ya(n, "compositionend", BI),
              ya(n, "change", BI));
        },
        mounted(n, { value: e }) {
          n.value = e == null ? "" : e;
        },
        beforeUpdate(
          n,
          { value: e, modifiers: { lazy: t, trim: i, number: r } },
          s
        ) {
          if (
            ((n._assign = _o(s)),
            n.composing ||
              (document.activeElement === n &&
                n.type !== "range" &&
                (t ||
                  (i && n.value.trim() === e) ||
                  ((r || n.type === "number") && vt.toNumber(n.value) === e))))
          )
            return;
          let a = e == null ? "" : e;
          n.value !== a && (n.value = a);
        },
      },
      Xb = {
        deep: !0,
        created(n, e, t) {
          (n._assign = _o(t)),
            ya(n, "change", () => {
              let i = n._modelValue,
                r = Xc(n),
                s = n.checked,
                a = n._assign;
              if (vt.isArray(i)) {
                let o = vt.looseIndexOf(i, r),
                  l = o !== -1;
                if (s && !l) a(i.concat(r));
                else if (!s && l) {
                  let c = [...i];
                  c.splice(o, 1), a(c);
                }
              } else if (vt.isSet(i)) {
                let o = new Set(i);
                s ? o.add(r) : o.delete(r), a(o);
              } else a(ZI(n, s));
            });
        },
        mounted: zI,
        beforeUpdate(n, e, t) {
          (n._assign = _o(t)), zI(n, e, t);
        },
      };
    function zI(n, { value: e, oldValue: t }, i) {
      (n._modelValue = e),
        vt.isArray(e)
          ? (n.checked = vt.looseIndexOf(e, i.props.value) > -1)
          : vt.isSet(e)
          ? (n.checked = e.has(i.props.value))
          : e !== t && (n.checked = vt.looseEqual(e, ZI(n, !0)));
    }
    var Yb = {
        created(n, { value: e }, t) {
          (n.checked = vt.looseEqual(e, t.props.value)),
            (n._assign = _o(t)),
            ya(n, "change", () => {
              n._assign(Xc(n));
            });
        },
        beforeUpdate(n, { value: e, oldValue: t }, i) {
          (n._assign = _o(i)),
            e !== t && (n.checked = vt.looseEqual(e, i.props.value));
        },
      },
      JI = {
        deep: !0,
        created(n, { value: e, modifiers: { number: t } }, i) {
          let r = vt.isSet(e);
          ya(n, "change", () => {
            let s = Array.prototype.filter
              .call(n.options, (a) => a.selected)
              .map((a) => (t ? vt.toNumber(Xc(a)) : Xc(a)));
            n._assign(n.multiple ? (r ? new Set(s) : s) : s[0]);
          }),
            (n._assign = _o(i));
        },
        mounted(n, { value: e }) {
          UI(n, e);
        },
        beforeUpdate(n, e, t) {
          n._assign = _o(t);
        },
        updated(n, { value: e }) {
          UI(n, e);
        },
      };
    function UI(n, e) {
      let t = n.multiple;
      if (!(t && !vt.isArray(e) && !vt.isSet(e))) {
        for (let i = 0, r = n.options.length; i < r; i++) {
          let s = n.options[i],
            a = Xc(s);
          if (t)
            vt.isArray(e)
              ? (s.selected = vt.looseIndexOf(e, a) > -1)
              : (s.selected = e.has(a));
          else if (vt.looseEqual(Xc(s), e)) {
            n.selectedIndex !== i && (n.selectedIndex = i);
            return;
          }
        }
        !t && n.selectedIndex !== -1 && (n.selectedIndex = -1);
      }
    }
    function Xc(n) {
      return "_value" in n ? n._value : n.value;
    }
    function ZI(n, e) {
      let t = e ? "_trueValue" : "_falseValue";
      return t in n ? n[t] : e;
    }
    var QI = {
      created(n, e, t) {
        dm(n, e, t, null, "created");
      },
      mounted(n, e, t) {
        dm(n, e, t, null, "mounted");
      },
      beforeUpdate(n, e, t, i) {
        dm(n, e, t, i, "beforeUpdate");
      },
      updated(n, e, t, i) {
        dm(n, e, t, i, "updated");
      },
    };
    function e2(n, e) {
      switch (n) {
        case "SELECT":
          return JI;
        case "TEXTAREA":
          return pm;
        default:
          switch (e) {
            case "checkbox":
              return Xb;
            case "radio":
              return Yb;
            default:
              return pm;
          }
      }
    }
    function dm(n, e, t, i, r) {
      let a = e2(n.tagName, t.props && t.props.type)[r];
      a && a(n, e, t, i);
    }
    function y7() {
      (pm.getSSRProps = ({ value: n }) => ({ value: n })),
        (Yb.getSSRProps = ({ value: n }, e) => {
          if (e.props && vt.looseEqual(e.props.value, n))
            return { checked: !0 };
        }),
        (Xb.getSSRProps = ({ value: n }, e) => {
          if (vt.isArray(n)) {
            if (e.props && vt.looseIndexOf(n, e.props.value) > -1)
              return { checked: !0 };
          } else if (vt.isSet(n)) {
            if (e.props && n.has(e.props.value)) return { checked: !0 };
          } else if (n) return { checked: !0 };
        }),
        (QI.getSSRProps = (n, e) => {
          if (typeof e.type != "string") return;
          let t = e2(e.type.toUpperCase(), e.props && e.props.type);
          if (t.getSSRProps) return t.getSSRProps(n, e);
        });
    }
    var v7 = ["ctrl", "shift", "alt", "meta"],
      x7 = {
        stop: (n) => n.stopPropagation(),
        prevent: (n) => n.preventDefault(),
        self: (n) => n.target !== n.currentTarget,
        ctrl: (n) => !n.ctrlKey,
        shift: (n) => !n.shiftKey,
        alt: (n) => !n.altKey,
        meta: (n) => !n.metaKey,
        left: (n) => "button" in n && n.button !== 0,
        middle: (n) => "button" in n && n.button !== 1,
        right: (n) => "button" in n && n.button !== 2,
        exact: (n, e) => v7.some((t) => n[`${t}Key`] && !e.includes(t)),
      },
      b7 =
        (n, e) =>
        (t, ...i) => {
          for (let r = 0; r < e.length; r++) {
            let s = x7[e[r]];
            if (s && s(t, e)) return;
          }
          return n(t, ...i);
        },
      _7 = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace",
      },
      E7 = (n, e) => (t) => {
        if (!("key" in t)) return;
        let i = vt.hyphenate(t.key);
        if (e.some((r) => r === i || _7[r] === i)) return n(t);
      },
      t2 = {
        beforeMount(n, { value: e }, { transition: t }) {
          (n._vod = n.style.display === "none" ? "" : n.style.display),
            t && e ? t.beforeEnter(n) : ef(n, e);
        },
        mounted(n, { value: e }, { transition: t }) {
          t && e && t.enter(n);
        },
        updated(n, { value: e, oldValue: t }, { transition: i }) {
          !e != !t &&
            (i
              ? e
                ? (i.beforeEnter(n), ef(n, !0), i.enter(n))
                : i.leave(n, () => {
                    ef(n, !1);
                  })
              : ef(n, e));
        },
        beforeUnmount(n, { value: e }) {
          ef(n, e);
        },
      };
    function ef(n, e) {
      n.style.display = e ? n._vod : "none";
    }
    function T7() {
      t2.getSSRProps = ({ value: n }) => {
        if (!n) return { style: { display: "none" } };
      };
    }
    var i2 = vt.extend({ patchProp: t7 }, UW),
      tf,
      VI = !1;
    function n2() {
      return tf || (tf = Ri.createRenderer(i2));
    }
    function r2() {
      return (tf = VI ? tf : Ri.createHydrationRenderer(i2)), (VI = !0), tf;
    }
    var qb = (...n) => {
        n2().render(...n);
      },
      s2 = (...n) => {
        r2().hydrate(...n);
      },
      S7 = (...n) => {
        let e = n2().createApp(...n),
          { mount: t } = e;
        return (
          (e.mount = (i) => {
            let r = a2(i);
            if (!r) return;
            let s = e._component;
            !vt.isFunction(s) &&
              !s.render &&
              !s.template &&
              (s.template = r.innerHTML),
              (r.innerHTML = "");
            let a = t(r, !1, r instanceof SVGElement);
            return (
              r instanceof Element &&
                (r.removeAttribute("v-cloak"),
                r.setAttribute("data-v-app", "")),
              a
            );
          }),
          e
        );
      },
      w7 = (...n) => {
        let e = r2().createApp(...n),
          { mount: t } = e;
        return (
          (e.mount = (i) => {
            let r = a2(i);
            if (r) return t(r, !0, r instanceof SVGElement);
          }),
          e
        );
      };
    function a2(n) {
      return vt.isString(n) ? document.querySelector(n) : n;
    }
    var GI = !1,
      M7 = () => {
        GI || ((GI = !0), y7(), T7());
      };
    Object.keys(Ri).forEach(function (n) {
      n !== "default" && (zi[n] = Ri[n]);
    });
    zi.Transition = jb;
    zi.TransitionGroup = h7;
    zi.VueElement = nf;
    zi.createApp = S7;
    zi.createSSRApp = w7;
    zi.defineCustomElement = $I;
    zi.defineSSRCustomElement = n7;
    zi.hydrate = s2;
    zi.initDirectivesForSSR = M7;
    zi.render = qb;
    zi.useCssModule = s7;
    zi.useCssVars = a7;
    zi.vModelCheckbox = Xb;
    zi.vModelDynamic = QI;
    zi.vModelRadio = Yb;
    zi.vModelSelect = JI;
    zi.vModelText = pm;
    zi.vShow = t2;
    zi.withKeys = E7;
    zi.withModifiers = b7;
  });
  var Yc = jt((dse, l2) => {
    "use strict";
    l2.exports = o2();
  });
  var pL = jt((vf) => {
    "use strict";
    Object.defineProperty(vf, "__esModule", { value: !0 });
    function Em(n, e) {
      if (n == null) return {};
      var t = {},
        i = Object.keys(n),
        r,
        s;
      for (s = 0; s < i.length; s++)
        (r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r]);
      return t;
    }
    var Aa = class {
        constructor(e, t, i) {
          (this.line = void 0),
            (this.column = void 0),
            (this.index = void 0),
            (this.line = e),
            (this.column = t),
            (this.index = i);
        }
      },
      pf = class {
        constructor(e, t) {
          (this.start = void 0),
            (this.end = void 0),
            (this.filename = void 0),
            (this.identifierName = void 0),
            (this.start = e),
            (this.end = t);
        }
      };
    function Sr(n, e) {
      let { line: t, column: i, index: r } = n;
      return new Aa(t, i + e, r + e);
    }
    var r_ = {
        SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
        SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED",
      },
      A7 = (n, e = n.length - 1) => ({
        get() {
          return n.reduce((t, i) => t[i], this);
        },
        set(t) {
          n.reduce((i, r, s) => (s === e ? (i[r] = t) : i[r]), this);
        },
      }),
      C7 = (n, e, t) =>
        Object.keys(t)
          .map((i) => [i, t[i]])
          .filter(([, i]) => !!i)
          .map(([i, r]) => [
            i,
            typeof r == "function"
              ? { value: r, enumerable: !1 }
              : typeof r.reflect == "string"
              ? Object.assign({}, r, A7(r.reflect.split(".")))
              : r,
          ])
          .reduce(
            (i, [r, s]) =>
              Object.defineProperty(
                i,
                r,
                Object.assign({ configurable: !0 }, s)
              ),
            Object.assign(new n(), e)
          ),
      P7 = {
        ImportMetaOutsideModule: {
          message: `import.meta may appear only with 'sourceType: "module"'`,
          code: r_.SourceTypeModuleError,
        },
        ImportOutsideModule: {
          message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
          code: r_.SourceTypeModuleError,
        },
      },
      c2 = {
        ArrayPattern: "array destructuring pattern",
        AssignmentExpression: "assignment expression",
        AssignmentPattern: "assignment expression",
        ArrowFunctionExpression: "arrow function expression",
        ConditionalExpression: "conditional expression",
        CatchClause: "catch clause",
        ForOfStatement: "for-of statement",
        ForInStatement: "for-in statement",
        ForStatement: "for-loop",
        FormalParameters: "function parameter list",
        Identifier: "identifier",
        ImportSpecifier: "import specifier",
        ImportDefaultSpecifier: "import default specifier",
        ImportNamespaceSpecifier: "import namespace specifier",
        ObjectPattern: "object destructuring pattern",
        ParenthesizedExpression: "parenthesized expression",
        RestElement: "rest element",
        UpdateExpression: {
          true: "prefix operation",
          false: "postfix operation",
        },
        VariableDeclarator: "variable declaration",
        YieldExpression: "yield expression",
      },
      s_ = ({ type: n, prefix: e }) =>
        n === "UpdateExpression" ? c2.UpdateExpression[String(e)] : c2[n],
      D7 = {
        AccessorIsGenerator: ({ kind: n }) =>
          `A ${n}ter cannot be a generator.`,
        ArgumentsInClass:
          "'arguments' is only allowed in functions and class methods.",
        AsyncFunctionInSingleStatementContext:
          "Async functions can only be declared at the top level or inside a block.",
        AwaitBindingIdentifier:
          "Can not use 'await' as identifier inside an async function.",
        AwaitBindingIdentifierInStaticBlock:
          "Can not use 'await' as identifier inside a static block.",
        AwaitExpressionFormalParameter:
          "'await' is not allowed in async function parameters.",
        AwaitNotInAsyncContext:
          "'await' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncFunction:
          "'await' is only allowed within async functions.",
        BadGetterArity: "A 'get' accesor must not have any formal parameters.",
        BadSetterArity:
          "A 'set' accesor must have exactly one formal parameter.",
        BadSetterRestParameter:
          "A 'set' accesor function argument must not be a rest parameter.",
        ConstructorClassField:
          "Classes may not have a field named 'constructor'.",
        ConstructorClassPrivateField:
          "Classes may not have a private field named '#constructor'.",
        ConstructorIsAccessor: "Class constructor may not be an accessor.",
        ConstructorIsAsync: "Constructor can't be an async function.",
        ConstructorIsGenerator: "Constructor can't be a generator.",
        DeclarationMissingInitializer: ({ kind: n }) =>
          `Missing initializer in ${n} declaration.`,
        DecoratorBeforeExport:
          "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
        DecoratorConstructor:
          "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass:
          "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
        DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
        DecoratorStaticBlock: "Decorators can't be used with a static block.",
        DeletePrivateField: "Deleting a private field is not allowed.",
        DestructureNamedImport:
          "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
        DuplicateConstructor: "Duplicate constructor in the same class.",
        DuplicateDefaultExport: "Only one default export allowed per module.",
        DuplicateExport: ({ exportName: n }) =>
          `\`${n}\` has already been exported. Exported identifiers must be unique.`,
        DuplicateProto: "Redefinition of __proto__ property.",
        DuplicateRegExpFlags: "Duplicate regular expression flag.",
        ElementAfterRest: "Rest element must be last element.",
        EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
        ExportBindingIsString: ({
          localName: n,
          exportName: e,
        }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${n}' as '${e}' } from 'some-module'\`?`,
        ExportDefaultFromAsIdentifier:
          "'from' is not allowed as an identifier after 'export default'.",
        ForInOfLoopInitializer: ({ type: n }) =>
          `'${
            n === "ForInStatement" ? "for-in" : "for-of"
          }' loop variable declaration may not have an initializer.`,
        ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
        ForOfLet:
          "The left-hand side of a for-of loop may not start with 'let'.",
        GeneratorInSingleStatementContext:
          "Generators can only be declared at the top level or inside a block.",
        IllegalBreakContinue: ({ type: n }) =>
          `Unsyntactic ${n === "BreakStatement" ? "break" : "continue"}.`,
        IllegalLanguageModeDirective:
          "Illegal 'use strict' directive in function with non-simple parameter list.",
        IllegalReturn: "'return' outside of function.",
        ImportBindingIsString: ({
          importName: n,
        }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${n}" as foo }\`?`,
        ImportCallArgumentTrailingComma:
          "Trailing comma is disallowed inside import(...) arguments.",
        ImportCallArity: ({ maxArgumentCount: n }) =>
          `\`import()\` requires exactly ${
            n === 1 ? "one argument" : "one or two arguments"
          }.`,
        ImportCallNotNewExpression: "Cannot use new with import(...).",
        ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
        ImportJSONBindingNotDefault:
          "A JSON module can only be imported with `default`.",
        IncompatibleRegExpUVFlags:
          "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
        InvalidBigIntLiteral: "Invalid BigIntLiteral.",
        InvalidCodePoint: "Code point out of bounds.",
        InvalidCoverInitializedName: "Invalid shorthand property initializer.",
        InvalidDecimal: "Invalid decimal.",
        InvalidDigit: ({ radix: n }) => `Expected number in radix ${n}.`,
        InvalidEscapeSequence: "Bad character escape sequence.",
        InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
        InvalidEscapedReservedWord: ({ reservedWord: n }) =>
          `Escape sequence in keyword ${n}.`,
        InvalidIdentifier: ({ identifierName: n }) =>
          `Invalid identifier ${n}.`,
        InvalidLhs: ({ ancestor: n }) => `Invalid left-hand side in ${s_(n)}.`,
        InvalidLhsBinding: ({ ancestor: n }) =>
          `Binding invalid left-hand side in ${s_(n)}.`,
        InvalidNumber: "Invalid number.",
        InvalidOrMissingExponent:
          "Floating-point numbers require a valid exponent after the 'e'.",
        InvalidOrUnexpectedToken: ({ unexpected: n }) =>
          `Unexpected character '${n}'.`,
        InvalidParenthesizedAssignment:
          "Invalid parenthesized assignment pattern.",
        InvalidPrivateFieldResolution: ({ identifierName: n }) =>
          `Private name #${n} is not defined.`,
        InvalidPropertyBindingPattern: "Binding member expression.",
        InvalidRecordProperty:
          "Only properties and spread elements are allowed in record definitions.",
        InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
        LabelRedeclaration: ({ labelName: n }) =>
          `Label '${n}' is already declared.`,
        LetInLexicalBinding:
          "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
        MalformedRegExpFlags: "Invalid regular expression flag.",
        MissingClassName: "A class name is required.",
        MissingEqInAssignment:
          "Only '=' operator can be used for specifying default value.",
        MissingSemicolon: "Missing semicolon.",
        MissingPlugin: ({ missingPlugin: n }) =>
          `This experimental syntax requires enabling the parser plugin: ${n
            .map((e) => JSON.stringify(e))
            .join(", ")}.`,
        MissingOneOfPlugins: ({ missingPlugin: n }) =>
          `This experimental syntax requires enabling one of the following parser plugin(s): ${n
            .map((e) => JSON.stringify(e))
            .join(", ")}.`,
        MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
        MixingCoalesceWithLogical:
          "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
        ModuleAttributeDifferentFromType:
          "The only accepted module attribute is `type`.",
        ModuleAttributeInvalidValue:
          "Only string literals are allowed as module attribute values.",
        ModuleAttributesWithDuplicateKeys: ({ key: n }) =>
          `Duplicate key "${n}" is not allowed in module attributes.`,
        ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: n }) =>
          `An export name cannot include a lone surrogate, found '\\u${n.toString(
            16
          )}'.`,
        ModuleExportUndefined: ({ localName: n }) =>
          `Export '${n}' is not defined.`,
        MultipleDefaultsInSwitch: "Multiple default clauses.",
        NewlineAfterThrow: "Illegal newline after throw.",
        NoCatchOrFinally: "Missing catch or finally clause.",
        NumberIdentifier: "Identifier directly after number.",
        NumericSeparatorInEscapeSequence:
          "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
        ObsoleteAwaitStar:
          "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew:
          "Constructors in/after an Optional Chain are not allowed.",
        OptionalChainingNoTemplate:
          "Tagged Template Literals are not allowed in optionalChain.",
        OverrideOnConstructor:
          "'override' modifier cannot appear on a constructor declaration.",
        ParamDupe: "Argument name clash.",
        PatternHasAccessor: "Object pattern can't contain getter or setter.",
        PatternHasMethod: "Object pattern can't contain methods.",
        PrivateInExpectedIn: ({ identifierName: n }) =>
          `Private names are only allowed in property accesses (\`obj.#${n}\`) or in \`in\` expressions (\`#${n} in obj\`).`,
        PrivateNameRedeclaration: ({ identifierName: n }) =>
          `Duplicate private name #${n}.`,
        RecordExpressionBarIncorrectEndSyntaxType:
          "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionBarIncorrectStartSyntaxType:
          "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionHashIncorrectStartSyntaxType:
          "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        RecordNoProto: "'__proto__' is not allowed in Record expressions.",
        RestTrailingComma: "Unexpected trailing comma after rest element.",
        SloppyFunction:
          "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
        StaticPrototype:
          "Classes may not have static property named prototype.",
        SuperNotAllowed:
          "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super.",
        TrailingDecorator: "Decorators must be attached to a class element.",
        TupleExpressionBarIncorrectEndSyntaxType:
          "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionBarIncorrectStartSyntaxType:
          "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionHashIncorrectStartSyntaxType:
          "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
        UnexpectedAwaitAfterPipelineBody:
          'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
        UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
        UnexpectedImportExport:
          "'import' and 'export' may only appear at the top level.",
        UnexpectedKeyword: ({ keyword: n }) => `Unexpected keyword '${n}'.`,
        UnexpectedLeadingDecorator:
          "Leading decorators must be attached to a class declaration.",
        UnexpectedLexicalDeclaration:
          "Lexical declaration cannot appear in a single-statement context.",
        UnexpectedNewTarget:
          "`new.target` can only be used in functions or class properties.",
        UnexpectedNumericSeparator:
          "A numeric separator is only allowed between two digits.",
        UnexpectedPrivateField: "Unexpected private name.",
        UnexpectedReservedWord: ({ reservedWord: n }) =>
          `Unexpected reserved word '${n}'.`,
        UnexpectedSuper:
          "'super' is only allowed in object methods and classes.",
        UnexpectedToken: ({ expected: n, unexpected: e }) =>
          `Unexpected token${e ? ` '${e}'.` : ""}${
            n ? `, expected "${n}"` : ""
          }`,
        UnexpectedTokenUnaryExponentiation:
          "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
        UnsupportedBind: "Binding should be performed on object property.",
        UnsupportedDecoratorExport:
          "A decorated export must export a class declaration.",
        UnsupportedDefaultExport:
          "Only expressions, functions or classes are allowed as the `default` export.",
        UnsupportedImport:
          "`import` can only be used in `import()` or `import.meta`.",
        UnsupportedMetaProperty: ({ target: n, onlyValidPropertyName: e }) =>
          `The only valid meta property for ${n} is ${n}.${e}.`,
        UnsupportedParameterDecorator:
          "Decorators cannot be used to decorate parameters.",
        UnsupportedPropertyDecorator:
          "Decorators cannot be used to decorate object literal properties.",
        UnsupportedSuper:
          "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
        UnterminatedComment: "Unterminated comment.",
        UnterminatedRegExp: "Unterminated regular expression.",
        UnterminatedString: "Unterminated string constant.",
        UnterminatedTemplate: "Unterminated template.",
        VarRedeclaration: ({ identifierName: n }) =>
          `Identifier '${n}' has already been declared.`,
        YieldBindingIdentifier:
          "Can not use 'yield' as identifier inside a generator.",
        YieldInParameter:
          "Yield expression is not allowed in formal parameters.",
        ZeroDigitNumericSeparator:
          "Numeric separator can not be used after leading 0.",
      },
      I7 = {
        StrictDelete: "Deleting local variable in strict mode.",
        StrictEvalArguments: ({ referenceName: n }) =>
          `Assigning to '${n}' in strict mode.`,
        StrictEvalArgumentsBinding: ({ bindingName: n }) =>
          `Binding '${n}' in strict mode.`,
        StrictFunction:
          "In strict mode code, functions can only be declared at top level or inside a block.",
        StrictNumericEscape:
          "The only valid numeric escape in strict mode is '\\0'.",
        StrictOctalLiteral:
          "Legacy octal literals are not allowed in strict mode.",
        StrictWith: "'with' in strict mode.",
      },
      L7 = new Set([
        "ArrowFunctionExpression",
        "AssignmentExpression",
        "ConditionalExpression",
        "YieldExpression",
      ]),
      R7 = {
        PipeBodyIsTighter:
          "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
        PipeTopicRequiresHackPipes:
          'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
        PipeTopicUnbound:
          "Topic reference is unbound; it must be inside a pipe body.",
        PipeTopicUnconfiguredToken: ({ token: n }) =>
          `Invalid topic token ${n}. In order to use ${n} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${n}" }.`,
        PipeTopicUnused:
          "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
        PipeUnparenthesizedBody: ({ type: n }) =>
          `Hack-style pipe body cannot be an unparenthesized ${s_({
            type: n,
          })}; please wrap it in parentheses.`,
        PipelineBodyNoArrow:
          'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
        PipelineBodySequenceExpression:
          "Pipeline body may not be a comma-separated sequence expression.",
        PipelineHeadSequenceExpression:
          "Pipeline head should not be a comma-separated sequence expression.",
        PipelineTopicUnused:
          "Pipeline is in topic style but does not use topic reference.",
        PrimaryTopicNotAllowed:
          "Topic reference was used in a lexical context without topic binding.",
        PrimaryTopicRequiresSmartPipeline:
          'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      },
      O7 = ["toMessage"],
      N7 = ["message"];
    function k7(n) {
      let { toMessage: e } = n,
        t = Em(n, O7);
      return function i({ loc: r, details: s }) {
        return C7(SyntaxError, Object.assign({}, t, { loc: r }), {
          clone(a = {}) {
            let o = a.loc || {};
            return i({
              loc: new Aa(
                "line" in o ? o.line : this.loc.line,
                "column" in o ? o.column : this.loc.column,
                "index" in o ? o.index : this.loc.index
              ),
              details: Object.assign({}, this.details, a.details),
            });
          },
          details: { value: s, enumerable: !1 },
          message: {
            get() {
              return `${e(this.details)} (${this.loc.line}:${this.loc.column})`;
            },
            set(a) {
              Object.defineProperty(this, "message", { value: a });
            },
          },
          pos: { reflect: "loc.index", enumerable: !0 },
          missingPlugin: "missingPlugin" in s && {
            reflect: "details.missingPlugin",
            enumerable: !0,
          },
        });
      };
    }
    function Ea(n, e) {
      if (Array.isArray(n)) return (i) => Ea(i, n[0]);
      let t = {};
      for (let i of Object.keys(n)) {
        let r = n[i],
          s =
            typeof r == "string"
              ? { message: () => r }
              : typeof r == "function"
              ? { message: r }
              : r,
          { message: a } = s,
          o = Em(s, N7),
          l = typeof a == "string" ? () => a : a;
        t[i] = k7(
          Object.assign(
            { code: r_.SyntaxError, reasonCode: i, toMessage: l },
            e ? { syntaxPlugin: e } : {},
            o
          )
        );
      }
      return t;
    }
    var ne = Object.assign(
        {},
        Ea(P7),
        Ea(D7),
        Ea(I7),
        Ea`pipelineOperator`(R7)
      ),
      { defineProperty: F7 } = Object,
      u2 = (n, e) => F7(n, e, { enumerable: !1, value: n[e] });
    function rf(n) {
      return (
        n.loc.start && u2(n.loc.start, "index"),
        n.loc.end && u2(n.loc.end, "index"),
        n
      );
    }
    var B7 = (n) =>
        class extends n {
          parse() {
            let t = rf(super.parse());
            return this.options.tokens && (t.tokens = t.tokens.map(rf)), t;
          }
          parseRegExpLiteral({ pattern: t, flags: i }) {
            let r = null;
            try {
              r = new RegExp(t, i);
            } catch (a) {}
            let s = this.estreeParseLiteral(r);
            return (s.regex = { pattern: t, flags: i }), s;
          }
          parseBigIntLiteral(t) {
            let i;
            try {
              i = BigInt(t);
            } catch (s) {
              i = null;
            }
            let r = this.estreeParseLiteral(i);
            return (r.bigint = String(r.value || t)), r;
          }
          parseDecimalLiteral(t) {
            let r = this.estreeParseLiteral(null);
            return (r.decimal = String(r.value || t)), r;
          }
          estreeParseLiteral(t) {
            return this.parseLiteral(t, "Literal");
          }
          parseStringLiteral(t) {
            return this.estreeParseLiteral(t);
          }
          parseNumericLiteral(t) {
            return this.estreeParseLiteral(t);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(t) {
            return this.estreeParseLiteral(t);
          }
          directiveToStmt(t) {
            let i = t.value,
              r = this.startNodeAt(t.start, t.loc.start),
              s = this.startNodeAt(i.start, i.loc.start);
            return (
              (s.value = i.extra.expressionValue),
              (s.raw = i.extra.raw),
              (r.expression = this.finishNodeAt(s, "Literal", i.loc.end)),
              (r.directive = i.extra.raw.slice(1, -1)),
              this.finishNodeAt(r, "ExpressionStatement", t.loc.end)
            );
          }
          initFunction(t, i) {
            super.initFunction(t, i), (t.expression = !1);
          }
          checkDeclaration(t) {
            t != null && this.isObjectProperty(t)
              ? this.checkDeclaration(t.value)
              : super.checkDeclaration(t);
          }
          getObjectOrClassMethodParams(t) {
            return t.value.params;
          }
          isValidDirective(t) {
            var i;
            return (
              t.type === "ExpressionStatement" &&
              t.expression.type === "Literal" &&
              typeof t.expression.value == "string" &&
              !((i = t.expression.extra) != null && i.parenthesized)
            );
          }
          parseBlockBody(t, i, r, s, a) {
            super.parseBlockBody(t, i, r, s, a);
            let o = t.directives.map((l) => this.directiveToStmt(l));
            (t.body = o.concat(t.body)), delete t.directives;
          }
          pushClassMethod(t, i, r, s, a, o) {
            this.parseMethod(i, r, s, a, o, "ClassMethod", !0),
              i.typeParameters &&
                ((i.value.typeParameters = i.typeParameters),
                delete i.typeParameters),
              t.body.push(i);
          }
          parsePrivateName() {
            let t = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures")
              ? this.convertPrivateNameToPrivateIdentifier(t)
              : t;
          }
          convertPrivateNameToPrivateIdentifier(t) {
            let i = super.getPrivateNameSV(t);
            return (
              (t = t),
              delete t.id,
              (t.name = i),
              (t.type = "PrivateIdentifier"),
              t
            );
          }
          isPrivateName(t) {
            return this.getPluginOption("estree", "classFeatures")
              ? t.type === "PrivateIdentifier"
              : super.isPrivateName(t);
          }
          getPrivateNameSV(t) {
            return this.getPluginOption("estree", "classFeatures")
              ? t.name
              : super.getPrivateNameSV(t);
          }
          parseLiteral(t, i) {
            let r = super.parseLiteral(t, i);
            return (r.raw = r.extra.raw), delete r.extra, r;
          }
          parseFunctionBody(t, i, r = !1) {
            super.parseFunctionBody(t, i, r),
              (t.expression = t.body.type !== "BlockStatement");
          }
          parseMethod(t, i, r, s, a, o, l = !1) {
            let c = this.startNode();
            return (
              (c.kind = t.kind),
              (c = super.parseMethod(c, i, r, s, a, o, l)),
              (c.type = "FunctionExpression"),
              delete c.kind,
              (t.value = c),
              o === "ClassPrivateMethod" && (t.computed = !1),
              this.finishNode(t, "MethodDefinition")
            );
          }
          parseClassProperty(...t) {
            let i = super.parseClassProperty(...t);
            return (
              this.getPluginOption("estree", "classFeatures") &&
                (i.type = "PropertyDefinition"),
              i
            );
          }
          parseClassPrivateProperty(...t) {
            let i = super.parseClassPrivateProperty(...t);
            return (
              this.getPluginOption("estree", "classFeatures") &&
                ((i.type = "PropertyDefinition"), (i.computed = !1)),
              i
            );
          }
          parseObjectMethod(t, i, r, s, a) {
            let o = super.parseObjectMethod(t, i, r, s, a);
            return (
              o &&
                ((o.type = "Property"),
                o.kind === "method" && (o.kind = "init"),
                (o.shorthand = !1)),
              o
            );
          }
          parseObjectProperty(t, i, r, s, a) {
            let o = super.parseObjectProperty(t, i, r, s, a);
            return o && ((o.kind = "init"), (o.type = "Property")), o;
          }
          isValidLVal(t, i, r) {
            return t === "Property" ? "value" : super.isValidLVal(t, i, r);
          }
          isAssignable(t, i) {
            return t != null && this.isObjectProperty(t)
              ? this.isAssignable(t.value, i)
              : super.isAssignable(t, i);
          }
          toAssignable(t, i = !1) {
            if (t != null && this.isObjectProperty(t)) {
              let { key: r, value: s } = t;
              this.isPrivateName(r) &&
                this.classScope.usePrivateName(
                  this.getPrivateNameSV(r),
                  r.loc.start
                ),
                this.toAssignable(s, i);
            } else super.toAssignable(t, i);
          }
          toAssignableObjectExpressionProp(t, i, r) {
            t.kind === "get" || t.kind === "set"
              ? this.raise(ne.PatternHasAccessor, { at: t.key })
              : t.method
              ? this.raise(ne.PatternHasMethod, { at: t.key })
              : super.toAssignableObjectExpressionProp(t, i, r);
          }
          finishCallExpression(t, i) {
            let r = super.finishCallExpression(t, i);
            if (r.callee.type === "Import") {
              if (
                ((r.type = "ImportExpression"),
                (r.source = r.arguments[0]),
                this.hasPlugin("importAssertions"))
              ) {
                var s;
                r.attributes = (s = r.arguments[1]) != null ? s : null;
              }
              delete r.arguments, delete r.callee;
            }
            return r;
          }
          toReferencedArguments(t) {
            t.type !== "ImportExpression" && super.toReferencedArguments(t);
          }
          parseExport(t) {
            let i = super.parseExport(t);
            switch (i.type) {
              case "ExportAllDeclaration":
                i.exported = null;
                break;
              case "ExportNamedDeclaration":
                i.specifiers.length === 1 &&
                  i.specifiers[0].type === "ExportNamespaceSpecifier" &&
                  ((i.type = "ExportAllDeclaration"),
                  (i.exported = i.specifiers[0].exported),
                  delete i.specifiers);
                break;
            }
            return i;
          }
          parseSubscript(t, i, r, s, a) {
            let o = super.parseSubscript(t, i, r, s, a);
            if (a.optionalChainMember) {
              if (
                ((o.type === "OptionalMemberExpression" ||
                  o.type === "OptionalCallExpression") &&
                  (o.type = o.type.substring(8)),
                a.stop)
              ) {
                let l = this.startNodeAtNode(o);
                return (
                  (l.expression = o), this.finishNode(l, "ChainExpression")
                );
              }
            } else
              (o.type === "MemberExpression" || o.type === "CallExpression") &&
                (o.optional = !1);
            return o;
          }
          hasPropertyAsPrivateName(t) {
            return (
              t.type === "ChainExpression" && (t = t.expression),
              super.hasPropertyAsPrivateName(t)
            );
          }
          isOptionalChain(t) {
            return t.type === "ChainExpression";
          }
          isObjectProperty(t) {
            return t.type === "Property" && t.kind === "init" && !t.method;
          }
          isObjectMethod(t) {
            return t.method || t.kind === "get" || t.kind === "set";
          }
          finishNodeAt(t, i, r) {
            return rf(super.finishNodeAt(t, i, r));
          }
          resetStartLocation(t, i, r) {
            super.resetStartLocation(t, i, r), rf(t);
          }
          resetEndLocation(t, i = this.state.lastTokEndLoc) {
            super.resetEndLocation(t, i), rf(t);
          }
        },
      Jc = class {
        constructor(e, t) {
          (this.token = void 0),
            (this.preserveSpace = void 0),
            (this.token = e),
            (this.preserveSpace = !!t);
        }
      },
      Si = {
        brace: new Jc("{"),
        j_oTag: new Jc("<tag"),
        j_cTag: new Jc("</tag"),
        j_expr: new Jc("<tag>...</tag>", !0),
      };
    Si.template = new Jc("`", !0);
    var qt = !0,
      tt = !0,
      Kb = !0,
      sf = !0,
      Eo = !0,
      z7 = !0,
      d_ = class {
        constructor(e, t = {}) {
          (this.label = void 0),
            (this.keyword = void 0),
            (this.beforeExpr = void 0),
            (this.startsExpr = void 0),
            (this.rightAssociative = void 0),
            (this.isLoop = void 0),
            (this.isAssign = void 0),
            (this.prefix = void 0),
            (this.postfix = void 0),
            (this.binop = void 0),
            (this.label = e),
            (this.keyword = t.keyword),
            (this.beforeExpr = !!t.beforeExpr),
            (this.startsExpr = !!t.startsExpr),
            (this.rightAssociative = !!t.rightAssociative),
            (this.isLoop = !!t.isLoop),
            (this.isAssign = !!t.isAssign),
            (this.prefix = !!t.prefix),
            (this.postfix = !!t.postfix),
            (this.binop = t.binop != null ? t.binop : null),
            (this.updateContext = null);
        }
      },
      p_ = new Map();
    function li(n, e = {}) {
      e.keyword = n;
      let t = xt(n, e);
      return p_.set(n, t), t;
    }
    function Yn(n, e) {
      return xt(n, { beforeExpr: qt, binop: e });
    }
    var uf = -1,
      ba = [],
      m_ = [],
      g_ = [],
      y_ = [],
      v_ = [],
      x_ = [];
    function xt(n, e = {}) {
      var t, i, r, s;
      return (
        ++uf,
        m_.push(n),
        g_.push((t = e.binop) != null ? t : -1),
        y_.push((i = e.beforeExpr) != null ? i : !1),
        v_.push((r = e.startsExpr) != null ? r : !1),
        x_.push((s = e.prefix) != null ? s : !1),
        ba.push(new d_(n, e)),
        uf
      );
    }
    function ci(n, e = {}) {
      var t, i, r, s;
      return (
        ++uf,
        p_.set(n, uf),
        m_.push(n),
        g_.push((t = e.binop) != null ? t : -1),
        y_.push((i = e.beforeExpr) != null ? i : !1),
        v_.push((r = e.startsExpr) != null ? r : !1),
        x_.push((s = e.prefix) != null ? s : !1),
        ba.push(new d_("name", e)),
        uf
      );
    }
    var U7 = {
      bracketL: xt("[", { beforeExpr: qt, startsExpr: tt }),
      bracketHashL: xt("#[", { beforeExpr: qt, startsExpr: tt }),
      bracketBarL: xt("[|", { beforeExpr: qt, startsExpr: tt }),
      bracketR: xt("]"),
      bracketBarR: xt("|]"),
      braceL: xt("{", { beforeExpr: qt, startsExpr: tt }),
      braceBarL: xt("{|", { beforeExpr: qt, startsExpr: tt }),
      braceHashL: xt("#{", { beforeExpr: qt, startsExpr: tt }),
      braceR: xt("}"),
      braceBarR: xt("|}"),
      parenL: xt("(", { beforeExpr: qt, startsExpr: tt }),
      parenR: xt(")"),
      comma: xt(",", { beforeExpr: qt }),
      semi: xt(";", { beforeExpr: qt }),
      colon: xt(":", { beforeExpr: qt }),
      doubleColon: xt("::", { beforeExpr: qt }),
      dot: xt("."),
      question: xt("?", { beforeExpr: qt }),
      questionDot: xt("?."),
      arrow: xt("=>", { beforeExpr: qt }),
      template: xt("template"),
      ellipsis: xt("...", { beforeExpr: qt }),
      backQuote: xt("`", { startsExpr: tt }),
      dollarBraceL: xt("${", { beforeExpr: qt, startsExpr: tt }),
      templateTail: xt("...`", { startsExpr: tt }),
      templateNonTail: xt("...${", { beforeExpr: qt, startsExpr: tt }),
      at: xt("@"),
      hash: xt("#", { startsExpr: tt }),
      interpreterDirective: xt("#!..."),
      eq: xt("=", { beforeExpr: qt, isAssign: sf }),
      assign: xt("_=", { beforeExpr: qt, isAssign: sf }),
      slashAssign: xt("_=", { beforeExpr: qt, isAssign: sf }),
      xorAssign: xt("_=", { beforeExpr: qt, isAssign: sf }),
      moduloAssign: xt("_=", { beforeExpr: qt, isAssign: sf }),
      incDec: xt("++/--", { prefix: Eo, postfix: z7, startsExpr: tt }),
      bang: xt("!", { beforeExpr: qt, prefix: Eo, startsExpr: tt }),
      tilde: xt("~", { beforeExpr: qt, prefix: Eo, startsExpr: tt }),
      doubleCaret: xt("^^", { startsExpr: tt }),
      doubleAt: xt("@@", { startsExpr: tt }),
      pipeline: Yn("|>", 0),
      nullishCoalescing: Yn("??", 1),
      logicalOR: Yn("||", 1),
      logicalAND: Yn("&&", 2),
      bitwiseOR: Yn("|", 3),
      bitwiseXOR: Yn("^", 4),
      bitwiseAND: Yn("&", 5),
      equality: Yn("==/!=/===/!==", 6),
      lt: Yn("</>/<=/>=", 7),
      gt: Yn("</>/<=/>=", 7),
      relational: Yn("</>/<=/>=", 7),
      bitShift: Yn("<</>>/>>>", 8),
      bitShiftL: Yn("<</>>/>>>", 8),
      bitShiftR: Yn("<</>>/>>>", 8),
      plusMin: xt("+/-", {
        beforeExpr: qt,
        binop: 9,
        prefix: Eo,
        startsExpr: tt,
      }),
      modulo: xt("%", { binop: 10, startsExpr: tt }),
      star: xt("*", { binop: 10 }),
      slash: Yn("/", 10),
      exponent: xt("**", { beforeExpr: qt, binop: 11, rightAssociative: !0 }),
      _in: li("in", { beforeExpr: qt, binop: 7 }),
      _instanceof: li("instanceof", { beforeExpr: qt, binop: 7 }),
      _break: li("break"),
      _case: li("case", { beforeExpr: qt }),
      _catch: li("catch"),
      _continue: li("continue"),
      _debugger: li("debugger"),
      _default: li("default", { beforeExpr: qt }),
      _else: li("else", { beforeExpr: qt }),
      _finally: li("finally"),
      _function: li("function", { startsExpr: tt }),
      _if: li("if"),
      _return: li("return", { beforeExpr: qt }),
      _switch: li("switch"),
      _throw: li("throw", { beforeExpr: qt, prefix: Eo, startsExpr: tt }),
      _try: li("try"),
      _var: li("var"),
      _const: li("const"),
      _with: li("with"),
      _new: li("new", { beforeExpr: qt, startsExpr: tt }),
      _this: li("this", { startsExpr: tt }),
      _super: li("super", { startsExpr: tt }),
      _class: li("class", { startsExpr: tt }),
      _extends: li("extends", { beforeExpr: qt }),
      _export: li("export"),
      _import: li("import", { startsExpr: tt }),
      _null: li("null", { startsExpr: tt }),
      _true: li("true", { startsExpr: tt }),
      _false: li("false", { startsExpr: tt }),
      _typeof: li("typeof", { beforeExpr: qt, prefix: Eo, startsExpr: tt }),
      _void: li("void", { beforeExpr: qt, prefix: Eo, startsExpr: tt }),
      _delete: li("delete", { beforeExpr: qt, prefix: Eo, startsExpr: tt }),
      _do: li("do", { isLoop: Kb, beforeExpr: qt }),
      _for: li("for", { isLoop: Kb }),
      _while: li("while", { isLoop: Kb }),
      _as: ci("as", { startsExpr: tt }),
      _assert: ci("assert", { startsExpr: tt }),
      _async: ci("async", { startsExpr: tt }),
      _await: ci("await", { startsExpr: tt }),
      _from: ci("from", { startsExpr: tt }),
      _get: ci("get", { startsExpr: tt }),
      _let: ci("let", { startsExpr: tt }),
      _meta: ci("meta", { startsExpr: tt }),
      _of: ci("of", { startsExpr: tt }),
      _sent: ci("sent", { startsExpr: tt }),
      _set: ci("set", { startsExpr: tt }),
      _static: ci("static", { startsExpr: tt }),
      _yield: ci("yield", { startsExpr: tt }),
      _asserts: ci("asserts", { startsExpr: tt }),
      _checks: ci("checks", { startsExpr: tt }),
      _exports: ci("exports", { startsExpr: tt }),
      _global: ci("global", { startsExpr: tt }),
      _implements: ci("implements", { startsExpr: tt }),
      _intrinsic: ci("intrinsic", { startsExpr: tt }),
      _infer: ci("infer", { startsExpr: tt }),
      _is: ci("is", { startsExpr: tt }),
      _mixins: ci("mixins", { startsExpr: tt }),
      _proto: ci("proto", { startsExpr: tt }),
      _require: ci("require", { startsExpr: tt }),
      _keyof: ci("keyof", { startsExpr: tt }),
      _readonly: ci("readonly", { startsExpr: tt }),
      _unique: ci("unique", { startsExpr: tt }),
      _abstract: ci("abstract", { startsExpr: tt }),
      _declare: ci("declare", { startsExpr: tt }),
      _enum: ci("enum", { startsExpr: tt }),
      _module: ci("module", { startsExpr: tt }),
      _namespace: ci("namespace", { startsExpr: tt }),
      _interface: ci("interface", { startsExpr: tt }),
      _type: ci("type", { startsExpr: tt }),
      _opaque: ci("opaque", { startsExpr: tt }),
      name: xt("name", { startsExpr: tt }),
      string: xt("string", { startsExpr: tt }),
      num: xt("num", { startsExpr: tt }),
      bigint: xt("bigint", { startsExpr: tt }),
      decimal: xt("decimal", { startsExpr: tt }),
      regexp: xt("regexp", { startsExpr: tt }),
      privateName: xt("#name", { startsExpr: tt }),
      eof: xt("eof"),
      jsxName: xt("jsxName"),
      jsxText: xt("jsxText", { beforeExpr: !0 }),
      jsxTagStart: xt("jsxTagStart", { startsExpr: !0 }),
      jsxTagEnd: xt("jsxTagEnd"),
      placeholder: xt("%%", { startsExpr: !0 }),
    };
    function pi(n) {
      return n >= 93 && n <= 128;
    }
    function V7(n) {
      return n <= 92;
    }
    function wa(n) {
      return n >= 58 && n <= 128;
    }
    function A2(n) {
      return n >= 58 && n <= 132;
    }
    function G7(n) {
      return y_[n];
    }
    function a_(n) {
      return v_[n];
    }
    function H7(n) {
      return n >= 29 && n <= 33;
    }
    function h2(n) {
      return n >= 125 && n <= 127;
    }
    function $7(n) {
      return n >= 90 && n <= 92;
    }
    function b_(n) {
      return n >= 58 && n <= 92;
    }
    function W7(n) {
      return n >= 39 && n <= 59;
    }
    function q7(n) {
      return n === 34;
    }
    function j7(n) {
      return x_[n];
    }
    function X7(n) {
      return n >= 117 && n <= 119;
    }
    function Y7(n) {
      return n >= 120 && n <= 126;
    }
    function So(n) {
      return m_[n];
    }
    function vm(n) {
      return g_[n];
    }
    function K7(n) {
      return n === 57;
    }
    function Tm(n) {
      return n >= 24 && n <= 25;
    }
    function va(n) {
      return ba[n];
    }
    (ba[8].updateContext = (n) => {
      n.pop();
    }),
      (ba[5].updateContext =
        ba[7].updateContext =
        ba[23].updateContext =
          (n) => {
            n.push(Si.brace);
          }),
      (ba[22].updateContext = (n) => {
        n[n.length - 1] === Si.template ? n.pop() : n.push(Si.template);
      }),
      (ba[138].updateContext = (n) => {
        n.push(Si.j_expr, Si.j_oTag);
      });
    var __ =
        "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
      C2 =
        "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F",
      J7 = new RegExp("[" + __ + "]"),
      Z7 = new RegExp("[" + __ + C2 + "]");
    __ = C2 = null;
    var P2 = [
        0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4,
        48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35,
        5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2,
        1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1,
        4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1,
        65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21,
        11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28,
        11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33,
        24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36,
        17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2,
        6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1,
        2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186,
        43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38,
        17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8,
        2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31,
        15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070,
        4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6,
        18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43,
        8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12,
        4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6,
        2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24,
        2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7,
        1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1,
        2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2,
        3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2,
        0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6,
        2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104,
        541, 1507, 4938,
      ],
      Q7 = [
        509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166,
        1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1,
        11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49,
        13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1,
        3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9,
        214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14,
        166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9,
        41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13,
        123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3,
        19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12,
        1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2,
        1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3,
        6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9,
        4759, 9, 787719, 239,
      ];
    function o_(n, e) {
      let t = 65536;
      for (let i = 0, r = e.length; i < r; i += 2) {
        if (((t += e[i]), t > n)) return !1;
        if (((t += e[i + 1]), t >= n)) return !0;
      }
      return !1;
    }
    function _a(n) {
      return n < 65
        ? n === 36
        : n <= 90
        ? !0
        : n < 97
        ? n === 95
        : n <= 122
        ? !0
        : n <= 65535
        ? n >= 170 && J7.test(String.fromCharCode(n))
        : o_(n, P2);
    }
    function eu(n) {
      return n < 48
        ? n === 36
        : n < 58
        ? !0
        : n < 65
        ? !1
        : n <= 90
        ? !0
        : n < 97
        ? n === 95
        : n <= 122
        ? !0
        : n <= 65535
        ? n >= 170 && Z7.test(String.fromCharCode(n))
        : o_(n, P2) || o_(n, Q7);
    }
    var E_ = {
        keyword: [
          "break",
          "case",
          "catch",
          "continue",
          "debugger",
          "default",
          "do",
          "else",
          "finally",
          "for",
          "function",
          "if",
          "return",
          "switch",
          "throw",
          "try",
          "var",
          "const",
          "while",
          "with",
          "new",
          "this",
          "super",
          "class",
          "extends",
          "export",
          "import",
          "null",
          "true",
          "false",
          "in",
          "instanceof",
          "typeof",
          "void",
          "delete",
        ],
        strict: [
          "implements",
          "interface",
          "let",
          "package",
          "private",
          "protected",
          "public",
          "static",
          "yield",
        ],
        strictBind: ["eval", "arguments"],
      },
      eq = new Set(E_.keyword),
      tq = new Set(E_.strict),
      iq = new Set(E_.strictBind);
    function D2(n, e) {
      return (e && n === "await") || n === "enum";
    }
    function I2(n, e) {
      return D2(n, e) || tq.has(n);
    }
    function L2(n) {
      return iq.has(n);
    }
    function R2(n, e) {
      return I2(n, e) || L2(n);
    }
    function nq(n) {
      return eq.has(n);
    }
    function rq(n, e, t) {
      return n === 64 && e === 64 && _a(t);
    }
    var sq = new Set([
      "break",
      "case",
      "catch",
      "continue",
      "debugger",
      "default",
      "do",
      "else",
      "finally",
      "for",
      "function",
      "if",
      "return",
      "switch",
      "throw",
      "try",
      "var",
      "const",
      "while",
      "with",
      "new",
      "this",
      "super",
      "class",
      "extends",
      "export",
      "import",
      "null",
      "true",
      "false",
      "in",
      "instanceof",
      "typeof",
      "void",
      "delete",
      "implements",
      "interface",
      "let",
      "package",
      "private",
      "protected",
      "public",
      "static",
      "yield",
      "eval",
      "arguments",
      "enum",
      "await",
    ]);
    function aq(n) {
      return sq.has(n);
    }
    var Zc = 0,
      hf = 1,
      Ta = 2,
      T_ = 4,
      O2 = 8,
      Sm = 16,
      N2 = 32,
      Cl = 64,
      l_ = 128,
      xm = 256,
      mm = hf | Ta | xm,
      Ca = 1,
      iu = 2,
      k2 = 4,
      wo = 8,
      bm = 16,
      F2 = 64,
      wm = 128,
      c_ = 256,
      u_ = 512,
      S_ = 1024,
      h_ = 2048,
      B2 = Ca | iu | wo | wm,
      Sa = Ca | 0 | wo | 0,
      Mm = Ca | 0 | k2 | 0,
      z2 = Ca | 0 | bm | 0,
      oq = 0 | iu | 0 | wm,
      lq = 0 | iu | 0 | 0,
      U2 = Ca | iu | wo | c_,
      f2 = 0 | S_,
      Al = 0 | F2,
      cq = Ca | 0 | 0 | F2,
      uq = U2 | u_,
      hq = 0 | S_,
      fq = h_,
      Am = 4,
      w_ = 2,
      M_ = 1,
      Jb = w_ | M_,
      dq = w_ | Am,
      pq = M_ | Am,
      mq = w_,
      gq = M_,
      Zb = 0,
      V2 = class {
        constructor() {
          (this.sawUnambiguousESM = !1),
            (this.ambiguousScriptDifferentAst = !1);
        }
        hasPlugin(e) {
          if (typeof e == "string") return this.plugins.has(e);
          {
            let [t, i] = e;
            if (!this.hasPlugin(t)) return !1;
            let r = this.plugins.get(t);
            for (let s of Object.keys(i))
              if ((r == null ? void 0 : r[s]) !== i[s]) return !1;
            return !0;
          }
        }
        getPluginOption(e, t) {
          var i;
          return (i = this.plugins.get(e)) == null ? void 0 : i[t];
        }
      };
    function G2(n, e) {
      n.trailingComments === void 0
        ? (n.trailingComments = e)
        : n.trailingComments.unshift(...e);
    }
    function yq(n, e) {
      n.leadingComments === void 0
        ? (n.leadingComments = e)
        : n.leadingComments.unshift(...e);
    }
    function mf(n, e) {
      n.innerComments === void 0
        ? (n.innerComments = e)
        : n.innerComments.unshift(...e);
    }
    function af(n, e, t) {
      let i = null,
        r = e.length;
      for (; i === null && r > 0; ) i = e[--r];
      i === null || i.start > t.start ? mf(n, t.comments) : G2(i, t.comments);
    }
    var H2 = class extends V2 {
        addComment(e) {
          this.filename && (e.loc.filename = this.filename),
            this.state.comments.push(e);
        }
        processComment(e) {
          let { commentStack: t } = this.state,
            i = t.length;
          if (i === 0) return;
          let r = i - 1,
            s = t[r];
          s.start === e.end && ((s.leadingNode = e), r--);
          let { start: a } = e;
          for (; r >= 0; r--) {
            let o = t[r],
              l = o.end;
            if (l > a)
              (o.containingNode = e), this.finalizeComment(o), t.splice(r, 1);
            else {
              l === a && (o.trailingNode = e);
              break;
            }
          }
        }
        finalizeComment(e) {
          let { comments: t } = e;
          if (e.leadingNode !== null || e.trailingNode !== null)
            e.leadingNode !== null && G2(e.leadingNode, t),
              e.trailingNode !== null && yq(e.trailingNode, t);
          else {
            let { containingNode: i, start: r } = e;
            if (this.input.charCodeAt(r - 1) === 44)
              switch (i.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  af(i, i.properties, e);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  af(i, i.arguments, e);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  af(i, i.params, e);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  af(i, i.elements, e);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  af(i, i.specifiers, e);
                  break;
                default:
                  mf(i, t);
              }
            else mf(i, t);
          }
        }
        finalizeRemainingComments() {
          let { commentStack: e } = this.state;
          for (let t = e.length - 1; t >= 0; t--) this.finalizeComment(e[t]);
          this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(e) {
          let { commentStack: t } = this.state,
            { length: i } = t;
          if (i === 0) return;
          let r = t[i - 1];
          r.leadingNode === e && (r.leadingNode = null);
        }
        takeSurroundingComments(e, t, i) {
          let { commentStack: r } = this.state,
            s = r.length;
          if (s === 0) return;
          let a = s - 1;
          for (; a >= 0; a--) {
            let o = r[a],
              l = o.end;
            if (o.start === i) o.leadingNode = e;
            else if (l === t) o.trailingNode = e;
            else if (l < t) break;
          }
        }
      },
      A_ = /\r\n?|[\n\u2028\u2029]/,
      gm = new RegExp(A_.source, "g");
    function ff(n) {
      switch (n) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return !0;
        default:
          return !1;
      }
    }
    var Qb = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
      vq = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y,
      d2 = new RegExp(
        "(?=(" +
          vq.source +
          "))\\1" +
          /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,
        "y"
      );
    function xq(n) {
      switch (n) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return !0;
        default:
          return !1;
      }
    }
    var Cm = class {
        constructor() {
          (this.strict = void 0),
            (this.curLine = void 0),
            (this.lineStart = void 0),
            (this.startLoc = void 0),
            (this.endLoc = void 0),
            (this.errors = []),
            (this.potentialArrowAt = -1),
            (this.noArrowAt = []),
            (this.noArrowParamsConversionAt = []),
            (this.maybeInArrowParameters = !1),
            (this.inType = !1),
            (this.noAnonFunctionType = !1),
            (this.hasFlowComment = !1),
            (this.isAmbientContext = !1),
            (this.inAbstractClass = !1),
            (this.inDisallowConditionalTypesContext = !1),
            (this.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null,
            }),
            (this.soloAwait = !1),
            (this.inFSharpPipelineDirectBody = !1),
            (this.labels = []),
            (this.decoratorStack = [[]]),
            (this.comments = []),
            (this.commentStack = []),
            (this.pos = 0),
            (this.type = 135),
            (this.value = null),
            (this.start = 0),
            (this.end = 0),
            (this.lastTokEndLoc = null),
            (this.lastTokStartLoc = null),
            (this.lastTokStart = 0),
            (this.context = [Si.brace]),
            (this.canStartJSXElement = !0),
            (this.containsEsc = !1),
            (this.strictErrors = new Map()),
            (this.tokensLength = 0);
        }
        init({ strictMode: e, sourceType: t, startLine: i, startColumn: r }) {
          (this.strict = e === !1 ? !1 : e === !0 ? !0 : t === "module"),
            (this.curLine = i),
            (this.lineStart = -r),
            (this.startLoc = this.endLoc = new Aa(i, r, 0));
        }
        curPosition() {
          return new Aa(this.curLine, this.pos - this.lineStart, this.pos);
        }
        clone(e) {
          let t = new Cm(),
            i = Object.keys(this);
          for (let r = 0, s = i.length; r < s; r++) {
            let a = i[r],
              o = this[a];
            !e && Array.isArray(o) && (o = o.slice()), (t[a] = o);
          }
          return t;
        }
      },
      bq = function (e) {
        return e >= 48 && e <= 57;
      },
      p2 = {
        decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: new Set([46, 88, 95, 120]),
      },
      ym = {
        bin: (n) => n === 48 || n === 49,
        oct: (n) => n >= 48 && n <= 55,
        dec: (n) => n >= 48 && n <= 57,
        hex: (n) =>
          (n >= 48 && n <= 57) || (n >= 65 && n <= 70) || (n >= 97 && n <= 102),
      };
    function m2(n, e, t, i, r, s) {
      let a = t,
        o = i,
        l = r,
        c = "",
        u = !1,
        f = t,
        { length: d } = e;
      for (;;) {
        if (t >= d) {
          s.unterminated(a, o, l), (c += e.slice(f, t));
          break;
        }
        let m = e.charCodeAt(t);
        if (_q(n, m, e, t)) {
          c += e.slice(f, t);
          break;
        }
        if (m === 92) {
          c += e.slice(f, t);
          let x;
          ({
            ch: x,
            pos: t,
            lineStart: i,
            curLine: r,
          } = Eq(e, t, i, r, n === "template", s)),
            x === null ? (u = !0) : (c += x),
            (f = t);
        } else
          m === 8232 || m === 8233
            ? (++t, ++r, (i = t))
            : m === 10 || m === 13
            ? n === "template"
              ? ((c +=
                  e.slice(f, t) +
                  `
`),
                ++t,
                m === 13 && e.charCodeAt(t) === 10 && ++t,
                ++r,
                (f = i = t))
              : s.unterminated(a, o, l)
            : ++t;
      }
      return { pos: t, str: c, containsInvalid: u, lineStart: i, curLine: r };
    }
    function _q(n, e, t, i) {
      return n === "template"
        ? e === 96 || (e === 36 && t.charCodeAt(i + 1) === 123)
        : e === (n === "double" ? 34 : 39);
    }
    function Eq(n, e, t, i, r, s) {
      let a = !r;
      e++;
      let o = (c) => ({ pos: e, ch: c, lineStart: t, curLine: i }),
        l = n.charCodeAt(e++);
      switch (l) {
        case 110:
          return o(`
`);
        case 114:
          return o("\r");
        case 120: {
          let c;
          return (
            ({ code: c, pos: e } = f_(n, e, t, i, 2, !1, a, s)),
            o(c === null ? null : String.fromCharCode(c))
          );
        }
        case 117: {
          let c;
          return (
            ({ code: c, pos: e } = W2(n, e, t, i, a, s)),
            o(c === null ? null : String.fromCodePoint(c))
          );
        }
        case 116:
          return o("	");
        case 98:
          return o("\b");
        case 118:
          return o("\v");
        case 102:
          return o("\f");
        case 13:
          n.charCodeAt(e) === 10 && ++e;
        case 10:
          (t = e), ++i;
        case 8232:
        case 8233:
          return o("");
        case 56:
        case 57:
          if (r) return o(null);
          s.strictNumericEscape(e - 1, t, i);
        default:
          if (l >= 48 && l <= 55) {
            let c = e - 1,
              f = n.slice(c, e + 2).match(/^[0-7]+/)[0],
              d = parseInt(f, 8);
            d > 255 && ((f = f.slice(0, -1)), (d = parseInt(f, 8))),
              (e += f.length - 1);
            let m = n.charCodeAt(e);
            if (f !== "0" || m === 56 || m === 57) {
              if (r) return o(null);
              s.strictNumericEscape(c, t, i);
            }
            return o(String.fromCharCode(d));
          }
          return o(String.fromCharCode(l));
      }
    }
    function f_(n, e, t, i, r, s, a, o) {
      let l = e,
        c;
      return (
        ({ n: c, pos: e } = $2(n, e, t, i, 16, r, s, !1, o)),
        c === null && (a ? o.invalidEscapeSequence(l, t, i) : (e = l - 1)),
        { code: c, pos: e }
      );
    }
    function $2(n, e, t, i, r, s, a, o, l) {
      let c = e,
        u = r === 16 ? p2.hex : p2.decBinOct,
        f = r === 16 ? ym.hex : r === 10 ? ym.dec : r === 8 ? ym.oct : ym.bin,
        d = !1,
        m = 0;
      for (let x = 0, y = s == null ? 1 / 0 : s; x < y; ++x) {
        let g = n.charCodeAt(e),
          b;
        if (g === 95 && o !== "bail") {
          let _ = n.charCodeAt(e - 1),
            E = n.charCodeAt(e + 1);
          o
            ? (Number.isNaN(E) || !f(E) || u.has(_) || u.has(E)) &&
              l.unexpectedNumericSeparator(e, t, i)
            : l.numericSeparatorInEscapeSequence(e, t, i),
            ++e;
          continue;
        }
        if (
          (g >= 97
            ? (b = g - 97 + 10)
            : g >= 65
            ? (b = g - 65 + 10)
            : bq(g)
            ? (b = g - 48)
            : (b = 1 / 0),
          b >= r)
        )
          if (b <= 9 && l.invalidDigit(e, t, i, r)) b = 0;
          else if (a) (b = 0), (d = !0);
          else break;
        ++e, (m = m * r + b);
      }
      return e === c || (s != null && e - c !== s) || d
        ? { n: null, pos: e }
        : { n: m, pos: e };
    }
    function W2(n, e, t, i, r, s) {
      let a = n.charCodeAt(e),
        o;
      if (a === 123) {
        if (
          (++e,
          ({ code: o, pos: e } = f_(
            n,
            e,
            t,
            i,
            n.indexOf("}", e) - e,
            !0,
            r,
            s
          )),
          ++e,
          o !== null && o > 1114111)
        )
          if (r) s.invalidCodePoint(e, t, i);
          else return { code: null, pos: e };
      } else ({ code: o, pos: e } = f_(n, e, t, i, 4, !1, r, s));
      return { code: o, pos: e };
    }
    var Tq = ["at"],
      Sq = ["at"];
    function of(n, e, t) {
      return new Aa(t, n - e, n);
    }
    var wq = new Set([103, 109, 115, 105, 121, 117, 100, 118]),
      xa = class {
        constructor(e) {
          (this.type = e.type),
            (this.value = e.value),
            (this.start = e.start),
            (this.end = e.end),
            (this.loc = new pf(e.startLoc, e.endLoc));
        }
      },
      q2 = class extends H2 {
        constructor(e, t) {
          super();
          (this.isLookahead = void 0),
            (this.tokens = []),
            (this.errorHandlers_readInt = {
              invalidDigit: (i, r, s, a) =>
                this.options.errorRecovery
                  ? (this.raise(ne.InvalidDigit, { at: of(i, r, s), radix: a }),
                    !0)
                  : !1,
              numericSeparatorInEscapeSequence: this.errorBuilder(
                ne.NumericSeparatorInEscapeSequence
              ),
              unexpectedNumericSeparator: this.errorBuilder(
                ne.UnexpectedNumericSeparator
              ),
            }),
            (this.errorHandlers_readCodePoint = Object.assign(
              {},
              this.errorHandlers_readInt,
              {
                invalidEscapeSequence: this.errorBuilder(
                  ne.InvalidEscapeSequence
                ),
                invalidCodePoint: this.errorBuilder(ne.InvalidCodePoint),
              }
            )),
            (this.errorHandlers_readStringContents_string = Object.assign(
              {},
              this.errorHandlers_readCodePoint,
              {
                strictNumericEscape: (i, r, s) => {
                  this.recordStrictModeErrors(ne.StrictNumericEscape, {
                    at: of(i, r, s),
                  });
                },
                unterminated: (i, r, s) => {
                  throw this.raise(ne.UnterminatedString, {
                    at: of(i - 1, r, s),
                  });
                },
              }
            )),
            (this.errorHandlers_readStringContents_template = Object.assign(
              {},
              this.errorHandlers_readCodePoint,
              {
                strictNumericEscape: this.errorBuilder(ne.StrictNumericEscape),
                unterminated: (i, r, s) => {
                  throw this.raise(ne.UnterminatedTemplate, {
                    at: of(i, r, s),
                  });
                },
              }
            )),
            (this.state = new Cm()),
            this.state.init(e),
            (this.input = t),
            (this.length = t.length),
            (this.isLookahead = !1);
        }
        pushToken(e) {
          (this.tokens.length = this.state.tokensLength),
            this.tokens.push(e),
            ++this.state.tokensLength;
        }
        next() {
          this.checkKeywordEscapes(),
            this.options.tokens && this.pushToken(new xa(this.state)),
            (this.state.lastTokStart = this.state.start),
            (this.state.lastTokEndLoc = this.state.endLoc),
            (this.state.lastTokStartLoc = this.state.startLoc),
            this.nextToken();
        }
        eat(e) {
          return this.match(e) ? (this.next(), !0) : !1;
        }
        match(e) {
          return this.state.type === e;
        }
        createLookaheadState(e) {
          return {
            pos: e.pos,
            value: null,
            type: e.type,
            start: e.start,
            end: e.end,
            context: [this.curContext()],
            inType: e.inType,
            startLoc: e.startLoc,
            lastTokEndLoc: e.lastTokEndLoc,
            curLine: e.curLine,
            lineStart: e.lineStart,
            curPosition: e.curPosition,
          };
        }
        lookahead() {
          let e = this.state;
          (this.state = this.createLookaheadState(e)),
            (this.isLookahead = !0),
            this.nextToken(),
            (this.isLookahead = !1);
          let t = this.state;
          return (this.state = e), t;
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(e) {
          return (Qb.lastIndex = e), Qb.test(this.input) ? Qb.lastIndex : e;
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart());
        }
        codePointAtPos(e) {
          let t = this.input.charCodeAt(e);
          if ((t & 64512) === 55296 && ++e < this.input.length) {
            let i = this.input.charCodeAt(e);
            (i & 64512) === 56320 &&
              (t = 65536 + ((t & 1023) << 10) + (i & 1023));
          }
          return t;
        }
        setStrict(e) {
          (this.state.strict = e),
            e &&
              (this.state.strictErrors.forEach(([t, i]) =>
                this.raise(t, { at: i })
              ),
              this.state.strictErrors.clear());
        }
        curContext() {
          return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
          if (
            (this.skipSpace(),
            (this.state.start = this.state.pos),
            this.isLookahead ||
              (this.state.startLoc = this.state.curPosition()),
            this.state.pos >= this.length)
          ) {
            this.finishToken(135);
            return;
          }
          this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment() {
          let e;
          this.isLookahead || (e = this.state.curPosition());
          let t = this.state.pos,
            i = this.input.indexOf("*/", t + 2);
          if (i === -1)
            throw this.raise(ne.UnterminatedComment, {
              at: this.state.curPosition(),
            });
          for (
            this.state.pos = i + 2, gm.lastIndex = t + 2;
            gm.test(this.input) && gm.lastIndex <= i;

          )
            ++this.state.curLine, (this.state.lineStart = gm.lastIndex);
          if (this.isLookahead) return;
          let r = {
            type: "CommentBlock",
            value: this.input.slice(t + 2, i),
            start: t,
            end: i + 2,
            loc: new pf(e, this.state.curPosition()),
          };
          return this.options.tokens && this.pushToken(r), r;
        }
        skipLineComment(e) {
          let t = this.state.pos,
            i;
          this.isLookahead || (i = this.state.curPosition());
          let r = this.input.charCodeAt((this.state.pos += e));
          if (this.state.pos < this.length)
            for (; !ff(r) && ++this.state.pos < this.length; )
              r = this.input.charCodeAt(this.state.pos);
          if (this.isLookahead) return;
          let s = this.state.pos,
            a = this.input.slice(t + e, s),
            o = {
              type: "CommentLine",
              value: a,
              start: t,
              end: s,
              loc: new pf(i, this.state.curPosition()),
            };
          return this.options.tokens && this.pushToken(o), o;
        }
        skipSpace() {
          let e = this.state.pos,
            t = [];
          e: for (; this.state.pos < this.length; ) {
            let i = this.input.charCodeAt(this.state.pos);
            switch (i) {
              case 32:
              case 160:
              case 9:
                ++this.state.pos;
                break;
              case 13:
                this.input.charCodeAt(this.state.pos + 1) === 10 &&
                  ++this.state.pos;
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos,
                  ++this.state.curLine,
                  (this.state.lineStart = this.state.pos);
                break;
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42: {
                    let r = this.skipBlockComment();
                    r !== void 0 &&
                      (this.addComment(r),
                      this.options.attachComment && t.push(r));
                    break;
                  }
                  case 47: {
                    let r = this.skipLineComment(2);
                    r !== void 0 &&
                      (this.addComment(r),
                      this.options.attachComment && t.push(r));
                    break;
                  }
                  default:
                    break e;
                }
                break;
              default:
                if (xq(i)) ++this.state.pos;
                else if (i === 45 && !this.inModule) {
                  let r = this.state.pos;
                  if (
                    this.input.charCodeAt(r + 1) === 45 &&
                    this.input.charCodeAt(r + 2) === 62 &&
                    (e === 0 || this.state.lineStart > e)
                  ) {
                    let s = this.skipLineComment(3);
                    s !== void 0 &&
                      (this.addComment(s),
                      this.options.attachComment && t.push(s));
                  } else break e;
                } else if (i === 60 && !this.inModule) {
                  let r = this.state.pos;
                  if (
                    this.input.charCodeAt(r + 1) === 33 &&
                    this.input.charCodeAt(r + 2) === 45 &&
                    this.input.charCodeAt(r + 3) === 45
                  ) {
                    let s = this.skipLineComment(4);
                    s !== void 0 &&
                      (this.addComment(s),
                      this.options.attachComment && t.push(s));
                  } else break e;
                } else break e;
            }
          }
          if (t.length > 0) {
            let i = this.state.pos,
              r = {
                start: e,
                end: i,
                comments: t,
                leadingNode: null,
                trailingNode: null,
                containingNode: null,
              };
            this.state.commentStack.push(r);
          }
        }
        finishToken(e, t) {
          (this.state.end = this.state.pos),
            (this.state.endLoc = this.state.curPosition());
          let i = this.state.type;
          (this.state.type = e),
            (this.state.value = t),
            this.isLookahead || this.updateContext(i);
        }
        replaceToken(e) {
          (this.state.type = e), this.updateContext();
        }
        readToken_numberSign() {
          if (this.state.pos === 0 && this.readToken_interpreter()) return;
          let e = this.state.pos + 1,
            t = this.codePointAtPos(e);
          if (t >= 48 && t <= 57)
            throw this.raise(ne.UnexpectedDigitAfterHash, {
              at: this.state.curPosition(),
            });
          if (t === 123 || (t === 91 && this.hasPlugin("recordAndTuple"))) {
            if (
              (this.expectPlugin("recordAndTuple"),
              this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
            )
              throw this.raise(
                t === 123
                  ? ne.RecordExpressionHashIncorrectStartSyntaxType
                  : ne.TupleExpressionHashIncorrectStartSyntaxType,
                { at: this.state.curPosition() }
              );
            (this.state.pos += 2),
              t === 123 ? this.finishToken(7) : this.finishToken(1);
          } else
            _a(t)
              ? (++this.state.pos, this.finishToken(134, this.readWord1(t)))
              : t === 92
              ? (++this.state.pos, this.finishToken(134, this.readWord1()))
              : this.finishOp(27, 1);
        }
        readToken_dot() {
          let e = this.input.charCodeAt(this.state.pos + 1);
          if (e >= 48 && e <= 57) {
            this.readNumber(!0);
            return;
          }
          e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46
            ? ((this.state.pos += 3), this.finishToken(21))
            : (++this.state.pos, this.finishToken(16));
        }
        readToken_slash() {
          this.input.charCodeAt(this.state.pos + 1) === 61
            ? this.finishOp(31, 2)
            : this.finishOp(56, 1);
        }
        readToken_interpreter() {
          if (this.state.pos !== 0 || this.length < 2) return !1;
          let e = this.input.charCodeAt(this.state.pos + 1);
          if (e !== 33) return !1;
          let t = this.state.pos;
          for (this.state.pos += 1; !ff(e) && ++this.state.pos < this.length; )
            e = this.input.charCodeAt(this.state.pos);
          let i = this.input.slice(t + 2, this.state.pos);
          return this.finishToken(28, i), !0;
        }
        readToken_mult_modulo(e) {
          let t = e === 42 ? 55 : 54,
            i = 1,
            r = this.input.charCodeAt(this.state.pos + 1);
          e === 42 &&
            r === 42 &&
            (i++, (r = this.input.charCodeAt(this.state.pos + 2)), (t = 57)),
            r === 61 && !this.state.inType && (i++, (t = e === 37 ? 33 : 30)),
            this.finishOp(t, i);
        }
        readToken_pipe_amp(e) {
          let t = this.input.charCodeAt(this.state.pos + 1);
          if (t === e) {
            this.input.charCodeAt(this.state.pos + 2) === 61
              ? this.finishOp(30, 3)
              : this.finishOp(e === 124 ? 41 : 42, 2);
            return;
          }
          if (e === 124) {
            if (t === 62) {
              this.finishOp(39, 2);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && t === 125) {
              if (
                this.getPluginOption("recordAndTuple", "syntaxType") !== "bar"
              )
                throw this.raise(ne.RecordExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition(),
                });
              (this.state.pos += 2), this.finishToken(9);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && t === 93) {
              if (
                this.getPluginOption("recordAndTuple", "syntaxType") !== "bar"
              )
                throw this.raise(ne.TupleExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition(),
                });
              (this.state.pos += 2), this.finishToken(4);
              return;
            }
          }
          if (t === 61) {
            this.finishOp(30, 2);
            return;
          }
          this.finishOp(e === 124 ? 43 : 45, 1);
        }
        readToken_caret() {
          let e = this.input.charCodeAt(this.state.pos + 1);
          if (e === 61 && !this.state.inType) this.finishOp(32, 2);
          else if (
            e === 94 &&
            this.hasPlugin([
              "pipelineOperator",
              { proposal: "hack", topicToken: "^^" },
            ])
          ) {
            if (
              (this.finishOp(37, 2),
              this.input.codePointAt(this.state.pos) === 94)
            )
              throw this.unexpected();
          } else this.finishOp(44, 1);
        }
        readToken_atSign() {
          this.input.charCodeAt(this.state.pos + 1) === 64 &&
          this.hasPlugin([
            "pipelineOperator",
            { proposal: "hack", topicToken: "@@" },
          ])
            ? this.finishOp(38, 2)
            : this.finishOp(26, 1);
        }
        readToken_plus_min(e) {
          let t = this.input.charCodeAt(this.state.pos + 1);
          if (t === e) {
            this.finishOp(34, 2);
            return;
          }
          t === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
        }
        readToken_lt() {
          let { pos: e } = this.state,
            t = this.input.charCodeAt(e + 1);
          if (t === 60) {
            if (this.input.charCodeAt(e + 2) === 61) {
              this.finishOp(30, 3);
              return;
            }
            this.finishOp(51, 2);
            return;
          }
          if (t === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(47, 1);
        }
        readToken_gt() {
          let { pos: e } = this.state,
            t = this.input.charCodeAt(e + 1);
          if (t === 62) {
            let i = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(e + i) === 61) {
              this.finishOp(30, i + 1);
              return;
            }
            this.finishOp(52, i);
            return;
          }
          if (t === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(48, 1);
        }
        readToken_eq_excl(e) {
          let t = this.input.charCodeAt(this.state.pos + 1);
          if (t === 61) {
            this.finishOp(
              46,
              this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2
            );
            return;
          }
          if (e === 61 && t === 62) {
            (this.state.pos += 2), this.finishToken(19);
            return;
          }
          this.finishOp(e === 61 ? 29 : 35, 1);
        }
        readToken_question() {
          let e = this.input.charCodeAt(this.state.pos + 1),
            t = this.input.charCodeAt(this.state.pos + 2);
          e === 63
            ? t === 61
              ? this.finishOp(30, 3)
              : this.finishOp(40, 2)
            : e === 46 && !(t >= 48 && t <= 57)
            ? ((this.state.pos += 2), this.finishToken(18))
            : (++this.state.pos, this.finishToken(17));
        }
        getTokenFromCode(e) {
          switch (e) {
            case 46:
              this.readToken_dot();
              return;
            case 40:
              ++this.state.pos, this.finishToken(10);
              return;
            case 41:
              ++this.state.pos, this.finishToken(11);
              return;
            case 59:
              ++this.state.pos, this.finishToken(13);
              return;
            case 44:
              ++this.state.pos, this.finishToken(12);
              return;
            case 91:
              if (
                this.hasPlugin("recordAndTuple") &&
                this.input.charCodeAt(this.state.pos + 1) === 124
              ) {
                if (
                  this.getPluginOption("recordAndTuple", "syntaxType") !== "bar"
                )
                  throw this.raise(
                    ne.TupleExpressionBarIncorrectStartSyntaxType,
                    { at: this.state.curPosition() }
                  );
                (this.state.pos += 2), this.finishToken(2);
              } else ++this.state.pos, this.finishToken(0);
              return;
            case 93:
              ++this.state.pos, this.finishToken(3);
              return;
            case 123:
              if (
                this.hasPlugin("recordAndTuple") &&
                this.input.charCodeAt(this.state.pos + 1) === 124
              ) {
                if (
                  this.getPluginOption("recordAndTuple", "syntaxType") !== "bar"
                )
                  throw this.raise(
                    ne.RecordExpressionBarIncorrectStartSyntaxType,
                    { at: this.state.curPosition() }
                  );
                (this.state.pos += 2), this.finishToken(6);
              } else ++this.state.pos, this.finishToken(5);
              return;
            case 125:
              ++this.state.pos, this.finishToken(8);
              return;
            case 58:
              this.hasPlugin("functionBind") &&
              this.input.charCodeAt(this.state.pos + 1) === 58
                ? this.finishOp(15, 2)
                : (++this.state.pos, this.finishToken(14));
              return;
            case 63:
              this.readToken_question();
              return;
            case 96:
              this.readTemplateToken();
              return;
            case 48: {
              let t = this.input.charCodeAt(this.state.pos + 1);
              if (t === 120 || t === 88) {
                this.readRadixNumber(16);
                return;
              }
              if (t === 111 || t === 79) {
                this.readRadixNumber(8);
                return;
              }
              if (t === 98 || t === 66) {
                this.readRadixNumber(2);
                return;
              }
            }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              this.readNumber(!1);
              return;
            case 34:
            case 39:
              this.readString(e);
              return;
            case 47:
              this.readToken_slash();
              return;
            case 37:
            case 42:
              this.readToken_mult_modulo(e);
              return;
            case 124:
            case 38:
              this.readToken_pipe_amp(e);
              return;
            case 94:
              this.readToken_caret();
              return;
            case 43:
            case 45:
              this.readToken_plus_min(e);
              return;
            case 60:
              this.readToken_lt();
              return;
            case 62:
              this.readToken_gt();
              return;
            case 61:
            case 33:
              this.readToken_eq_excl(e);
              return;
            case 126:
              this.finishOp(36, 1);
              return;
            case 64:
              this.readToken_atSign();
              return;
            case 35:
              this.readToken_numberSign();
              return;
            case 92:
              this.readWord();
              return;
            default:
              if (_a(e)) {
                this.readWord(e);
                return;
              }
          }
          throw this.raise(ne.InvalidOrUnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: String.fromCodePoint(e),
          });
        }
        finishOp(e, t) {
          let i = this.input.slice(this.state.pos, this.state.pos + t);
          (this.state.pos += t), this.finishToken(e, i);
        }
        readRegexp() {
          let e = this.state.startLoc,
            t = this.state.start + 1,
            i,
            r,
            { pos: s } = this.state;
          for (; ; ++s) {
            if (s >= this.length)
              throw this.raise(ne.UnterminatedRegExp, { at: Sr(e, 1) });
            let c = this.input.charCodeAt(s);
            if (ff(c))
              throw this.raise(ne.UnterminatedRegExp, { at: Sr(e, 1) });
            if (i) i = !1;
            else {
              if (c === 91) r = !0;
              else if (c === 93 && r) r = !1;
              else if (c === 47 && !r) break;
              i = c === 92;
            }
          }
          let a = this.input.slice(t, s);
          ++s;
          let o = "",
            l = () => Sr(e, s + 2 - t);
          for (; s < this.length; ) {
            let c = this.codePointAtPos(s),
              u = String.fromCharCode(c);
            if (wq.has(c))
              c === 118
                ? (this.expectPlugin("regexpUnicodeSets", l()),
                  o.includes("u") &&
                    this.raise(ne.IncompatibleRegExpUVFlags, { at: l() }))
                : c === 117 &&
                  o.includes("v") &&
                  this.raise(ne.IncompatibleRegExpUVFlags, { at: l() }),
                o.includes(u) &&
                  this.raise(ne.DuplicateRegExpFlags, { at: l() });
            else if (eu(c) || c === 92)
              this.raise(ne.MalformedRegExpFlags, { at: l() });
            else break;
            ++s, (o += u);
          }
          (this.state.pos = s), this.finishToken(133, { pattern: a, flags: o });
        }
        readInt(e, t, i = !1, r = !0) {
          let { n: s, pos: a } = $2(
            this.input,
            this.state.pos,
            this.state.lineStart,
            this.state.curLine,
            e,
            t,
            i,
            r,
            this.errorHandlers_readInt
          );
          return (this.state.pos = a), s;
        }
        readRadixNumber(e) {
          let t = this.state.curPosition(),
            i = !1;
          this.state.pos += 2;
          let r = this.readInt(e);
          r == null && this.raise(ne.InvalidDigit, { at: Sr(t, 2), radix: e });
          let s = this.input.charCodeAt(this.state.pos);
          if (s === 110) ++this.state.pos, (i = !0);
          else if (s === 109) throw this.raise(ne.InvalidDecimal, { at: t });
          if (_a(this.codePointAtPos(this.state.pos)))
            throw this.raise(ne.NumberIdentifier, {
              at: this.state.curPosition(),
            });
          if (i) {
            let a = this.input
              .slice(t.index, this.state.pos)
              .replace(/[_n]/g, "");
            this.finishToken(131, a);
            return;
          }
          this.finishToken(130, r);
        }
        readNumber(e) {
          let t = this.state.pos,
            i = this.state.curPosition(),
            r = !1,
            s = !1,
            a = !1,
            o = !1,
            l = !1;
          !e &&
            this.readInt(10) === null &&
            this.raise(ne.InvalidNumber, { at: this.state.curPosition() });
          let c = this.state.pos - t >= 2 && this.input.charCodeAt(t) === 48;
          if (c) {
            let m = this.input.slice(t, this.state.pos);
            if (
              (this.recordStrictModeErrors(ne.StrictOctalLiteral, { at: i }),
              !this.state.strict)
            ) {
              let x = m.indexOf("_");
              x > 0 &&
                this.raise(ne.ZeroDigitNumericSeparator, { at: Sr(i, x) });
            }
            l = c && !/[89]/.test(m);
          }
          let u = this.input.charCodeAt(this.state.pos);
          if (
            (u === 46 &&
              !l &&
              (++this.state.pos,
              this.readInt(10),
              (r = !0),
              (u = this.input.charCodeAt(this.state.pos))),
            (u === 69 || u === 101) &&
              !l &&
              ((u = this.input.charCodeAt(++this.state.pos)),
              (u === 43 || u === 45) && ++this.state.pos,
              this.readInt(10) === null &&
                this.raise(ne.InvalidOrMissingExponent, { at: i }),
              (r = !0),
              (o = !0),
              (u = this.input.charCodeAt(this.state.pos))),
            u === 110 &&
              ((r || c) && this.raise(ne.InvalidBigIntLiteral, { at: i }),
              ++this.state.pos,
              (s = !0)),
            u === 109 &&
              (this.expectPlugin("decimal", this.state.curPosition()),
              (o || c) && this.raise(ne.InvalidDecimal, { at: i }),
              ++this.state.pos,
              (a = !0)),
            _a(this.codePointAtPos(this.state.pos)))
          )
            throw this.raise(ne.NumberIdentifier, {
              at: this.state.curPosition(),
            });
          let f = this.input.slice(t, this.state.pos).replace(/[_mn]/g, "");
          if (s) {
            this.finishToken(131, f);
            return;
          }
          if (a) {
            this.finishToken(132, f);
            return;
          }
          let d = l ? parseInt(f, 8) : parseFloat(f);
          this.finishToken(130, d);
        }
        readCodePoint(e) {
          let { code: t, pos: i } = W2(
            this.input,
            this.state.pos,
            this.state.lineStart,
            this.state.curLine,
            e,
            this.errorHandlers_readCodePoint
          );
          return (this.state.pos = i), t;
        }
        readString(e) {
          let {
            str: t,
            pos: i,
            curLine: r,
            lineStart: s,
          } = m2(
            e === 34 ? "double" : "single",
            this.input,
            this.state.pos + 1,
            this.state.lineStart,
            this.state.curLine,
            this.errorHandlers_readStringContents_string
          );
          (this.state.pos = i + 1),
            (this.state.lineStart = s),
            (this.state.curLine = r),
            this.finishToken(129, t);
        }
        readTemplateContinuation() {
          this.match(8) || this.unexpected(null, 8),
            this.state.pos--,
            this.readTemplateToken();
        }
        readTemplateToken() {
          let e = this.input[this.state.pos],
            {
              str: t,
              containsInvalid: i,
              pos: r,
              curLine: s,
              lineStart: a,
            } = m2(
              "template",
              this.input,
              this.state.pos + 1,
              this.state.lineStart,
              this.state.curLine,
              this.errorHandlers_readStringContents_template
            );
          (this.state.pos = r + 1),
            (this.state.lineStart = a),
            (this.state.curLine = s),
            this.input.codePointAt(r) === 96
              ? this.finishToken(24, i ? null : e + t + "`")
              : (this.state.pos++,
                this.finishToken(25, i ? null : e + t + "${"));
        }
        recordStrictModeErrors(e, { at: t }) {
          let i = t.index;
          this.state.strict && !this.state.strictErrors.has(i)
            ? this.raise(e, { at: t })
            : this.state.strictErrors.set(i, [e, t]);
        }
        readWord1(e) {
          this.state.containsEsc = !1;
          let t = "",
            i = this.state.pos,
            r = this.state.pos;
          for (
            e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2);
            this.state.pos < this.length;

          ) {
            let s = this.codePointAtPos(this.state.pos);
            if (eu(s)) this.state.pos += s <= 65535 ? 1 : 2;
            else if (s === 92) {
              (this.state.containsEsc = !0),
                (t += this.input.slice(r, this.state.pos));
              let a = this.state.curPosition(),
                o = this.state.pos === i ? _a : eu;
              if (this.input.charCodeAt(++this.state.pos) !== 117) {
                this.raise(ne.MissingUnicodeEscape, {
                  at: this.state.curPosition(),
                }),
                  (r = this.state.pos - 1);
                continue;
              }
              ++this.state.pos;
              let l = this.readCodePoint(!0);
              l !== null &&
                (o(l) || this.raise(ne.EscapedCharNotAnIdentifier, { at: a }),
                (t += String.fromCodePoint(l))),
                (r = this.state.pos);
            } else break;
          }
          return t + this.input.slice(r, this.state.pos);
        }
        readWord(e) {
          let t = this.readWord1(e),
            i = p_.get(t);
          i !== void 0 ? this.finishToken(i, So(i)) : this.finishToken(128, t);
        }
        checkKeywordEscapes() {
          let { type: e } = this.state;
          b_(e) &&
            this.state.containsEsc &&
            this.raise(ne.InvalidEscapedReservedWord, {
              at: this.state.startLoc,
              reservedWord: So(e),
            });
        }
        raise(e, t) {
          let { at: i } = t,
            r = Em(t, Tq),
            s = i instanceof Aa ? i : i.loc.start,
            a = e({ loc: s, details: r });
          if (!this.options.errorRecovery) throw a;
          return this.isLookahead || this.state.errors.push(a), a;
        }
        raiseOverwrite(e, t) {
          let { at: i } = t,
            r = Em(t, Sq),
            s = i instanceof Aa ? i : i.loc.start,
            a = s.index,
            o = this.state.errors;
          for (let l = o.length - 1; l >= 0; l--) {
            let c = o[l];
            if (c.loc.index === a) return (o[l] = e({ loc: s, details: r }));
            if (c.loc.index < a) break;
          }
          return this.raise(e, t);
        }
        updateContext(e) {}
        unexpected(e, t) {
          throw this.raise(ne.UnexpectedToken, {
            expected: t ? So(t) : null,
            at: e != null ? e : this.state.startLoc,
          });
        }
        expectPlugin(e, t) {
          if (this.hasPlugin(e)) return !0;
          throw this.raise(ne.MissingPlugin, {
            at: t != null ? t : this.state.startLoc,
            missingPlugin: [e],
          });
        }
        expectOnePlugin(e) {
          if (!e.some((t) => this.hasPlugin(t)))
            throw this.raise(ne.MissingOneOfPlugins, {
              at: this.state.startLoc,
              missingPlugin: e,
            });
        }
        errorBuilder(e) {
          return (t, i, r) => {
            this.raise(e, { at: of(t, i, r) });
          };
        }
      },
      Pm = class {
        constructor(e) {
          (this.var = new Set()),
            (this.lexical = new Set()),
            (this.functions = new Set()),
            (this.flags = e);
        }
      },
      Dm = class {
        constructor(e, t) {
          (this.parser = void 0),
            (this.scopeStack = []),
            (this.inModule = void 0),
            (this.undefinedExports = new Map()),
            (this.parser = e),
            (this.inModule = t);
        }
        get inFunction() {
          return (this.currentVarScopeFlags() & Ta) > 0;
        }
        get allowSuper() {
          return (this.currentThisScopeFlags() & Sm) > 0;
        }
        get allowDirectSuper() {
          return (this.currentThisScopeFlags() & N2) > 0;
        }
        get inClass() {
          return (this.currentThisScopeFlags() & Cl) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
          let e = this.currentThisScopeFlags();
          return (e & Cl) > 0 && (e & Ta) === 0;
        }
        get inStaticBlock() {
          for (let e = this.scopeStack.length - 1; ; e--) {
            let { flags: t } = this.scopeStack[e];
            if (t & l_) return !0;
            if (t & (mm | Cl)) return !1;
          }
        }
        get inNonArrowFunction() {
          return (this.currentThisScopeFlags() & Ta) > 0;
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(e) {
          return new Pm(e);
        }
        enter(e) {
          this.scopeStack.push(this.createScope(e));
        }
        exit() {
          this.scopeStack.pop();
        }
        treatFunctionsAsVarInScope(e) {
          return !!(
            e.flags & (Ta | l_) ||
            (!this.parser.inModule && e.flags & hf)
          );
        }
        declareName(e, t, i) {
          let r = this.currentScope();
          if (t & wo || t & bm)
            this.checkRedeclarationInScope(r, e, t, i),
              t & bm ? r.functions.add(e) : r.lexical.add(e),
              t & wo && this.maybeExportDefined(r, e);
          else if (t & k2)
            for (
              let s = this.scopeStack.length - 1;
              s >= 0 &&
              ((r = this.scopeStack[s]),
              this.checkRedeclarationInScope(r, e, t, i),
              r.var.add(e),
              this.maybeExportDefined(r, e),
              !(r.flags & mm));
              --s
            );
          this.parser.inModule &&
            r.flags & hf &&
            this.undefinedExports.delete(e);
        }
        maybeExportDefined(e, t) {
          this.parser.inModule &&
            e.flags & hf &&
            this.undefinedExports.delete(t);
        }
        checkRedeclarationInScope(e, t, i, r) {
          this.isRedeclaredInScope(e, t, i) &&
            this.parser.raise(ne.VarRedeclaration, {
              at: r,
              identifierName: t,
            });
        }
        isRedeclaredInScope(e, t, i) {
          return i & Ca
            ? i & wo
              ? e.lexical.has(t) || e.functions.has(t) || e.var.has(t)
              : i & bm
              ? e.lexical.has(t) ||
                (!this.treatFunctionsAsVarInScope(e) && e.var.has(t))
              : (e.lexical.has(t) &&
                  !(e.flags & O2 && e.lexical.values().next().value === t)) ||
                (!this.treatFunctionsAsVarInScope(e) && e.functions.has(t))
            : !1;
        }
        checkLocalExport(e) {
          let { name: t } = e,
            i = this.scopeStack[0];
          !i.lexical.has(t) &&
            !i.var.has(t) &&
            !i.functions.has(t) &&
            this.undefinedExports.set(t, e.loc.start);
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
          for (let e = this.scopeStack.length - 1; ; e--) {
            let { flags: t } = this.scopeStack[e];
            if (t & mm) return t;
          }
        }
        currentThisScopeFlags() {
          for (let e = this.scopeStack.length - 1; ; e--) {
            let { flags: t } = this.scopeStack[e];
            if (t & (mm | Cl) && !(t & T_)) return t;
          }
        }
      },
      j2 = class extends Pm {
        constructor(...e) {
          super(...e);
          this.declareFunctions = new Set();
        }
      },
      X2 = class extends Dm {
        createScope(e) {
          return new j2(e);
        }
        declareName(e, t, i) {
          let r = this.currentScope();
          if (t & h_) {
            this.checkRedeclarationInScope(r, e, t, i),
              this.maybeExportDefined(r, e),
              r.declareFunctions.add(e);
            return;
          }
          super.declareName(e, t, i);
        }
        isRedeclaredInScope(e, t, i) {
          return super.isRedeclaredInScope(e, t, i)
            ? !0
            : i & h_
            ? !e.declareFunctions.has(t) &&
              (e.lexical.has(t) || e.functions.has(t))
            : !1;
        }
        checkLocalExport(e) {
          this.scopeStack[0].declareFunctions.has(e.name) ||
            super.checkLocalExport(e);
        }
      },
      Y2 = class {
        constructor() {
          (this.privateNames = new Set()),
            (this.loneAccessors = new Map()),
            (this.undefinedPrivateNames = new Map());
        }
      },
      K2 = class {
        constructor(e) {
          (this.parser = void 0),
            (this.stack = []),
            (this.undefinedPrivateNames = new Map()),
            (this.parser = e);
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        enter() {
          this.stack.push(new Y2());
        }
        exit() {
          let e = this.stack.pop(),
            t = this.current();
          for (let [i, r] of Array.from(e.undefinedPrivateNames))
            t
              ? t.undefinedPrivateNames.has(i) ||
                t.undefinedPrivateNames.set(i, r)
              : this.parser.raise(ne.InvalidPrivateFieldResolution, {
                  at: r,
                  identifierName: i,
                });
        }
        declarePrivateName(e, t, i) {
          let {
              privateNames: r,
              loneAccessors: s,
              undefinedPrivateNames: a,
            } = this.current(),
            o = r.has(e);
          if (t & Jb) {
            let l = o && s.get(e);
            if (l) {
              let c = l & Am,
                u = t & Am,
                f = l & Jb,
                d = t & Jb;
              (o = f === d || c !== u), o || s.delete(e);
            } else o || s.set(e, t);
          }
          o &&
            this.parser.raise(ne.PrivateNameRedeclaration, {
              at: i,
              identifierName: e,
            }),
            r.add(e),
            a.delete(e);
        }
        usePrivateName(e, t) {
          let i;
          for (i of this.stack) if (i.privateNames.has(e)) return;
          i
            ? i.undefinedPrivateNames.set(e, t)
            : this.parser.raise(ne.InvalidPrivateFieldResolution, {
                at: t,
                identifierName: e,
              });
        }
      },
      Mq = 0,
      J2 = 1,
      C_ = 2,
      Z2 = 3,
      yf = class {
        constructor(e = Mq) {
          (this.type = void 0), (this.type = e);
        }
        canBeArrowParameterDeclaration() {
          return this.type === C_ || this.type === J2;
        }
        isCertainlyParameterDeclaration() {
          return this.type === Z2;
        }
      },
      P_ = class extends yf {
        constructor(e) {
          super(e);
          this.declarationErrors = new Map();
        }
        recordDeclarationError(e, { at: t }) {
          let i = t.index;
          this.declarationErrors.set(i, [e, t]);
        }
        clearDeclarationError(e) {
          this.declarationErrors.delete(e);
        }
        iterateErrors(e) {
          this.declarationErrors.forEach(e);
        }
      },
      Q2 = class {
        constructor(e) {
          (this.parser = void 0), (this.stack = [new yf()]), (this.parser = e);
        }
        enter(e) {
          this.stack.push(e);
        }
        exit() {
          this.stack.pop();
        }
        recordParameterInitializerError(e, { at: t }) {
          let i = { at: t.loc.start },
            { stack: r } = this,
            s = r.length - 1,
            a = r[s];
          for (; !a.isCertainlyParameterDeclaration(); ) {
            if (a.canBeArrowParameterDeclaration())
              a.recordDeclarationError(e, i);
            else return;
            a = r[--s];
          }
          this.parser.raise(e, i);
        }
        recordArrowParemeterBindingError(e, { at: t }) {
          let { stack: i } = this,
            r = i[i.length - 1],
            s = { at: t.loc.start };
          if (r.isCertainlyParameterDeclaration()) this.parser.raise(e, s);
          else if (r.canBeArrowParameterDeclaration())
            r.recordDeclarationError(e, s);
          else return;
        }
        recordAsyncArrowParametersError({ at: e }) {
          let { stack: t } = this,
            i = t.length - 1,
            r = t[i];
          for (; r.canBeArrowParameterDeclaration(); )
            r.type === C_ &&
              r.recordDeclarationError(ne.AwaitBindingIdentifier, { at: e }),
              (r = t[--i]);
        }
        validateAsPattern() {
          let { stack: e } = this,
            t = e[e.length - 1];
          !t.canBeArrowParameterDeclaration() ||
            t.iterateErrors(([i, r]) => {
              this.parser.raise(i, { at: r });
              let s = e.length - 2,
                a = e[s];
              for (; a.canBeArrowParameterDeclaration(); )
                a.clearDeclarationError(r.index), (a = e[--s]);
            });
        }
      };
    function Aq() {
      return new yf(Z2);
    }
    function Cq() {
      return new P_(J2);
    }
    function Pq() {
      return new P_(C_);
    }
    function eL() {
      return new yf();
    }
    var tu = 0,
      tL = 1,
      Im = 2,
      iL = 4,
      Kc = 8,
      nL = class {
        constructor() {
          this.stacks = [];
        }
        enter(e) {
          this.stacks.push(e);
        }
        exit() {
          this.stacks.pop();
        }
        currentFlags() {
          return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
          return (this.currentFlags() & Im) > 0;
        }
        get hasYield() {
          return (this.currentFlags() & tL) > 0;
        }
        get hasReturn() {
          return (this.currentFlags() & iL) > 0;
        }
        get hasIn() {
          return (this.currentFlags() & Kc) > 0;
        }
      };
    function _m(n, e) {
      return (n ? Im : 0) | (e ? tL : 0);
    }
    var rL = class extends q2 {
        addExtra(e, t, i, r = !0) {
          if (!e) return;
          let s = (e.extra = e.extra || {});
          r
            ? (s[t] = i)
            : Object.defineProperty(s, t, { enumerable: r, value: i });
        }
        isContextual(e) {
          return this.state.type === e && !this.state.containsEsc;
        }
        isUnparsedContextual(e, t) {
          let i = e + t.length;
          if (this.input.slice(e, i) === t) {
            let r = this.input.charCodeAt(i);
            return !(eu(r) || (r & 64512) === 55296);
          }
          return !1;
        }
        isLookaheadContextual(e) {
          let t = this.nextTokenStart();
          return this.isUnparsedContextual(t, e);
        }
        eatContextual(e) {
          return this.isContextual(e) ? (this.next(), !0) : !1;
        }
        expectContextual(e, t) {
          if (!this.eatContextual(e))
            throw t != null
              ? this.raise(t, { at: this.state.startLoc })
              : this.unexpected(null, e);
        }
        canInsertSemicolon() {
          return (
            this.match(135) || this.match(8) || this.hasPrecedingLineBreak()
          );
        }
        hasPrecedingLineBreak() {
          return A_.test(
            this.input.slice(this.state.lastTokEndLoc.index, this.state.start)
          );
        }
        hasFollowingLineBreak() {
          return (d2.lastIndex = this.state.end), d2.test(this.input);
        }
        isLineTerminator() {
          return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(e = !0) {
          (e ? this.isLineTerminator() : this.eat(13)) ||
            this.raise(ne.MissingSemicolon, { at: this.state.lastTokEndLoc });
        }
        expect(e, t) {
          this.eat(e) || this.unexpected(t, e);
        }
        tryParse(e, t = this.state.clone()) {
          let i = { node: null };
          try {
            let r = e((s = null) => {
              throw ((i.node = s), i);
            });
            if (this.state.errors.length > t.errors.length) {
              let s = this.state;
              return (
                (this.state = t),
                (this.state.tokensLength = s.tokensLength),
                {
                  node: r,
                  error: s.errors[t.errors.length],
                  thrown: !1,
                  aborted: !1,
                  failState: s,
                }
              );
            }
            return {
              node: r,
              error: null,
              thrown: !1,
              aborted: !1,
              failState: null,
            };
          } catch (r) {
            let s = this.state;
            if (((this.state = t), r instanceof SyntaxError))
              return {
                node: null,
                error: r,
                thrown: !0,
                aborted: !1,
                failState: s,
              };
            if (r === i)
              return {
                node: i.node,
                error: null,
                thrown: !1,
                aborted: !0,
                failState: s,
              };
            throw r;
          }
        }
        checkExpressionErrors(e, t) {
          if (!e) return !1;
          let {
              shorthandAssignLoc: i,
              doubleProtoLoc: r,
              privateKeyLoc: s,
              optionalParametersLoc: a,
            } = e,
            o = !!i || !!r || !!a || !!s;
          if (!t) return o;
          i != null && this.raise(ne.InvalidCoverInitializedName, { at: i }),
            r != null && this.raise(ne.DuplicateProto, { at: r }),
            s != null && this.raise(ne.UnexpectedPrivateField, { at: s }),
            a != null && this.unexpected(a);
        }
        isLiteralPropertyName() {
          return A2(this.state.type);
        }
        isPrivateName(e) {
          return e.type === "PrivateName";
        }
        getPrivateNameSV(e) {
          return e.id.name;
        }
        hasPropertyAsPrivateName(e) {
          return (
            (e.type === "MemberExpression" ||
              e.type === "OptionalMemberExpression") &&
            this.isPrivateName(e.property)
          );
        }
        isOptionalChain(e) {
          return (
            e.type === "OptionalMemberExpression" ||
            e.type === "OptionalCallExpression"
          );
        }
        isObjectProperty(e) {
          return e.type === "ObjectProperty";
        }
        isObjectMethod(e) {
          return e.type === "ObjectMethod";
        }
        initializeScopes(e = this.options.sourceType === "module") {
          let t = this.state.labels;
          this.state.labels = [];
          let i = this.exportedIdentifiers;
          this.exportedIdentifiers = new Set();
          let r = this.inModule;
          this.inModule = e;
          let s = this.scope,
            a = this.getScopeHandler();
          this.scope = new a(this, e);
          let o = this.prodParam;
          this.prodParam = new nL();
          let l = this.classScope;
          this.classScope = new K2(this);
          let c = this.expressionScope;
          return (
            (this.expressionScope = new Q2(this)),
            () => {
              (this.state.labels = t),
                (this.exportedIdentifiers = i),
                (this.inModule = r),
                (this.scope = s),
                (this.prodParam = o),
                (this.classScope = l),
                (this.expressionScope = c);
            }
          );
        }
        enterInitialScopes() {
          let e = tu;
          this.inModule && (e |= Im),
            this.scope.enter(hf),
            this.prodParam.enter(e);
        }
        checkDestructuringPrivate(e) {
          let { privateKeyLoc: t } = e;
          t !== null && this.expectPlugin("destructuringPrivate", t);
        }
      },
      df = class {
        constructor() {
          (this.shorthandAssignLoc = null),
            (this.doubleProtoLoc = null),
            (this.privateKeyLoc = null),
            (this.optionalParametersLoc = null);
        }
      },
      gf = class {
        constructor(e, t, i) {
          (this.type = ""),
            (this.start = t),
            (this.end = 0),
            (this.loc = new pf(i)),
            e != null && e.options.ranges && (this.range = [t, 0]),
            e != null && e.filename && (this.loc.filename = e.filename);
        }
      },
      D_ = gf.prototype;
    D_.__clone = function () {
      let n = new gf(),
        e = Object.keys(this);
      for (let t = 0, i = e.length; t < i; t++) {
        let r = e[t];
        r !== "leadingComments" &&
          r !== "trailingComments" &&
          r !== "innerComments" &&
          (n[r] = this[r]);
      }
      return n;
    };
    function Dq(n) {
      return Ma(n);
    }
    function Ma(n) {
      let {
          type: e,
          start: t,
          end: i,
          loc: r,
          range: s,
          extra: a,
          name: o,
        } = n,
        l = Object.create(D_);
      return (
        (l.type = e),
        (l.start = t),
        (l.end = i),
        (l.loc = r),
        (l.range = s),
        (l.extra = a),
        (l.name = o),
        e === "Placeholder" && (l.expectedNode = n.expectedNode),
        l
      );
    }
    function Iq(n) {
      let { type: e, start: t, end: i, loc: r, range: s, extra: a } = n;
      if (e === "Placeholder") return Dq(n);
      let o = Object.create(D_);
      return (
        (o.type = e),
        (o.start = t),
        (o.end = i),
        (o.loc = r),
        (o.range = s),
        n.raw !== void 0 ? (o.raw = n.raw) : (o.extra = a),
        (o.value = n.value),
        o
      );
    }
    var sL = class extends rL {
        startNode() {
          return new gf(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(e, t) {
          return new gf(this, e, t);
        }
        startNodeAtNode(e) {
          return this.startNodeAt(e.start, e.loc.start);
        }
        finishNode(e, t) {
          return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
        }
        finishNodeAt(e, t, i) {
          return (
            (e.type = t),
            (e.end = i.index),
            (e.loc.end = i),
            this.options.ranges && (e.range[1] = i.index),
            this.options.attachComment && this.processComment(e),
            e
          );
        }
        resetStartLocation(e, t, i) {
          (e.start = t),
            (e.loc.start = i),
            this.options.ranges && (e.range[0] = t);
        }
        resetEndLocation(e, t = this.state.lastTokEndLoc) {
          (e.end = t.index),
            (e.loc.end = t),
            this.options.ranges && (e.range[1] = t.index);
        }
        resetStartLocationFromNode(e, t) {
          this.resetStartLocation(e, t.start, t.loc.start);
        }
      },
      Lq = new Set([
        "_",
        "any",
        "bool",
        "boolean",
        "empty",
        "extends",
        "false",
        "interface",
        "mixed",
        "null",
        "number",
        "static",
        "string",
        "true",
        "typeof",
        "void",
      ]),
      Mt = Ea`flow`({
        AmbiguousConditionalArrow:
          "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
        AmbiguousDeclareModuleKind:
          "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
        AssignReservedType: ({ reservedType: n }) =>
          `Cannot overwrite reserved type ${n}.`,
        DeclareClassElement:
          "The `declare` modifier can only appear on class fields.",
        DeclareClassFieldInitializer:
          "Initializers are not allowed in fields with the `declare` modifier.",
        DuplicateDeclareModuleExports:
          "Duplicate `declare module.exports` statement.",
        EnumBooleanMemberNotInitialized: ({ memberName: n, enumName: e }) =>
          `Boolean enum members need to be initialized. Use either \`${n} = true,\` or \`${n} = false,\` in enum \`${e}\`.`,
        EnumDuplicateMemberName: ({ memberName: n, enumName: e }) =>
          `Enum member names need to be unique, but the name \`${n}\` has already been used before in enum \`${e}\`.`,
        EnumInconsistentMemberValues: ({ enumName: n }) =>
          `Enum \`${n}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
        EnumInvalidExplicitType: ({ invalidEnumType: n, enumName: e }) =>
          `Enum type \`${n}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`,
        EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: n }) =>
          `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${n}\`.`,
        EnumInvalidMemberInitializerPrimaryType: ({
          enumName: n,
          memberName: e,
          explicitType: t,
        }) =>
          `Enum \`${n}\` has type \`${t}\`, so the initializer of \`${e}\` needs to be a ${t} literal.`,
        EnumInvalidMemberInitializerSymbolType: ({
          enumName: n,
          memberName: e,
        }) =>
          `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${n}\`.`,
        EnumInvalidMemberInitializerUnknownType: ({
          enumName: n,
          memberName: e,
        }) =>
          `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${n}\`.`,
        EnumInvalidMemberName: ({
          enumName: n,
          memberName: e,
          suggestion: t,
        }) =>
          `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${t}\`, in enum \`${n}\`.`,
        EnumNumberMemberNotInitialized: ({ enumName: n, memberName: e }) =>
          `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${n}\`.`,
        EnumStringMemberInconsistentlyInitailized: ({ enumName: n }) =>
          `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${n}\`.`,
        GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
        ImportTypeShorthandOnlyInPureImport:
          "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
        InexactInsideExact:
          "Explicit inexact syntax cannot appear inside an explicit exact object type.",
        InexactInsideNonObject:
          "Explicit inexact syntax cannot appear in class or interface definitions.",
        InexactVariance: "Explicit inexact syntax cannot have variance.",
        InvalidNonTypeImportInDeclareModule:
          "Imports within a `declare module` body must always be `import type` or `import typeof`.",
        MissingTypeParamDefault:
          "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
        NestedDeclareModule:
          "`declare module` cannot be used inside another `declare module`.",
        NestedFlowComment:
          "Cannot have a flow comment inside another flow comment.",
        PatternIsOptional: Object.assign(
          {
            message:
              "A binding pattern parameter cannot be optional in an implementation signature.",
          },
          { reasonCode: "OptionalBindingPattern" }
        ),
        SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
        SpreadVariance: "Spread properties cannot have variance.",
        ThisParamAnnotationRequired:
          "A type annotation is required for the `this` parameter.",
        ThisParamBannedInConstructor:
          "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
        ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
        ThisParamMustBeFirst:
          "The `this` parameter must be the first function parameter.",
        ThisParamNoDefault:
          "The `this` parameter may not have a default value.",
        TypeBeforeInitializer:
          "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeCastInPattern:
          "The type cast expression is expected to be wrapped with parenthesis.",
        UnexpectedExplicitInexactInObject:
          "Explicit inexact syntax must appear at the end of an inexact object.",
        UnexpectedReservedType: ({ reservedType: n }) =>
          `Unexpected reserved type ${n}.`,
        UnexpectedReservedUnderscore:
          "`_` is only allowed as a type argument to call or new.",
        UnexpectedSpaceBetweenModuloChecks:
          "Spaces between `%` and `checks` are not allowed here.",
        UnexpectedSpreadType:
          "Spread operator cannot appear in class or interface definitions.",
        UnexpectedSubtractionOperand:
          'Unexpected token, expected "number" or "bigint".',
        UnexpectedTokenAfterTypeParameter:
          "Expected an arrow function after this type parameter declaration.",
        UnexpectedTypeParameterBeforeAsyncArrowFunction:
          "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
        UnsupportedDeclareExportKind: ({
          unsupportedExportKind: n,
          suggestion: e,
        }) => `\`declare export ${n}\` is not supported. Use \`${e}\` instead.`,
        UnsupportedStatementInDeclareModule:
          "Only declares and type imports are allowed inside declare module.",
        UnterminatedFlowComment: "Unterminated flow-comment.",
      });
    function Rq(n) {
      return (
        n.type === "DeclareExportAllDeclaration" ||
        (n.type === "DeclareExportDeclaration" &&
          (!n.declaration ||
            (n.declaration.type !== "TypeAlias" &&
              n.declaration.type !== "InterfaceDeclaration")))
      );
    }
    function e_(n) {
      return n.importKind === "type" || n.importKind === "typeof";
    }
    function g2(n) {
      return wa(n) && n !== 97;
    }
    var Oq = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface",
    };
    function Nq(n, e) {
      let t = [],
        i = [];
      for (let r = 0; r < n.length; r++) (e(n[r], r, n) ? t : i).push(n[r]);
      return [t, i];
    }
    var kq = /\*?\s*@((?:no)?flow)\b/,
      Fq = (n) =>
        class extends n {
          constructor(...t) {
            super(...t);
            this.flowPragma = void 0;
          }
          getScopeHandler() {
            return X2;
          }
          shouldParseTypes() {
            return (
              this.getPluginOption("flow", "all") || this.flowPragma === "flow"
            );
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(t, i) {
            return (
              t !== 129 &&
                t !== 13 &&
                t !== 28 &&
                this.flowPragma === void 0 &&
                (this.flowPragma = null),
              super.finishToken(t, i)
            );
          }
          addComment(t) {
            if (this.flowPragma === void 0) {
              let i = kq.exec(t.value);
              if (i)
                if (i[1] === "flow") this.flowPragma = "flow";
                else if (i[1] === "noflow") this.flowPragma = "noflow";
                else throw new Error("Unexpected flow pragma");
            }
            return super.addComment(t);
          }
          flowParseTypeInitialiser(t) {
            let i = this.state.inType;
            (this.state.inType = !0), this.expect(t || 14);
            let r = this.flowParseType();
            return (this.state.inType = i), r;
          }
          flowParsePredicate() {
            let t = this.startNode(),
              i = this.state.startLoc;
            return (
              this.next(),
              this.expectContextual(107),
              this.state.lastTokStart > i.index + 1 &&
                this.raise(Mt.UnexpectedSpaceBetweenModuloChecks, { at: i }),
              this.eat(10)
                ? ((t.value = super.parseExpression()),
                  this.expect(11),
                  this.finishNode(t, "DeclaredPredicate"))
                : this.finishNode(t, "InferredPredicate")
            );
          }
          flowParseTypeAndPredicateInitialiser() {
            let t = this.state.inType;
            (this.state.inType = !0), this.expect(14);
            let i = null,
              r = null;
            return (
              this.match(54)
                ? ((this.state.inType = t), (r = this.flowParsePredicate()))
                : ((i = this.flowParseType()),
                  (this.state.inType = t),
                  this.match(54) && (r = this.flowParsePredicate())),
              [i, r]
            );
          }
          flowParseDeclareClass(t) {
            return (
              this.next(),
              this.flowParseInterfaceish(t, !0),
              this.finishNode(t, "DeclareClass")
            );
          }
          flowParseDeclareFunction(t) {
            this.next();
            let i = (t.id = this.parseIdentifier()),
              r = this.startNode(),
              s = this.startNode();
            this.match(47)
              ? (r.typeParameters = this.flowParseTypeParameterDeclaration())
              : (r.typeParameters = null),
              this.expect(10);
            let a = this.flowParseFunctionTypeParams();
            return (
              (r.params = a.params),
              (r.rest = a.rest),
              (r.this = a._this),
              this.expect(11),
              ([r.returnType, t.predicate] =
                this.flowParseTypeAndPredicateInitialiser()),
              (s.typeAnnotation = this.finishNode(r, "FunctionTypeAnnotation")),
              (i.typeAnnotation = this.finishNode(s, "TypeAnnotation")),
              this.resetEndLocation(i),
              this.semicolon(),
              this.scope.declareName(t.id.name, fq, t.id.loc.start),
              this.finishNode(t, "DeclareFunction")
            );
          }
          flowParseDeclare(t, i) {
            if (this.match(80)) return this.flowParseDeclareClass(t);
            if (this.match(68)) return this.flowParseDeclareFunction(t);
            if (this.match(74)) return this.flowParseDeclareVariable(t);
            if (this.eatContextual(123))
              return this.match(16)
                ? this.flowParseDeclareModuleExports(t)
                : (i &&
                    this.raise(Mt.NestedDeclareModule, {
                      at: this.state.lastTokStartLoc,
                    }),
                  this.flowParseDeclareModule(t));
            if (this.isContextual(126))
              return this.flowParseDeclareTypeAlias(t);
            if (this.isContextual(127))
              return this.flowParseDeclareOpaqueType(t);
            if (this.isContextual(125))
              return this.flowParseDeclareInterface(t);
            if (this.match(82))
              return this.flowParseDeclareExportDeclaration(t, i);
            throw this.unexpected();
          }
          flowParseDeclareVariable(t) {
            return (
              this.next(),
              (t.id = this.flowParseTypeAnnotatableIdentifier(!0)),
              this.scope.declareName(t.id.name, Mm, t.id.loc.start),
              this.semicolon(),
              this.finishNode(t, "DeclareVariable")
            );
          }
          flowParseDeclareModule(t) {
            this.scope.enter(Zc),
              this.match(129)
                ? (t.id = super.parseExprAtom())
                : (t.id = this.parseIdentifier());
            let i = (t.body = this.startNode()),
              r = (i.body = []);
            for (this.expect(5); !this.match(8); ) {
              let o = this.startNode();
              this.match(83)
                ? (this.next(),
                  !this.isContextual(126) &&
                    !this.match(87) &&
                    this.raise(Mt.InvalidNonTypeImportInDeclareModule, {
                      at: this.state.lastTokStartLoc,
                    }),
                  super.parseImport(o))
                : (this.expectContextual(
                    121,
                    Mt.UnsupportedStatementInDeclareModule
                  ),
                  (o = this.flowParseDeclare(o, !0))),
                r.push(o);
            }
            this.scope.exit(),
              this.expect(8),
              this.finishNode(i, "BlockStatement");
            let s = null,
              a = !1;
            return (
              r.forEach((o) => {
                Rq(o)
                  ? (s === "CommonJS" &&
                      this.raise(Mt.AmbiguousDeclareModuleKind, { at: o }),
                    (s = "ES"))
                  : o.type === "DeclareModuleExports" &&
                    (a &&
                      this.raise(Mt.DuplicateDeclareModuleExports, { at: o }),
                    s === "ES" &&
                      this.raise(Mt.AmbiguousDeclareModuleKind, { at: o }),
                    (s = "CommonJS"),
                    (a = !0));
              }),
              (t.kind = s || "CommonJS"),
              this.finishNode(t, "DeclareModule")
            );
          }
          flowParseDeclareExportDeclaration(t, i) {
            if ((this.expect(82), this.eat(65)))
              return (
                this.match(68) || this.match(80)
                  ? (t.declaration = this.flowParseDeclare(this.startNode()))
                  : ((t.declaration = this.flowParseType()), this.semicolon()),
                (t.default = !0),
                this.finishNode(t, "DeclareExportDeclaration")
              );
            if (
              this.match(75) ||
              this.isLet() ||
              ((this.isContextual(126) || this.isContextual(125)) && !i)
            ) {
              let r = this.state.value;
              throw this.raise(Mt.UnsupportedDeclareExportKind, {
                at: this.state.startLoc,
                unsupportedExportKind: r,
                suggestion: Oq[r],
              });
            }
            if (
              this.match(74) ||
              this.match(68) ||
              this.match(80) ||
              this.isContextual(127)
            )
              return (
                (t.declaration = this.flowParseDeclare(this.startNode())),
                (t.default = !1),
                this.finishNode(t, "DeclareExportDeclaration")
              );
            if (
              this.match(55) ||
              this.match(5) ||
              this.isContextual(125) ||
              this.isContextual(126) ||
              this.isContextual(127)
            )
              return (
                (t = this.parseExport(t)),
                t.type === "ExportNamedDeclaration" &&
                  ((t.type = "ExportDeclaration"),
                  (t.default = !1),
                  delete t.exportKind),
                (t.type = "Declare" + t.type),
                t
              );
            throw this.unexpected();
          }
          flowParseDeclareModuleExports(t) {
            return (
              this.next(),
              this.expectContextual(108),
              (t.typeAnnotation = this.flowParseTypeAnnotation()),
              this.semicolon(),
              this.finishNode(t, "DeclareModuleExports")
            );
          }
          flowParseDeclareTypeAlias(t) {
            this.next();
            let i = this.flowParseTypeAlias(t);
            return (i.type = "DeclareTypeAlias"), i;
          }
          flowParseDeclareOpaqueType(t) {
            this.next();
            let i = this.flowParseOpaqueType(t, !0);
            return (i.type = "DeclareOpaqueType"), i;
          }
          flowParseDeclareInterface(t) {
            return (
              this.next(),
              this.flowParseInterfaceish(t),
              this.finishNode(t, "DeclareInterface")
            );
          }
          flowParseInterfaceish(t, i = !1) {
            if (
              ((t.id = this.flowParseRestrictedIdentifier(!i, !0)),
              this.scope.declareName(t.id.name, i ? z2 : Sa, t.id.loc.start),
              this.match(47)
                ? (t.typeParameters = this.flowParseTypeParameterDeclaration())
                : (t.typeParameters = null),
              (t.extends = []),
              (t.implements = []),
              (t.mixins = []),
              this.eat(81))
            )
              do t.extends.push(this.flowParseInterfaceExtends());
              while (!i && this.eat(12));
            if (this.isContextual(114)) {
              this.next();
              do t.mixins.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
            }
            if (this.isContextual(110)) {
              this.next();
              do t.implements.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
            }
            t.body = this.flowParseObjectType({
              allowStatic: i,
              allowExact: !1,
              allowSpread: !1,
              allowProto: i,
              allowInexact: !1,
            });
          }
          flowParseInterfaceExtends() {
            let t = this.startNode();
            return (
              (t.id = this.flowParseQualifiedTypeIdentifier()),
              this.match(47)
                ? (t.typeParameters =
                    this.flowParseTypeParameterInstantiation())
                : (t.typeParameters = null),
              this.finishNode(t, "InterfaceExtends")
            );
          }
          flowParseInterface(t) {
            return (
              this.flowParseInterfaceish(t),
              this.finishNode(t, "InterfaceDeclaration")
            );
          }
          checkNotUnderscore(t) {
            t === "_" &&
              this.raise(Mt.UnexpectedReservedUnderscore, {
                at: this.state.startLoc,
              });
          }
          checkReservedType(t, i, r) {
            !Lq.has(t) ||
              this.raise(
                r ? Mt.AssignReservedType : Mt.UnexpectedReservedType,
                { at: i, reservedType: t }
              );
          }
          flowParseRestrictedIdentifier(t, i) {
            return (
              this.checkReservedType(this.state.value, this.state.startLoc, i),
              this.parseIdentifier(t)
            );
          }
          flowParseTypeAlias(t) {
            return (
              (t.id = this.flowParseRestrictedIdentifier(!1, !0)),
              this.scope.declareName(t.id.name, Sa, t.id.loc.start),
              this.match(47)
                ? (t.typeParameters = this.flowParseTypeParameterDeclaration())
                : (t.typeParameters = null),
              (t.right = this.flowParseTypeInitialiser(29)),
              this.semicolon(),
              this.finishNode(t, "TypeAlias")
            );
          }
          flowParseOpaqueType(t, i) {
            return (
              this.expectContextual(126),
              (t.id = this.flowParseRestrictedIdentifier(!0, !0)),
              this.scope.declareName(t.id.name, Sa, t.id.loc.start),
              this.match(47)
                ? (t.typeParameters = this.flowParseTypeParameterDeclaration())
                : (t.typeParameters = null),
              (t.supertype = null),
              this.match(14) &&
                (t.supertype = this.flowParseTypeInitialiser(14)),
              (t.impltype = null),
              i || (t.impltype = this.flowParseTypeInitialiser(29)),
              this.semicolon(),
              this.finishNode(t, "OpaqueType")
            );
          }
          flowParseTypeParameter(t = !1) {
            let i = this.state.startLoc,
              r = this.startNode(),
              s = this.flowParseVariance(),
              a = this.flowParseTypeAnnotatableIdentifier();
            return (
              (r.name = a.name),
              (r.variance = s),
              (r.bound = a.typeAnnotation),
              this.match(29)
                ? (this.eat(29), (r.default = this.flowParseType()))
                : t && this.raise(Mt.MissingTypeParamDefault, { at: i }),
              this.finishNode(r, "TypeParameter")
            );
          }
          flowParseTypeParameterDeclaration() {
            let t = this.state.inType,
              i = this.startNode();
            (i.params = []),
              (this.state.inType = !0),
              this.match(47) || this.match(138)
                ? this.next()
                : this.unexpected();
            let r = !1;
            do {
              let s = this.flowParseTypeParameter(r);
              i.params.push(s),
                s.default && (r = !0),
                this.match(48) || this.expect(12);
            } while (!this.match(48));
            return (
              this.expect(48),
              (this.state.inType = t),
              this.finishNode(i, "TypeParameterDeclaration")
            );
          }
          flowParseTypeParameterInstantiation() {
            let t = this.startNode(),
              i = this.state.inType;
            (t.params = []), (this.state.inType = !0), this.expect(47);
            let r = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = !1; !this.match(48); )
              t.params.push(this.flowParseType()),
                this.match(48) || this.expect(12);
            return (
              (this.state.noAnonFunctionType = r),
              this.expect(48),
              (this.state.inType = i),
              this.finishNode(t, "TypeParameterInstantiation")
            );
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            let t = this.startNode(),
              i = this.state.inType;
            for (
              t.params = [], this.state.inType = !0, this.expect(47);
              !this.match(48);

            )
              t.params.push(this.flowParseTypeOrImplicitInstantiation()),
                this.match(48) || this.expect(12);
            return (
              this.expect(48),
              (this.state.inType = i),
              this.finishNode(t, "TypeParameterInstantiation")
            );
          }
          flowParseInterfaceType() {
            let t = this.startNode();
            if ((this.expectContextual(125), (t.extends = []), this.eat(81)))
              do t.extends.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
            return (
              (t.body = this.flowParseObjectType({
                allowStatic: !1,
                allowExact: !1,
                allowSpread: !1,
                allowProto: !1,
                allowInexact: !1,
              })),
              this.finishNode(t, "InterfaceTypeAnnotation")
            );
          }
          flowParseObjectPropertyKey() {
            return this.match(130) || this.match(129)
              ? super.parseExprAtom()
              : this.parseIdentifier(!0);
          }
          flowParseObjectTypeIndexer(t, i, r) {
            return (
              (t.static = i),
              this.lookahead().type === 14
                ? ((t.id = this.flowParseObjectPropertyKey()),
                  (t.key = this.flowParseTypeInitialiser()))
                : ((t.id = null), (t.key = this.flowParseType())),
              this.expect(3),
              (t.value = this.flowParseTypeInitialiser()),
              (t.variance = r),
              this.finishNode(t, "ObjectTypeIndexer")
            );
          }
          flowParseObjectTypeInternalSlot(t, i) {
            return (
              (t.static = i),
              (t.id = this.flowParseObjectPropertyKey()),
              this.expect(3),
              this.expect(3),
              this.match(47) || this.match(10)
                ? ((t.method = !0),
                  (t.optional = !1),
                  (t.value = this.flowParseObjectTypeMethodish(
                    this.startNodeAt(t.start, t.loc.start)
                  )))
                : ((t.method = !1),
                  this.eat(17) && (t.optional = !0),
                  (t.value = this.flowParseTypeInitialiser())),
              this.finishNode(t, "ObjectTypeInternalSlot")
            );
          }
          flowParseObjectTypeMethodish(t) {
            for (
              t.params = [],
                t.rest = null,
                t.typeParameters = null,
                t.this = null,
                this.match(47) &&
                  (t.typeParameters = this.flowParseTypeParameterDeclaration()),
                this.expect(10),
                this.match(78) &&
                  ((t.this = this.flowParseFunctionTypeParam(!0)),
                  (t.this.name = null),
                  this.match(11) || this.expect(12));
              !this.match(11) && !this.match(21);

            )
              t.params.push(this.flowParseFunctionTypeParam(!1)),
                this.match(11) || this.expect(12);
            return (
              this.eat(21) && (t.rest = this.flowParseFunctionTypeParam(!1)),
              this.expect(11),
              (t.returnType = this.flowParseTypeInitialiser()),
              this.finishNode(t, "FunctionTypeAnnotation")
            );
          }
          flowParseObjectTypeCallProperty(t, i) {
            let r = this.startNode();
            return (
              (t.static = i),
              (t.value = this.flowParseObjectTypeMethodish(r)),
              this.finishNode(t, "ObjectTypeCallProperty")
            );
          }
          flowParseObjectType({
            allowStatic: t,
            allowExact: i,
            allowSpread: r,
            allowProto: s,
            allowInexact: a,
          }) {
            let o = this.state.inType;
            this.state.inType = !0;
            let l = this.startNode();
            (l.callProperties = []),
              (l.properties = []),
              (l.indexers = []),
              (l.internalSlots = []);
            let c,
              u,
              f = !1;
            for (
              i && this.match(6)
                ? (this.expect(6), (c = 9), (u = !0))
                : (this.expect(5), (c = 8), (u = !1)),
                l.exact = u;
              !this.match(c);

            ) {
              let m = !1,
                x = null,
                y = null,
                g = this.startNode();
              if (s && this.isContextual(115)) {
                let _ = this.lookahead();
                _.type !== 14 &&
                  _.type !== 17 &&
                  (this.next(), (x = this.state.startLoc), (t = !1));
              }
              if (t && this.isContextual(104)) {
                let _ = this.lookahead();
                _.type !== 14 && _.type !== 17 && (this.next(), (m = !0));
              }
              let b = this.flowParseVariance();
              if (this.eat(0))
                x != null && this.unexpected(x),
                  this.eat(0)
                    ? (b && this.unexpected(b.loc.start),
                      l.internalSlots.push(
                        this.flowParseObjectTypeInternalSlot(g, m)
                      ))
                    : l.indexers.push(this.flowParseObjectTypeIndexer(g, m, b));
              else if (this.match(10) || this.match(47))
                x != null && this.unexpected(x),
                  b && this.unexpected(b.loc.start),
                  l.callProperties.push(
                    this.flowParseObjectTypeCallProperty(g, m)
                  );
              else {
                let _ = "init";
                if (this.isContextual(98) || this.isContextual(103)) {
                  let w = this.lookahead();
                  A2(w.type) && ((_ = this.state.value), this.next());
                }
                let E = this.flowParseObjectTypeProperty(
                  g,
                  m,
                  x,
                  b,
                  _,
                  r,
                  a != null ? a : !u
                );
                E === null
                  ? ((f = !0), (y = this.state.lastTokStartLoc))
                  : l.properties.push(E);
              }
              this.flowObjectTypeSemicolon(),
                y &&
                  !this.match(8) &&
                  !this.match(9) &&
                  this.raise(Mt.UnexpectedExplicitInexactInObject, { at: y });
            }
            this.expect(c), r && (l.inexact = f);
            let d = this.finishNode(l, "ObjectTypeAnnotation");
            return (this.state.inType = o), d;
          }
          flowParseObjectTypeProperty(t, i, r, s, a, o, l) {
            if (this.eat(21))
              return this.match(12) ||
                this.match(13) ||
                this.match(8) ||
                this.match(9)
                ? (o
                    ? l ||
                      this.raise(Mt.InexactInsideExact, {
                        at: this.state.lastTokStartLoc,
                      })
                    : this.raise(Mt.InexactInsideNonObject, {
                        at: this.state.lastTokStartLoc,
                      }),
                  s && this.raise(Mt.InexactVariance, { at: s }),
                  null)
                : (o ||
                    this.raise(Mt.UnexpectedSpreadType, {
                      at: this.state.lastTokStartLoc,
                    }),
                  r != null && this.unexpected(r),
                  s && this.raise(Mt.SpreadVariance, { at: s }),
                  (t.argument = this.flowParseType()),
                  this.finishNode(t, "ObjectTypeSpreadProperty"));
            {
              (t.key = this.flowParseObjectPropertyKey()),
                (t.static = i),
                (t.proto = r != null),
                (t.kind = a);
              let c = !1;
              return (
                this.match(47) || this.match(10)
                  ? ((t.method = !0),
                    r != null && this.unexpected(r),
                    s && this.unexpected(s.loc.start),
                    (t.value = this.flowParseObjectTypeMethodish(
                      this.startNodeAt(t.start, t.loc.start)
                    )),
                    (a === "get" || a === "set") &&
                      this.flowCheckGetterSetterParams(t),
                    !o &&
                      t.key.name === "constructor" &&
                      t.value.this &&
                      this.raise(Mt.ThisParamBannedInConstructor, {
                        at: t.value.this,
                      }))
                  : (a !== "init" && this.unexpected(),
                    (t.method = !1),
                    this.eat(17) && (c = !0),
                    (t.value = this.flowParseTypeInitialiser()),
                    (t.variance = s)),
                (t.optional = c),
                this.finishNode(t, "ObjectTypeProperty")
              );
            }
          }
          flowCheckGetterSetterParams(t) {
            let i = t.kind === "get" ? 0 : 1,
              r = t.value.params.length + (t.value.rest ? 1 : 0);
            t.value.this &&
              this.raise(
                t.kind === "get"
                  ? Mt.GetterMayNotHaveThisParam
                  : Mt.SetterMayNotHaveThisParam,
                { at: t.value.this }
              ),
              r !== i &&
                this.raise(
                  t.kind === "get" ? ne.BadGetterArity : ne.BadSetterArity,
                  { at: t }
                ),
              t.kind === "set" &&
                t.value.rest &&
                this.raise(ne.BadSetterRestParameter, { at: t });
          }
          flowObjectTypeSemicolon() {
            !this.eat(13) &&
              !this.eat(12) &&
              !this.match(8) &&
              !this.match(9) &&
              this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(t, i, r) {
            (t = t || this.state.start), (i = i || this.state.startLoc);
            let s = r || this.flowParseRestrictedIdentifier(!0);
            for (; this.eat(16); ) {
              let a = this.startNodeAt(t, i);
              (a.qualification = s),
                (a.id = this.flowParseRestrictedIdentifier(!0)),
                (s = this.finishNode(a, "QualifiedTypeIdentifier"));
            }
            return s;
          }
          flowParseGenericType(t, i, r) {
            let s = this.startNodeAt(t, i);
            return (
              (s.typeParameters = null),
              (s.id = this.flowParseQualifiedTypeIdentifier(t, i, r)),
              this.match(47) &&
                (s.typeParameters = this.flowParseTypeParameterInstantiation()),
              this.finishNode(s, "GenericTypeAnnotation")
            );
          }
          flowParseTypeofType() {
            let t = this.startNode();
            return (
              this.expect(87),
              (t.argument = this.flowParsePrimaryType()),
              this.finishNode(t, "TypeofTypeAnnotation")
            );
          }
          flowParseTupleType() {
            let t = this.startNode();
            for (
              t.types = [], this.expect(0);
              this.state.pos < this.length &&
              !this.match(3) &&
              (t.types.push(this.flowParseType()), !this.match(3));

            )
              this.expect(12);
            return this.expect(3), this.finishNode(t, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(t) {
            let i = null,
              r = !1,
              s = null,
              a = this.startNode(),
              o = this.lookahead(),
              l = this.state.type === 78;
            return (
              o.type === 14 || o.type === 17
                ? (l && !t && this.raise(Mt.ThisParamMustBeFirst, { at: a }),
                  (i = this.parseIdentifier(l)),
                  this.eat(17) &&
                    ((r = !0),
                    l && this.raise(Mt.ThisParamMayNotBeOptional, { at: a })),
                  (s = this.flowParseTypeInitialiser()))
                : (s = this.flowParseType()),
              (a.name = i),
              (a.optional = r),
              (a.typeAnnotation = s),
              this.finishNode(a, "FunctionTypeParam")
            );
          }
          reinterpretTypeAsFunctionTypeParam(t) {
            let i = this.startNodeAt(t.start, t.loc.start);
            return (
              (i.name = null),
              (i.optional = !1),
              (i.typeAnnotation = t),
              this.finishNode(i, "FunctionTypeParam")
            );
          }
          flowParseFunctionTypeParams(t = []) {
            let i = null,
              r = null;
            for (
              this.match(78) &&
              ((r = this.flowParseFunctionTypeParam(!0)),
              (r.name = null),
              this.match(11) || this.expect(12));
              !this.match(11) && !this.match(21);

            )
              t.push(this.flowParseFunctionTypeParam(!1)),
                this.match(11) || this.expect(12);
            return (
              this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)),
              { params: t, rest: i, _this: r }
            );
          }
          flowIdentToTypeAnnotation(t, i, r, s) {
            switch (s.name) {
              case "any":
                return this.finishNode(r, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(r, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(r, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(r, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(r, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(r, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(r, "SymbolTypeAnnotation");
              default:
                return (
                  this.checkNotUnderscore(s.name),
                  this.flowParseGenericType(t, i, s)
                );
            }
          }
          flowParsePrimaryType() {
            let t = this.state.start,
              i = this.state.startLoc,
              r = this.startNode(),
              s,
              a,
              o = !1,
              l = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({
                  allowStatic: !1,
                  allowExact: !1,
                  allowSpread: !0,
                  allowProto: !1,
                  allowInexact: !0,
                });
              case 6:
                return this.flowParseObjectType({
                  allowStatic: !1,
                  allowExact: !0,
                  allowSpread: !0,
                  allowProto: !1,
                  allowInexact: !1,
                });
              case 0:
                return (
                  (this.state.noAnonFunctionType = !1),
                  (a = this.flowParseTupleType()),
                  (this.state.noAnonFunctionType = l),
                  a
                );
              case 47:
                return (
                  (r.typeParameters = this.flowParseTypeParameterDeclaration()),
                  this.expect(10),
                  (s = this.flowParseFunctionTypeParams()),
                  (r.params = s.params),
                  (r.rest = s.rest),
                  (r.this = s._this),
                  this.expect(11),
                  this.expect(19),
                  (r.returnType = this.flowParseType()),
                  this.finishNode(r, "FunctionTypeAnnotation")
                );
              case 10:
                if ((this.next(), !this.match(11) && !this.match(21)))
                  if (pi(this.state.type) || this.match(78)) {
                    let c = this.lookahead().type;
                    o = c !== 17 && c !== 14;
                  } else o = !0;
                if (o) {
                  if (
                    ((this.state.noAnonFunctionType = !1),
                    (a = this.flowParseType()),
                    (this.state.noAnonFunctionType = l),
                    this.state.noAnonFunctionType ||
                      !(
                        this.match(12) ||
                        (this.match(11) && this.lookahead().type === 19)
                      ))
                  )
                    return this.expect(11), a;
                  this.eat(12);
                }
                return (
                  a
                    ? (s = this.flowParseFunctionTypeParams([
                        this.reinterpretTypeAsFunctionTypeParam(a),
                      ]))
                    : (s = this.flowParseFunctionTypeParams()),
                  (r.params = s.params),
                  (r.rest = s.rest),
                  (r.this = s._this),
                  this.expect(11),
                  this.expect(19),
                  (r.returnType = this.flowParseType()),
                  (r.typeParameters = null),
                  this.finishNode(r, "FunctionTypeAnnotation")
                );
              case 129:
                return this.parseLiteral(
                  this.state.value,
                  "StringLiteralTypeAnnotation"
                );
              case 85:
              case 86:
                return (
                  (r.value = this.match(85)),
                  this.next(),
                  this.finishNode(r, "BooleanLiteralTypeAnnotation")
                );
              case 53:
                if (this.state.value === "-") {
                  if ((this.next(), this.match(130)))
                    return this.parseLiteralAtNode(
                      -this.state.value,
                      "NumberLiteralTypeAnnotation",
                      r
                    );
                  if (this.match(131))
                    return this.parseLiteralAtNode(
                      -this.state.value,
                      "BigIntLiteralTypeAnnotation",
                      r
                    );
                  throw this.raise(Mt.UnexpectedSubtractionOperand, {
                    at: this.state.startLoc,
                  });
                }
                throw this.unexpected();
              case 130:
                return this.parseLiteral(
                  this.state.value,
                  "NumberLiteralTypeAnnotation"
                );
              case 131:
                return this.parseLiteral(
                  this.state.value,
                  "BigIntLiteralTypeAnnotation"
                );
              case 88:
                return this.next(), this.finishNode(r, "VoidTypeAnnotation");
              case 84:
                return (
                  this.next(), this.finishNode(r, "NullLiteralTypeAnnotation")
                );
              case 78:
                return this.next(), this.finishNode(r, "ThisTypeAnnotation");
              case 55:
                return this.next(), this.finishNode(r, "ExistsTypeAnnotation");
              case 87:
                return this.flowParseTypeofType();
              default:
                if (b_(this.state.type)) {
                  let c = So(this.state.type);
                  return this.next(), super.createIdentifier(r, c);
                } else if (pi(this.state.type))
                  return this.isContextual(125)
                    ? this.flowParseInterfaceType()
                    : this.flowIdentToTypeAnnotation(
                        t,
                        i,
                        r,
                        this.parseIdentifier()
                      );
            }
            throw this.unexpected();
          }
          flowParsePostfixType() {
            let t = this.state.start,
              i = this.state.startLoc,
              r = this.flowParsePrimaryType(),
              s = !1;
            for (
              ;
              (this.match(0) || this.match(18)) && !this.canInsertSemicolon();

            ) {
              let a = this.startNodeAt(t, i),
                o = this.eat(18);
              (s = s || o),
                this.expect(0),
                !o && this.match(3)
                  ? ((a.elementType = r),
                    this.next(),
                    (r = this.finishNode(a, "ArrayTypeAnnotation")))
                  : ((a.objectType = r),
                    (a.indexType = this.flowParseType()),
                    this.expect(3),
                    s
                      ? ((a.optional = o),
                        (r = this.finishNode(a, "OptionalIndexedAccessType")))
                      : (r = this.finishNode(a, "IndexedAccessType")));
            }
            return r;
          }
          flowParsePrefixType() {
            let t = this.startNode();
            return this.eat(17)
              ? ((t.typeAnnotation = this.flowParsePrefixType()),
                this.finishNode(t, "NullableTypeAnnotation"))
              : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            let t = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              let i = this.startNodeAt(t.start, t.loc.start);
              return (
                (i.params = [this.reinterpretTypeAsFunctionTypeParam(t)]),
                (i.rest = null),
                (i.this = null),
                (i.returnType = this.flowParseType()),
                (i.typeParameters = null),
                this.finishNode(i, "FunctionTypeAnnotation")
              );
            }
            return t;
          }
          flowParseIntersectionType() {
            let t = this.startNode();
            this.eat(45);
            let i = this.flowParseAnonFunctionWithoutParens();
            for (t.types = [i]; this.eat(45); )
              t.types.push(this.flowParseAnonFunctionWithoutParens());
            return t.types.length === 1
              ? i
              : this.finishNode(t, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            let t = this.startNode();
            this.eat(43);
            let i = this.flowParseIntersectionType();
            for (t.types = [i]; this.eat(43); )
              t.types.push(this.flowParseIntersectionType());
            return t.types.length === 1
              ? i
              : this.finishNode(t, "UnionTypeAnnotation");
          }
          flowParseType() {
            let t = this.state.inType;
            this.state.inType = !0;
            let i = this.flowParseUnionType();
            return (this.state.inType = t), i;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 128 && this.state.value === "_") {
              let t = this.state.start,
                i = this.state.startLoc,
                r = this.parseIdentifier();
              return this.flowParseGenericType(t, i, r);
            } else return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            let t = this.startNode();
            return (
              (t.typeAnnotation = this.flowParseTypeInitialiser()),
              this.finishNode(t, "TypeAnnotation")
            );
          }
          flowParseTypeAnnotatableIdentifier(t) {
            let i = t
              ? this.parseIdentifier()
              : this.flowParseRestrictedIdentifier();
            return (
              this.match(14) &&
                ((i.typeAnnotation = this.flowParseTypeAnnotation()),
                this.resetEndLocation(i)),
              i
            );
          }
          typeCastToParameter(t) {
            return (
              (t.expression.typeAnnotation = t.typeAnnotation),
              this.resetEndLocation(t.expression, t.typeAnnotation.loc.end),
              t.expression
            );
          }
          flowParseVariance() {
            let t = null;
            return this.match(53)
              ? ((t = this.startNode()),
                this.state.value === "+"
                  ? (t.kind = "plus")
                  : (t.kind = "minus"),
                this.next(),
                this.finishNode(t, "Variance"))
              : t;
          }
          parseFunctionBody(t, i, r = !1) {
            return i
              ? this.forwardNoArrowParamsConversionAt(t, () =>
                  super.parseFunctionBody(t, !0, r)
                )
              : super.parseFunctionBody(t, !1, r);
          }
          parseFunctionBodyAndFinish(t, i, r = !1) {
            if (this.match(14)) {
              let s = this.startNode();
              ([s.typeAnnotation, t.predicate] =
                this.flowParseTypeAndPredicateInitialiser()),
                (t.returnType = s.typeAnnotation
                  ? this.finishNode(s, "TypeAnnotation")
                  : null);
            }
            return super.parseFunctionBodyAndFinish(t, i, r);
          }
          parseStatement(t, i) {
            if (this.state.strict && this.isContextual(125)) {
              let s = this.lookahead();
              if (wa(s.type)) {
                let a = this.startNode();
                return this.next(), this.flowParseInterface(a);
              }
            } else if (this.shouldParseEnums() && this.isContextual(122)) {
              let s = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(s);
            }
            let r = super.parseStatement(t, i);
            return (
              this.flowPragma === void 0 &&
                !this.isValidDirective(r) &&
                (this.flowPragma = null),
              r
            );
          }
          parseExpressionStatement(t, i) {
            if (i.type === "Identifier") {
              if (i.name === "declare") {
                if (
                  this.match(80) ||
                  pi(this.state.type) ||
                  this.match(68) ||
                  this.match(74) ||
                  this.match(82)
                )
                  return this.flowParseDeclare(t);
              } else if (pi(this.state.type)) {
                if (i.name === "interface") return this.flowParseInterface(t);
                if (i.name === "type") return this.flowParseTypeAlias(t);
                if (i.name === "opaque") return this.flowParseOpaqueType(t, !1);
              }
            }
            return super.parseExpressionStatement(t, i);
          }
          shouldParseExportDeclaration() {
            let { type: t } = this.state;
            return h2(t) || (this.shouldParseEnums() && t === 122)
              ? !this.state.containsEsc
              : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            let { type: t } = this.state;
            return h2(t) || (this.shouldParseEnums() && t === 122)
              ? this.state.containsEsc
              : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(122)) {
              let t = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(t);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(t, i, r, s) {
            if (!this.match(17)) return t;
            if (this.state.maybeInArrowParameters) {
              let m = this.lookaheadCharCode();
              if (m === 44 || m === 61 || m === 58 || m === 41)
                return this.setOptionalParametersError(s), t;
            }
            this.expect(17);
            let a = this.state.clone(),
              o = this.state.noArrowAt,
              l = this.startNodeAt(i, r),
              { consequent: c, failed: u } =
                this.tryParseConditionalConsequent(),
              [f, d] = this.getArrowLikeExpressions(c);
            if (u || d.length > 0) {
              let m = [...o];
              if (d.length > 0) {
                (this.state = a), (this.state.noArrowAt = m);
                for (let x = 0; x < d.length; x++) m.push(d[x].start);
                ({ consequent: c, failed: u } =
                  this.tryParseConditionalConsequent()),
                  ([f, d] = this.getArrowLikeExpressions(c));
              }
              u &&
                f.length > 1 &&
                this.raise(Mt.AmbiguousConditionalArrow, { at: a.startLoc }),
                u &&
                  f.length === 1 &&
                  ((this.state = a),
                  m.push(f[0].start),
                  (this.state.noArrowAt = m),
                  ({ consequent: c, failed: u } =
                    this.tryParseConditionalConsequent()));
            }
            return (
              this.getArrowLikeExpressions(c, !0),
              (this.state.noArrowAt = o),
              this.expect(14),
              (l.test = t),
              (l.consequent = c),
              (l.alternate = this.forwardNoArrowParamsConversionAt(l, () =>
                this.parseMaybeAssign(void 0, void 0)
              )),
              this.finishNode(l, "ConditionalExpression")
            );
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            let t = this.parseMaybeAssignAllowIn(),
              i = !this.match(14);
            return (
              this.state.noArrowParamsConversionAt.pop(),
              { consequent: t, failed: i }
            );
          }
          getArrowLikeExpressions(t, i) {
            let r = [t],
              s = [];
            for (; r.length !== 0; ) {
              let a = r.pop();
              a.type === "ArrowFunctionExpression"
                ? (a.typeParameters || !a.returnType
                    ? this.finishArrowValidation(a)
                    : s.push(a),
                  r.push(a.body))
                : a.type === "ConditionalExpression" &&
                  (r.push(a.consequent), r.push(a.alternate));
            }
            return i
              ? (s.forEach((a) => this.finishArrowValidation(a)), [s, []])
              : Nq(s, (a) => a.params.every((o) => this.isAssignable(o, !0)));
          }
          finishArrowValidation(t) {
            var i;
            this.toAssignableList(
              t.params,
              (i = t.extra) == null ? void 0 : i.trailingCommaLoc,
              !1
            ),
              this.scope.enter(Ta | T_),
              super.checkParams(t, !1, !0),
              this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(t, i) {
            let r;
            return (
              this.state.noArrowParamsConversionAt.indexOf(t.start) !== -1
                ? (this.state.noArrowParamsConversionAt.push(this.state.start),
                  (r = i()),
                  this.state.noArrowParamsConversionAt.pop())
                : (r = i()),
              r
            );
          }
          parseParenItem(t, i, r) {
            if (
              ((t = super.parseParenItem(t, i, r)),
              this.eat(17) && ((t.optional = !0), this.resetEndLocation(t)),
              this.match(14))
            ) {
              let s = this.startNodeAt(i, r);
              return (
                (s.expression = t),
                (s.typeAnnotation = this.flowParseTypeAnnotation()),
                this.finishNode(s, "TypeCastExpression")
              );
            }
            return t;
          }
          assertModuleNodeAllowed(t) {
            (t.type === "ImportDeclaration" &&
              (t.importKind === "type" || t.importKind === "typeof")) ||
              (t.type === "ExportNamedDeclaration" &&
                t.exportKind === "type") ||
              (t.type === "ExportAllDeclaration" && t.exportKind === "type") ||
              super.assertModuleNodeAllowed(t);
          }
          parseExport(t) {
            let i = super.parseExport(t);
            return (
              (i.type === "ExportNamedDeclaration" ||
                i.type === "ExportAllDeclaration") &&
                (i.exportKind = i.exportKind || "value"),
              i
            );
          }
          parseExportDeclaration(t) {
            if (this.isContextual(126)) {
              t.exportKind = "type";
              let i = this.startNode();
              return (
                this.next(),
                this.match(5)
                  ? ((t.specifiers = this.parseExportSpecifiers(!0)),
                    super.parseExportFrom(t),
                    null)
                  : this.flowParseTypeAlias(i)
              );
            } else if (this.isContextual(127)) {
              t.exportKind = "type";
              let i = this.startNode();
              return this.next(), this.flowParseOpaqueType(i, !1);
            } else if (this.isContextual(125)) {
              t.exportKind = "type";
              let i = this.startNode();
              return this.next(), this.flowParseInterface(i);
            } else if (this.shouldParseEnums() && this.isContextual(122)) {
              t.exportKind = "value";
              let i = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(i);
            } else return super.parseExportDeclaration(t);
          }
          eatExportStar(t) {
            return super.eatExportStar(t)
              ? !0
              : this.isContextual(126) && this.lookahead().type === 55
              ? ((t.exportKind = "type"), this.next(), this.next(), !0)
              : !1;
          }
          maybeParseExportNamespaceSpecifier(t) {
            let { startLoc: i } = this.state,
              r = super.maybeParseExportNamespaceSpecifier(t);
            return r && t.exportKind === "type" && this.unexpected(i), r;
          }
          parseClassId(t, i, r) {
            super.parseClassId(t, i, r),
              this.match(47) &&
                (t.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(t, i, r) {
            let { startLoc: s } = this.state;
            if (this.isContextual(121)) {
              if (super.parseClassMemberFromModifier(t, i)) return;
              i.declare = !0;
            }
            super.parseClassMember(t, i, r),
              i.declare &&
                (i.type !== "ClassProperty" &&
                i.type !== "ClassPrivateProperty" &&
                i.type !== "PropertyDefinition"
                  ? this.raise(Mt.DeclareClassElement, { at: s })
                  : i.value &&
                    this.raise(Mt.DeclareClassFieldInitializer, {
                      at: i.value,
                    }));
          }
          isIterator(t) {
            return t === "iterator" || t === "asyncIterator";
          }
          readIterator() {
            let t = super.readWord1(),
              i = "@@" + t;
            (!this.isIterator(t) || !this.state.inType) &&
              this.raise(ne.InvalidIdentifier, {
                at: this.state.curPosition(),
                identifierName: i,
              }),
              this.finishToken(128, i);
          }
          getTokenFromCode(t) {
            let i = this.input.charCodeAt(this.state.pos + 1);
            return t === 123 && i === 124
              ? this.finishOp(6, 2)
              : this.state.inType && (t === 62 || t === 60)
              ? this.finishOp(t === 62 ? 48 : 47, 1)
              : this.state.inType && t === 63
              ? i === 46
                ? this.finishOp(18, 2)
                : this.finishOp(17, 1)
              : rq(t, i, this.input.charCodeAt(this.state.pos + 2))
              ? ((this.state.pos += 2), this.readIterator())
              : super.getTokenFromCode(t);
          }
          isAssignable(t, i) {
            return t.type === "TypeCastExpression"
              ? this.isAssignable(t.expression, i)
              : super.isAssignable(t, i);
          }
          toAssignable(t, i = !1) {
            !i &&
              t.type === "AssignmentExpression" &&
              t.left.type === "TypeCastExpression" &&
              (t.left = this.typeCastToParameter(t.left)),
              super.toAssignable(t, i);
          }
          toAssignableList(t, i, r) {
            for (let s = 0; s < t.length; s++) {
              let a = t[s];
              (a == null ? void 0 : a.type) === "TypeCastExpression" &&
                (t[s] = this.typeCastToParameter(a));
            }
            super.toAssignableList(t, i, r);
          }
          toReferencedList(t, i) {
            for (let s = 0; s < t.length; s++) {
              var r;
              let a = t[s];
              a &&
                a.type === "TypeCastExpression" &&
                !((r = a.extra) != null && r.parenthesized) &&
                (t.length > 1 || !i) &&
                this.raise(Mt.TypeCastInPattern, { at: a.typeAnnotation });
            }
            return t;
          }
          parseArrayLike(t, i, r, s) {
            let a = super.parseArrayLike(t, i, r, s);
            return (
              i &&
                !this.state.maybeInArrowParameters &&
                this.toReferencedList(a.elements),
              a
            );
          }
          isValidLVal(t, i, r) {
            return t === "TypeCastExpression" || super.isValidLVal(t, i, r);
          }
          parseClassProperty(t) {
            return (
              this.match(14) &&
                (t.typeAnnotation = this.flowParseTypeAnnotation()),
              super.parseClassProperty(t)
            );
          }
          parseClassPrivateProperty(t) {
            return (
              this.match(14) &&
                (t.typeAnnotation = this.flowParseTypeAnnotation()),
              super.parseClassPrivateProperty(t)
            );
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(t) {
            return !this.match(14) && super.isNonstaticConstructor(t);
          }
          pushClassMethod(t, i, r, s, a, o) {
            if (
              (i.variance && this.unexpected(i.variance.loc.start),
              delete i.variance,
              this.match(47) &&
                (i.typeParameters = this.flowParseTypeParameterDeclaration()),
              super.pushClassMethod(t, i, r, s, a, o),
              i.params && a)
            ) {
              let l = i.params;
              l.length > 0 &&
                this.isThisParam(l[0]) &&
                this.raise(Mt.ThisParamBannedInConstructor, { at: i });
            } else if (i.type === "MethodDefinition" && a && i.value.params) {
              let l = i.value.params;
              l.length > 0 &&
                this.isThisParam(l[0]) &&
                this.raise(Mt.ThisParamBannedInConstructor, { at: i });
            }
          }
          pushClassPrivateMethod(t, i, r, s) {
            i.variance && this.unexpected(i.variance.loc.start),
              delete i.variance,
              this.match(47) &&
                (i.typeParameters = this.flowParseTypeParameterDeclaration()),
              super.pushClassPrivateMethod(t, i, r, s);
          }
          parseClassSuper(t) {
            if (
              (super.parseClassSuper(t),
              t.superClass &&
                this.match(47) &&
                (t.superTypeParameters =
                  this.flowParseTypeParameterInstantiation()),
              this.isContextual(110))
            ) {
              this.next();
              let i = (t.implements = []);
              do {
                let r = this.startNode();
                (r.id = this.flowParseRestrictedIdentifier(!0)),
                  this.match(47)
                    ? (r.typeParameters =
                        this.flowParseTypeParameterInstantiation())
                    : (r.typeParameters = null),
                  i.push(this.finishNode(r, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(t) {
            super.checkGetterSetterParams(t);
            let i = this.getObjectOrClassMethodParams(t);
            if (i.length > 0) {
              let r = i[0];
              this.isThisParam(r) && t.kind === "get"
                ? this.raise(Mt.GetterMayNotHaveThisParam, { at: r })
                : this.isThisParam(r) &&
                  this.raise(Mt.SetterMayNotHaveThisParam, { at: r });
            }
          }
          parsePropertyNamePrefixOperator(t) {
            t.variance = this.flowParseVariance();
          }
          parseObjPropValue(t, i, r, s, a, o, l, c) {
            t.variance && this.unexpected(t.variance.loc.start),
              delete t.variance;
            let u;
            this.match(47) &&
              !l &&
              ((u = this.flowParseTypeParameterDeclaration()),
              this.match(10) || this.unexpected());
            let f = super.parseObjPropValue(t, i, r, s, a, o, l, c);
            return u && ((f.value || f).typeParameters = u), f;
          }
          parseAssignableListItemTypes(t) {
            return (
              this.eat(17) &&
                (t.type !== "Identifier" &&
                  this.raise(Mt.PatternIsOptional, { at: t }),
                this.isThisParam(t) &&
                  this.raise(Mt.ThisParamMayNotBeOptional, { at: t }),
                (t.optional = !0)),
              this.match(14)
                ? (t.typeAnnotation = this.flowParseTypeAnnotation())
                : this.isThisParam(t) &&
                  this.raise(Mt.ThisParamAnnotationRequired, { at: t }),
              this.match(29) &&
                this.isThisParam(t) &&
                this.raise(Mt.ThisParamNoDefault, { at: t }),
              this.resetEndLocation(t),
              t
            );
          }
          parseMaybeDefault(t, i, r) {
            let s = super.parseMaybeDefault(t, i, r);
            return (
              s.type === "AssignmentPattern" &&
                s.typeAnnotation &&
                s.right.start < s.typeAnnotation.start &&
                this.raise(Mt.TypeBeforeInitializer, { at: s.typeAnnotation }),
              s
            );
          }
          shouldParseDefaultImport(t) {
            return e_(t)
              ? g2(this.state.type)
              : super.shouldParseDefaultImport(t);
          }
          parseImportSpecifierLocal(t, i, r) {
            (i.local = e_(t)
              ? this.flowParseRestrictedIdentifier(!0, !0)
              : this.parseIdentifier()),
              t.specifiers.push(this.finishImportSpecifier(i, r));
          }
          maybeParseDefaultImportSpecifier(t) {
            t.importKind = "value";
            let i = null;
            if (
              (this.match(87)
                ? (i = "typeof")
                : this.isContextual(126) && (i = "type"),
              i)
            ) {
              let r = this.lookahead(),
                { type: s } = r;
              i === "type" && s === 55 && this.unexpected(null, r.type),
                (g2(s) || s === 5 || s === 55) &&
                  (this.next(), (t.importKind = i));
            }
            return super.maybeParseDefaultImportSpecifier(t);
          }
          parseImportSpecifier(t, i, r, s) {
            let a = t.imported,
              o = null;
            a.type === "Identifier" &&
              (a.name === "type"
                ? (o = "type")
                : a.name === "typeof" && (o = "typeof"));
            let l = !1;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
              let u = this.parseIdentifier(!0);
              o !== null && !wa(this.state.type)
                ? ((t.imported = u), (t.importKind = o), (t.local = Ma(u)))
                : ((t.imported = a),
                  (t.importKind = null),
                  (t.local = this.parseIdentifier()));
            } else {
              if (o !== null && wa(this.state.type))
                (t.imported = this.parseIdentifier(!0)), (t.importKind = o);
              else {
                if (i)
                  throw this.raise(ne.ImportBindingIsString, {
                    at: t,
                    importName: a.value,
                  });
                (t.imported = a), (t.importKind = null);
              }
              this.eatContextual(93)
                ? (t.local = this.parseIdentifier())
                : ((l = !0), (t.local = Ma(t.imported)));
            }
            let c = e_(t);
            return (
              r &&
                c &&
                this.raise(Mt.ImportTypeShorthandOnlyInPureImport, { at: t }),
              (r || c) &&
                this.checkReservedType(t.local.name, t.local.loc.start, !0),
              l &&
                !r &&
                !c &&
                this.checkReservedWord(t.local.name, t.loc.start, !0, !0),
              this.finishImportSpecifier(t, "ImportSpecifier")
            );
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 78:
                return this.parseIdentifier(!0);
              default:
                return super.parseBindingAtom();
            }
          }
          parseFunctionParams(t, i) {
            let r = t.kind;
            r !== "get" &&
              r !== "set" &&
              this.match(47) &&
              (t.typeParameters = this.flowParseTypeParameterDeclaration()),
              super.parseFunctionParams(t, i);
          }
          parseVarId(t, i) {
            super.parseVarId(t, i),
              this.match(14) &&
                ((t.id.typeAnnotation = this.flowParseTypeAnnotation()),
                this.resetEndLocation(t.id));
          }
          parseAsyncArrowFromCallExpression(t, i) {
            if (this.match(14)) {
              let r = this.state.noAnonFunctionType;
              (this.state.noAnonFunctionType = !0),
                (t.returnType = this.flowParseTypeAnnotation()),
                (this.state.noAnonFunctionType = r);
            }
            return super.parseAsyncArrowFromCallExpression(t, i);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(t, i) {
            var r;
            let s = null,
              a;
            if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
              if (
                ((s = this.state.clone()),
                (a = this.tryParse(() => super.parseMaybeAssign(t, i), s)),
                !a.error)
              )
                return a.node;
              let { context: c } = this.state,
                u = c[c.length - 1];
              (u === Si.j_oTag || u === Si.j_expr) && c.pop();
            }
            if (((r = a) != null && r.error) || this.match(47)) {
              var o, l;
              s = s || this.state.clone();
              let c,
                u = this.tryParse((d) => {
                  var m;
                  c = this.flowParseTypeParameterDeclaration();
                  let x = this.forwardNoArrowParamsConversionAt(c, () => {
                    let g = super.parseMaybeAssign(t, i);
                    return this.resetStartLocationFromNode(g, c), g;
                  });
                  (m = x.extra) != null && m.parenthesized && d();
                  let y = this.maybeUnwrapTypeCastExpression(x);
                  return (
                    y.type !== "ArrowFunctionExpression" && d(),
                    (y.typeParameters = c),
                    this.resetStartLocationFromNode(y, c),
                    x
                  );
                }, s),
                f = null;
              if (
                u.node &&
                this.maybeUnwrapTypeCastExpression(u.node).type ===
                  "ArrowFunctionExpression"
              ) {
                if (!u.error && !u.aborted)
                  return (
                    u.node.async &&
                      this.raise(
                        Mt.UnexpectedTypeParameterBeforeAsyncArrowFunction,
                        { at: c }
                      ),
                    u.node
                  );
                f = u.node;
              }
              if ((o = a) != null && o.node)
                return (this.state = a.failState), a.node;
              if (f) return (this.state = u.failState), f;
              throw (l = a) != null && l.thrown
                ? a.error
                : u.thrown
                ? u.error
                : this.raise(Mt.UnexpectedTokenAfterTypeParameter, { at: c });
            }
            return super.parseMaybeAssign(t, i);
          }
          parseArrow(t) {
            if (this.match(14)) {
              let i = this.tryParse(() => {
                let r = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = !0;
                let s = this.startNode();
                return (
                  ([s.typeAnnotation, t.predicate] =
                    this.flowParseTypeAndPredicateInitialiser()),
                  (this.state.noAnonFunctionType = r),
                  this.canInsertSemicolon() && this.unexpected(),
                  this.match(19) || this.unexpected(),
                  s
                );
              });
              if (i.thrown) return null;
              i.error && (this.state = i.failState),
                (t.returnType = i.node.typeAnnotation
                  ? this.finishNode(i.node, "TypeAnnotation")
                  : null);
            }
            return super.parseArrow(t);
          }
          shouldParseArrow(t) {
            return this.match(14) || super.shouldParseArrow(t);
          }
          setArrowFunctionParameters(t, i) {
            this.state.noArrowParamsConversionAt.indexOf(t.start) !== -1
              ? (t.params = i)
              : super.setArrowFunctionParameters(t, i);
          }
          checkParams(t, i, r, s = !0) {
            if (
              !(
                r &&
                this.state.noArrowParamsConversionAt.indexOf(t.start) !== -1
              )
            ) {
              for (let a = 0; a < t.params.length; a++)
                this.isThisParam(t.params[a]) &&
                  a > 0 &&
                  this.raise(Mt.ThisParamMustBeFirst, { at: t.params[a] });
              return super.checkParams(t, i, r, s);
            }
          }
          parseParenAndDistinguishExpression(t) {
            return super.parseParenAndDistinguishExpression(
              t && this.state.noArrowAt.indexOf(this.state.start) === -1
            );
          }
          parseSubscripts(t, i, r, s) {
            if (
              t.type === "Identifier" &&
              t.name === "async" &&
              this.state.noArrowAt.indexOf(i) !== -1
            ) {
              this.next();
              let a = this.startNodeAt(i, r);
              (a.callee = t),
                (a.arguments = super.parseCallExpressionArguments(11, !1)),
                (t = this.finishNode(a, "CallExpression"));
            } else if (
              t.type === "Identifier" &&
              t.name === "async" &&
              this.match(47)
            ) {
              let a = this.state.clone(),
                o = this.tryParse(
                  (c) => this.parseAsyncArrowWithTypeParameters(i, r) || c(),
                  a
                );
              if (!o.error && !o.aborted) return o.node;
              let l = this.tryParse(() => super.parseSubscripts(t, i, r, s), a);
              if (l.node && !l.error) return l.node;
              if (o.node) return (this.state = o.failState), o.node;
              if (l.node) return (this.state = l.failState), l.node;
              throw o.error || l.error;
            }
            return super.parseSubscripts(t, i, r, s);
          }
          parseSubscript(t, i, r, s, a) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (((a.optionalChainMember = !0), s)) return (a.stop = !0), t;
              this.next();
              let o = this.startNodeAt(i, r);
              return (
                (o.callee = t),
                (o.typeArguments = this.flowParseTypeParameterInstantiation()),
                this.expect(10),
                (o.arguments = this.parseCallExpressionArguments(11, !1)),
                (o.optional = !0),
                this.finishCallExpression(o, !0)
              );
            } else if (!s && this.shouldParseTypes() && this.match(47)) {
              let o = this.startNodeAt(i, r);
              o.callee = t;
              let l = this.tryParse(
                () => (
                  (o.typeArguments =
                    this.flowParseTypeParameterInstantiationCallOrNew()),
                  this.expect(10),
                  (o.arguments = super.parseCallExpressionArguments(11, !1)),
                  a.optionalChainMember && (o.optional = !1),
                  this.finishCallExpression(o, a.optionalChainMember)
                )
              );
              if (l.node) return l.error && (this.state = l.failState), l.node;
            }
            return super.parseSubscript(t, i, r, s, a);
          }
          parseNewCallee(t) {
            super.parseNewCallee(t);
            let i = null;
            this.shouldParseTypes() &&
              this.match(47) &&
              (i = this.tryParse(() =>
                this.flowParseTypeParameterInstantiationCallOrNew()
              ).node),
              (t.typeArguments = i);
          }
          parseAsyncArrowWithTypeParameters(t, i) {
            let r = this.startNodeAt(t, i);
            if ((this.parseFunctionParams(r), !!this.parseArrow(r)))
              return super.parseArrowExpression(r, void 0, !0);
          }
          readToken_mult_modulo(t) {
            let i = this.input.charCodeAt(this.state.pos + 1);
            if (t === 42 && i === 47 && this.state.hasFlowComment) {
              (this.state.hasFlowComment = !1),
                (this.state.pos += 2),
                this.nextToken();
              return;
            }
            super.readToken_mult_modulo(t);
          }
          readToken_pipe_amp(t) {
            let i = this.input.charCodeAt(this.state.pos + 1);
            if (t === 124 && i === 125) {
              this.finishOp(9, 2);
              return;
            }
            super.readToken_pipe_amp(t);
          }
          parseTopLevel(t, i) {
            let r = super.parseTopLevel(t, i);
            return (
              this.state.hasFlowComment &&
                this.raise(Mt.UnterminatedFlowComment, {
                  at: this.state.curPosition(),
                }),
              r
            );
          }
          skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
              if (this.state.hasFlowComment)
                throw this.raise(Mt.NestedFlowComment, {
                  at: this.state.startLoc,
                });
              this.hasFlowCommentCompletion();
              let t = this.skipFlowComment();
              t && ((this.state.pos += t), (this.state.hasFlowComment = !0));
              return;
            }
            if (this.state.hasFlowComment) {
              let t = this.input.indexOf("*-/", this.state.pos + 2);
              if (t === -1)
                throw this.raise(ne.UnterminatedComment, {
                  at: this.state.curPosition(),
                });
              this.state.pos = t + 2 + 3;
              return;
            }
            return super.skipBlockComment();
          }
          skipFlowComment() {
            let { pos: t } = this.state,
              i = 2;
            for (; [32, 9].includes(this.input.charCodeAt(t + i)); ) i++;
            let r = this.input.charCodeAt(i + t),
              s = this.input.charCodeAt(i + t + 1);
            return r === 58 && s === 58
              ? i + 2
              : this.input.slice(i + t, i + t + 12) === "flow-include"
              ? i + 12
              : r === 58 && s !== 58
              ? i
              : !1;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf("*/", this.state.pos) === -1)
              throw this.raise(ne.UnterminatedComment, {
                at: this.state.curPosition(),
              });
          }
          flowEnumErrorBooleanMemberNotInitialized(
            t,
            { enumName: i, memberName: r }
          ) {
            this.raise(Mt.EnumBooleanMemberNotInitialized, {
              at: t,
              memberName: r,
              enumName: i,
            });
          }
          flowEnumErrorInvalidMemberInitializer(t, i) {
            return this.raise(
              i.explicitType
                ? i.explicitType === "symbol"
                  ? Mt.EnumInvalidMemberInitializerSymbolType
                  : Mt.EnumInvalidMemberInitializerPrimaryType
                : Mt.EnumInvalidMemberInitializerUnknownType,
              Object.assign({ at: t }, i)
            );
          }
          flowEnumErrorNumberMemberNotInitialized(
            t,
            { enumName: i, memberName: r }
          ) {
            this.raise(Mt.EnumNumberMemberNotInitialized, {
              at: t,
              enumName: i,
              memberName: r,
            });
          }
          flowEnumErrorStringMemberInconsistentlyInitailized(
            t,
            { enumName: i }
          ) {
            this.raise(Mt.EnumStringMemberInconsistentlyInitailized, {
              at: t,
              enumName: i,
            });
          }
          flowEnumMemberInit() {
            let t = this.state.startLoc,
              i = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 130: {
                let r = this.parseNumericLiteral(this.state.value);
                return i()
                  ? { type: "number", loc: r.loc.start, value: r }
                  : { type: "invalid", loc: t };
              }
              case 129: {
                let r = this.parseStringLiteral(this.state.value);
                return i()
                  ? { type: "string", loc: r.loc.start, value: r }
                  : { type: "invalid", loc: t };
              }
              case 85:
              case 86: {
                let r = this.parseBooleanLiteral(this.match(85));
                return i()
                  ? { type: "boolean", loc: r.loc.start, value: r }
                  : { type: "invalid", loc: t };
              }
              default:
                return { type: "invalid", loc: t };
            }
          }
          flowEnumMemberRaw() {
            let t = this.state.startLoc,
              i = this.parseIdentifier(!0),
              r = this.eat(29)
                ? this.flowEnumMemberInit()
                : { type: "none", loc: t };
            return { id: i, init: r };
          }
          flowEnumCheckExplicitTypeMismatch(t, i, r) {
            let { explicitType: s } = i;
            s !== null &&
              s !== r &&
              this.flowEnumErrorInvalidMemberInitializer(t, i);
          }
          flowEnumMembers({ enumName: t, explicitType: i }) {
            let r = new Set(),
              s = {
                booleanMembers: [],
                numberMembers: [],
                stringMembers: [],
                defaultedMembers: [],
              },
              a = !1;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                a = !0;
                break;
              }
              let o = this.startNode(),
                { id: l, init: c } = this.flowEnumMemberRaw(),
                u = l.name;
              if (u === "") continue;
              /^[a-z]/.test(u) &&
                this.raise(Mt.EnumInvalidMemberName, {
                  at: l,
                  memberName: u,
                  suggestion: u[0].toUpperCase() + u.slice(1),
                  enumName: t,
                }),
                r.has(u) &&
                  this.raise(Mt.EnumDuplicateMemberName, {
                    at: l,
                    memberName: u,
                    enumName: t,
                  }),
                r.add(u);
              let f = { enumName: t, explicitType: i, memberName: u };
              switch (((o.id = l), c.type)) {
                case "boolean": {
                  this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "boolean"),
                    (o.init = c.value),
                    s.booleanMembers.push(
                      this.finishNode(o, "EnumBooleanMember")
                    );
                  break;
                }
                case "number": {
                  this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "number"),
                    (o.init = c.value),
                    s.numberMembers.push(
                      this.finishNode(o, "EnumNumberMember")
                    );
                  break;
                }
                case "string": {
                  this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "string"),
                    (o.init = c.value),
                    s.stringMembers.push(
                      this.finishNode(o, "EnumStringMember")
                    );
                  break;
                }
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(c.loc, f);
                case "none":
                  switch (i) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(c.loc, f);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(c.loc, f);
                      break;
                    default:
                      s.defaultedMembers.push(
                        this.finishNode(o, "EnumDefaultedMember")
                      );
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: s, hasUnknownMembers: a };
          }
          flowEnumStringMembers(t, i, { enumName: r }) {
            if (t.length === 0) return i;
            if (i.length === 0) return t;
            if (i.length > t.length) {
              for (let s of t)
                this.flowEnumErrorStringMemberInconsistentlyInitailized(s, {
                  enumName: r,
                });
              return i;
            } else {
              for (let s of i)
                this.flowEnumErrorStringMemberInconsistentlyInitailized(s, {
                  enumName: r,
                });
              return t;
            }
          }
          flowEnumParseExplicitType({ enumName: t }) {
            if (!this.eatContextual(101)) return null;
            if (!pi(this.state.type))
              throw this.raise(Mt.EnumInvalidExplicitTypeUnknownSupplied, {
                at: this.state.startLoc,
                enumName: t,
              });
            let { value: i } = this.state;
            return (
              this.next(),
              i !== "boolean" &&
                i !== "number" &&
                i !== "string" &&
                i !== "symbol" &&
                this.raise(Mt.EnumInvalidExplicitType, {
                  at: this.state.startLoc,
                  enumName: t,
                  invalidEnumType: i,
                }),
              i
            );
          }
          flowEnumBody(t, i) {
            let r = i.name,
              s = i.loc.start,
              a = this.flowEnumParseExplicitType({ enumName: r });
            this.expect(5);
            let { members: o, hasUnknownMembers: l } = this.flowEnumMembers({
              enumName: r,
              explicitType: a,
            });
            switch (((t.hasUnknownMembers = l), a)) {
              case "boolean":
                return (
                  (t.explicitType = !0),
                  (t.members = o.booleanMembers),
                  this.expect(8),
                  this.finishNode(t, "EnumBooleanBody")
                );
              case "number":
                return (
                  (t.explicitType = !0),
                  (t.members = o.numberMembers),
                  this.expect(8),
                  this.finishNode(t, "EnumNumberBody")
                );
              case "string":
                return (
                  (t.explicitType = !0),
                  (t.members = this.flowEnumStringMembers(
                    o.stringMembers,
                    o.defaultedMembers,
                    { enumName: r }
                  )),
                  this.expect(8),
                  this.finishNode(t, "EnumStringBody")
                );
              case "symbol":
                return (
                  (t.members = o.defaultedMembers),
                  this.expect(8),
                  this.finishNode(t, "EnumSymbolBody")
                );
              default: {
                let c = () => (
                  (t.members = []),
                  this.expect(8),
                  this.finishNode(t, "EnumStringBody")
                );
                t.explicitType = !1;
                let u = o.booleanMembers.length,
                  f = o.numberMembers.length,
                  d = o.stringMembers.length,
                  m = o.defaultedMembers.length;
                if (!u && !f && !d && !m) return c();
                if (!u && !f)
                  return (
                    (t.members = this.flowEnumStringMembers(
                      o.stringMembers,
                      o.defaultedMembers,
                      { enumName: r }
                    )),
                    this.expect(8),
                    this.finishNode(t, "EnumStringBody")
                  );
                if (!f && !d && u >= m) {
                  for (let x of o.defaultedMembers)
                    this.flowEnumErrorBooleanMemberNotInitialized(x.loc.start, {
                      enumName: r,
                      memberName: x.id.name,
                    });
                  return (
                    (t.members = o.booleanMembers),
                    this.expect(8),
                    this.finishNode(t, "EnumBooleanBody")
                  );
                } else if (!u && !d && f >= m) {
                  for (let x of o.defaultedMembers)
                    this.flowEnumErrorNumberMemberNotInitialized(x.loc.start, {
                      enumName: r,
                      memberName: x.id.name,
                    });
                  return (
                    (t.members = o.numberMembers),
                    this.expect(8),
                    this.finishNode(t, "EnumNumberBody")
                  );
                } else
                  return (
                    this.raise(Mt.EnumInconsistentMemberValues, {
                      at: s,
                      enumName: r,
                    }),
                    c()
                  );
              }
            }
          }
          flowParseEnumDeclaration(t) {
            let i = this.parseIdentifier();
            return (
              (t.id = i),
              (t.body = this.flowEnumBody(this.startNode(), i)),
              this.finishNode(t, "EnumDeclaration")
            );
          }
          isLookaheadToken_lt() {
            let t = this.nextTokenStart();
            if (this.input.charCodeAt(t) === 60) {
              let i = this.input.charCodeAt(t + 1);
              return i !== 60 && i !== 61;
            }
            return !1;
          }
          maybeUnwrapTypeCastExpression(t) {
            return t.type === "TypeCastExpression" ? t.expression : t;
          }
        },
      Bq = {
        __proto__: null,
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        iexcl: "\xA1",
        cent: "\xA2",
        pound: "\xA3",
        curren: "\xA4",
        yen: "\xA5",
        brvbar: "\xA6",
        sect: "\xA7",
        uml: "\xA8",
        copy: "\xA9",
        ordf: "\xAA",
        laquo: "\xAB",
        not: "\xAC",
        shy: "\xAD",
        reg: "\xAE",
        macr: "\xAF",
        deg: "\xB0",
        plusmn: "\xB1",
        sup2: "\xB2",
        sup3: "\xB3",
        acute: "\xB4",
        micro: "\xB5",
        para: "\xB6",
        middot: "\xB7",
        cedil: "\xB8",
        sup1: "\xB9",
        ordm: "\xBA",
        raquo: "\xBB",
        frac14: "\xBC",
        frac12: "\xBD",
        frac34: "\xBE",
        iquest: "\xBF",
        Agrave: "\xC0",
        Aacute: "\xC1",
        Acirc: "\xC2",
        Atilde: "\xC3",
        Auml: "\xC4",
        Aring: "\xC5",
        AElig: "\xC6",
        Ccedil: "\xC7",
        Egrave: "\xC8",
        Eacute: "\xC9",
        Ecirc: "\xCA",
        Euml: "\xCB",
        Igrave: "\xCC",
        Iacute: "\xCD",
        Icirc: "\xCE",
        Iuml: "\xCF",
        ETH: "\xD0",
        Ntilde: "\xD1",
        Ograve: "\xD2",
        Oacute: "\xD3",
        Ocirc: "\xD4",
        Otilde: "\xD5",
        Ouml: "\xD6",
        times: "\xD7",
        Oslash: "\xD8",
        Ugrave: "\xD9",
        Uacute: "\xDA",
        Ucirc: "\xDB",
        Uuml: "\xDC",
        Yacute: "\xDD",
        THORN: "\xDE",
        szlig: "\xDF",
        agrave: "\xE0",
        aacute: "\xE1",
        acirc: "\xE2",
        atilde: "\xE3",
        auml: "\xE4",
        aring: "\xE5",
        aelig: "\xE6",
        ccedil: "\xE7",
        egrave: "\xE8",
        eacute: "\xE9",
        ecirc: "\xEA",
        euml: "\xEB",
        igrave: "\xEC",
        iacute: "\xED",
        icirc: "\xEE",
        iuml: "\xEF",
        eth: "\xF0",
        ntilde: "\xF1",
        ograve: "\xF2",
        oacute: "\xF3",
        ocirc: "\xF4",
        otilde: "\xF5",
        ouml: "\xF6",
        divide: "\xF7",
        oslash: "\xF8",
        ugrave: "\xF9",
        uacute: "\xFA",
        ucirc: "\xFB",
        uuml: "\xFC",
        yacute: "\xFD",
        thorn: "\xFE",
        yuml: "\xFF",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        fnof: "\u0192",
        circ: "\u02C6",
        tilde: "\u02DC",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039A",
        Lambda: "\u039B",
        Mu: "\u039C",
        Nu: "\u039D",
        Xi: "\u039E",
        Omicron: "\u039F",
        Pi: "\u03A0",
        Rho: "\u03A1",
        Sigma: "\u03A3",
        Tau: "\u03A4",
        Upsilon: "\u03A5",
        Phi: "\u03A6",
        Chi: "\u03A7",
        Psi: "\u03A8",
        Omega: "\u03A9",
        alpha: "\u03B1",
        beta: "\u03B2",
        gamma: "\u03B3",
        delta: "\u03B4",
        epsilon: "\u03B5",
        zeta: "\u03B6",
        eta: "\u03B7",
        theta: "\u03B8",
        iota: "\u03B9",
        kappa: "\u03BA",
        lambda: "\u03BB",
        mu: "\u03BC",
        nu: "\u03BD",
        xi: "\u03BE",
        omicron: "\u03BF",
        pi: "\u03C0",
        rho: "\u03C1",
        sigmaf: "\u03C2",
        sigma: "\u03C3",
        tau: "\u03C4",
        upsilon: "\u03C5",
        phi: "\u03C6",
        chi: "\u03C7",
        psi: "\u03C8",
        omega: "\u03C9",
        thetasym: "\u03D1",
        upsih: "\u03D2",
        piv: "\u03D6",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200C",
        zwj: "\u200D",
        lrm: "\u200E",
        rlm: "\u200F",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201A",
        ldquo: "\u201C",
        rdquo: "\u201D",
        bdquo: "\u201E",
        dagger: "\u2020",
        Dagger: "\u2021",
        bull: "\u2022",
        hellip: "\u2026",
        permil: "\u2030",
        prime: "\u2032",
        Prime: "\u2033",
        lsaquo: "\u2039",
        rsaquo: "\u203A",
        oline: "\u203E",
        frasl: "\u2044",
        euro: "\u20AC",
        image: "\u2111",
        weierp: "\u2118",
        real: "\u211C",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21B5",
        lArr: "\u21D0",
        uArr: "\u21D1",
        rArr: "\u21D2",
        dArr: "\u21D3",
        hArr: "\u21D4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220B",
        prod: "\u220F",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221A",
        prop: "\u221D",
        infin: "\u221E",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222A",
        int: "\u222B",
        there4: "\u2234",
        sim: "\u223C",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22A5",
        sdot: "\u22C5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230A",
        rfloor: "\u230B",
        lang: "\u2329",
        rang: "\u232A",
        loz: "\u25CA",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666",
      },
      Ml = Ea`jsx`({
        AttributeIsEmpty:
          "JSX attributes must only be assigned a non-empty expression.",
        MissingClosingTagElement: ({ openingTagName: n }) =>
          `Expected corresponding JSX closing tag for <${n}>.`,
        MissingClosingTagFragment:
          "Expected corresponding JSX closing tag for <>.",
        UnexpectedSequenceExpression:
          "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
        UnexpectedToken: ({ unexpected: n, HTMLEntity: e }) =>
          `Unexpected token \`${n}\`. Did you mean \`${e}\` or \`{'${n}'}\`?`,
        UnsupportedJsxValue:
          "JSX value should be either an expression or a quoted JSX text.",
        UnterminatedJsxContent: "Unterminated JSX contents.",
        UnwrappedAdjacentJSXElements:
          "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?",
      });
    function To(n) {
      return n
        ? n.type === "JSXOpeningFragment" || n.type === "JSXClosingFragment"
        : !1;
    }
    function Qc(n) {
      if (n.type === "JSXIdentifier") return n.name;
      if (n.type === "JSXNamespacedName")
        return n.namespace.name + ":" + n.name.name;
      if (n.type === "JSXMemberExpression")
        return Qc(n.object) + "." + Qc(n.property);
      throw new Error("Node had unexpected type: " + n.type);
    }
    var zq = (n) =>
        class extends n {
          jsxReadToken() {
            let t = "",
              i = this.state.pos;
            for (;;) {
              if (this.state.pos >= this.length)
                throw this.raise(Ml.UnterminatedJsxContent, {
                  at: this.state.startLoc,
                });
              let r = this.input.charCodeAt(this.state.pos);
              switch (r) {
                case 60:
                case 123:
                  return this.state.pos === this.state.start
                    ? r === 60 && this.state.canStartJSXElement
                      ? (++this.state.pos, this.finishToken(138))
                      : super.getTokenFromCode(r)
                    : ((t += this.input.slice(i, this.state.pos)),
                      this.finishToken(137, t));
                case 38:
                  (t += this.input.slice(i, this.state.pos)),
                    (t += this.jsxReadEntity()),
                    (i = this.state.pos);
                  break;
                case 62:
                case 125:
                default:
                  ff(r)
                    ? ((t += this.input.slice(i, this.state.pos)),
                      (t += this.jsxReadNewLine(!0)),
                      (i = this.state.pos))
                    : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(t) {
            let i = this.input.charCodeAt(this.state.pos),
              r;
            return (
              ++this.state.pos,
              i === 13 && this.input.charCodeAt(this.state.pos) === 10
                ? (++this.state.pos,
                  (r = t
                    ? `
`
                    : `\r
`))
                : (r = String.fromCharCode(i)),
              ++this.state.curLine,
              (this.state.lineStart = this.state.pos),
              r
            );
          }
          jsxReadString(t) {
            let i = "",
              r = ++this.state.pos;
            for (;;) {
              if (this.state.pos >= this.length)
                throw this.raise(ne.UnterminatedString, {
                  at: this.state.startLoc,
                });
              let s = this.input.charCodeAt(this.state.pos);
              if (s === t) break;
              s === 38
                ? ((i += this.input.slice(r, this.state.pos)),
                  (i += this.jsxReadEntity()),
                  (r = this.state.pos))
                : ff(s)
                ? ((i += this.input.slice(r, this.state.pos)),
                  (i += this.jsxReadNewLine(!1)),
                  (r = this.state.pos))
                : ++this.state.pos;
            }
            return (
              (i += this.input.slice(r, this.state.pos++)),
              this.finishToken(129, i)
            );
          }
          jsxReadEntity() {
            let t = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
              ++this.state.pos;
              let i = 10;
              this.codePointAtPos(this.state.pos) === 120 &&
                ((i = 16), ++this.state.pos);
              let r = this.readInt(i, void 0, !1, "bail");
              if (r !== null && this.codePointAtPos(this.state.pos) === 59)
                return ++this.state.pos, String.fromCodePoint(r);
            } else {
              let i = 0,
                r = !1;
              for (
                ;
                i++ < 10 &&
                this.state.pos < this.length &&
                !(r = this.codePointAtPos(this.state.pos) == 59);

              )
                ++this.state.pos;
              if (r) {
                let s = this.input.slice(t, this.state.pos),
                  a = Bq[s];
                if ((++this.state.pos, a)) return a;
              }
            }
            return (this.state.pos = t), "&";
          }
          jsxReadWord() {
            let t,
              i = this.state.pos;
            do t = this.input.charCodeAt(++this.state.pos);
            while (eu(t) || t === 45);
            return this.finishToken(136, this.input.slice(i, this.state.pos));
          }
          jsxParseIdentifier() {
            let t = this.startNode();
            return (
              this.match(136)
                ? (t.name = this.state.value)
                : b_(this.state.type)
                ? (t.name = So(this.state.type))
                : this.unexpected(),
              this.next(),
              this.finishNode(t, "JSXIdentifier")
            );
          }
          jsxParseNamespacedName() {
            let t = this.state.start,
              i = this.state.startLoc,
              r = this.jsxParseIdentifier();
            if (!this.eat(14)) return r;
            let s = this.startNodeAt(t, i);
            return (
              (s.namespace = r),
              (s.name = this.jsxParseIdentifier()),
              this.finishNode(s, "JSXNamespacedName")
            );
          }
          jsxParseElementName() {
            let t = this.state.start,
              i = this.state.startLoc,
              r = this.jsxParseNamespacedName();
            if (r.type === "JSXNamespacedName") return r;
            for (; this.eat(16); ) {
              let s = this.startNodeAt(t, i);
              (s.object = r),
                (s.property = this.jsxParseIdentifier()),
                (r = this.finishNode(s, "JSXMemberExpression"));
            }
            return r;
          }
          jsxParseAttributeValue() {
            let t;
            switch (this.state.type) {
              case 5:
                return (
                  (t = this.startNode()),
                  this.setContext(Si.brace),
                  this.next(),
                  (t = this.jsxParseExpressionContainer(t, Si.j_oTag)),
                  t.expression.type === "JSXEmptyExpression" &&
                    this.raise(Ml.AttributeIsEmpty, { at: t }),
                  t
                );
              case 138:
              case 129:
                return this.parseExprAtom();
              default:
                throw this.raise(Ml.UnsupportedJsxValue, {
                  at: this.state.startLoc,
                });
            }
          }
          jsxParseEmptyExpression() {
            let t = this.startNodeAt(
              this.state.lastTokEndLoc.index,
              this.state.lastTokEndLoc
            );
            return this.finishNodeAt(
              t,
              "JSXEmptyExpression",
              this.state.startLoc
            );
          }
          jsxParseSpreadChild(t) {
            return (
              this.next(),
              (t.expression = this.parseExpression()),
              this.setContext(Si.j_oTag),
              (this.state.canStartJSXElement = !0),
              this.expect(8),
              this.finishNode(t, "JSXSpreadChild")
            );
          }
          jsxParseExpressionContainer(t, i) {
            if (this.match(8)) t.expression = this.jsxParseEmptyExpression();
            else {
              let r = this.parseExpression();
              t.expression = r;
            }
            return (
              this.setContext(i),
              (this.state.canStartJSXElement = !0),
              this.expect(8),
              this.finishNode(t, "JSXExpressionContainer")
            );
          }
          jsxParseAttribute() {
            let t = this.startNode();
            return this.match(5)
              ? (this.setContext(Si.brace),
                this.next(),
                this.expect(21),
                (t.argument = this.parseMaybeAssignAllowIn()),
                this.setContext(Si.j_oTag),
                (this.state.canStartJSXElement = !0),
                this.expect(8),
                this.finishNode(t, "JSXSpreadAttribute"))
              : ((t.name = this.jsxParseNamespacedName()),
                (t.value = this.eat(29) ? this.jsxParseAttributeValue() : null),
                this.finishNode(t, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(t, i) {
            let r = this.startNodeAt(t, i);
            return this.eat(139)
              ? this.finishNode(r, "JSXOpeningFragment")
              : ((r.name = this.jsxParseElementName()),
                this.jsxParseOpeningElementAfterName(r));
          }
          jsxParseOpeningElementAfterName(t) {
            let i = [];
            for (; !this.match(56) && !this.match(139); )
              i.push(this.jsxParseAttribute());
            return (
              (t.attributes = i),
              (t.selfClosing = this.eat(56)),
              this.expect(139),
              this.finishNode(t, "JSXOpeningElement")
            );
          }
          jsxParseClosingElementAt(t, i) {
            let r = this.startNodeAt(t, i);
            return this.eat(139)
              ? this.finishNode(r, "JSXClosingFragment")
              : ((r.name = this.jsxParseElementName()),
                this.expect(139),
                this.finishNode(r, "JSXClosingElement"));
          }
          jsxParseElementAt(t, i) {
            let r = this.startNodeAt(t, i),
              s = [],
              a = this.jsxParseOpeningElementAt(t, i),
              o = null;
            if (!a.selfClosing) {
              e: for (;;)
                switch (this.state.type) {
                  case 138:
                    if (
                      ((t = this.state.start),
                      (i = this.state.startLoc),
                      this.next(),
                      this.eat(56))
                    ) {
                      o = this.jsxParseClosingElementAt(t, i);
                      break e;
                    }
                    s.push(this.jsxParseElementAt(t, i));
                    break;
                  case 137:
                    s.push(this.parseExprAtom());
                    break;
                  case 5: {
                    let l = this.startNode();
                    this.setContext(Si.brace),
                      this.next(),
                      this.match(21)
                        ? s.push(this.jsxParseSpreadChild(l))
                        : s.push(
                            this.jsxParseExpressionContainer(l, Si.j_expr)
                          );
                    break;
                  }
                  default:
                    throw this.unexpected();
                }
              To(a) && !To(o) && o !== null
                ? this.raise(Ml.MissingClosingTagFragment, { at: o })
                : !To(a) && To(o)
                ? this.raise(Ml.MissingClosingTagElement, {
                    at: o,
                    openingTagName: Qc(a.name),
                  })
                : !To(a) &&
                  !To(o) &&
                  Qc(o.name) !== Qc(a.name) &&
                  this.raise(Ml.MissingClosingTagElement, {
                    at: o,
                    openingTagName: Qc(a.name),
                  });
            }
            if (
              (To(a)
                ? ((r.openingFragment = a), (r.closingFragment = o))
                : ((r.openingElement = a), (r.closingElement = o)),
              (r.children = s),
              this.match(47))
            )
              throw this.raise(Ml.UnwrappedAdjacentJSXElements, {
                at: this.state.startLoc,
              });
            return To(a)
              ? this.finishNode(r, "JSXFragment")
              : this.finishNode(r, "JSXElement");
          }
          jsxParseElement() {
            let t = this.state.start,
              i = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(t, i);
          }
          setContext(t) {
            let { context: i } = this.state;
            i[i.length - 1] = t;
          }
          parseExprAtom(t) {
            return this.match(137)
              ? this.parseLiteral(this.state.value, "JSXText")
              : this.match(138)
              ? this.jsxParseElement()
              : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33
              ? (this.replaceToken(138), this.jsxParseElement())
              : super.parseExprAtom(t);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(t) {
            let i = this.curContext();
            if (i === Si.j_expr) return this.jsxReadToken();
            if (i === Si.j_oTag || i === Si.j_cTag) {
              if (_a(t)) return this.jsxReadWord();
              if (t === 62) return ++this.state.pos, this.finishToken(139);
              if ((t === 34 || t === 39) && i === Si.j_oTag)
                return this.jsxReadString(t);
            }
            return t === 60 &&
              this.state.canStartJSXElement &&
              this.input.charCodeAt(this.state.pos + 1) !== 33
              ? (++this.state.pos, this.finishToken(138))
              : super.getTokenFromCode(t);
          }
          updateContext(t) {
            let { context: i, type: r } = this.state;
            if (r === 56 && t === 138)
              i.splice(-2, 2, Si.j_cTag), (this.state.canStartJSXElement = !1);
            else if (r === 138) i.push(Si.j_oTag);
            else if (r === 139) {
              let s = i[i.length - 1];
              (s === Si.j_oTag && t === 56) || s === Si.j_cTag
                ? (i.pop(),
                  (this.state.canStartJSXElement =
                    i[i.length - 1] === Si.j_expr))
                : (this.setContext(Si.j_expr),
                  (this.state.canStartJSXElement = !0));
            } else this.state.canStartJSXElement = G7(r);
          }
        },
      aL = class extends Pm {
        constructor(...e) {
          super(...e);
          (this.types = new Set()),
            (this.enums = new Set()),
            (this.constEnums = new Set()),
            (this.classes = new Set()),
            (this.exportOnlyBindings = new Set());
        }
      },
      oL = class extends Dm {
        createScope(e) {
          return new aL(e);
        }
        declareName(e, t, i) {
          let r = this.currentScope();
          if (t & S_) {
            this.maybeExportDefined(r, e), r.exportOnlyBindings.add(e);
            return;
          }
          super.declareName(e, t, i),
            t & iu &&
              (t & Ca ||
                (this.checkRedeclarationInScope(r, e, t, i),
                this.maybeExportDefined(r, e)),
              r.types.add(e)),
            t & c_ && r.enums.add(e),
            t & u_ && r.constEnums.add(e),
            t & wm && r.classes.add(e);
        }
        isRedeclaredInScope(e, t, i) {
          if (e.enums.has(t)) {
            if (i & c_) {
              let r = !!(i & u_),
                s = e.constEnums.has(t);
              return r !== s;
            }
            return !0;
          }
          return i & wm && e.classes.has(t)
            ? e.lexical.has(t)
              ? !!(i & Ca)
              : !1
            : i & iu && e.types.has(t)
            ? !0
            : super.isRedeclaredInScope(e, t, i);
        }
        checkLocalExport(e) {
          let t = this.scopeStack[0],
            { name: i } = e;
          !t.types.has(i) &&
            !t.exportOnlyBindings.has(i) &&
            super.checkLocalExport(e);
        }
      },
      Uq = (n, e) => Object.hasOwnProperty.call(n, e) && n[e];
    function Vq(n) {
      if (n == null) throw new Error(`Unexpected ${n} value.`);
      return n;
    }
    function y2(n) {
      if (!n) throw new Error("Assert fail");
    }
    var gt = Ea`typescript`({
      AbstractMethodHasImplementation: ({ methodName: n }) =>
        `Method '${n}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({ propertyName: n }) =>
        `Property '${n}' cannot have an initializer because it is marked abstract.`,
      AccesorCannotDeclareThisParameter:
        "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccesorCannotHaveTypeParameters:
        "An accessor cannot have type parameters.",
      CannotFindName: ({ name: n }) => `Cannot find name '${n}'.`,
      ClassMethodHasDeclare:
        "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly:
        "Class methods cannot have the 'readonly' modifier.",
      ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference:
        "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters:
        "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: ({ kind: n }) => `'declare' is not allowed in ${n}ters.`,
      DeclareClassFieldHasInitializer:
        "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation:
        "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: ({ modifier: n }) =>
        "Accessibility modifier already seen.",
      DuplicateModifier: ({ modifier: n }) => `Duplicate modifier: '${n}'.`,
      EmptyHeritageClauseType: ({ token: n }) => `'${n}' list cannot be empty.`,
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare:
        "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      IncompatibleModifiers: ({ modifiers: n }) =>
        `'${n[0]}' modifier cannot be used with '${n[1]}' modifier.`,
      IndexSignatureHasAbstract:
        "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({ modifier: n }) =>
        `Index signatures cannot have an accessibility modifier ('${n}').`,
      IndexSignatureHasDeclare:
        "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride:
        "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic:
        "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext:
        "Initializers are not allowed in ambient contexts.",
      InvalidModifierOnTypeMember: ({ modifier: n }) =>
        `'${n}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({ modifier: n }) =>
        `'${n}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({ modifier: n }) =>
        `'${n}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifiersOrder: ({ orderedModifiers: n }) =>
        `'${n[0]}' modifier must precede '${n[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression:
        "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
      InvalidTupleMemberLabel:
        "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName:
        "'interface' declarations must be followed by an identifier.",
      MixedLabeledAndUnlabeledElements:
        "Tuple members must all have names or all not have names.",
      NonAbstractClassHasAbstractMethod:
        "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifer:
        "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired:
        "A required element cannot follow an optional element.",
      OverrideNotInSubClass:
        "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional:
        "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract:
        "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({ modifier: n }) =>
        `Private elements cannot have an accessibility modifier ('${n}').`,
      ReadonlyForMethodSignature:
        "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam:
        "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion:
        "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccesorCannotHaveOptionalParameter:
        "A 'set' accessor cannot have an optional parameter.",
      SetAccesorCannotHaveRestParameter:
        "A 'set' accessor cannot have rest parameter.",
      SetAccesorCannotHaveReturnType:
        "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: n }) =>
        `Single type parameter ${n} should have a trailing comma. Example usage: <${n},>.`,
      StaticBlockCannotHaveModifier:
        "Static class blocks cannot have any modifier.",
      TypeAnnotationAfterAssign:
        "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed:
        "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports:
        "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports:
        "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier:
        "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly:
        "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter:
        "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument:
        "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind:
        "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: ({ type: n }) =>
        `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${n}.`,
    });
    function Gq(n) {
      switch (n) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return;
      }
    }
    function v2(n) {
      return n === "private" || n === "public" || n === "protected";
    }
    function Hq(n) {
      return n === "in" || n === "out";
    }
    var $q = (n) =>
      class extends n {
        getScopeHandler() {
          return oL;
        }
        tsIsIdentifier() {
          return pi(this.state.type);
        }
        tsTokenCanFollowModifier() {
          return (
            (this.match(0) ||
              this.match(5) ||
              this.match(55) ||
              this.match(21) ||
              this.match(134) ||
              this.isLiteralPropertyName()) &&
            !this.hasPrecedingLineBreak()
          );
        }
        tsNextTokenCanFollowModifier() {
          return this.next(), this.tsTokenCanFollowModifier();
        }
        tsParseModifier(t, i) {
          if (!pi(this.state.type) && this.state.type !== 58) return;
          let r = this.state.value;
          if (t.indexOf(r) !== -1) {
            if (i && this.tsIsStartOfStaticBlocks()) return;
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
              return r;
          }
        }
        tsParseModifiers({
          modified: t,
          allowedModifiers: i,
          disallowedModifiers: r,
          stopOnStartOfClassStaticBlock: s,
          errorTemplate: a = gt.InvalidModifierOnTypeMember,
        }) {
          let o = (c, u, f, d) => {
              u === f &&
                t[d] &&
                this.raise(gt.InvalidModifiersOrder, {
                  at: c,
                  orderedModifiers: [f, d],
                });
            },
            l = (c, u, f, d) => {
              ((t[f] && u === d) || (t[d] && u === f)) &&
                this.raise(gt.IncompatibleModifiers, {
                  at: c,
                  modifiers: [f, d],
                });
            };
          for (;;) {
            let { startLoc: c } = this.state,
              u = this.tsParseModifier(i.concat(r != null ? r : []), s);
            if (!u) break;
            v2(u)
              ? t.accessibility
                ? this.raise(gt.DuplicateAccessibilityModifier, {
                    at: c,
                    modifier: u,
                  })
                : (o(c, u, u, "override"),
                  o(c, u, u, "static"),
                  o(c, u, u, "readonly"),
                  (t.accessibility = u))
              : Hq(u)
              ? (t[u] &&
                  this.raise(gt.DuplicateModifier, { at: c, modifier: u }),
                (t[u] = !0),
                o(c, u, "in", "out"))
              : (Object.hasOwnProperty.call(t, u)
                  ? this.raise(gt.DuplicateModifier, { at: c, modifier: u })
                  : (o(c, u, "static", "readonly"),
                    o(c, u, "static", "override"),
                    o(c, u, "override", "readonly"),
                    o(c, u, "abstract", "override"),
                    l(c, u, "declare", "override"),
                    l(c, u, "static", "abstract")),
                (t[u] = !0)),
              r != null &&
                r.includes(u) &&
                this.raise(a, { at: c, modifier: u });
          }
        }
        tsIsListTerminator(t) {
          switch (t) {
            case "EnumMembers":
            case "TypeMembers":
              return this.match(8);
            case "HeritageClauseElement":
              return this.match(5);
            case "TupleElementTypes":
              return this.match(3);
            case "TypeParametersOrArguments":
              return this.match(48);
          }
          throw new Error("Unreachable");
        }
        tsParseList(t, i) {
          let r = [];
          for (; !this.tsIsListTerminator(t); ) r.push(i());
          return r;
        }
        tsParseDelimitedList(t, i, r) {
          return Vq(this.tsParseDelimitedListWorker(t, i, !0, r));
        }
        tsParseDelimitedListWorker(t, i, r, s) {
          let a = [],
            o = -1;
          for (; !this.tsIsListTerminator(t); ) {
            o = -1;
            let l = i();
            if (l == null) return;
            if ((a.push(l), this.eat(12))) {
              o = this.state.lastTokStart;
              continue;
            }
            if (this.tsIsListTerminator(t)) break;
            r && this.expect(12);
            return;
          }
          return s && (s.value = o), a;
        }
        tsParseBracketedList(t, i, r, s, a) {
          s || (r ? this.expect(0) : this.expect(47));
          let o = this.tsParseDelimitedList(t, i, a);
          return r ? this.expect(3) : this.expect(48), o;
        }
        tsParseImportType() {
          let t = this.startNode();
          return (
            this.expect(83),
            this.expect(10),
            this.match(129) ||
              this.raise(gt.UnsupportedImportTypeArgument, {
                at: this.state.startLoc,
              }),
            (t.argument = super.parseExprAtom()),
            this.expect(11),
            this.eat(16) && (t.qualifier = this.tsParseEntityName()),
            this.match(47) && (t.typeParameters = this.tsParseTypeArguments()),
            this.finishNode(t, "TSImportType")
          );
        }
        tsParseEntityName(t = !0) {
          let i = this.parseIdentifier(t);
          for (; this.eat(16); ) {
            let r = this.startNodeAtNode(i);
            (r.left = i),
              (r.right = this.parseIdentifier(t)),
              (i = this.finishNode(r, "TSQualifiedName"));
          }
          return i;
        }
        tsParseTypeReference() {
          let t = this.startNode();
          return (
            (t.typeName = this.tsParseEntityName()),
            !this.hasPrecedingLineBreak() &&
              this.match(47) &&
              (t.typeParameters = this.tsParseTypeArguments()),
            this.finishNode(t, "TSTypeReference")
          );
        }
        tsParseThisTypePredicate(t) {
          this.next();
          let i = this.startNodeAtNode(t);
          return (
            (i.parameterName = t),
            (i.typeAnnotation = this.tsParseTypeAnnotation(!1)),
            (i.asserts = !1),
            this.finishNode(i, "TSTypePredicate")
          );
        }
        tsParseThisTypeNode() {
          let t = this.startNode();
          return this.next(), this.finishNode(t, "TSThisType");
        }
        tsParseTypeQuery() {
          let t = this.startNode();
          return (
            this.expect(87),
            this.match(83)
              ? (t.exprName = this.tsParseImportType())
              : (t.exprName = this.tsParseEntityName()),
            !this.hasPrecedingLineBreak() &&
              this.match(47) &&
              (t.typeParameters = this.tsParseTypeArguments()),
            this.finishNode(t, "TSTypeQuery")
          );
        }
        tsParseInOutModifiers(t) {
          this.tsParseModifiers({
            modified: t,
            allowedModifiers: ["in", "out"],
            disallowedModifiers: [
              "public",
              "private",
              "protected",
              "readonly",
              "declare",
              "abstract",
              "override",
            ],
            errorTemplate: gt.InvalidModifierOnTypeParameter,
          });
        }
        tsParseNoneModifiers(t) {
          this.tsParseModifiers({
            modified: t,
            allowedModifiers: [],
            disallowedModifiers: ["in", "out"],
            errorTemplate: gt.InvalidModifierOnTypeParameterPositions,
          });
        }
        tsParseTypeParameter(t = this.tsParseNoneModifiers.bind(this)) {
          let i = this.startNode();
          return (
            t(i),
            (i.name = this.tsParseTypeParameterName()),
            (i.constraint = this.tsEatThenParseType(81)),
            (i.default = this.tsEatThenParseType(29)),
            this.finishNode(i, "TSTypeParameter")
          );
        }
        tsTryParseTypeParameters(t) {
          if (this.match(47)) return this.tsParseTypeParameters(t);
        }
        tsParseTypeParameters(t) {
          let i = this.startNode();
          this.match(47) || this.match(138) ? this.next() : this.unexpected();
          let r = { value: -1 };
          return (
            (i.params = this.tsParseBracketedList(
              "TypeParametersOrArguments",
              this.tsParseTypeParameter.bind(this, t),
              !1,
              !0,
              r
            )),
            i.params.length === 0 &&
              this.raise(gt.EmptyTypeParameters, { at: i }),
            r.value !== -1 && this.addExtra(i, "trailingComma", r.value),
            this.finishNode(i, "TSTypeParameterDeclaration")
          );
        }
        tsTryNextParseConstantContext() {
          if (this.lookahead().type !== 75) return null;
          this.next();
          let t = this.tsParseTypeReference();
          return (
            t.typeParameters &&
              this.raise(gt.CannotFindName, { at: t.typeName, name: "const" }),
            t
          );
        }
        tsFillSignature(t, i) {
          let r = t === 19,
            s = "parameters",
            a = "typeAnnotation";
          (i.typeParameters = this.tsTryParseTypeParameters()),
            this.expect(10),
            (i[s] = this.tsParseBindingListForSignature()),
            r
              ? (i[a] = this.tsParseTypeOrTypePredicateAnnotation(t))
              : this.match(t) &&
                (i[a] = this.tsParseTypeOrTypePredicateAnnotation(t));
        }
        tsParseBindingListForSignature() {
          return super
            .parseBindingList(11, 41)
            .map(
              (t) => (
                t.type !== "Identifier" &&
                  t.type !== "RestElement" &&
                  t.type !== "ObjectPattern" &&
                  t.type !== "ArrayPattern" &&
                  this.raise(gt.UnsupportedSignatureParameterKind, {
                    at: t,
                    type: t.type,
                  }),
                t
              )
            );
        }
        tsParseTypeMemberSemicolon() {
          !this.eat(12) && !this.isLineTerminator() && this.expect(13);
        }
        tsParseSignatureMember(t, i) {
          return (
            this.tsFillSignature(14, i),
            this.tsParseTypeMemberSemicolon(),
            this.finishNode(i, t)
          );
        }
        tsIsUnambiguouslyIndexSignature() {
          return (
            this.next(),
            pi(this.state.type) ? (this.next(), this.match(14)) : !1
          );
        }
        tsTryParseIndexSignature(t) {
          if (
            !(
              this.match(0) &&
              this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))
            )
          )
            return;
          this.expect(0);
          let i = this.parseIdentifier();
          (i.typeAnnotation = this.tsParseTypeAnnotation()),
            this.resetEndLocation(i),
            this.expect(3),
            (t.parameters = [i]);
          let r = this.tsTryParseTypeAnnotation();
          return (
            r && (t.typeAnnotation = r),
            this.tsParseTypeMemberSemicolon(),
            this.finishNode(t, "TSIndexSignature")
          );
        }
        tsParsePropertyOrMethodSignature(t, i) {
          this.eat(17) && (t.optional = !0);
          let r = t;
          if (this.match(10) || this.match(47)) {
            i && this.raise(gt.ReadonlyForMethodSignature, { at: t });
            let s = r;
            s.kind &&
              this.match(47) &&
              this.raise(gt.AccesorCannotHaveTypeParameters, {
                at: this.state.curPosition(),
              }),
              this.tsFillSignature(14, s),
              this.tsParseTypeMemberSemicolon();
            let a = "parameters",
              o = "typeAnnotation";
            if (s.kind === "get")
              s[a].length > 0 &&
                (this.raise(ne.BadGetterArity, {
                  at: this.state.curPosition(),
                }),
                this.isThisParam(s[a][0]) &&
                  this.raise(gt.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition(),
                  }));
            else if (s.kind === "set") {
              if (s[a].length !== 1)
                this.raise(ne.BadSetterArity, { at: this.state.curPosition() });
              else {
                let l = s[a][0];
                this.isThisParam(l) &&
                  this.raise(gt.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition(),
                  }),
                  l.type === "Identifier" &&
                    l.optional &&
                    this.raise(gt.SetAccesorCannotHaveOptionalParameter, {
                      at: this.state.curPosition(),
                    }),
                  l.type === "RestElement" &&
                    this.raise(gt.SetAccesorCannotHaveRestParameter, {
                      at: this.state.curPosition(),
                    });
              }
              s[o] &&
                this.raise(gt.SetAccesorCannotHaveReturnType, { at: s[o] });
            } else s.kind = "method";
            return this.finishNode(s, "TSMethodSignature");
          } else {
            let s = r;
            i && (s.readonly = !0);
            let a = this.tsTryParseTypeAnnotation();
            return (
              a && (s.typeAnnotation = a),
              this.tsParseTypeMemberSemicolon(),
              this.finishNode(s, "TSPropertySignature")
            );
          }
        }
        tsParseTypeMember() {
          let t = this.startNode();
          if (this.match(10) || this.match(47))
            return this.tsParseSignatureMember("TSCallSignatureDeclaration", t);
          if (this.match(77)) {
            let r = this.startNode();
            return (
              this.next(),
              this.match(10) || this.match(47)
                ? this.tsParseSignatureMember(
                    "TSConstructSignatureDeclaration",
                    t
                  )
                : ((t.key = this.createIdentifier(r, "new")),
                  this.tsParsePropertyOrMethodSignature(t, !1))
            );
          }
          this.tsParseModifiers({
            modified: t,
            allowedModifiers: ["readonly"],
            disallowedModifiers: [
              "declare",
              "abstract",
              "private",
              "protected",
              "public",
              "static",
              "override",
            ],
          });
          let i = this.tsTryParseIndexSignature(t);
          return (
            i ||
            (super.parsePropertyName(t),
            !t.computed &&
              t.key.type === "Identifier" &&
              (t.key.name === "get" || t.key.name === "set") &&
              this.tsTokenCanFollowModifier() &&
              ((t.kind = t.key.name), super.parsePropertyName(t)),
            this.tsParsePropertyOrMethodSignature(t, !!t.readonly))
          );
        }
        tsParseTypeLiteral() {
          let t = this.startNode();
          return (
            (t.members = this.tsParseObjectTypeMembers()),
            this.finishNode(t, "TSTypeLiteral")
          );
        }
        tsParseObjectTypeMembers() {
          this.expect(5);
          let t = this.tsParseList(
            "TypeMembers",
            this.tsParseTypeMember.bind(this)
          );
          return this.expect(8), t;
        }
        tsIsStartOfMappedType() {
          return (
            this.next(),
            this.eat(53)
              ? this.isContextual(118)
              : (this.isContextual(118) && this.next(),
                !this.match(0) || (this.next(), !this.tsIsIdentifier())
                  ? !1
                  : (this.next(), this.match(58)))
          );
        }
        tsParseMappedTypeParameter() {
          let t = this.startNode();
          return (
            (t.name = this.tsParseTypeParameterName()),
            (t.constraint = this.tsExpectThenParseType(58)),
            this.finishNode(t, "TSTypeParameter")
          );
        }
        tsParseMappedType() {
          let t = this.startNode();
          return (
            this.expect(5),
            this.match(53)
              ? ((t.readonly = this.state.value),
                this.next(),
                this.expectContextual(118))
              : this.eatContextual(118) && (t.readonly = !0),
            this.expect(0),
            (t.typeParameter = this.tsParseMappedTypeParameter()),
            (t.nameType = this.eatContextual(93) ? this.tsParseType() : null),
            this.expect(3),
            this.match(53)
              ? ((t.optional = this.state.value), this.next(), this.expect(17))
              : this.eat(17) && (t.optional = !0),
            (t.typeAnnotation = this.tsTryParseType()),
            this.semicolon(),
            this.expect(8),
            this.finishNode(t, "TSMappedType")
          );
        }
        tsParseTupleType() {
          let t = this.startNode();
          t.elementTypes = this.tsParseBracketedList(
            "TupleElementTypes",
            this.tsParseTupleElementType.bind(this),
            !0,
            !1
          );
          let i = !1,
            r = null;
          return (
            t.elementTypes.forEach((s) => {
              var a;
              let { type: o } = s;
              i &&
                o !== "TSRestType" &&
                o !== "TSOptionalType" &&
                !(o === "TSNamedTupleMember" && s.optional) &&
                this.raise(gt.OptionalTypeBeforeRequired, { at: s }),
                i ||
                  (i =
                    (o === "TSNamedTupleMember" && s.optional) ||
                    o === "TSOptionalType");
              let l = o;
              o === "TSRestType" && ((s = s.typeAnnotation), (l = s.type));
              let c = l === "TSNamedTupleMember";
              (a = r) != null || (r = c),
                r !== c &&
                  this.raise(gt.MixedLabeledAndUnlabeledElements, { at: s });
            }),
            this.finishNode(t, "TSTupleType")
          );
        }
        tsParseTupleElementType() {
          let { start: t, startLoc: i } = this.state,
            r = this.eat(21),
            s = this.tsParseType(),
            a = this.eat(17);
          if (this.eat(14)) {
            let l = this.startNodeAtNode(s);
            (l.optional = a),
              s.type === "TSTypeReference" &&
              !s.typeParameters &&
              s.typeName.type === "Identifier"
                ? (l.label = s.typeName)
                : (this.raise(gt.InvalidTupleMemberLabel, { at: s }),
                  (l.label = s)),
              (l.elementType = this.tsParseType()),
              (s = this.finishNode(l, "TSNamedTupleMember"));
          } else if (a) {
            let l = this.startNodeAtNode(s);
            (l.typeAnnotation = s), (s = this.finishNode(l, "TSOptionalType"));
          }
          if (r) {
            let l = this.startNodeAt(t, i);
            (l.typeAnnotation = s), (s = this.finishNode(l, "TSRestType"));
          }
          return s;
        }
        tsParseParenthesizedType() {
          let t = this.startNode();
          return (
            this.expect(10),
            (t.typeAnnotation = this.tsParseType()),
            this.expect(11),
            this.finishNode(t, "TSParenthesizedType")
          );
        }
        tsParseFunctionOrConstructorType(t, i) {
          let r = this.startNode();
          return (
            t === "TSConstructorType" &&
              ((r.abstract = !!i), i && this.next(), this.next()),
            this.tsInAllowConditionalTypesContext(() =>
              this.tsFillSignature(19, r)
            ),
            this.finishNode(r, t)
          );
        }
        tsParseLiteralTypeNode() {
          let t = this.startNode();
          return (
            (t.literal = (() => {
              switch (this.state.type) {
                case 130:
                case 131:
                case 129:
                case 85:
                case 86:
                  return super.parseExprAtom();
                default:
                  throw this.unexpected();
              }
            })()),
            this.finishNode(t, "TSLiteralType")
          );
        }
        tsParseTemplateLiteralType() {
          let t = this.startNode();
          return (
            (t.literal = super.parseTemplate(!1)),
            this.finishNode(t, "TSLiteralType")
          );
        }
        parseTemplateSubstitution() {
          return this.state.inType
            ? this.tsParseType()
            : super.parseTemplateSubstitution();
        }
        tsParseThisTypeOrThisTypePredicate() {
          let t = this.tsParseThisTypeNode();
          return this.isContextual(113) && !this.hasPrecedingLineBreak()
            ? this.tsParseThisTypePredicate(t)
            : t;
        }
        tsParseNonArrayType() {
          switch (this.state.type) {
            case 129:
            case 130:
            case 131:
            case 85:
            case 86:
              return this.tsParseLiteralTypeNode();
            case 53:
              if (this.state.value === "-") {
                let t = this.startNode(),
                  i = this.lookahead();
                if (i.type !== 130 && i.type !== 131) throw this.unexpected();
                return (
                  (t.literal = this.parseMaybeUnary()),
                  this.finishNode(t, "TSLiteralType")
                );
              }
              break;
            case 78:
              return this.tsParseThisTypeOrThisTypePredicate();
            case 87:
              return this.tsParseTypeQuery();
            case 83:
              return this.tsParseImportType();
            case 5:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))
                ? this.tsParseMappedType()
                : this.tsParseTypeLiteral();
            case 0:
              return this.tsParseTupleType();
            case 10:
              return this.tsParseParenthesizedType();
            case 25:
            case 24:
              return this.tsParseTemplateLiteralType();
            default: {
              let { type: t } = this.state;
              if (pi(t) || t === 88 || t === 84) {
                let i =
                  t === 88
                    ? "TSVoidKeyword"
                    : t === 84
                    ? "TSNullKeyword"
                    : Gq(this.state.value);
                if (i !== void 0 && this.lookaheadCharCode() !== 46) {
                  let r = this.startNode();
                  return this.next(), this.finishNode(r, i);
                }
                return this.tsParseTypeReference();
              }
            }
          }
          throw this.unexpected();
        }
        tsParseArrayTypeOrHigher() {
          let t = this.tsParseNonArrayType();
          for (; !this.hasPrecedingLineBreak() && this.eat(0); )
            if (this.match(3)) {
              let i = this.startNodeAtNode(t);
              (i.elementType = t),
                this.expect(3),
                (t = this.finishNode(i, "TSArrayType"));
            } else {
              let i = this.startNodeAtNode(t);
              (i.objectType = t),
                (i.indexType = this.tsParseType()),
                this.expect(3),
                (t = this.finishNode(i, "TSIndexedAccessType"));
            }
          return t;
        }
        tsParseTypeOperator() {
          let t = this.startNode(),
            i = this.state.value;
          return (
            this.next(),
            (t.operator = i),
            (t.typeAnnotation = this.tsParseTypeOperatorOrHigher()),
            i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(t),
            this.finishNode(t, "TSTypeOperator")
          );
        }
        tsCheckTypeAnnotationForReadOnly(t) {
          switch (t.typeAnnotation.type) {
            case "TSTupleType":
            case "TSArrayType":
              return;
            default:
              this.raise(gt.UnexpectedReadonly, { at: t });
          }
        }
        tsParseInferType() {
          let t = this.startNode();
          this.expectContextual(112);
          let i = this.startNode();
          return (
            (i.name = this.tsParseTypeParameterName()),
            (i.constraint = this.tsTryParse(() =>
              this.tsParseConstraintForInferType()
            )),
            (t.typeParameter = this.finishNode(i, "TSTypeParameter")),
            this.finishNode(t, "TSInferType")
          );
        }
        tsParseConstraintForInferType() {
          if (this.eat(81)) {
            let t = this.tsInDisallowConditionalTypesContext(() =>
              this.tsParseType()
            );
            if (this.state.inDisallowConditionalTypesContext || !this.match(17))
              return t;
          }
        }
        tsParseTypeOperatorOrHigher() {
          return X7(this.state.type) && !this.state.containsEsc
            ? this.tsParseTypeOperator()
            : this.isContextual(112)
            ? this.tsParseInferType()
            : this.tsInAllowConditionalTypesContext(() =>
                this.tsParseArrayTypeOrHigher()
              );
        }
        tsParseUnionOrIntersectionType(t, i, r) {
          let s = this.startNode(),
            a = this.eat(r),
            o = [];
          do o.push(i());
          while (this.eat(r));
          return o.length === 1 && !a
            ? o[0]
            : ((s.types = o), this.finishNode(s, t));
        }
        tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType(
            "TSIntersectionType",
            this.tsParseTypeOperatorOrHigher.bind(this),
            45
          );
        }
        tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType(
            "TSUnionType",
            this.tsParseIntersectionTypeOrHigher.bind(this),
            43
          );
        }
        tsIsStartOfFunctionType() {
          return this.match(47)
            ? !0
            : this.match(10) &&
                this.tsLookAhead(
                  this.tsIsUnambiguouslyStartOfFunctionType.bind(this)
                );
        }
        tsSkipParameterStart() {
          if (pi(this.state.type) || this.match(78)) return this.next(), !0;
          if (this.match(5)) {
            let { errors: t } = this.state,
              i = t.length;
            try {
              return this.parseObjectLike(8, !0), t.length === i;
            } catch (r) {
              return !1;
            }
          }
          if (this.match(0)) {
            this.next();
            let { errors: t } = this.state,
              i = t.length;
            try {
              return super.parseBindingList(3, 93, !0), t.length === i;
            } catch (r) {
              return !1;
            }
          }
          return !1;
        }
        tsIsUnambiguouslyStartOfFunctionType() {
          return (
            this.next(),
            !!(
              this.match(11) ||
              this.match(21) ||
              (this.tsSkipParameterStart() &&
                (this.match(14) ||
                  this.match(12) ||
                  this.match(17) ||
                  this.match(29) ||
                  (this.match(11) && (this.next(), this.match(19)))))
            )
          );
        }
        tsParseTypeOrTypePredicateAnnotation(t) {
          return this.tsInType(() => {
            let i = this.startNode();
            this.expect(t);
            let r = this.startNode(),
              s = !!this.tsTryParse(
                this.tsParseTypePredicateAsserts.bind(this)
              );
            if (s && this.match(78)) {
              let l = this.tsParseThisTypeOrThisTypePredicate();
              return (
                l.type === "TSThisType"
                  ? ((r.parameterName = l),
                    (r.asserts = !0),
                    (r.typeAnnotation = null),
                    (l = this.finishNode(r, "TSTypePredicate")))
                  : (this.resetStartLocationFromNode(l, r), (l.asserts = !0)),
                (i.typeAnnotation = l),
                this.finishNode(i, "TSTypeAnnotation")
              );
            }
            let a =
              this.tsIsIdentifier() &&
              this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            if (!a)
              return s
                ? ((r.parameterName = this.parseIdentifier()),
                  (r.asserts = s),
                  (r.typeAnnotation = null),
                  (i.typeAnnotation = this.finishNode(r, "TSTypePredicate")),
                  this.finishNode(i, "TSTypeAnnotation"))
                : this.tsParseTypeAnnotation(!1, i);
            let o = this.tsParseTypeAnnotation(!1);
            return (
              (r.parameterName = a),
              (r.typeAnnotation = o),
              (r.asserts = s),
              (i.typeAnnotation = this.finishNode(r, "TSTypePredicate")),
              this.finishNode(i, "TSTypeAnnotation")
            );
          });
        }
        tsTryParseTypeOrTypePredicateAnnotation() {
          return this.match(14)
            ? this.tsParseTypeOrTypePredicateAnnotation(14)
            : void 0;
        }
        tsTryParseTypeAnnotation() {
          return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
        }
        tsTryParseType() {
          return this.tsEatThenParseType(14);
        }
        tsParseTypePredicatePrefix() {
          let t = this.parseIdentifier();
          if (this.isContextual(113) && !this.hasPrecedingLineBreak())
            return this.next(), t;
        }
        tsParseTypePredicateAsserts() {
          if (this.state.type !== 106) return !1;
          let t = this.state.containsEsc;
          return (
            this.next(),
            !pi(this.state.type) && !this.match(78)
              ? !1
              : (t &&
                  this.raise(ne.InvalidEscapedReservedWord, {
                    at: this.state.lastTokStartLoc,
                    reservedWord: "asserts",
                  }),
                !0)
          );
        }
        tsParseTypeAnnotation(t = !0, i = this.startNode()) {
          return (
            this.tsInType(() => {
              t && this.expect(14), (i.typeAnnotation = this.tsParseType());
            }),
            this.finishNode(i, "TSTypeAnnotation")
          );
        }
        tsParseType() {
          y2(this.state.inType);
          let t = this.tsParseNonConditionalType();
          if (
            this.state.inDisallowConditionalTypesContext ||
            this.hasPrecedingLineBreak() ||
            !this.eat(81)
          )
            return t;
          let i = this.startNodeAtNode(t);
          return (
            (i.checkType = t),
            (i.extendsType = this.tsInDisallowConditionalTypesContext(() =>
              this.tsParseNonConditionalType()
            )),
            this.expect(17),
            (i.trueType = this.tsInAllowConditionalTypesContext(() =>
              this.tsParseType()
            )),
            this.expect(14),
            (i.falseType = this.tsInAllowConditionalTypesContext(() =>
              this.tsParseType()
            )),
            this.finishNode(i, "TSConditionalType")
          );
        }
        isAbstractConstructorSignature() {
          return this.isContextual(120) && this.lookahead().type === 77;
        }
        tsParseNonConditionalType() {
          return this.tsIsStartOfFunctionType()
            ? this.tsParseFunctionOrConstructorType("TSFunctionType")
            : this.match(77)
            ? this.tsParseFunctionOrConstructorType("TSConstructorType")
            : this.isAbstractConstructorSignature()
            ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0)
            : this.tsParseUnionTypeOrHigher();
        }
        tsParseTypeAssertion() {
          this.getPluginOption("typescript", "disallowAmbiguousJSXLike") &&
            this.raise(gt.ReservedTypeAssertion, { at: this.state.startLoc });
          let t = this.startNode(),
            i = this.tsTryNextParseConstantContext();
          return (
            (t.typeAnnotation = i || this.tsNextThenParseType()),
            this.expect(48),
            (t.expression = this.parseMaybeUnary()),
            this.finishNode(t, "TSTypeAssertion")
          );
        }
        tsParseHeritageClause(t) {
          let i = this.state.startLoc,
            r = this.tsParseDelimitedList("HeritageClauseElement", () => {
              let s = this.startNode();
              return (
                (s.expression = this.tsParseEntityName()),
                this.match(47) &&
                  (s.typeParameters = this.tsParseTypeArguments()),
                this.finishNode(s, "TSExpressionWithTypeArguments")
              );
            });
          return (
            r.length ||
              this.raise(gt.EmptyHeritageClauseType, { at: i, token: t }),
            r
          );
        }
        tsParseInterfaceDeclaration(t, i = {}) {
          if (this.hasFollowingLineBreak()) return null;
          this.expectContextual(125),
            i.declare && (t.declare = !0),
            pi(this.state.type)
              ? ((t.id = this.parseIdentifier()),
                this.checkIdentifier(t.id, oq))
              : ((t.id = null),
                this.raise(gt.MissingInterfaceName, {
                  at: this.state.startLoc,
                })),
            (t.typeParameters = this.tsTryParseTypeParameters(
              this.tsParseInOutModifiers.bind(this)
            )),
            this.eat(81) && (t.extends = this.tsParseHeritageClause("extends"));
          let r = this.startNode();
          return (
            (r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))),
            (t.body = this.finishNode(r, "TSInterfaceBody")),
            this.finishNode(t, "TSInterfaceDeclaration")
          );
        }
        tsParseTypeAliasDeclaration(t) {
          return (
            (t.id = this.parseIdentifier()),
            this.checkIdentifier(t.id, lq),
            (t.typeAnnotation = this.tsInType(() => {
              if (
                ((t.typeParameters = this.tsTryParseTypeParameters(
                  this.tsParseInOutModifiers.bind(this)
                )),
                this.expect(29),
                this.isContextual(111) && this.lookahead().type !== 16)
              ) {
                let i = this.startNode();
                return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            })),
            this.semicolon(),
            this.finishNode(t, "TSTypeAliasDeclaration")
          );
        }
        tsInNoContext(t) {
          let i = this.state.context;
          this.state.context = [i[0]];
          try {
            return t();
          } finally {
            this.state.context = i;
          }
        }
        tsInType(t) {
          let i = this.state.inType;
          this.state.inType = !0;
          try {
            return t();
          } finally {
            this.state.inType = i;
          }
        }
        tsInDisallowConditionalTypesContext(t) {
          let i = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = !0;
          try {
            return t();
          } finally {
            this.state.inDisallowConditionalTypesContext = i;
          }
        }
        tsInAllowConditionalTypesContext(t) {
          let i = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = !1;
          try {
            return t();
          } finally {
            this.state.inDisallowConditionalTypesContext = i;
          }
        }
        tsEatThenParseType(t) {
          return this.match(t) ? this.tsNextThenParseType() : void 0;
        }
        tsExpectThenParseType(t) {
          return this.tsDoThenParseType(() => this.expect(t));
        }
        tsNextThenParseType() {
          return this.tsDoThenParseType(() => this.next());
        }
        tsDoThenParseType(t) {
          return this.tsInType(() => (t(), this.tsParseType()));
        }
        tsParseEnumMember() {
          let t = this.startNode();
          return (
            (t.id = this.match(129)
              ? super.parseStringLiteral(this.state.value)
              : this.parseIdentifier(!0)),
            this.eat(29) && (t.initializer = super.parseMaybeAssignAllowIn()),
            this.finishNode(t, "TSEnumMember")
          );
        }
        tsParseEnumDeclaration(t, i = {}) {
          return (
            i.const && (t.const = !0),
            i.declare && (t.declare = !0),
            this.expectContextual(122),
            (t.id = this.parseIdentifier()),
            this.checkIdentifier(t.id, t.const ? uq : U2),
            this.expect(5),
            (t.members = this.tsParseDelimitedList(
              "EnumMembers",
              this.tsParseEnumMember.bind(this)
            )),
            this.expect(8),
            this.finishNode(t, "TSEnumDeclaration")
          );
        }
        tsParseModuleBlock() {
          let t = this.startNode();
          return (
            this.scope.enter(Zc),
            this.expect(5),
            super.parseBlockOrModuleBlockBody((t.body = []), void 0, !0, 8),
            this.scope.exit(),
            this.finishNode(t, "TSModuleBlock")
          );
        }
        tsParseModuleOrNamespaceDeclaration(t, i = !1) {
          if (
            ((t.id = this.parseIdentifier()),
            i || this.checkIdentifier(t.id, hq),
            this.eat(16))
          ) {
            let r = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(r, !0), (t.body = r);
          } else
            this.scope.enter(xm),
              this.prodParam.enter(tu),
              (t.body = this.tsParseModuleBlock()),
              this.prodParam.exit(),
              this.scope.exit();
          return this.finishNode(t, "TSModuleDeclaration");
        }
        tsParseAmbientExternalModuleDeclaration(t) {
          return (
            this.isContextual(109)
              ? ((t.global = !0), (t.id = this.parseIdentifier()))
              : this.match(129)
              ? (t.id = super.parseStringLiteral(this.state.value))
              : this.unexpected(),
            this.match(5)
              ? (this.scope.enter(xm),
                this.prodParam.enter(tu),
                (t.body = this.tsParseModuleBlock()),
                this.prodParam.exit(),
                this.scope.exit())
              : this.semicolon(),
            this.finishNode(t, "TSModuleDeclaration")
          );
        }
        tsParseImportEqualsDeclaration(t, i) {
          (t.isExport = i || !1),
            (t.id = this.parseIdentifier()),
            this.checkIdentifier(t.id, Sa),
            this.expect(29);
          let r = this.tsParseModuleReference();
          return (
            t.importKind === "type" &&
              r.type !== "TSExternalModuleReference" &&
              this.raise(gt.ImportAliasHasImportType, { at: r }),
            (t.moduleReference = r),
            this.semicolon(),
            this.finishNode(t, "TSImportEqualsDeclaration")
          );
        }
        tsIsExternalModuleReference() {
          return this.isContextual(116) && this.lookaheadCharCode() === 40;
        }
        tsParseModuleReference() {
          return this.tsIsExternalModuleReference()
            ? this.tsParseExternalModuleReference()
            : this.tsParseEntityName(!1);
        }
        tsParseExternalModuleReference() {
          let t = this.startNode();
          if ((this.expectContextual(116), this.expect(10), !this.match(129)))
            throw this.unexpected();
          return (
            (t.expression = super.parseExprAtom()),
            this.expect(11),
            this.finishNode(t, "TSExternalModuleReference")
          );
        }
        tsLookAhead(t) {
          let i = this.state.clone(),
            r = t();
          return (this.state = i), r;
        }
        tsTryParseAndCatch(t) {
          let i = this.tryParse((r) => t() || r());
          if (!(i.aborted || !i.node))
            return i.error && (this.state = i.failState), i.node;
        }
        tsTryParse(t) {
          let i = this.state.clone(),
            r = t();
          if (r !== void 0 && r !== !1) return r;
          this.state = i;
        }
        tsTryParseDeclare(t) {
          if (this.isLineTerminator()) return;
          let i = this.state.type,
            r;
          return (
            this.isContextual(99) && ((i = 74), (r = "let")),
            this.tsInAmbientContext(() => {
              if (i === 68)
                return (
                  (t.declare = !0), super.parseFunctionStatement(t, !1, !0)
                );
              if (i === 80) return (t.declare = !0), this.parseClass(t, !0, !1);
              if (i === 122)
                return this.tsParseEnumDeclaration(t, { declare: !0 });
              if (i === 109)
                return this.tsParseAmbientExternalModuleDeclaration(t);
              if (i === 75 || i === 74)
                return !this.match(75) || !this.isLookaheadContextual("enum")
                  ? ((t.declare = !0),
                    this.parseVarStatement(t, r || this.state.value, !0))
                  : (this.expect(75),
                    this.tsParseEnumDeclaration(t, { const: !0, declare: !0 }));
              if (i === 125) {
                let s = this.tsParseInterfaceDeclaration(t, { declare: !0 });
                if (s) return s;
              }
              if (pi(i))
                return this.tsParseDeclaration(t, this.state.value, !0);
            })
          );
        }
        tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(
            this.startNode(),
            this.state.value,
            !0
          );
        }
        tsParseExpressionStatement(t, i) {
          switch (i.name) {
            case "declare": {
              let r = this.tsTryParseDeclare(t);
              if (r) return (r.declare = !0), r;
              break;
            }
            case "global":
              if (this.match(5)) {
                this.scope.enter(xm), this.prodParam.enter(tu);
                let r = t;
                return (
                  (r.global = !0),
                  (r.id = i),
                  (r.body = this.tsParseModuleBlock()),
                  this.scope.exit(),
                  this.prodParam.exit(),
                  this.finishNode(r, "TSModuleDeclaration")
                );
              }
              break;
            default:
              return this.tsParseDeclaration(t, i.name, !1);
          }
        }
        tsParseDeclaration(t, i, r) {
          switch (i) {
            case "abstract":
              if (
                this.tsCheckLineTerminator(r) &&
                (this.match(80) || pi(this.state.type))
              )
                return this.tsParseAbstractDeclaration(t);
              break;
            case "module":
              if (this.tsCheckLineTerminator(r)) {
                if (this.match(129))
                  return this.tsParseAmbientExternalModuleDeclaration(t);
                if (pi(this.state.type))
                  return this.tsParseModuleOrNamespaceDeclaration(t);
              }
              break;
            case "namespace":
              if (this.tsCheckLineTerminator(r) && pi(this.state.type))
                return this.tsParseModuleOrNamespaceDeclaration(t);
              break;
            case "type":
              if (this.tsCheckLineTerminator(r) && pi(this.state.type))
                return this.tsParseTypeAliasDeclaration(t);
              break;
          }
        }
        tsCheckLineTerminator(t) {
          return t
            ? this.hasFollowingLineBreak()
              ? !1
              : (this.next(), !0)
            : !this.isLineTerminator();
        }
        tsTryParseGenericAsyncArrowFunction(t, i) {
          if (!this.match(47)) return;
          let r = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = !0;
          let s = this.tsTryParseAndCatch(() => {
            let a = this.startNodeAt(t, i);
            return (
              (a.typeParameters = this.tsParseTypeParameters()),
              super.parseFunctionParams(a),
              (a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()),
              this.expect(19),
              a
            );
          });
          if (((this.state.maybeInArrowParameters = r), !!s))
            return super.parseArrowExpression(s, null, !0);
        }
        tsParseTypeArgumentsInExpression() {
          if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
        }
        tsParseTypeArguments() {
          let t = this.startNode();
          return (
            (t.params = this.tsInType(() =>
              this.tsInNoContext(
                () => (
                  this.expect(47),
                  this.tsParseDelimitedList(
                    "TypeParametersOrArguments",
                    this.tsParseType.bind(this)
                  )
                )
              )
            )),
            t.params.length === 0 &&
              this.raise(gt.EmptyTypeArguments, { at: t }),
            this.expect(48),
            this.finishNode(t, "TSTypeParameterInstantiation")
          );
        }
        tsIsDeclarationStart() {
          return Y7(this.state.type);
        }
        isExportDefaultSpecifier() {
          return this.tsIsDeclarationStart()
            ? !1
            : super.isExportDefaultSpecifier();
        }
        parseAssignableListItem(t, i) {
          let r = this.state.start,
            s = this.state.startLoc,
            a,
            o = !1,
            l = !1;
          if (t !== void 0) {
            let f = {};
            this.tsParseModifiers({
              modified: f,
              allowedModifiers: [
                "public",
                "private",
                "protected",
                "override",
                "readonly",
              ],
            }),
              (a = f.accessibility),
              (l = f.override),
              (o = f.readonly),
              t === !1 &&
                (a || o || l) &&
                this.raise(gt.UnexpectedParameterModifier, { at: s });
          }
          let c = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(c);
          let u = this.parseMaybeDefault(c.start, c.loc.start, c);
          if (a || o || l) {
            let f = this.startNodeAt(r, s);
            return (
              i.length && (f.decorators = i),
              a && (f.accessibility = a),
              o && (f.readonly = o),
              l && (f.override = l),
              u.type !== "Identifier" &&
                u.type !== "AssignmentPattern" &&
                this.raise(gt.UnsupportedParameterPropertyKind, { at: f }),
              (f.parameter = u),
              this.finishNode(f, "TSParameterProperty")
            );
          }
          return i.length && (c.decorators = i), u;
        }
        isSimpleParameter(t) {
          return (
            (t.type === "TSParameterProperty" &&
              super.isSimpleParameter(t.parameter)) ||
            super.isSimpleParameter(t)
          );
        }
        parseFunctionBodyAndFinish(t, i, r = !1) {
          this.match(14) &&
            (t.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
          let s =
            i === "FunctionDeclaration"
              ? "TSDeclareFunction"
              : i === "ClassMethod" || i === "ClassPrivateMethod"
              ? "TSDeclareMethod"
              : void 0;
          return s && !this.match(5) && this.isLineTerminator()
            ? this.finishNode(t, s)
            : s === "TSDeclareFunction" &&
              this.state.isAmbientContext &&
              (this.raise(gt.DeclareFunctionHasImplementation, { at: t }),
              t.declare)
            ? super.parseFunctionBodyAndFinish(t, s, r)
            : super.parseFunctionBodyAndFinish(t, i, r);
        }
        registerFunctionStatementId(t) {
          !t.body && t.id
            ? this.checkIdentifier(t.id, f2)
            : super.registerFunctionStatementId(t);
        }
        tsCheckForInvalidTypeCasts(t) {
          t.forEach((i) => {
            (i == null ? void 0 : i.type) === "TSTypeCastExpression" &&
              this.raise(gt.UnexpectedTypeAnnotation, { at: i.typeAnnotation });
          });
        }
        toReferencedList(t, i) {
          return this.tsCheckForInvalidTypeCasts(t), t;
        }
        parseArrayLike(t, i, r, s) {
          let a = super.parseArrayLike(t, i, r, s);
          return (
            a.type === "ArrayExpression" &&
              this.tsCheckForInvalidTypeCasts(a.elements),
            a
          );
        }
        parseSubscript(t, i, r, s, a) {
          if (!this.hasPrecedingLineBreak() && this.match(35)) {
            (this.state.canStartJSXElement = !1), this.next();
            let l = this.startNodeAt(i, r);
            return (
              (l.expression = t), this.finishNode(l, "TSNonNullExpression")
            );
          }
          let o = !1;
          if (this.match(18) && this.lookaheadCharCode() === 60) {
            if (s) return (a.stop = !0), t;
            (a.optionalChainMember = o = !0), this.next();
          }
          if (this.match(47) || this.match(51)) {
            let l,
              c = this.tsTryParseAndCatch(() => {
                if (!s && this.atPossibleAsyncArrow(t)) {
                  let m = this.tsTryParseGenericAsyncArrowFunction(i, r);
                  if (m) return m;
                }
                let u = this.tsParseTypeArgumentsInExpression();
                if (!u) return;
                if (o && !this.match(10)) {
                  l = this.state.curPosition();
                  return;
                }
                if (Tm(this.state.type)) {
                  let m = super.parseTaggedTemplateExpression(t, i, r, a);
                  return (m.typeParameters = u), m;
                }
                if (!s && this.eat(10)) {
                  let m = this.startNodeAt(i, r);
                  return (
                    (m.callee = t),
                    (m.arguments = this.parseCallExpressionArguments(11, !1)),
                    this.tsCheckForInvalidTypeCasts(m.arguments),
                    (m.typeParameters = u),
                    a.optionalChainMember && (m.optional = o),
                    this.finishCallExpression(m, a.optionalChainMember)
                  );
                }
                let f = this.state.type;
                if (
                  f === 48 ||
                  (f !== 10 && a_(f) && !this.hasPrecedingLineBreak())
                )
                  return;
                let d = this.startNodeAt(i, r);
                return (
                  (d.expression = t),
                  (d.typeParameters = u),
                  this.finishNode(d, "TSInstantiationExpression")
                );
              });
            if ((l && this.unexpected(l, 10), c))
              return (
                c.type === "TSInstantiationExpression" &&
                  (this.match(16) ||
                    (this.match(18) && this.lookaheadCharCode() !== 40)) &&
                  this.raise(
                    gt.InvalidPropertyAccessAfterInstantiationExpression,
                    { at: this.state.startLoc }
                  ),
                c
              );
          }
          return super.parseSubscript(t, i, r, s, a);
        }
        parseNewCallee(t) {
          var i;
          super.parseNewCallee(t);
          let { callee: r } = t;
          r.type === "TSInstantiationExpression" &&
            !((i = r.extra) != null && i.parenthesized) &&
            ((t.typeParameters = r.typeParameters), (t.callee = r.expression));
        }
        parseExprOp(t, i, r, s) {
          if (
            vm(58) > s &&
            !this.hasPrecedingLineBreak() &&
            this.isContextual(93)
          ) {
            let a = this.startNodeAt(i, r);
            a.expression = t;
            let o = this.tsTryNextParseConstantContext();
            return (
              o
                ? (a.typeAnnotation = o)
                : (a.typeAnnotation = this.tsNextThenParseType()),
              this.finishNode(a, "TSAsExpression"),
              this.reScan_lt_gt(),
              this.parseExprOp(a, i, r, s)
            );
          }
          return super.parseExprOp(t, i, r, s);
        }
        checkReservedWord(t, i, r, s) {
          this.state.isAmbientContext || super.checkReservedWord(t, i, r, s);
        }
        checkDuplicateExports() {}
        parseImport(t) {
          if (
            ((t.importKind = "value"),
            pi(this.state.type) || this.match(55) || this.match(5))
          ) {
            let r = this.lookahead();
            if (
              (this.isContextual(126) &&
                r.type !== 12 &&
                r.type !== 97 &&
                r.type !== 29 &&
                ((t.importKind = "type"), this.next(), (r = this.lookahead())),
              pi(this.state.type) && r.type === 29)
            )
              return this.tsParseImportEqualsDeclaration(t);
          }
          let i = super.parseImport(t);
          return (
            i.importKind === "type" &&
              i.specifiers.length > 1 &&
              i.specifiers[0].type === "ImportDefaultSpecifier" &&
              this.raise(gt.TypeImportCannotSpecifyDefaultAndNamed, { at: i }),
            i
          );
        }
        parseExport(t) {
          if (this.match(83))
            return (
              this.next(),
              this.isContextual(126) && this.lookaheadCharCode() !== 61
                ? ((t.importKind = "type"), this.next())
                : (t.importKind = "value"),
              this.tsParseImportEqualsDeclaration(t, !0)
            );
          if (this.eat(29)) {
            let i = t;
            return (
              (i.expression = super.parseExpression()),
              this.semicolon(),
              this.finishNode(i, "TSExportAssignment")
            );
          } else if (this.eatContextual(93)) {
            let i = t;
            return (
              this.expectContextual(124),
              (i.id = this.parseIdentifier()),
              this.semicolon(),
              this.finishNode(i, "TSNamespaceExportDeclaration")
            );
          } else
            return (
              this.isContextual(126) && this.lookahead().type === 5
                ? (this.next(), (t.exportKind = "type"))
                : (t.exportKind = "value"),
              super.parseExport(t)
            );
        }
        isAbstractClass() {
          return this.isContextual(120) && this.lookahead().type === 80;
        }
        parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            let t = this.startNode();
            return this.next(), (t.abstract = !0), this.parseClass(t, !0, !0);
          }
          if (this.match(125)) {
            let t = this.tsParseInterfaceDeclaration(this.startNode());
            if (t) return t;
          }
          return super.parseExportDefaultExpression();
        }
        parseVarStatement(t, i, r = !1) {
          let { isAmbientContext: s } = this.state,
            a = super.parseVarStatement(t, i, r || s);
          if (!s) return a;
          for (let { id: o, init: l } of a.declarations)
            !l ||
              (i !== "const" || !!o.typeAnnotation
                ? this.raise(gt.InitializerNotAllowedInAmbientContext, {
                    at: l,
                  })
                : l.type !== "StringLiteral" &&
                  l.type !== "BooleanLiteral" &&
                  l.type !== "NumericLiteral" &&
                  l.type !== "BigIntLiteral" &&
                  (l.type !== "TemplateLiteral" || l.expressions.length > 0) &&
                  !Wq(l) &&
                  this.raise(
                    gt.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference,
                    { at: l }
                  ));
          return a;
        }
        parseStatementContent(t, i) {
          if (this.match(75) && this.isLookaheadContextual("enum")) {
            let r = this.startNode();
            return (
              this.expect(75), this.tsParseEnumDeclaration(r, { const: !0 })
            );
          }
          if (this.isContextual(122))
            return this.tsParseEnumDeclaration(this.startNode());
          if (this.isContextual(125)) {
            let r = this.tsParseInterfaceDeclaration(this.startNode());
            if (r) return r;
          }
          return super.parseStatementContent(t, i);
        }
        parseAccessModifier() {
          return this.tsParseModifier(["public", "protected", "private"]);
        }
        tsHasSomeModifiers(t, i) {
          return i.some((r) => (v2(r) ? t.accessibility === r : !!t[r]));
        }
        tsIsStartOfStaticBlocks() {
          return this.isContextual(104) && this.lookaheadCharCode() === 123;
        }
        parseClassMember(t, i, r) {
          let s = [
            "declare",
            "private",
            "public",
            "protected",
            "override",
            "abstract",
            "readonly",
            "static",
          ];
          this.tsParseModifiers({
            modified: i,
            allowedModifiers: s,
            disallowedModifiers: ["in", "out"],
            stopOnStartOfClassStaticBlock: !0,
            errorTemplate: gt.InvalidModifierOnTypeParameterPositions,
          });
          let a = () => {
            this.tsIsStartOfStaticBlocks()
              ? (this.next(),
                this.next(),
                this.tsHasSomeModifiers(i, s) &&
                  this.raise(gt.StaticBlockCannotHaveModifier, {
                    at: this.state.curPosition(),
                  }),
                super.parseClassStaticBlock(t, i))
              : this.parseClassMemberWithIsStatic(t, i, r, !!i.static);
          };
          i.declare ? this.tsInAmbientContext(a) : a();
        }
        parseClassMemberWithIsStatic(t, i, r, s) {
          let a = this.tsTryParseIndexSignature(i);
          if (a) {
            t.body.push(a),
              i.abstract && this.raise(gt.IndexSignatureHasAbstract, { at: i }),
              i.accessibility &&
                this.raise(gt.IndexSignatureHasAccessibility, {
                  at: i,
                  modifier: i.accessibility,
                }),
              i.declare && this.raise(gt.IndexSignatureHasDeclare, { at: i }),
              i.override && this.raise(gt.IndexSignatureHasOverride, { at: i });
            return;
          }
          !this.state.inAbstractClass &&
            i.abstract &&
            this.raise(gt.NonAbstractClassHasAbstractMethod, { at: i }),
            i.override &&
              (r.hadSuperClass ||
                this.raise(gt.OverrideNotInSubClass, { at: i })),
            super.parseClassMemberWithIsStatic(t, i, r, s);
        }
        parsePostMemberNameModifiers(t) {
          this.eat(17) && (t.optional = !0),
            t.readonly &&
              this.match(10) &&
              this.raise(gt.ClassMethodHasReadonly, { at: t }),
            t.declare &&
              this.match(10) &&
              this.raise(gt.ClassMethodHasDeclare, { at: t });
        }
        parseExpressionStatement(t, i) {
          return (
            (i.type === "Identifier"
              ? this.tsParseExpressionStatement(t, i)
              : void 0) || super.parseExpressionStatement(t, i)
          );
        }
        shouldParseExportDeclaration() {
          return this.tsIsDeclarationStart()
            ? !0
            : super.shouldParseExportDeclaration();
        }
        parseConditional(t, i, r, s) {
          if (!this.state.maybeInArrowParameters || !this.match(17))
            return super.parseConditional(t, i, r, s);
          let a = this.tryParse(() => super.parseConditional(t, i, r));
          return a.node
            ? (a.error && (this.state = a.failState), a.node)
            : (a.error && super.setOptionalParametersError(s, a.error), t);
        }
        parseParenItem(t, i, r) {
          if (
            ((t = super.parseParenItem(t, i, r)),
            this.eat(17) && ((t.optional = !0), this.resetEndLocation(t)),
            this.match(14))
          ) {
            let s = this.startNodeAt(i, r);
            return (
              (s.expression = t),
              (s.typeAnnotation = this.tsParseTypeAnnotation()),
              this.finishNode(s, "TSTypeCastExpression")
            );
          }
          return t;
        }
        parseExportDeclaration(t) {
          if (!this.state.isAmbientContext && this.isContextual(121))
            return this.tsInAmbientContext(() =>
              this.parseExportDeclaration(t)
            );
          let i = this.state.start,
            r = this.state.startLoc,
            s = this.eatContextual(121);
          if (
            s &&
            (this.isContextual(121) || !this.shouldParseExportDeclaration())
          )
            throw this.raise(gt.ExpectedAmbientAfterExportDeclare, {
              at: this.state.startLoc,
            });
          let o =
            (pi(this.state.type) && this.tsTryParseExportDeclaration()) ||
            super.parseExportDeclaration(t);
          return o
            ? ((o.type === "TSInterfaceDeclaration" ||
                o.type === "TSTypeAliasDeclaration" ||
                s) &&
                (t.exportKind = "type"),
              s && (this.resetStartLocation(o, i, r), (o.declare = !0)),
              o)
            : null;
        }
        parseClassId(t, i, r, s) {
          if ((!i || r) && this.isContextual(110)) return;
          super.parseClassId(t, i, r, t.declare ? f2 : B2);
          let a = this.tsTryParseTypeParameters(
            this.tsParseInOutModifiers.bind(this)
          );
          a && (t.typeParameters = a);
        }
        parseClassPropertyAnnotation(t) {
          !t.optional && this.eat(35) && (t.definite = !0);
          let i = this.tsTryParseTypeAnnotation();
          i && (t.typeAnnotation = i);
        }
        parseClassProperty(t) {
          if (
            (this.parseClassPropertyAnnotation(t),
            this.state.isAmbientContext &&
              !(t.readonly && !t.typeAnnotation) &&
              this.match(29) &&
              this.raise(gt.DeclareClassFieldHasInitializer, {
                at: this.state.startLoc,
              }),
            t.abstract && this.match(29))
          ) {
            let { key: i } = t;
            this.raise(gt.AbstractPropertyHasInitializer, {
              at: this.state.startLoc,
              propertyName:
                i.type === "Identifier" && !t.computed
                  ? i.name
                  : `[${this.input.slice(i.start, i.end)}]`,
            });
          }
          return super.parseClassProperty(t);
        }
        parseClassPrivateProperty(t) {
          return (
            t.abstract && this.raise(gt.PrivateElementHasAbstract, { at: t }),
            t.accessibility &&
              this.raise(gt.PrivateElementHasAccessibility, {
                at: t,
                modifier: t.accessibility,
              }),
            this.parseClassPropertyAnnotation(t),
            super.parseClassPrivateProperty(t)
          );
        }
        pushClassMethod(t, i, r, s, a, o) {
          let l = this.tsTryParseTypeParameters();
          l && a && this.raise(gt.ConstructorHasTypeParameters, { at: l });
          let { declare: c = !1, kind: u } = i;
          c &&
            (u === "get" || u === "set") &&
            this.raise(gt.DeclareAccessor, { at: i, kind: u }),
            l && (i.typeParameters = l),
            super.pushClassMethod(t, i, r, s, a, o);
        }
        pushClassPrivateMethod(t, i, r, s) {
          let a = this.tsTryParseTypeParameters();
          a && (i.typeParameters = a), super.pushClassPrivateMethod(t, i, r, s);
        }
        declareClassPrivateMethodInScope(t, i) {
          t.type !== "TSDeclareMethod" &&
            ((t.type === "MethodDefinition" && !t.value.body) ||
              super.declareClassPrivateMethodInScope(t, i));
        }
        parseClassSuper(t) {
          super.parseClassSuper(t),
            t.superClass &&
              (this.match(47) || this.match(51)) &&
              (t.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
            this.eatContextual(110) &&
              (t.implements = this.tsParseHeritageClause("implements"));
        }
        parseObjPropValue(t, i, r, s, a, o, l, c) {
          let u = this.tsTryParseTypeParameters();
          return (
            u && (t.typeParameters = u),
            super.parseObjPropValue(t, i, r, s, a, o, l, c)
          );
        }
        parseFunctionParams(t, i) {
          let r = this.tsTryParseTypeParameters();
          r && (t.typeParameters = r), super.parseFunctionParams(t, i);
        }
        parseVarId(t, i) {
          super.parseVarId(t, i),
            t.id.type === "Identifier" &&
              !this.hasPrecedingLineBreak() &&
              this.eat(35) &&
              (t.definite = !0);
          let r = this.tsTryParseTypeAnnotation();
          r && ((t.id.typeAnnotation = r), this.resetEndLocation(t.id));
        }
        parseAsyncArrowFromCallExpression(t, i) {
          return (
            this.match(14) && (t.returnType = this.tsParseTypeAnnotation()),
            super.parseAsyncArrowFromCallExpression(t, i)
          );
        }
        parseMaybeAssign(t, i) {
          var r, s, a, o, l, c, u;
          let f, d, m;
          if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
            if (
              ((f = this.state.clone()),
              (d = this.tryParse(() => super.parseMaybeAssign(t, i), f)),
              !d.error)
            )
              return d.node;
            let { context: g } = this.state,
              b = g[g.length - 1];
            (b === Si.j_oTag || b === Si.j_expr) && g.pop();
          }
          if (!((r = d) != null && r.error) && !this.match(47))
            return super.parseMaybeAssign(t, i);
          (!f || f === this.state) && (f = this.state.clone());
          let x,
            y = this.tryParse((g) => {
              var b, _;
              x = this.tsParseTypeParameters();
              let E = super.parseMaybeAssign(t, i);
              return (
                (E.type !== "ArrowFunctionExpression" ||
                  ((b = E.extra) != null && b.parenthesized)) &&
                  g(),
                ((_ = x) == null ? void 0 : _.params.length) !== 0 &&
                  this.resetStartLocationFromNode(E, x),
                (E.typeParameters = x),
                E
              );
            }, f);
          if (!y.error && !y.aborted)
            return x && this.reportReservedArrowTypeParam(x), y.node;
          if (
            !d &&
            (y2(!this.hasPlugin("jsx")),
            (m = this.tryParse(() => super.parseMaybeAssign(t, i), f)),
            !m.error)
          )
            return m.node;
          if ((s = d) != null && s.node)
            return (this.state = d.failState), d.node;
          if (y.node)
            return (
              (this.state = y.failState),
              x && this.reportReservedArrowTypeParam(x),
              y.node
            );
          if ((a = m) != null && a.node)
            return (this.state = m.failState), m.node;
          throw (o = d) != null && o.thrown
            ? d.error
            : y.thrown
            ? y.error
            : (l = m) != null && l.thrown
            ? m.error
            : ((c = d) == null ? void 0 : c.error) ||
              y.error ||
              ((u = m) == null ? void 0 : u.error);
        }
        reportReservedArrowTypeParam(t) {
          var i;
          t.params.length === 1 &&
            !((i = t.extra) != null && i.trailingComma) &&
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") &&
            this.raise(gt.ReservedArrowTypeParam, { at: t });
        }
        parseMaybeUnary(t, i) {
          return !this.hasPlugin("jsx") && this.match(47)
            ? this.tsParseTypeAssertion()
            : super.parseMaybeUnary(t, i);
        }
        parseArrow(t) {
          if (this.match(14)) {
            let i = this.tryParse((r) => {
              let s = this.tsParseTypeOrTypePredicateAnnotation(14);
              return (this.canInsertSemicolon() || !this.match(19)) && r(), s;
            });
            if (i.aborted) return;
            i.thrown ||
              (i.error && (this.state = i.failState), (t.returnType = i.node));
          }
          return super.parseArrow(t);
        }
        parseAssignableListItemTypes(t) {
          this.eat(17) &&
            (t.type !== "Identifier" &&
              !this.state.isAmbientContext &&
              !this.state.inType &&
              this.raise(gt.PatternIsOptional, { at: t }),
            (t.optional = !0));
          let i = this.tsTryParseTypeAnnotation();
          return i && (t.typeAnnotation = i), this.resetEndLocation(t), t;
        }
        isAssignable(t, i) {
          switch (t.type) {
            case "TSTypeCastExpression":
              return this.isAssignable(t.expression, i);
            case "TSParameterProperty":
              return !0;
            default:
              return super.isAssignable(t, i);
          }
        }
        toAssignable(t, i = !1) {
          switch (t.type) {
            case "ParenthesizedExpression":
              this.toAssignableParenthesizedExpression(t, i);
              break;
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              i
                ? this.expressionScope.recordArrowParemeterBindingError(
                    gt.UnexpectedTypeCastInParameter,
                    { at: t }
                  )
                : this.raise(gt.UnexpectedTypeCastInParameter, { at: t }),
                this.toAssignable(t.expression, i);
              break;
            case "AssignmentExpression":
              !i &&
                t.left.type === "TSTypeCastExpression" &&
                (t.left = this.typeCastToParameter(t.left));
            default:
              super.toAssignable(t, i);
          }
        }
        toAssignableParenthesizedExpression(t, i) {
          switch (t.expression.type) {
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
            case "ParenthesizedExpression":
              this.toAssignable(t.expression, i);
              break;
            default:
              super.toAssignable(t, i);
          }
        }
        checkToRestConversion(t, i) {
          switch (t.type) {
            case "TSAsExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              this.checkToRestConversion(t.expression, !1);
              break;
            default:
              super.checkToRestConversion(t, i);
          }
        }
        isValidLVal(t, i, r) {
          return (
            Uq(
              {
                TSTypeCastExpression: !0,
                TSParameterProperty: "parameter",
                TSNonNullExpression: "expression",
                TSAsExpression: (r !== Al || !i) && ["expression", !0],
                TSTypeAssertion: (r !== Al || !i) && ["expression", !0],
              },
              t
            ) || super.isValidLVal(t, i, r)
          );
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(!0);
            default:
              return super.parseBindingAtom();
          }
        }
        parseMaybeDecoratorArguments(t) {
          if (this.match(47) || this.match(51)) {
            let i = this.tsParseTypeArgumentsInExpression();
            if (this.match(10)) {
              let r = super.parseMaybeDecoratorArguments(t);
              return (r.typeParameters = i), r;
            }
            this.unexpected(null, 10);
          }
          return super.parseMaybeDecoratorArguments(t);
        }
        checkCommaAfterRest(t) {
          return this.state.isAmbientContext &&
            this.match(12) &&
            this.lookaheadCharCode() === t
            ? (this.next(), !1)
            : super.checkCommaAfterRest(t);
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(35) || this.match(14) || super.isClassProperty();
        }
        parseMaybeDefault(t, i, r) {
          let s = super.parseMaybeDefault(t, i, r);
          return (
            s.type === "AssignmentPattern" &&
              s.typeAnnotation &&
              s.right.start < s.typeAnnotation.start &&
              this.raise(gt.TypeAnnotationAfterAssign, {
                at: s.typeAnnotation,
              }),
            s
          );
        }
        getTokenFromCode(t) {
          if (this.state.inType) {
            if (t === 62) return this.finishOp(48, 1);
            if (t === 60) return this.finishOp(47, 1);
          }
          return super.getTokenFromCode(t);
        }
        reScan_lt_gt() {
          let { type: t } = this.state;
          t === 47
            ? ((this.state.pos -= 1), this.readToken_lt())
            : t === 48 && ((this.state.pos -= 1), this.readToken_gt());
        }
        reScan_lt() {
          let { type: t } = this.state;
          return t === 51
            ? ((this.state.pos -= 2), this.finishOp(47, 1), 47)
            : t;
        }
        toAssignableList(t, i, r) {
          for (let s = 0; s < t.length; s++) {
            let a = t[s];
            (a == null ? void 0 : a.type) === "TSTypeCastExpression" &&
              (t[s] = this.typeCastToParameter(a));
          }
          super.toAssignableList(t, i, r);
        }
        typeCastToParameter(t) {
          return (
            (t.expression.typeAnnotation = t.typeAnnotation),
            this.resetEndLocation(t.expression, t.typeAnnotation.loc.end),
            t.expression
          );
        }
        shouldParseArrow(t) {
          return this.match(14)
            ? t.every((i) => this.isAssignable(i, !0))
            : super.shouldParseArrow(t);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        canHaveLeadingDecorator() {
          return super.canHaveLeadingDecorator() || this.isAbstractClass();
        }
        jsxParseOpeningElementAfterName(t) {
          if (this.match(47) || this.match(51)) {
            let i = this.tsTryParseAndCatch(() =>
              this.tsParseTypeArgumentsInExpression()
            );
            i && (t.typeParameters = i);
          }
          return super.jsxParseOpeningElementAfterName(t);
        }
        getGetterSetterExpectedParamCount(t) {
          let i = super.getGetterSetterExpectedParamCount(t),
            s = this.getObjectOrClassMethodParams(t)[0];
          return s && this.isThisParam(s) ? i + 1 : i;
        }
        parseCatchClauseParam() {
          let t = super.parseCatchClauseParam(),
            i = this.tsTryParseTypeAnnotation();
          return i && ((t.typeAnnotation = i), this.resetEndLocation(t)), t;
        }
        tsInAmbientContext(t) {
          let i = this.state.isAmbientContext;
          this.state.isAmbientContext = !0;
          try {
            return t();
          } finally {
            this.state.isAmbientContext = i;
          }
        }
        parseClass(t, i, r) {
          let s = this.state.inAbstractClass;
          this.state.inAbstractClass = !!t.abstract;
          try {
            return super.parseClass(t, i, r);
          } finally {
            this.state.inAbstractClass = s;
          }
        }
        tsParseAbstractDeclaration(t) {
          if (this.match(80))
            return (t.abstract = !0), this.parseClass(t, !0, !1);
          if (this.isContextual(125)) {
            if (!this.hasFollowingLineBreak())
              return (
                (t.abstract = !0),
                this.raise(gt.NonClassMethodPropertyHasAbstractModifer, {
                  at: t,
                }),
                this.tsParseInterfaceDeclaration(t)
              );
          } else this.unexpected(null, 80);
        }
        parseMethod(t, i, r, s, a, o, l) {
          let c = super.parseMethod(t, i, r, s, a, o, l);
          if (
            c.abstract &&
            (this.hasPlugin("estree") ? !!c.value.body : !!c.body)
          ) {
            let { key: f } = c;
            this.raise(gt.AbstractMethodHasImplementation, {
              at: c,
              methodName:
                f.type === "Identifier" && !c.computed
                  ? f.name
                  : `[${this.input.slice(f.start, f.end)}]`,
            });
          }
          return c;
        }
        tsParseTypeParameterName() {
          return this.parseIdentifier().name;
        }
        shouldParseAsAmbientContext() {
          return !!this.getPluginOption("typescript", "dts");
        }
        parse() {
          return (
            this.shouldParseAsAmbientContext() &&
              (this.state.isAmbientContext = !0),
            super.parse()
          );
        }
        getExpression() {
          return (
            this.shouldParseAsAmbientContext() &&
              (this.state.isAmbientContext = !0),
            super.getExpression()
          );
        }
        parseExportSpecifier(t, i, r, s) {
          return !i && s
            ? (this.parseTypeOnlyImportExportSpecifier(t, !1, r),
              this.finishNode(t, "ExportSpecifier"))
            : ((t.exportKind = "value"),
              super.parseExportSpecifier(t, i, r, s));
        }
        parseImportSpecifier(t, i, r, s) {
          return !i && s
            ? (this.parseTypeOnlyImportExportSpecifier(t, !0, r),
              this.finishNode(t, "ImportSpecifier"))
            : ((t.importKind = "value"),
              super.parseImportSpecifier(t, i, r, s));
        }
        parseTypeOnlyImportExportSpecifier(t, i, r) {
          let s = i ? "imported" : "local",
            a = i ? "local" : "exported",
            o = t[s],
            l,
            c = !1,
            u = !0,
            f = o.loc.start;
          if (this.isContextual(93)) {
            let m = this.parseIdentifier();
            if (this.isContextual(93)) {
              let x = this.parseIdentifier();
              wa(this.state.type)
                ? ((c = !0),
                  (o = m),
                  (l = i
                    ? this.parseIdentifier()
                    : this.parseModuleExportName()),
                  (u = !1))
                : ((l = x), (u = !1));
            } else
              wa(this.state.type)
                ? ((u = !1),
                  (l = i
                    ? this.parseIdentifier()
                    : this.parseModuleExportName()))
                : ((c = !0), (o = m));
          } else
            wa(this.state.type) &&
              ((c = !0),
              i
                ? ((o = this.parseIdentifier(!0)),
                  this.isContextual(93) ||
                    this.checkReservedWord(o.name, o.loc.start, !0, !0))
                : (o = this.parseModuleExportName()));
          c &&
            r &&
            this.raise(
              i
                ? gt.TypeModifierIsUsedInTypeImports
                : gt.TypeModifierIsUsedInTypeExports,
              { at: f }
            ),
            (t[s] = o),
            (t[a] = l);
          let d = i ? "importKind" : "exportKind";
          (t[d] = c ? "type" : "value"),
            u &&
              this.eatContextual(93) &&
              (t[a] = i
                ? this.parseIdentifier()
                : this.parseModuleExportName()),
            t[a] || (t[a] = Ma(t[s])),
            i && this.checkIdentifier(t[a], Sa);
        }
      };
    function Wq(n) {
      if (n.type !== "MemberExpression") return !1;
      let { computed: e, property: t } = n;
      return e &&
        t.type !== "StringLiteral" &&
        (t.type !== "TemplateLiteral" || t.expressions.length > 0)
        ? !1
        : lL(n.object);
    }
    function lL(n) {
      return n.type === "Identifier"
        ? !0
        : n.type !== "MemberExpression" || n.computed
        ? !1
        : lL(n.object);
    }
    var x2 = Ea`placeholders`({
        ClassNameIsRequired: "A class name is required.",
        UnexpectedSpace: "Unexpected space in placeholder.",
      }),
      qq = (n) =>
        class extends n {
          parsePlaceholder(t) {
            if (this.match(140)) {
              let i = this.startNode();
              return (
                this.next(),
                this.assertNoSpace(),
                (i.name = super.parseIdentifier(!0)),
                this.assertNoSpace(),
                this.expect(140),
                this.finishPlaceholder(i, t)
              );
            }
          }
          finishPlaceholder(t, i) {
            let r = !!(t.expectedNode && t.type === "Placeholder");
            return (
              (t.expectedNode = i), r ? t : this.finishNode(t, "Placeholder")
            );
          }
          getTokenFromCode(t) {
            return t === 37 && this.input.charCodeAt(this.state.pos + 1) === 37
              ? this.finishOp(140, 2)
              : super.getTokenFromCode(t);
          }
          parseExprAtom(t) {
            return (
              this.parsePlaceholder("Expression") || super.parseExprAtom(t)
            );
          }
          parseIdentifier(t) {
            return (
              this.parsePlaceholder("Identifier") || super.parseIdentifier(t)
            );
          }
          checkReservedWord(t, i, r, s) {
            t !== void 0 && super.checkReservedWord(t, i, r, s);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
          }
          isValidLVal(t, i, r) {
            return t === "Placeholder" || super.isValidLVal(t, i, r);
          }
          toAssignable(t, i) {
            t && t.type === "Placeholder" && t.expectedNode === "Expression"
              ? (t.expectedNode = "Pattern")
              : super.toAssignable(t, i);
          }
          isLet(t) {
            return super.isLet(t)
              ? !0
              : !this.isContextual(99) || t
              ? !1
              : this.lookahead().type === 140;
          }
          verifyBreakContinue(t, i) {
            (t.label && t.label.type === "Placeholder") ||
              super.verifyBreakContinue(t, i);
          }
          parseExpressionStatement(t, i) {
            if (i.type !== "Placeholder" || (i.extra && i.extra.parenthesized))
              return super.parseExpressionStatement(t, i);
            if (this.match(14)) {
              let r = t;
              return (
                (r.label = this.finishPlaceholder(i, "Identifier")),
                this.next(),
                (r.body = super.parseStatement("label")),
                this.finishNode(r, "LabeledStatement")
              );
            }
            return (
              this.semicolon(),
              (t.name = i.name),
              this.finishPlaceholder(t, "Statement")
            );
          }
          parseBlock(t, i, r) {
            return (
              this.parsePlaceholder("BlockStatement") ||
              super.parseBlock(t, i, r)
            );
          }
          parseFunctionId(t) {
            return (
              this.parsePlaceholder("Identifier") || super.parseFunctionId(t)
            );
          }
          parseClass(t, i, r) {
            let s = i ? "ClassDeclaration" : "ClassExpression";
            this.next(), this.takeDecorators(t);
            let a = this.state.strict,
              o = this.parsePlaceholder("Identifier");
            if (o)
              if (this.match(81) || this.match(140) || this.match(5)) t.id = o;
              else {
                if (r || !i)
                  return (
                    (t.id = null),
                    (t.body = this.finishPlaceholder(o, "ClassBody")),
                    this.finishNode(t, s)
                  );
                throw this.raise(x2.ClassNameIsRequired, {
                  at: this.state.startLoc,
                });
              }
            else this.parseClassId(t, i, r);
            return (
              super.parseClassSuper(t),
              (t.body =
                this.parsePlaceholder("ClassBody") ||
                super.parseClassBody(!!t.superClass, a)),
              this.finishNode(t, s)
            );
          }
          parseExport(t) {
            let i = this.parsePlaceholder("Identifier");
            if (!i) return super.parseExport(t);
            if (!this.isContextual(97) && !this.match(12))
              return (
                (t.specifiers = []),
                (t.source = null),
                (t.declaration = this.finishPlaceholder(i, "Declaration")),
                this.finishNode(t, "ExportNamedDeclaration")
              );
            this.expectPlugin("exportDefaultFrom");
            let r = this.startNode();
            return (
              (r.exported = i),
              (t.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")]),
              super.parseExport(t)
            );
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              let t = this.nextTokenStart();
              if (
                this.isUnparsedContextual(t, "from") &&
                this.input.startsWith(So(140), this.nextTokenStartSince(t + 4))
              )
                return !0;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(t) {
            return t.specifiers && t.specifiers.length > 0
              ? !0
              : super.maybeParseExportDefaultSpecifier(t);
          }
          checkExport(t) {
            let { specifiers: i } = t;
            i != null &&
              i.length &&
              (t.specifiers = i.filter(
                (r) => r.exported.type === "Placeholder"
              )),
              super.checkExport(t),
              (t.specifiers = i);
          }
          parseImport(t) {
            let i = this.parsePlaceholder("Identifier");
            if (!i) return super.parseImport(t);
            if (
              ((t.specifiers = []), !this.isContextual(97) && !this.match(12))
            )
              return (
                (t.source = this.finishPlaceholder(i, "StringLiteral")),
                this.semicolon(),
                this.finishNode(t, "ImportDeclaration")
              );
            let r = this.startNodeAtNode(i);
            return (
              (r.local = i),
              t.specifiers.push(this.finishNode(r, "ImportDefaultSpecifier")),
              this.eat(12) &&
                (this.maybeParseStarImportSpecifier(t) ||
                  this.parseNamedImportSpecifiers(t)),
              this.expectContextual(97),
              (t.source = this.parseImportSource()),
              this.semicolon(),
              this.finishNode(t, "ImportDeclaration")
            );
          }
          parseImportSource() {
            return (
              this.parsePlaceholder("StringLiteral") ||
              super.parseImportSource()
            );
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index &&
              this.raise(x2.UnexpectedSpace, { at: this.state.lastTokEndLoc });
          }
        },
      jq = (n) =>
        class extends n {
          parseV8Intrinsic() {
            if (this.match(54)) {
              let t = this.state.startLoc,
                i = this.startNode();
              if ((this.next(), pi(this.state.type))) {
                let r = this.parseIdentifierName(this.state.start),
                  s = this.createIdentifier(i, r);
                if (((s.type = "V8IntrinsicIdentifier"), this.match(10)))
                  return s;
              }
              this.unexpected(t);
            }
          }
          parseExprAtom(t) {
            return this.parseV8Intrinsic() || super.parseExprAtom(t);
          }
        };
    function On(n, e) {
      let [t, i] = typeof e == "string" ? [e, {}] : e,
        r = Object.keys(i),
        s = r.length === 0;
      return n.some((a) => {
        if (typeof a == "string") return s && a === t;
        {
          let [o, l] = a;
          if (o !== t) return !1;
          for (let c of r) if (l[c] !== i[c]) return !1;
          return !0;
        }
      });
    }
    function lf(n, e, t) {
      let i = n.find((r) => (Array.isArray(r) ? r[0] === e : r === e));
      return i && Array.isArray(i) ? i[1][t] : null;
    }
    var b2 = ["minimal", "fsharp", "hack", "smart"],
      _2 = ["^^", "@@", "^", "%", "#"],
      E2 = ["hash", "bar"];
    function Xq(n) {
      if (On(n, "decorators")) {
        if (On(n, "decorators-legacy"))
          throw new Error(
            "Cannot use the decorators and decorators-legacy plugin together"
          );
        let e = lf(n, "decorators", "decoratorsBeforeExport");
        if (e == null)
          throw new Error(
            "The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'."
          );
        if (typeof e != "boolean")
          throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
      if (On(n, "flow") && On(n, "typescript"))
        throw new Error("Cannot combine flow and typescript plugins.");
      if (On(n, "placeholders") && On(n, "v8intrinsic"))
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      if (On(n, "pipelineOperator")) {
        let e = lf(n, "pipelineOperator", "proposal");
        if (!b2.includes(e)) {
          let i = b2.map((r) => `"${r}"`).join(", ");
          throw new Error(
            `"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`
          );
        }
        let t = On(n, ["recordAndTuple", { syntaxType: "hash" }]);
        if (e === "hack") {
          if (On(n, "placeholders"))
            throw new Error(
              "Cannot combine placeholders plugin and Hack-style pipes."
            );
          if (On(n, "v8intrinsic"))
            throw new Error(
              "Cannot combine v8intrinsic plugin and Hack-style pipes."
            );
          let i = lf(n, "pipelineOperator", "topicToken");
          if (!_2.includes(i)) {
            let r = _2.map((s) => `"${s}"`).join(", ");
            throw new Error(
              `"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${r}.`
            );
          }
          if (i === "#" && t)
            throw new Error(
              'Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.'
            );
        } else if (e === "smart" && t)
          throw new Error(
            'Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.'
          );
      }
      if (On(n, "moduleAttributes")) {
        if (On(n, "importAssertions"))
          throw new Error(
            "Cannot combine importAssertions and moduleAttributes plugins."
          );
        if (lf(n, "moduleAttributes", "version") !== "may-2020")
          throw new Error(
            "The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'."
          );
      }
      if (
        On(n, "recordAndTuple") &&
        !E2.includes(lf(n, "recordAndTuple", "syntaxType"))
      )
        throw new Error(
          "'recordAndTuple' requires 'syntaxType' option whose value should be one of: " +
            E2.map((e) => `'${e}'`).join(", ")
        );
      if (On(n, "asyncDoExpressions") && !On(n, "doExpressions")) {
        let e = new Error(
          "'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins."
        );
        throw ((e.missingPlugins = "doExpressions"), e);
      }
    }
    var cL = {
        estree: B7,
        jsx: zq,
        flow: Fq,
        typescript: $q,
        v8intrinsic: jq,
        placeholders: qq,
      },
      Yq = Object.keys(cL),
      T2 = {
        sourceType: "script",
        sourceFilename: void 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: !1,
        allowReturnOutsideFunction: !1,
        allowImportExportEverywhere: !1,
        allowSuperOutsideMethod: !1,
        allowUndeclaredExports: !1,
        plugins: [],
        strictMode: null,
        ranges: !1,
        tokens: !1,
        createParenthesizedExpressions: !1,
        errorRecovery: !1,
        attachComment: !0,
      };
    function Kq(n) {
      let e = {};
      for (let t of Object.keys(T2)) e[t] = n && n[t] != null ? n[t] : T2[t];
      return e;
    }
    var Jq = (n, e) => Object.hasOwnProperty.call(n, e) && n[e],
      uL = (n) => (n.type === "ParenthesizedExpression" ? uL(n.expression) : n),
      hL = class extends sL {
        toAssignable(e, t = !1) {
          var i, r;
          let s;
          switch (
            ((e.type === "ParenthesizedExpression" ||
              ((i = e.extra) != null && i.parenthesized)) &&
              ((s = uL(e)),
              t
                ? s.type === "Identifier"
                  ? this.expressionScope.recordArrowParemeterBindingError(
                      ne.InvalidParenthesizedAssignment,
                      { at: e }
                    )
                  : s.type !== "MemberExpression" &&
                    this.raise(ne.InvalidParenthesizedAssignment, { at: e })
                : this.raise(ne.InvalidParenthesizedAssignment, { at: e })),
            e.type)
          ) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              e.type = "ObjectPattern";
              for (let o = 0, l = e.properties.length, c = l - 1; o < l; o++) {
                var a;
                let u = e.properties[o],
                  f = o === c;
                this.toAssignableObjectExpressionProp(u, f, t),
                  f &&
                    u.type === "RestElement" &&
                    (a = e.extra) != null &&
                    a.trailingCommaLoc &&
                    this.raise(ne.RestTrailingComma, {
                      at: e.extra.trailingCommaLoc,
                    });
              }
              break;
            case "ObjectProperty": {
              let { key: o, value: l } = e;
              this.isPrivateName(o) &&
                this.classScope.usePrivateName(
                  this.getPrivateNameSV(o),
                  o.loc.start
                ),
                this.toAssignable(l, t);
              break;
            }
            case "SpreadElement":
              throw new Error(
                "Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller."
              );
            case "ArrayExpression":
              (e.type = "ArrayPattern"),
                this.toAssignableList(
                  e.elements,
                  (r = e.extra) == null ? void 0 : r.trailingCommaLoc,
                  t
                );
              break;
            case "AssignmentExpression":
              e.operator !== "=" &&
                this.raise(ne.MissingEqInAssignment, { at: e.left.loc.end }),
                (e.type = "AssignmentPattern"),
                delete e.operator,
                this.toAssignable(e.left, t);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(s, t);
              break;
          }
        }
        toAssignableObjectExpressionProp(e, t, i) {
          if (e.type === "ObjectMethod")
            this.raise(
              e.kind === "get" || e.kind === "set"
                ? ne.PatternHasAccessor
                : ne.PatternHasMethod,
              { at: e.key }
            );
          else if (e.type === "SpreadElement") {
            e.type = "RestElement";
            let r = e.argument;
            this.checkToRestConversion(r, !1),
              this.toAssignable(r, i),
              t || this.raise(ne.RestTrailingComma, { at: e });
          } else this.toAssignable(e, i);
        }
        toAssignableList(e, t, i) {
          let r = e.length - 1;
          for (let s = 0; s <= r; s++) {
            let a = e[s];
            if (!!a) {
              if (a.type === "SpreadElement") {
                a.type = "RestElement";
                let o = a.argument;
                this.checkToRestConversion(o, !0), this.toAssignable(o, i);
              } else this.toAssignable(a, i);
              a.type === "RestElement" &&
                (s < r
                  ? this.raise(ne.RestTrailingComma, { at: a })
                  : t && this.raise(ne.RestTrailingComma, { at: t }));
            }
          }
        }
        isAssignable(e, t) {
          switch (e.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              return !0;
            case "ObjectExpression": {
              let i = e.properties.length - 1;
              return e.properties.every(
                (r, s) =>
                  r.type !== "ObjectMethod" &&
                  (s === i || r.type !== "SpreadElement") &&
                  this.isAssignable(r)
              );
            }
            case "ObjectProperty":
              return this.isAssignable(e.value);
            case "SpreadElement":
              return this.isAssignable(e.argument);
            case "ArrayExpression":
              return e.elements.every(
                (i) => i === null || this.isAssignable(i)
              );
            case "AssignmentExpression":
              return e.operator === "=";
            case "ParenthesizedExpression":
              return this.isAssignable(e.expression);
            case "MemberExpression":
            case "OptionalMemberExpression":
              return !t;
            default:
              return !1;
          }
        }
        toReferencedList(e, t) {
          return e;
        }
        toReferencedListDeep(e, t) {
          this.toReferencedList(e, t);
          for (let i of e)
            (i == null ? void 0 : i.type) === "ArrayExpression" &&
              this.toReferencedListDeep(i.elements);
        }
        parseSpread(e) {
          let t = this.startNode();
          return (
            this.next(),
            (t.argument = this.parseMaybeAssignAllowIn(e, void 0)),
            this.finishNode(t, "SpreadElement")
          );
        }
        parseRestBinding() {
          let e = this.startNode();
          return (
            this.next(),
            (e.argument = this.parseBindingAtom()),
            this.finishNode(e, "RestElement")
          );
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 0: {
              let e = this.startNode();
              return (
                this.next(),
                (e.elements = this.parseBindingList(3, 93, !0)),
                this.finishNode(e, "ArrayPattern")
              );
            }
            case 5:
              return this.parseObjectLike(8, !0);
          }
          return this.parseIdentifier();
        }
        parseBindingList(e, t, i, r) {
          let s = [],
            a = !0;
          for (; !this.eat(e); )
            if ((a ? (a = !1) : this.expect(12), i && this.match(12)))
              s.push(null);
            else {
              if (this.eat(e)) break;
              if (this.match(21)) {
                if (
                  (s.push(
                    this.parseAssignableListItemTypes(this.parseRestBinding())
                  ),
                  !this.checkCommaAfterRest(t))
                ) {
                  this.expect(e);
                  break;
                }
              } else {
                let o = [];
                for (
                  this.match(26) &&
                  this.hasPlugin("decorators") &&
                  this.raise(ne.UnsupportedParameterDecorator, {
                    at: this.state.startLoc,
                  });
                  this.match(26);

                )
                  o.push(this.parseDecorator());
                s.push(this.parseAssignableListItem(r, o));
              }
            }
          return s;
        }
        parseBindingRestProperty(e) {
          return (
            this.next(),
            (e.argument = this.parseIdentifier()),
            this.checkCommaAfterRest(125),
            this.finishNode(e, "RestElement")
          );
        }
        parseBindingProperty() {
          let e = this.startNode(),
            { type: t, start: i, startLoc: r } = this.state;
          return t === 21
            ? this.parseBindingRestProperty(e)
            : (t === 134
                ? (this.expectPlugin("destructuringPrivate", r),
                  this.classScope.usePrivateName(this.state.value, r),
                  (e.key = this.parsePrivateName()))
                : this.parsePropertyName(e),
              (e.method = !1),
              this.parseObjPropValue(e, i, r, !1, !1, !0, !1));
        }
        parseAssignableListItem(e, t) {
          let i = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(i);
          let r = this.parseMaybeDefault(i.start, i.loc.start, i);
          return t.length && (i.decorators = t), r;
        }
        parseAssignableListItemTypes(e) {
          return e;
        }
        parseMaybeDefault(e, t, i) {
          var r, s, a;
          if (
            ((t = (r = t) != null ? r : this.state.startLoc),
            (e = (s = e) != null ? s : this.state.start),
            (i = (a = i) != null ? a : this.parseBindingAtom()),
            !this.eat(29))
          )
            return i;
          let o = this.startNodeAt(e, t);
          return (
            (o.left = i),
            (o.right = this.parseMaybeAssignAllowIn()),
            this.finishNode(o, "AssignmentPattern")
          );
        }
        isValidLVal(e, t, i) {
          return Jq(
            {
              AssignmentPattern: "left",
              RestElement: "argument",
              ObjectProperty: "value",
              ParenthesizedExpression: "expression",
              ArrayPattern: "elements",
              ObjectPattern: "properties",
            },
            e
          );
        }
        checkLVal(
          e,
          {
            in: t,
            binding: i = Al,
            checkClashes: r = !1,
            strictModeChanged: s = !1,
            allowingSloppyLetBinding: a = !(i & wo),
            hasParenthesizedAncestor: o = !1,
          }
        ) {
          var l;
          let c = e.type;
          if (this.isObjectMethod(e)) return;
          if (c === "MemberExpression") {
            i !== Al && this.raise(ne.InvalidPropertyBindingPattern, { at: e });
            return;
          }
          if (e.type === "Identifier") {
            this.checkIdentifier(e, i, s, a);
            let { name: x } = e;
            r && (r.has(x) ? this.raise(ne.ParamDupe, { at: e }) : r.add(x));
            return;
          }
          let u = this.isValidLVal(
            e.type,
            !(o || ((l = e.extra) != null && l.parenthesized)) &&
              t.type === "AssignmentExpression",
            i
          );
          if (u === !0) return;
          if (u === !1) {
            let x = i === Al ? ne.InvalidLhs : ne.InvalidLhsBinding;
            this.raise(x, {
              at: e,
              ancestor:
                t.type === "UpdateExpression"
                  ? { type: "UpdateExpression", prefix: t.prefix }
                  : { type: t.type },
            });
            return;
          }
          let [f, d] = Array.isArray(u)
              ? u
              : [u, c === "ParenthesizedExpression"],
            m =
              e.type === "ArrayPattern" ||
              e.type === "ObjectPattern" ||
              e.type === "ParenthesizedExpression"
                ? e
                : t;
          for (let x of [].concat(e[f]))
            x &&
              this.checkLVal(x, {
                in: m,
                binding: i,
                checkClashes: r,
                allowingSloppyLetBinding: a,
                strictModeChanged: s,
                hasParenthesizedAncestor: d,
              });
        }
        checkIdentifier(e, t, i = !1, r = !(t & wo)) {
          this.state.strict &&
            (i ? R2(e.name, this.inModule) : L2(e.name)) &&
            (t === Al
              ? this.raise(ne.StrictEvalArguments, {
                  at: e,
                  referenceName: e.name,
                })
              : this.raise(ne.StrictEvalArgumentsBinding, {
                  at: e,
                  bindingName: e.name,
                })),
            !r &&
              e.name === "let" &&
              this.raise(ne.LetInLexicalBinding, { at: e }),
            t & Al || this.declareNameFromIdentifier(e, t);
        }
        declareNameFromIdentifier(e, t) {
          this.scope.declareName(e.name, t, e.loc.start);
        }
        checkToRestConversion(e, t) {
          switch (e.type) {
            case "ParenthesizedExpression":
              this.checkToRestConversion(e.expression, t);
              break;
            case "Identifier":
            case "MemberExpression":
              break;
            case "ArrayExpression":
            case "ObjectExpression":
              if (t) break;
            default:
              this.raise(ne.InvalidRestAssignmentPattern, { at: e });
          }
        }
        checkCommaAfterRest(e) {
          return this.match(12)
            ? (this.raise(
                this.lookaheadCharCode() === e
                  ? ne.RestTrailingComma
                  : ne.ElementAfterRest,
                { at: this.state.startLoc }
              ),
              !0)
            : !1;
        }
      },
      fL = class extends hL {
        checkProto(e, t, i, r) {
          if (
            e.type === "SpreadElement" ||
            this.isObjectMethod(e) ||
            e.computed ||
            e.shorthand
          )
            return;
          let s = e.key;
          if ((s.type === "Identifier" ? s.name : s.value) === "__proto__") {
            if (t) {
              this.raise(ne.RecordNoProto, { at: s });
              return;
            }
            i.used &&
              (r
                ? r.doubleProtoLoc === null && (r.doubleProtoLoc = s.loc.start)
                : this.raise(ne.DuplicateProto, { at: s })),
              (i.used = !0);
          }
        }
        shouldExitDescending(e, t) {
          return e.type === "ArrowFunctionExpression" && e.start === t;
        }
        getExpression() {
          this.enterInitialScopes(), this.nextToken();
          let e = this.parseExpression();
          return (
            this.match(135) || this.unexpected(),
            this.finalizeRemainingComments(),
            (e.comments = this.state.comments),
            (e.errors = this.state.errors),
            this.options.tokens && (e.tokens = this.tokens),
            e
          );
        }
        parseExpression(e, t) {
          return e
            ? this.disallowInAnd(() => this.parseExpressionBase(t))
            : this.allowInAnd(() => this.parseExpressionBase(t));
        }
        parseExpressionBase(e) {
          let t = this.state.start,
            i = this.state.startLoc,
            r = this.parseMaybeAssign(e);
          if (this.match(12)) {
            let s = this.startNodeAt(t, i);
            for (s.expressions = [r]; this.eat(12); )
              s.expressions.push(this.parseMaybeAssign(e));
            return (
              this.toReferencedList(s.expressions),
              this.finishNode(s, "SequenceExpression")
            );
          }
          return r;
        }
        parseMaybeAssignDisallowIn(e, t) {
          return this.disallowInAnd(() => this.parseMaybeAssign(e, t));
        }
        parseMaybeAssignAllowIn(e, t) {
          return this.allowInAnd(() => this.parseMaybeAssign(e, t));
        }
        setOptionalParametersError(e, t) {
          var i;
          e.optionalParametersLoc =
            (i = t == null ? void 0 : t.loc) != null ? i : this.state.startLoc;
        }
        parseMaybeAssign(e, t) {
          let i = this.state.start,
            r = this.state.startLoc;
          if (this.isContextual(105) && this.prodParam.hasYield) {
            let l = this.parseYield();
            return t && (l = t.call(this, l, i, r)), l;
          }
          let s;
          e ? (s = !1) : ((e = new df()), (s = !0));
          let { type: a } = this.state;
          (a === 10 || pi(a)) &&
            (this.state.potentialArrowAt = this.state.start);
          let o = this.parseMaybeConditional(e);
          if ((t && (o = t.call(this, o, i, r)), H7(this.state.type))) {
            let l = this.startNodeAt(i, r),
              c = this.state.value;
            return (
              (l.operator = c),
              this.match(29)
                ? (this.toAssignable(o, !0),
                  (l.left = o),
                  e.doubleProtoLoc != null &&
                    e.doubleProtoLoc.index >= i &&
                    (e.doubleProtoLoc = null),
                  e.shorthandAssignLoc != null &&
                    e.shorthandAssignLoc.index >= i &&
                    (e.shorthandAssignLoc = null),
                  e.privateKeyLoc != null &&
                    e.privateKeyLoc.index >= i &&
                    (this.checkDestructuringPrivate(e),
                    (e.privateKeyLoc = null)))
                : (l.left = o),
              this.next(),
              (l.right = this.parseMaybeAssign()),
              this.checkLVal(o, {
                in: this.finishNode(l, "AssignmentExpression"),
              }),
              l
            );
          } else s && this.checkExpressionErrors(e, !0);
          return o;
        }
        parseMaybeConditional(e) {
          let t = this.state.start,
            i = this.state.startLoc,
            r = this.state.potentialArrowAt,
            s = this.parseExprOps(e);
          return this.shouldExitDescending(s, r)
            ? s
            : this.parseConditional(s, t, i, e);
        }
        parseConditional(e, t, i, r) {
          if (this.eat(17)) {
            let s = this.startNodeAt(t, i);
            return (
              (s.test = e),
              (s.consequent = this.parseMaybeAssignAllowIn()),
              this.expect(14),
              (s.alternate = this.parseMaybeAssign()),
              this.finishNode(s, "ConditionalExpression")
            );
          }
          return e;
        }
        parseMaybeUnaryOrPrivate(e) {
          return this.match(134)
            ? this.parsePrivateName()
            : this.parseMaybeUnary(e);
        }
        parseExprOps(e) {
          let t = this.state.start,
            i = this.state.startLoc,
            r = this.state.potentialArrowAt,
            s = this.parseMaybeUnaryOrPrivate(e);
          return this.shouldExitDescending(s, r)
            ? s
            : this.parseExprOp(s, t, i, -1);
        }
        parseExprOp(e, t, i, r) {
          if (this.isPrivateName(e)) {
            let a = this.getPrivateNameSV(e);
            (r >= vm(58) || !this.prodParam.hasIn || !this.match(58)) &&
              this.raise(ne.PrivateInExpectedIn, { at: e, identifierName: a }),
              this.classScope.usePrivateName(a, e.loc.start);
          }
          let s = this.state.type;
          if (W7(s) && (this.prodParam.hasIn || !this.match(58))) {
            let a = vm(s);
            if (a > r) {
              if (s === 39) {
                if (
                  (this.expectPlugin("pipelineOperator"),
                  this.state.inFSharpPipelineDirectBody)
                )
                  return e;
                this.checkPipelineAtInfixOperator(e, i);
              }
              let o = this.startNodeAt(t, i);
              (o.left = e), (o.operator = this.state.value);
              let l = s === 41 || s === 42,
                c = s === 40;
              if (
                (c && (a = vm(42)),
                this.next(),
                s === 39 &&
                  this.hasPlugin([
                    "pipelineOperator",
                    { proposal: "minimal" },
                  ]) &&
                  this.state.type === 96 &&
                  this.prodParam.hasAwait)
              )
                throw this.raise(ne.UnexpectedAwaitAfterPipelineBody, {
                  at: this.state.startLoc,
                });
              o.right = this.parseExprOpRightExpr(s, a);
              let u = this.finishNode(
                  o,
                  l || c ? "LogicalExpression" : "BinaryExpression"
                ),
                f = this.state.type;
              if ((c && (f === 41 || f === 42)) || (l && f === 40))
                throw this.raise(ne.MixingCoalesceWithLogical, {
                  at: this.state.startLoc,
                });
              return this.parseExprOp(u, t, i, r);
            }
          }
          return e;
        }
        parseExprOpRightExpr(e, t) {
          let i = this.state.start,
            r = this.state.startLoc;
          switch (e) {
            case 39:
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(() =>
                    this.parseHackPipeBody()
                  );
                case "smart":
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(105))
                      throw this.raise(ne.PipeBodyIsTighter, {
                        at: this.state.startLoc,
                      });
                    return this.parseSmartPipelineBodyInStyle(
                      this.parseExprOpBaseRightExpr(e, t),
                      i,
                      r
                    );
                  });
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() =>
                    this.parseFSharpPipelineBody(t)
                  );
              }
            default:
              return this.parseExprOpBaseRightExpr(e, t);
          }
        }
        parseExprOpBaseRightExpr(e, t) {
          let i = this.state.start,
            r = this.state.startLoc;
          return this.parseExprOp(
            this.parseMaybeUnaryOrPrivate(),
            i,
            r,
            K7(e) ? t - 1 : t
          );
        }
        parseHackPipeBody() {
          var e;
          let { startLoc: t } = this.state,
            i = this.parseMaybeAssign();
          return (
            L7.has(i.type) &&
              !((e = i.extra) != null && e.parenthesized) &&
              this.raise(ne.PipeUnparenthesizedBody, { at: t, type: i.type }),
            this.topicReferenceWasUsedInCurrentContext() ||
              this.raise(ne.PipeTopicUnused, { at: t }),
            i
          );
        }
        checkExponentialAfterUnary(e) {
          this.match(57) &&
            this.raise(ne.UnexpectedTokenUnaryExponentiation, {
              at: e.argument,
            });
        }
        parseMaybeUnary(e, t) {
          let i = this.state.start,
            r = this.state.startLoc,
            s = this.isContextual(96);
          if (s && this.isAwaitAllowed()) {
            this.next();
            let c = this.parseAwait(i, r);
            return t || this.checkExponentialAfterUnary(c), c;
          }
          let a = this.match(34),
            o = this.startNode();
          if (j7(this.state.type)) {
            (o.operator = this.state.value),
              (o.prefix = !0),
              this.match(72) && this.expectPlugin("throwExpressions");
            let c = this.match(89);
            if (
              (this.next(),
              (o.argument = this.parseMaybeUnary(null, !0)),
              this.checkExpressionErrors(e, !0),
              this.state.strict && c)
            ) {
              let u = o.argument;
              u.type === "Identifier"
                ? this.raise(ne.StrictDelete, { at: o })
                : this.hasPropertyAsPrivateName(u) &&
                  this.raise(ne.DeletePrivateField, { at: o });
            }
            if (!a)
              return (
                t || this.checkExponentialAfterUnary(o),
                this.finishNode(o, "UnaryExpression")
              );
          }
          let l = this.parseUpdate(o, a, e);
          if (s) {
            let { type: c } = this.state;
            if (
              (this.hasPlugin("v8intrinsic")
                ? a_(c)
                : a_(c) && !this.match(54)) &&
              !this.isAmbiguousAwait()
            )
              return (
                this.raiseOverwrite(ne.AwaitNotInAsyncContext, { at: r }),
                this.parseAwait(i, r)
              );
          }
          return l;
        }
        parseUpdate(e, t, i) {
          if (t) {
            let o = e;
            return (
              this.checkLVal(o.argument, {
                in: this.finishNode(o, "UpdateExpression"),
              }),
              e
            );
          }
          let r = this.state.start,
            s = this.state.startLoc,
            a = this.parseExprSubscripts(i);
          if (this.checkExpressionErrors(i, !1)) return a;
          for (; q7(this.state.type) && !this.canInsertSemicolon(); ) {
            let o = this.startNodeAt(r, s);
            (o.operator = this.state.value),
              (o.prefix = !1),
              (o.argument = a),
              this.next(),
              this.checkLVal(a, {
                in: (a = this.finishNode(o, "UpdateExpression")),
              });
          }
          return a;
        }
        parseExprSubscripts(e) {
          let t = this.state.start,
            i = this.state.startLoc,
            r = this.state.potentialArrowAt,
            s = this.parseExprAtom(e);
          return this.shouldExitDescending(s, r)
            ? s
            : this.parseSubscripts(s, t, i);
        }
        parseSubscripts(e, t, i, r) {
          let s = {
            optionalChainMember: !1,
            maybeAsyncArrow: this.atPossibleAsyncArrow(e),
            stop: !1,
          };
          do (e = this.parseSubscript(e, t, i, r, s)), (s.maybeAsyncArrow = !1);
          while (!s.stop);
          return e;
        }
        parseSubscript(e, t, i, r, s) {
          let { type: a } = this.state;
          if (!r && a === 15) return this.parseBind(e, t, i, r, s);
          if (Tm(a)) return this.parseTaggedTemplateExpression(e, t, i, s);
          let o = !1;
          if (a === 18) {
            if (r && this.lookaheadCharCode() === 40) return (s.stop = !0), e;
            (s.optionalChainMember = o = !0), this.next();
          }
          if (!r && this.match(10))
            return this.parseCoverCallAndAsyncArrowHead(e, t, i, s, o);
          {
            let l = this.eat(0);
            return l || o || this.eat(16)
              ? this.parseMember(e, t, i, s, l, o)
              : ((s.stop = !0), e);
          }
        }
        parseMember(e, t, i, r, s, a) {
          let o = this.startNodeAt(t, i);
          return (
            (o.object = e),
            (o.computed = s),
            s
              ? ((o.property = this.parseExpression()), this.expect(3))
              : this.match(134)
              ? (e.type === "Super" &&
                  this.raise(ne.SuperPrivateField, { at: i }),
                this.classScope.usePrivateName(
                  this.state.value,
                  this.state.startLoc
                ),
                (o.property = this.parsePrivateName()))
              : (o.property = this.parseIdentifier(!0)),
            r.optionalChainMember
              ? ((o.optional = a),
                this.finishNode(o, "OptionalMemberExpression"))
              : this.finishNode(o, "MemberExpression")
          );
        }
        parseBind(e, t, i, r, s) {
          let a = this.startNodeAt(t, i);
          return (
            (a.object = e),
            this.next(),
            (a.callee = this.parseNoCallExpr()),
            (s.stop = !0),
            this.parseSubscripts(this.finishNode(a, "BindExpression"), t, i, r)
          );
        }
        parseCoverCallAndAsyncArrowHead(e, t, i, r, s) {
          let a = this.state.maybeInArrowParameters,
            o = null;
          (this.state.maybeInArrowParameters = !0), this.next();
          let l = this.startNodeAt(t, i);
          l.callee = e;
          let { maybeAsyncArrow: c, optionalChainMember: u } = r;
          c && (this.expressionScope.enter(Pq()), (o = new df())),
            u && (l.optional = s),
            s
              ? (l.arguments = this.parseCallExpressionArguments(11))
              : (l.arguments = this.parseCallExpressionArguments(
                  11,
                  e.type === "Import",
                  e.type !== "Super",
                  l,
                  o
                ));
          let f = this.finishCallExpression(l, u);
          return (
            c && this.shouldParseAsyncArrow() && !s
              ? ((r.stop = !0),
                this.checkDestructuringPrivate(o),
                this.expressionScope.validateAsPattern(),
                this.expressionScope.exit(),
                (f = this.parseAsyncArrowFromCallExpression(
                  this.startNodeAt(t, i),
                  f
                )))
              : (c &&
                  (this.checkExpressionErrors(o, !0),
                  this.expressionScope.exit()),
                this.toReferencedArguments(f)),
            (this.state.maybeInArrowParameters = a),
            f
          );
        }
        toReferencedArguments(e, t) {
          this.toReferencedListDeep(e.arguments, t);
        }
        parseTaggedTemplateExpression(e, t, i, r) {
          let s = this.startNodeAt(t, i);
          return (
            (s.tag = e),
            (s.quasi = this.parseTemplate(!0)),
            r.optionalChainMember &&
              this.raise(ne.OptionalChainingNoTemplate, { at: i }),
            this.finishNode(s, "TaggedTemplateExpression")
          );
        }
        atPossibleAsyncArrow(e) {
          return (
            e.type === "Identifier" &&
            e.name === "async" &&
            this.state.lastTokEndLoc.index === e.end &&
            !this.canInsertSemicolon() &&
            e.end - e.start === 5 &&
            e.start === this.state.potentialArrowAt
          );
        }
        finishCallExpression(e, t) {
          if (e.callee.type === "Import")
            if (
              (e.arguments.length === 2 &&
                (this.hasPlugin("moduleAttributes") ||
                  this.expectPlugin("importAssertions")),
              e.arguments.length === 0 || e.arguments.length > 2)
            )
              this.raise(ne.ImportCallArity, {
                at: e,
                maxArgumentCount:
                  this.hasPlugin("importAssertions") ||
                  this.hasPlugin("moduleAttributes")
                    ? 2
                    : 1,
              });
            else
              for (let i of e.arguments)
                i.type === "SpreadElement" &&
                  this.raise(ne.ImportCallSpreadArgument, { at: i });
          return this.finishNode(
            e,
            t ? "OptionalCallExpression" : "CallExpression"
          );
        }
        parseCallExpressionArguments(e, t, i, r, s) {
          let a = [],
            o = !0,
            l = this.state.inFSharpPipelineDirectBody;
          for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
            if (o) o = !1;
            else if ((this.expect(12), this.match(e))) {
              t &&
                !this.hasPlugin("importAssertions") &&
                !this.hasPlugin("moduleAttributes") &&
                this.raise(ne.ImportCallArgumentTrailingComma, {
                  at: this.state.lastTokStartLoc,
                }),
                r && this.addTrailingCommaExtraToNode(r),
                this.next();
              break;
            }
            a.push(this.parseExprListItem(!1, s, i));
          }
          return (this.state.inFSharpPipelineDirectBody = l), a;
        }
        shouldParseAsyncArrow() {
          return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(e, t) {
          var i;
          return (
            this.resetPreviousNodeTrailingComments(t),
            this.expect(19),
            this.parseArrowExpression(
              e,
              t.arguments,
              !0,
              (i = t.extra) == null ? void 0 : i.trailingCommaLoc
            ),
            t.innerComments && mf(e, t.innerComments),
            t.callee.trailingComments && mf(e, t.callee.trailingComments),
            e
          );
        }
        parseNoCallExpr() {
          let e = this.state.start,
            t = this.state.startLoc;
          return this.parseSubscripts(this.parseExprAtom(), e, t, !0);
        }
        parseExprAtom(e) {
          let t,
            { type: i } = this.state;
          switch (i) {
            case 79:
              return this.parseSuper();
            case 83:
              return (
                (t = this.startNode()),
                this.next(),
                this.match(16)
                  ? this.parseImportMetaProperty(t)
                  : (this.match(10) ||
                      this.raise(ne.UnsupportedImport, {
                        at: this.state.lastTokStartLoc,
                      }),
                    this.finishNode(t, "Import"))
              );
            case 78:
              return (
                (t = this.startNode()),
                this.next(),
                this.finishNode(t, "ThisExpression")
              );
            case 90:
              return this.parseDo(this.startNode(), !1);
            case 56:
            case 31:
              return (
                this.readRegexp(), this.parseRegExpLiteral(this.state.value)
              );
            case 130:
              return this.parseNumericLiteral(this.state.value);
            case 131:
              return this.parseBigIntLiteral(this.state.value);
            case 132:
              return this.parseDecimalLiteral(this.state.value);
            case 129:
              return this.parseStringLiteral(this.state.value);
            case 84:
              return this.parseNullLiteral();
            case 85:
              return this.parseBooleanLiteral(!0);
            case 86:
              return this.parseBooleanLiteral(!1);
            case 10: {
              let r = this.state.potentialArrowAt === this.state.start;
              return this.parseParenAndDistinguishExpression(r);
            }
            case 2:
            case 1:
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
            case 0:
              return this.parseArrayLike(3, !0, !1, e);
            case 6:
            case 7:
              return this.parseObjectLike(
                this.state.type === 6 ? 9 : 8,
                !1,
                !0
              );
            case 5:
              return this.parseObjectLike(8, !1, !1, e);
            case 68:
              return this.parseFunctionOrFunctionSent();
            case 26:
              this.parseDecorators();
            case 80:
              return (
                (t = this.startNode()),
                this.takeDecorators(t),
                this.parseClass(t, !1)
              );
            case 77:
              return this.parseNewOrNewTarget();
            case 25:
            case 24:
              return this.parseTemplate(!1);
            case 15: {
              (t = this.startNode()), this.next(), (t.object = null);
              let r = (t.callee = this.parseNoCallExpr());
              if (r.type === "MemberExpression")
                return this.finishNode(t, "BindExpression");
              throw this.raise(ne.UnsupportedBind, { at: r });
            }
            case 134:
              return (
                this.raise(ne.PrivateInExpectedIn, {
                  at: this.state.startLoc,
                  identifierName: this.state.value,
                }),
                this.parsePrivateName()
              );
            case 33:
              return this.parseTopicReferenceThenEqualsSign(54, "%");
            case 32:
              return this.parseTopicReferenceThenEqualsSign(44, "^");
            case 37:
            case 38:
              return this.parseTopicReference("hack");
            case 44:
            case 54:
            case 27: {
              let r = this.getPluginOption("pipelineOperator", "proposal");
              if (r) return this.parseTopicReference(r);
              throw this.unexpected();
            }
            case 47: {
              let r = this.input.codePointAt(this.nextTokenStart());
              if (_a(r) || r === 62) {
                this.expectOnePlugin(["jsx", "flow", "typescript"]);
                break;
              } else throw this.unexpected();
            }
            default:
              if (pi(i)) {
                if (
                  this.isContextual(123) &&
                  this.lookaheadCharCode() === 123 &&
                  !this.hasFollowingLineBreak()
                )
                  return this.parseModuleExpression();
                let r = this.state.potentialArrowAt === this.state.start,
                  s = this.state.containsEsc,
                  a = this.parseIdentifier();
                if (!s && a.name === "async" && !this.canInsertSemicolon()) {
                  let { type: o } = this.state;
                  if (o === 68)
                    return (
                      this.resetPreviousNodeTrailingComments(a),
                      this.next(),
                      this.parseFunction(this.startNodeAtNode(a), void 0, !0)
                    );
                  if (pi(o))
                    return this.lookaheadCharCode() === 61
                      ? this.parseAsyncArrowUnaryFunction(
                          this.startNodeAtNode(a)
                        )
                      : a;
                  if (o === 90)
                    return (
                      this.resetPreviousNodeTrailingComments(a),
                      this.parseDo(this.startNodeAtNode(a), !0)
                    );
                }
                return r && this.match(19) && !this.canInsertSemicolon()
                  ? (this.next(),
                    this.parseArrowExpression(this.startNodeAtNode(a), [a], !1))
                  : a;
              } else throw this.unexpected();
          }
        }
        parseTopicReferenceThenEqualsSign(e, t) {
          let i = this.getPluginOption("pipelineOperator", "proposal");
          if (i)
            return (
              (this.state.type = e),
              (this.state.value = t),
              this.state.pos--,
              this.state.end--,
              (this.state.endLoc = Sr(this.state.endLoc, -1)),
              this.parseTopicReference(i)
            );
          throw this.unexpected();
        }
        parseTopicReference(e) {
          let t = this.startNode(),
            i = this.state.startLoc,
            r = this.state.type;
          return this.next(), this.finishTopicReference(t, i, e, r);
        }
        finishTopicReference(e, t, i, r) {
          if (this.testTopicReferenceConfiguration(i, t, r)) {
            let s =
              i === "smart"
                ? "PipelinePrimaryTopicReference"
                : "TopicReference";
            return (
              this.topicReferenceIsAllowedInCurrentContext() ||
                this.raise(
                  i === "smart"
                    ? ne.PrimaryTopicNotAllowed
                    : ne.PipeTopicUnbound,
                  { at: t }
                ),
              this.registerTopicReference(),
              this.finishNode(e, s)
            );
          } else
            throw this.raise(ne.PipeTopicUnconfiguredToken, {
              at: t,
              token: So(r),
            });
        }
        testTopicReferenceConfiguration(e, t, i) {
          switch (e) {
            case "hack":
              return this.hasPlugin([
                "pipelineOperator",
                { topicToken: So(i) },
              ]);
            case "smart":
              return i === 27;
            default:
              throw this.raise(ne.PipeTopicRequiresHackPipes, { at: t });
          }
        }
        parseAsyncArrowUnaryFunction(e) {
          this.prodParam.enter(_m(!0, this.prodParam.hasYield));
          let t = [this.parseIdentifier()];
          return (
            this.prodParam.exit(),
            this.hasPrecedingLineBreak() &&
              this.raise(ne.LineTerminatorBeforeArrow, {
                at: this.state.curPosition(),
              }),
            this.expect(19),
            this.parseArrowExpression(e, t, !0)
          );
        }
        parseDo(e, t) {
          this.expectPlugin("doExpressions"),
            t && this.expectPlugin("asyncDoExpressions"),
            (e.async = t),
            this.next();
          let i = this.state.labels;
          return (
            (this.state.labels = []),
            t
              ? (this.prodParam.enter(Im),
                (e.body = this.parseBlock()),
                this.prodParam.exit())
              : (e.body = this.parseBlock()),
            (this.state.labels = i),
            this.finishNode(e, "DoExpression")
          );
        }
        parseSuper() {
          let e = this.startNode();
          return (
            this.next(),
            this.match(10) &&
            !this.scope.allowDirectSuper &&
            !this.options.allowSuperOutsideMethod
              ? this.raise(ne.SuperNotAllowed, { at: e })
              : !this.scope.allowSuper &&
                !this.options.allowSuperOutsideMethod &&
                this.raise(ne.UnexpectedSuper, { at: e }),
            !this.match(10) &&
              !this.match(0) &&
              !this.match(16) &&
              this.raise(ne.UnsupportedSuper, { at: e }),
            this.finishNode(e, "Super")
          );
        }
        parsePrivateName() {
          let e = this.startNode(),
            t = this.startNodeAt(
              this.state.start + 1,
              new Aa(
                this.state.curLine,
                this.state.start + 1 - this.state.lineStart,
                this.state.start + 1
              )
            ),
            i = this.state.value;
          return (
            this.next(),
            (e.id = this.createIdentifier(t, i)),
            this.finishNode(e, "PrivateName")
          );
        }
        parseFunctionOrFunctionSent() {
          let e = this.startNode();
          if ((this.next(), this.prodParam.hasYield && this.match(16))) {
            let t = this.createIdentifier(this.startNodeAtNode(e), "function");
            return (
              this.next(),
              this.match(102)
                ? this.expectPlugin("functionSent")
                : this.hasPlugin("functionSent") || this.unexpected(),
              this.parseMetaProperty(e, t, "sent")
            );
          }
          return this.parseFunction(e);
        }
        parseMetaProperty(e, t, i) {
          e.meta = t;
          let r = this.state.containsEsc;
          return (
            (e.property = this.parseIdentifier(!0)),
            (e.property.name !== i || r) &&
              this.raise(ne.UnsupportedMetaProperty, {
                at: e.property,
                target: t.name,
                onlyValidPropertyName: i,
              }),
            this.finishNode(e, "MetaProperty")
          );
        }
        parseImportMetaProperty(e) {
          let t = this.createIdentifier(this.startNodeAtNode(e), "import");
          return (
            this.next(),
            this.isContextual(100) &&
              (this.inModule ||
                this.raise(ne.ImportMetaOutsideModule, { at: t }),
              (this.sawUnambiguousESM = !0)),
            this.parseMetaProperty(e, t, "meta")
          );
        }
        parseLiteralAtNode(e, t, i) {
          return (
            this.addExtra(i, "rawValue", e),
            this.addExtra(i, "raw", this.input.slice(i.start, this.state.end)),
            (i.value = e),
            this.next(),
            this.finishNode(i, t)
          );
        }
        parseLiteral(e, t) {
          let i = this.startNode();
          return this.parseLiteralAtNode(e, t, i);
        }
        parseStringLiteral(e) {
          return this.parseLiteral(e, "StringLiteral");
        }
        parseNumericLiteral(e) {
          return this.parseLiteral(e, "NumericLiteral");
        }
        parseBigIntLiteral(e) {
          return this.parseLiteral(e, "BigIntLiteral");
        }
        parseDecimalLiteral(e) {
          return this.parseLiteral(e, "DecimalLiteral");
        }
        parseRegExpLiteral(e) {
          let t = this.parseLiteral(e.value, "RegExpLiteral");
          return (t.pattern = e.pattern), (t.flags = e.flags), t;
        }
        parseBooleanLiteral(e) {
          let t = this.startNode();
          return (
            (t.value = e), this.next(), this.finishNode(t, "BooleanLiteral")
          );
        }
        parseNullLiteral() {
          let e = this.startNode();
          return this.next(), this.finishNode(e, "NullLiteral");
        }
        parseParenAndDistinguishExpression(e) {
          let t = this.state.start,
            i = this.state.startLoc,
            r;
          this.next(), this.expressionScope.enter(Cq());
          let s = this.state.maybeInArrowParameters,
            a = this.state.inFSharpPipelineDirectBody;
          (this.state.maybeInArrowParameters = !0),
            (this.state.inFSharpPipelineDirectBody = !1);
          let o = this.state.start,
            l = this.state.startLoc,
            c = [],
            u = new df(),
            f = !0,
            d,
            m;
          for (; !this.match(11); ) {
            if (f) f = !1;
            else if (
              (this.expect(
                12,
                u.optionalParametersLoc === null
                  ? null
                  : u.optionalParametersLoc
              ),
              this.match(11))
            ) {
              m = this.state.startLoc;
              break;
            }
            if (this.match(21)) {
              let g = this.state.start,
                b = this.state.startLoc;
              if (
                ((d = this.state.startLoc),
                c.push(this.parseParenItem(this.parseRestBinding(), g, b)),
                !this.checkCommaAfterRest(41))
              )
                break;
            } else c.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
          }
          let x = this.state.lastTokEndLoc;
          this.expect(11),
            (this.state.maybeInArrowParameters = s),
            (this.state.inFSharpPipelineDirectBody = a);
          let y = this.startNodeAt(t, i);
          return e && this.shouldParseArrow(c) && (y = this.parseArrow(y))
            ? (this.checkDestructuringPrivate(u),
              this.expressionScope.validateAsPattern(),
              this.expressionScope.exit(),
              this.parseArrowExpression(y, c, !1),
              y)
            : (this.expressionScope.exit(),
              c.length || this.unexpected(this.state.lastTokStartLoc),
              m && this.unexpected(m),
              d && this.unexpected(d),
              this.checkExpressionErrors(u, !0),
              this.toReferencedListDeep(c, !0),
              c.length > 1
                ? ((r = this.startNodeAt(o, l)),
                  (r.expressions = c),
                  this.finishNode(r, "SequenceExpression"),
                  this.resetEndLocation(r, x))
                : (r = c[0]),
              this.wrapParenthesis(t, i, r));
        }
        wrapParenthesis(e, t, i) {
          if (!this.options.createParenthesizedExpressions)
            return (
              this.addExtra(i, "parenthesized", !0),
              this.addExtra(i, "parenStart", e),
              this.takeSurroundingComments(
                i,
                e,
                this.state.lastTokEndLoc.index
              ),
              i
            );
          let r = this.startNodeAt(e, t);
          return (
            (r.expression = i), this.finishNode(r, "ParenthesizedExpression")
          );
        }
        shouldParseArrow(e) {
          return !this.canInsertSemicolon();
        }
        parseArrow(e) {
          if (this.eat(19)) return e;
        }
        parseParenItem(e, t, i) {
          return e;
        }
        parseNewOrNewTarget() {
          let e = this.startNode();
          if ((this.next(), this.match(16))) {
            let t = this.createIdentifier(this.startNodeAtNode(e), "new");
            this.next();
            let i = this.parseMetaProperty(e, t, "target");
            return (
              !this.scope.inNonArrowFunction &&
                !this.scope.inClass &&
                this.raise(ne.UnexpectedNewTarget, { at: i }),
              i
            );
          }
          return this.parseNew(e);
        }
        parseNew(e) {
          if ((this.parseNewCallee(e), this.eat(10))) {
            let t = this.parseExprList(11);
            this.toReferencedList(t), (e.arguments = t);
          } else e.arguments = [];
          return this.finishNode(e, "NewExpression");
        }
        parseNewCallee(e) {
          (e.callee = this.parseNoCallExpr()),
            e.callee.type === "Import"
              ? this.raise(ne.ImportCallNotNewExpression, { at: e.callee })
              : this.isOptionalChain(e.callee)
              ? this.raise(ne.OptionalChainingNoNew, {
                  at: this.state.lastTokEndLoc,
                })
              : this.eat(18) &&
                this.raise(ne.OptionalChainingNoNew, {
                  at: this.state.startLoc,
                });
        }
        parseTemplateElement(e) {
          let { start: t, startLoc: i, end: r, value: s } = this.state,
            a = t + 1,
            o = this.startNodeAt(a, Sr(i, 1));
          s === null &&
            (e ||
              this.raise(ne.InvalidEscapeSequenceTemplate, { at: Sr(i, 2) }));
          let l = this.match(24),
            c = l ? -1 : -2,
            u = r + c;
          (o.value = {
            raw: this.input.slice(a, u).replace(
              /\r\n?/g,
              `
`
            ),
            cooked: s === null ? null : s.slice(1, c),
          }),
            (o.tail = l),
            this.next();
          let f = this.finishNode(o, "TemplateElement");
          return this.resetEndLocation(f, Sr(this.state.lastTokEndLoc, c)), f;
        }
        parseTemplate(e) {
          let t = this.startNode();
          t.expressions = [];
          let i = this.parseTemplateElement(e);
          for (t.quasis = [i]; !i.tail; )
            t.expressions.push(this.parseTemplateSubstitution()),
              this.readTemplateContinuation(),
              t.quasis.push((i = this.parseTemplateElement(e)));
          return this.finishNode(t, "TemplateLiteral");
        }
        parseTemplateSubstitution() {
          return this.parseExpression();
        }
        parseObjectLike(e, t, i, r) {
          i && this.expectPlugin("recordAndTuple");
          let s = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !1;
          let a = Object.create(null),
            o = !0,
            l = this.startNode();
          for (l.properties = [], this.next(); !this.match(e); ) {
            if (o) o = !1;
            else if ((this.expect(12), this.match(e))) {
              this.addTrailingCommaExtraToNode(l);
              break;
            }
            let u;
            t
              ? (u = this.parseBindingProperty())
              : ((u = this.parsePropertyDefinition(r)),
                this.checkProto(u, i, a, r)),
              i &&
                !this.isObjectProperty(u) &&
                u.type !== "SpreadElement" &&
                this.raise(ne.InvalidRecordProperty, { at: u }),
              u.shorthand && this.addExtra(u, "shorthand", !0),
              l.properties.push(u);
          }
          this.next(), (this.state.inFSharpPipelineDirectBody = s);
          let c = "ObjectExpression";
          return (
            t ? (c = "ObjectPattern") : i && (c = "RecordExpression"),
            this.finishNode(l, c)
          );
        }
        addTrailingCommaExtraToNode(e) {
          this.addExtra(e, "trailingComma", this.state.lastTokStart),
            this.addExtra(
              e,
              "trailingCommaLoc",
              this.state.lastTokStartLoc,
              !1
            );
        }
        maybeAsyncOrAccessorProp(e) {
          return (
            !e.computed &&
            e.key.type === "Identifier" &&
            (this.isLiteralPropertyName() || this.match(0) || this.match(55))
          );
        }
        parsePropertyDefinition(e) {
          let t = [];
          if (this.match(26))
            for (
              this.hasPlugin("decorators") &&
              this.raise(ne.UnsupportedPropertyDecorator, {
                at: this.state.startLoc,
              });
              this.match(26);

            )
              t.push(this.parseDecorator());
          let i = this.startNode(),
            r = !1,
            s = !1,
            a,
            o;
          if (this.match(21))
            return t.length && this.unexpected(), this.parseSpread();
          t.length && ((i.decorators = t), (t = [])),
            (i.method = !1),
            e && ((a = this.state.start), (o = this.state.startLoc));
          let l = this.eat(55);
          this.parsePropertyNamePrefixOperator(i);
          let c = this.state.containsEsc,
            u = this.parsePropertyName(i, e);
          if (!l && !c && this.maybeAsyncOrAccessorProp(i)) {
            let f = u.name;
            f === "async" &&
              !this.hasPrecedingLineBreak() &&
              ((r = !0),
              this.resetPreviousNodeTrailingComments(u),
              (l = this.eat(55)),
              this.parsePropertyName(i)),
              (f === "get" || f === "set") &&
                ((s = !0),
                this.resetPreviousNodeTrailingComments(u),
                (i.kind = f),
                this.match(55) &&
                  ((l = !0),
                  this.raise(ne.AccessorIsGenerator, {
                    at: this.state.curPosition(),
                    kind: f,
                  }),
                  this.next()),
                this.parsePropertyName(i));
          }
          return this.parseObjPropValue(i, a, o, l, r, !1, s, e);
        }
        getGetterSetterExpectedParamCount(e) {
          return e.kind === "get" ? 0 : 1;
        }
        getObjectOrClassMethodParams(e) {
          return e.params;
        }
        checkGetterSetterParams(e) {
          var t;
          let i = this.getGetterSetterExpectedParamCount(e),
            r = this.getObjectOrClassMethodParams(e);
          r.length !== i &&
            this.raise(
              e.kind === "get" ? ne.BadGetterArity : ne.BadSetterArity,
              { at: e }
            ),
            e.kind === "set" &&
              ((t = r[r.length - 1]) == null ? void 0 : t.type) ===
                "RestElement" &&
              this.raise(ne.BadSetterRestParameter, { at: e });
        }
        parseObjectMethod(e, t, i, r, s) {
          if (s) {
            let a = this.parseMethod(e, t, !1, !1, !1, "ObjectMethod");
            return this.checkGetterSetterParams(a), a;
          }
          if (i || t || this.match(10))
            return (
              r && this.unexpected(),
              (e.kind = "method"),
              (e.method = !0),
              this.parseMethod(e, t, i, !1, !1, "ObjectMethod")
            );
        }
        parseObjectProperty(e, t, i, r, s) {
          if (((e.shorthand = !1), this.eat(14)))
            return (
              (e.value = r
                ? this.parseMaybeDefault(this.state.start, this.state.startLoc)
                : this.parseMaybeAssignAllowIn(s)),
              this.finishNode(e, "ObjectProperty")
            );
          if (!e.computed && e.key.type === "Identifier") {
            if (
              (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), r)
            )
              e.value = this.parseMaybeDefault(t, i, Ma(e.key));
            else if (this.match(29)) {
              let a = this.state.startLoc;
              s != null
                ? s.shorthandAssignLoc === null && (s.shorthandAssignLoc = a)
                : this.raise(ne.InvalidCoverInitializedName, { at: a }),
                (e.value = this.parseMaybeDefault(t, i, Ma(e.key)));
            } else e.value = Ma(e.key);
            return (e.shorthand = !0), this.finishNode(e, "ObjectProperty");
          }
        }
        parseObjPropValue(e, t, i, r, s, a, o, l) {
          let c =
            this.parseObjectMethod(e, r, s, a, o) ||
            this.parseObjectProperty(e, t, i, a, l);
          return c || this.unexpected(), c;
        }
        parsePropertyName(e, t) {
          if (this.eat(0))
            (e.computed = !0),
              (e.key = this.parseMaybeAssignAllowIn()),
              this.expect(3);
          else {
            let { type: i, value: r } = this.state,
              s;
            if (wa(i)) s = this.parseIdentifier(!0);
            else
              switch (i) {
                case 130:
                  s = this.parseNumericLiteral(r);
                  break;
                case 129:
                  s = this.parseStringLiteral(r);
                  break;
                case 131:
                  s = this.parseBigIntLiteral(r);
                  break;
                case 132:
                  s = this.parseDecimalLiteral(r);
                  break;
                case 134: {
                  let a = this.state.startLoc;
                  t != null
                    ? t.privateKeyLoc === null && (t.privateKeyLoc = a)
                    : this.raise(ne.UnexpectedPrivateField, { at: a }),
                    (s = this.parsePrivateName());
                  break;
                }
                default:
                  throw this.unexpected();
              }
            (e.key = s), i !== 134 && (e.computed = !1);
          }
          return e.key;
        }
        initFunction(e, t) {
          (e.id = null), (e.generator = !1), (e.async = !!t);
        }
        parseMethod(e, t, i, r, s, a, o = !1) {
          this.initFunction(e, i), (e.generator = !!t);
          let l = r;
          this.scope.enter(Ta | Sm | (o ? Cl : 0) | (s ? N2 : 0)),
            this.prodParam.enter(_m(i, e.generator)),
            this.parseFunctionParams(e, l);
          let c = this.parseFunctionBodyAndFinish(e, a, !0);
          return this.prodParam.exit(), this.scope.exit(), c;
        }
        parseArrayLike(e, t, i, r) {
          i && this.expectPlugin("recordAndTuple");
          let s = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !1;
          let a = this.startNode();
          return (
            this.next(),
            (a.elements = this.parseExprList(e, !i, r, a)),
            (this.state.inFSharpPipelineDirectBody = s),
            this.finishNode(a, i ? "TupleExpression" : "ArrayExpression")
          );
        }
        parseArrowExpression(e, t, i, r) {
          this.scope.enter(Ta | T_);
          let s = _m(i, !1);
          !this.match(5) && this.prodParam.hasIn && (s |= Kc),
            this.prodParam.enter(s),
            this.initFunction(e, i);
          let a = this.state.maybeInArrowParameters;
          return (
            t &&
              ((this.state.maybeInArrowParameters = !0),
              this.setArrowFunctionParameters(e, t, r)),
            (this.state.maybeInArrowParameters = !1),
            this.parseFunctionBody(e, !0),
            this.prodParam.exit(),
            this.scope.exit(),
            (this.state.maybeInArrowParameters = a),
            this.finishNode(e, "ArrowFunctionExpression")
          );
        }
        setArrowFunctionParameters(e, t, i) {
          this.toAssignableList(t, i, !1), (e.params = t);
        }
        parseFunctionBodyAndFinish(e, t, i = !1) {
          return this.parseFunctionBody(e, !1, i), this.finishNode(e, t);
        }
        parseFunctionBody(e, t, i = !1) {
          let r = t && !this.match(5);
          if ((this.expressionScope.enter(eL()), r))
            (e.body = this.parseMaybeAssign()), this.checkParams(e, !1, t, !1);
          else {
            let s = this.state.strict,
              a = this.state.labels;
            (this.state.labels = []),
              this.prodParam.enter(this.prodParam.currentFlags() | iL),
              (e.body = this.parseBlock(!0, !1, (o) => {
                let l = !this.isSimpleParamList(e.params);
                o &&
                  l &&
                  this.raise(ne.IllegalLanguageModeDirective, {
                    at:
                      (e.kind === "method" || e.kind === "constructor") &&
                      !!e.key
                        ? e.key.loc.end
                        : e,
                  });
                let c = !s && this.state.strict;
                this.checkParams(e, !this.state.strict && !t && !i && !l, t, c),
                  this.state.strict &&
                    e.id &&
                    this.checkIdentifier(e.id, cq, c);
              })),
              this.prodParam.exit(),
              (this.state.labels = a);
          }
          this.expressionScope.exit();
        }
        isSimpleParameter(e) {
          return e.type === "Identifier";
        }
        isSimpleParamList(e) {
          for (let t = 0, i = e.length; t < i; t++)
            if (!this.isSimpleParameter(e[t])) return !1;
          return !0;
        }
        checkParams(e, t, i, r = !0) {
          let s = !t && new Set(),
            a = { type: "FormalParameters" };
          for (let o of e.params)
            this.checkLVal(o, {
              in: a,
              binding: Mm,
              checkClashes: s,
              strictModeChanged: r,
            });
        }
        parseExprList(e, t, i, r) {
          let s = [],
            a = !0;
          for (; !this.eat(e); ) {
            if (a) a = !1;
            else if ((this.expect(12), this.match(e))) {
              r && this.addTrailingCommaExtraToNode(r), this.next();
              break;
            }
            s.push(this.parseExprListItem(t, i));
          }
          return s;
        }
        parseExprListItem(e, t, i) {
          let r;
          if (this.match(12))
            e ||
              this.raise(ne.UnexpectedToken, {
                at: this.state.curPosition(),
                unexpected: ",",
              }),
              (r = null);
          else if (this.match(21)) {
            let s = this.state.start,
              a = this.state.startLoc;
            r = this.parseParenItem(this.parseSpread(t), s, a);
          } else if (this.match(17)) {
            this.expectPlugin("partialApplication"),
              i ||
                this.raise(ne.UnexpectedArgumentPlaceholder, {
                  at: this.state.startLoc,
                });
            let s = this.startNode();
            this.next(), (r = this.finishNode(s, "ArgumentPlaceholder"));
          } else r = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
          return r;
        }
        parseIdentifier(e) {
          let t = this.startNode(),
            i = this.parseIdentifierName(t.start, e);
          return this.createIdentifier(t, i);
        }
        createIdentifier(e, t) {
          return (
            (e.name = t),
            (e.loc.identifierName = t),
            this.finishNode(e, "Identifier")
          );
        }
        parseIdentifierName(e, t) {
          let i,
            { startLoc: r, type: s } = this.state;
          if (wa(s)) i = this.state.value;
          else throw this.unexpected();
          let a = V7(s);
          return (
            t
              ? a && this.replaceToken(128)
              : this.checkReservedWord(i, r, a, !1),
            this.next(),
            i
          );
        }
        checkReservedWord(e, t, i, r) {
          if (e.length > 10 || !aq(e)) return;
          if (e === "yield") {
            if (this.prodParam.hasYield) {
              this.raise(ne.YieldBindingIdentifier, { at: t });
              return;
            }
          } else if (e === "await") {
            if (this.prodParam.hasAwait) {
              this.raise(ne.AwaitBindingIdentifier, { at: t });
              return;
            }
            if (this.scope.inStaticBlock) {
              this.raise(ne.AwaitBindingIdentifierInStaticBlock, { at: t });
              return;
            }
            this.expressionScope.recordAsyncArrowParametersError({ at: t });
          } else if (
            e === "arguments" &&
            this.scope.inClassAndNotInNonArrowFunction
          ) {
            this.raise(ne.ArgumentsInClass, { at: t });
            return;
          }
          if (i && nq(e)) {
            this.raise(ne.UnexpectedKeyword, { at: t, keyword: e });
            return;
          }
          (this.state.strict ? (r ? R2 : I2) : D2)(e, this.inModule) &&
            this.raise(ne.UnexpectedReservedWord, { at: t, reservedWord: e });
        }
        isAwaitAllowed() {
          return !!(
            this.prodParam.hasAwait ||
            (this.options.allowAwaitOutsideFunction && !this.scope.inFunction)
          );
        }
        parseAwait(e, t) {
          let i = this.startNodeAt(e, t);
          return (
            this.expressionScope.recordParameterInitializerError(
              ne.AwaitExpressionFormalParameter,
              { at: i }
            ),
            this.eat(55) && this.raise(ne.ObsoleteAwaitStar, { at: i }),
            !this.scope.inFunction &&
              !this.options.allowAwaitOutsideFunction &&
              (this.isAmbiguousAwait()
                ? (this.ambiguousScriptDifferentAst = !0)
                : (this.sawUnambiguousESM = !0)),
            this.state.soloAwait ||
              (i.argument = this.parseMaybeUnary(null, !0)),
            this.finishNode(i, "AwaitExpression")
          );
        }
        isAmbiguousAwait() {
          if (this.hasPrecedingLineBreak()) return !0;
          let { type: e } = this.state;
          return (
            e === 53 ||
            e === 10 ||
            e === 0 ||
            Tm(e) ||
            e === 133 ||
            e === 56 ||
            (this.hasPlugin("v8intrinsic") && e === 54)
          );
        }
        parseYield() {
          let e = this.startNode();
          this.expressionScope.recordParameterInitializerError(
            ne.YieldInParameter,
            { at: e }
          ),
            this.next();
          let t = !1,
            i = null;
          if (!this.hasPrecedingLineBreak())
            switch (((t = this.eat(55)), this.state.type)) {
              case 13:
              case 135:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!t) break;
              default:
                i = this.parseMaybeAssign();
            }
          return (
            (e.delegate = t),
            (e.argument = i),
            this.finishNode(e, "YieldExpression")
          );
        }
        checkPipelineAtInfixOperator(e, t) {
          this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) &&
            e.type === "SequenceExpression" &&
            this.raise(ne.PipelineHeadSequenceExpression, { at: t });
        }
        parseSmartPipelineBodyInStyle(e, t, i) {
          if (this.isSimpleReference(e)) {
            let r = this.startNodeAt(t, i);
            return (r.callee = e), this.finishNode(r, "PipelineBareFunction");
          } else {
            let r = this.startNodeAt(t, i);
            return (
              this.checkSmartPipeTopicBodyEarlyErrors(i),
              (r.expression = e),
              this.finishNode(r, "PipelineTopicExpression")
            );
          }
        }
        isSimpleReference(e) {
          switch (e.type) {
            case "MemberExpression":
              return !e.computed && this.isSimpleReference(e.object);
            case "Identifier":
              return !0;
            default:
              return !1;
          }
        }
        checkSmartPipeTopicBodyEarlyErrors(e) {
          if (this.match(19))
            throw this.raise(ne.PipelineBodyNoArrow, {
              at: this.state.startLoc,
            });
          this.topicReferenceWasUsedInCurrentContext() ||
            this.raise(ne.PipelineTopicUnused, { at: e });
        }
        withTopicBindingContext(e) {
          let t = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null,
          };
          try {
            return e();
          } finally {
            this.state.topicContext = t;
          }
        }
        withSmartMixTopicForbiddingContext(e) {
          if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
            let t = this.state.topicContext;
            this.state.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null,
            };
            try {
              return e();
            } finally {
              this.state.topicContext = t;
            }
          } else return e();
        }
        withSoloAwaitPermittingContext(e) {
          let t = this.state.soloAwait;
          this.state.soloAwait = !0;
          try {
            return e();
          } finally {
            this.state.soloAwait = t;
          }
        }
        allowInAnd(e) {
          let t = this.prodParam.currentFlags();
          if (Kc & ~t) {
            this.prodParam.enter(t | Kc);
            try {
              return e();
            } finally {
              this.prodParam.exit();
            }
          }
          return e();
        }
        disallowInAnd(e) {
          let t = this.prodParam.currentFlags();
          if (Kc & t) {
            this.prodParam.enter(t & ~Kc);
            try {
              return e();
            } finally {
              this.prodParam.exit();
            }
          }
          return e();
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
          return (
            this.state.topicContext.maxTopicIndex != null &&
            this.state.topicContext.maxTopicIndex >= 0
          );
        }
        parseFSharpPipelineBody(e) {
          let t = this.state.start,
            i = this.state.startLoc;
          this.state.potentialArrowAt = this.state.start;
          let r = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !0;
          let s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, i, e);
          return (this.state.inFSharpPipelineDirectBody = r), s;
        }
        parseModuleExpression() {
          this.expectPlugin("moduleBlocks");
          let e = this.startNode();
          this.next(), this.eat(5);
          let t = this.initializeScopes(!0);
          this.enterInitialScopes();
          let i = this.startNode();
          try {
            e.body = this.parseProgram(i, 8, "module");
          } finally {
            t();
          }
          return this.eat(8), this.finishNode(e, "ModuleExpression");
        }
        parsePropertyNamePrefixOperator(e) {}
      },
      t_ = { kind: "loop" },
      Zq = { kind: "switch" },
      Qq = 0,
      i_ = 1,
      S2 = 2,
      w2 = 4,
      ej = /[\uD800-\uDFFF]/u,
      n_ = /in(?:stanceof)?/y;
    function tj(n, e) {
      for (let t = 0; t < n.length; t++) {
        let i = n[t],
          { type: r } = i;
        if (typeof r == "number") {
          {
            if (r === 134) {
              let { loc: s, start: a, value: o, end: l } = i,
                c = a + 1,
                u = Sr(s.start, 1);
              n.splice(
                t,
                1,
                new xa({
                  type: va(27),
                  value: "#",
                  start: a,
                  end: c,
                  startLoc: s.start,
                  endLoc: u,
                }),
                new xa({
                  type: va(128),
                  value: o,
                  start: c,
                  end: l,
                  startLoc: u,
                  endLoc: s.end,
                })
              ),
                t++;
              continue;
            }
            if (Tm(r)) {
              let { loc: s, start: a, value: o, end: l } = i,
                c = a + 1,
                u = Sr(s.start, 1),
                f;
              e.charCodeAt(a) === 96
                ? (f = new xa({
                    type: va(22),
                    value: "`",
                    start: a,
                    end: c,
                    startLoc: s.start,
                    endLoc: u,
                  }))
                : (f = new xa({
                    type: va(8),
                    value: "}",
                    start: a,
                    end: c,
                    startLoc: s.start,
                    endLoc: u,
                  }));
              let d, m, x, y;
              r === 24
                ? ((m = l - 1),
                  (x = Sr(s.end, -1)),
                  (d = o === null ? null : o.slice(1, -1)),
                  (y = new xa({
                    type: va(22),
                    value: "`",
                    start: m,
                    end: l,
                    startLoc: x,
                    endLoc: s.end,
                  })))
                : ((m = l - 2),
                  (x = Sr(s.end, -2)),
                  (d = o === null ? null : o.slice(1, -2)),
                  (y = new xa({
                    type: va(23),
                    value: "${",
                    start: m,
                    end: l,
                    startLoc: x,
                    endLoc: s.end,
                  }))),
                n.splice(
                  t,
                  1,
                  f,
                  new xa({
                    type: va(20),
                    value: d,
                    start: c,
                    end: m,
                    startLoc: u,
                    endLoc: x,
                  }),
                  y
                ),
                (t += 2);
              continue;
            }
          }
          i.type = va(r);
        }
      }
      return n;
    }
    var dL = class extends fL {
        parseTopLevel(e, t) {
          return (
            (e.program = this.parseProgram(t)),
            (e.comments = this.state.comments),
            this.options.tokens && (e.tokens = tj(this.tokens, this.input)),
            this.finishNode(e, "File")
          );
        }
        parseProgram(e, t = 135, i = this.options.sourceType) {
          if (
            ((e.sourceType = i),
            (e.interpreter = this.parseInterpreterDirective()),
            this.parseBlockBody(e, !0, !0, t),
            this.inModule &&
              !this.options.allowUndeclaredExports &&
              this.scope.undefinedExports.size > 0)
          )
            for (let [r, s] of Array.from(this.scope.undefinedExports))
              this.raise(ne.ModuleExportUndefined, { at: s, localName: r });
          return this.finishNode(e, "Program");
        }
        stmtToDirective(e) {
          let t = e;
          (t.type = "Directive"), (t.value = t.expression), delete t.expression;
          let i = t.value,
            r = i.value,
            s = this.input.slice(i.start, i.end),
            a = (i.value = s.slice(1, -1));
          return (
            this.addExtra(i, "raw", s),
            this.addExtra(i, "rawValue", a),
            this.addExtra(i, "expressionValue", r),
            (i.type = "DirectiveLiteral"),
            t
          );
        }
        parseInterpreterDirective() {
          if (!this.match(28)) return null;
          let e = this.startNode();
          return (
            (e.value = this.state.value),
            this.next(),
            this.finishNode(e, "InterpreterDirective")
          );
        }
        isLet(e) {
          return this.isContextual(99) ? this.isLetKeyword(e) : !1;
        }
        isLetKeyword(e) {
          let t = this.nextTokenStart(),
            i = this.codePointAtPos(t);
          if (i === 92 || i === 91) return !0;
          if (e) return !1;
          if (i === 123) return !0;
          if (_a(i)) {
            if (((n_.lastIndex = t), n_.test(this.input))) {
              let r = this.codePointAtPos(n_.lastIndex);
              if (!eu(r) && r !== 92) return !1;
            }
            return !0;
          }
          return !1;
        }
        parseStatement(e, t) {
          return (
            this.match(26) && this.parseDecorators(!0),
            this.parseStatementContent(e, t)
          );
        }
        parseStatementContent(e, t) {
          let i = this.state.type,
            r = this.startNode(),
            s;
          switch ((this.isLet(e) && ((i = 74), (s = "let")), i)) {
            case 60:
              return this.parseBreakContinueStatement(r, !0);
            case 63:
              return this.parseBreakContinueStatement(r, !1);
            case 64:
              return this.parseDebuggerStatement(r);
            case 90:
              return this.parseDoStatement(r);
            case 91:
              return this.parseForStatement(r);
            case 68:
              if (this.lookaheadCharCode() === 46) break;
              return (
                e &&
                  (this.state.strict
                    ? this.raise(ne.StrictFunction, { at: this.state.startLoc })
                    : e !== "if" &&
                      e !== "label" &&
                      this.raise(ne.SloppyFunction, {
                        at: this.state.startLoc,
                      })),
                this.parseFunctionStatement(r, !1, !e)
              );
            case 80:
              return e && this.unexpected(), this.parseClass(r, !0);
            case 69:
              return this.parseIfStatement(r);
            case 70:
              return this.parseReturnStatement(r);
            case 71:
              return this.parseSwitchStatement(r);
            case 72:
              return this.parseThrowStatement(r);
            case 73:
              return this.parseTryStatement(r);
            case 75:
            case 74:
              return (
                (s = s || this.state.value),
                e &&
                  s !== "var" &&
                  this.raise(ne.UnexpectedLexicalDeclaration, {
                    at: this.state.startLoc,
                  }),
                this.parseVarStatement(r, s)
              );
            case 92:
              return this.parseWhileStatement(r);
            case 76:
              return this.parseWithStatement(r);
            case 5:
              return this.parseBlock();
            case 13:
              return this.parseEmptyStatement(r);
            case 83: {
              let l = this.lookaheadCharCode();
              if (l === 40 || l === 46) break;
            }
            case 82: {
              !this.options.allowImportExportEverywhere &&
                !t &&
                this.raise(ne.UnexpectedImportExport, {
                  at: this.state.startLoc,
                }),
                this.next();
              let l;
              return (
                i === 83
                  ? ((l = this.parseImport(r)),
                    l.type === "ImportDeclaration" &&
                      (!l.importKind || l.importKind === "value") &&
                      (this.sawUnambiguousESM = !0))
                  : ((l = this.parseExport(r)),
                    ((l.type === "ExportNamedDeclaration" &&
                      (!l.exportKind || l.exportKind === "value")) ||
                      (l.type === "ExportAllDeclaration" &&
                        (!l.exportKind || l.exportKind === "value")) ||
                      l.type === "ExportDefaultDeclaration") &&
                      (this.sawUnambiguousESM = !0)),
                this.assertModuleNodeAllowed(l),
                l
              );
            }
            default:
              if (this.isAsyncFunction())
                return (
                  e &&
                    this.raise(ne.AsyncFunctionInSingleStatementContext, {
                      at: this.state.startLoc,
                    }),
                  this.next(),
                  this.parseFunctionStatement(r, !0, !e)
                );
          }
          let a = this.state.value,
            o = this.parseExpression();
          return pi(i) && o.type === "Identifier" && this.eat(14)
            ? this.parseLabeledStatement(r, a, o, e)
            : this.parseExpressionStatement(r, o);
        }
        assertModuleNodeAllowed(e) {
          !this.options.allowImportExportEverywhere &&
            !this.inModule &&
            this.raise(ne.ImportOutsideModule, { at: e });
        }
        takeDecorators(e) {
          let t =
            this.state.decoratorStack[this.state.decoratorStack.length - 1];
          t.length &&
            ((e.decorators = t),
            this.resetStartLocationFromNode(e, t[0]),
            (this.state.decoratorStack[this.state.decoratorStack.length - 1] =
              []));
        }
        canHaveLeadingDecorator() {
          return this.match(80);
        }
        parseDecorators(e) {
          let t =
            this.state.decoratorStack[this.state.decoratorStack.length - 1];
          for (; this.match(26); ) {
            let i = this.parseDecorator();
            t.push(i);
          }
          if (this.match(82))
            e || this.unexpected(),
              this.hasPlugin("decorators") &&
                !this.getPluginOption("decorators", "decoratorsBeforeExport") &&
                this.raise(ne.DecoratorExportClass, {
                  at: this.state.startLoc,
                });
          else if (!this.canHaveLeadingDecorator())
            throw this.raise(ne.UnexpectedLeadingDecorator, {
              at: this.state.startLoc,
            });
        }
        parseDecorator() {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          let e = this.startNode();
          if ((this.next(), this.hasPlugin("decorators"))) {
            this.state.decoratorStack.push([]);
            let t = this.state.start,
              i = this.state.startLoc,
              r;
            if (this.match(10)) {
              let s = this.state.start,
                a = this.state.startLoc;
              this.next(),
                (r = this.parseExpression()),
                this.expect(11),
                (r = this.wrapParenthesis(s, a, r));
            } else
              for (r = this.parseIdentifier(!1); this.eat(16); ) {
                let s = this.startNodeAt(t, i);
                (s.object = r),
                  (s.property = this.parseIdentifier(!0)),
                  (s.computed = !1),
                  (r = this.finishNode(s, "MemberExpression"));
              }
            (e.expression = this.parseMaybeDecoratorArguments(r)),
              this.state.decoratorStack.pop();
          } else e.expression = this.parseExprSubscripts();
          return this.finishNode(e, "Decorator");
        }
        parseMaybeDecoratorArguments(e) {
          if (this.eat(10)) {
            let t = this.startNodeAtNode(e);
            return (
              (t.callee = e),
              (t.arguments = this.parseCallExpressionArguments(11, !1)),
              this.toReferencedList(t.arguments),
              this.finishNode(t, "CallExpression")
            );
          }
          return e;
        }
        parseBreakContinueStatement(e, t) {
          return (
            this.next(),
            this.isLineTerminator()
              ? (e.label = null)
              : ((e.label = this.parseIdentifier()), this.semicolon()),
            this.verifyBreakContinue(e, t),
            this.finishNode(e, t ? "BreakStatement" : "ContinueStatement")
          );
        }
        verifyBreakContinue(e, t) {
          let i;
          for (i = 0; i < this.state.labels.length; ++i) {
            let r = this.state.labels[i];
            if (
              (e.label == null || r.name === e.label.name) &&
              ((r.kind != null && (t || r.kind === "loop")) || (e.label && t))
            )
              break;
          }
          if (i === this.state.labels.length) {
            let r = t ? "BreakStatement" : "ContinueStatement";
            this.raise(ne.IllegalBreakContinue, { at: e, type: r });
          }
        }
        parseDebuggerStatement(e) {
          return (
            this.next(),
            this.semicolon(),
            this.finishNode(e, "DebuggerStatement")
          );
        }
        parseHeaderExpression() {
          this.expect(10);
          let e = this.parseExpression();
          return this.expect(11), e;
        }
        parseDoStatement(e) {
          return (
            this.next(),
            this.state.labels.push(t_),
            (e.body = this.withSmartMixTopicForbiddingContext(() =>
              this.parseStatement("do")
            )),
            this.state.labels.pop(),
            this.expect(92),
            (e.test = this.parseHeaderExpression()),
            this.eat(13),
            this.finishNode(e, "DoWhileStatement")
          );
        }
        parseForStatement(e) {
          this.next(), this.state.labels.push(t_);
          let t = null;
          if (
            (this.isAwaitAllowed() &&
              this.eatContextual(96) &&
              (t = this.state.lastTokStartLoc),
            this.scope.enter(Zc),
            this.expect(10),
            this.match(13))
          )
            return t !== null && this.unexpected(t), this.parseFor(e, null);
          let i = this.isContextual(99),
            r = i && this.isLetKeyword();
          if (this.match(74) || this.match(75) || r) {
            let c = this.startNode(),
              u = r ? "let" : this.state.value;
            this.next(), this.parseVar(c, !0, u);
            let f = this.finishNode(c, "VariableDeclaration");
            return (this.match(58) || this.isContextual(101)) &&
              f.declarations.length === 1
              ? this.parseForIn(e, f, t)
              : (t !== null && this.unexpected(t), this.parseFor(e, f));
          }
          let s = this.isContextual(95),
            a = new df(),
            o = this.parseExpression(!0, a),
            l = this.isContextual(101);
          if (
            (l &&
              (i && this.raise(ne.ForOfLet, { at: o }),
              t === null &&
                s &&
                o.type === "Identifier" &&
                this.raise(ne.ForOfAsync, { at: o })),
            l || this.match(58))
          ) {
            this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
            let c = l ? "ForOfStatement" : "ForInStatement";
            return (
              this.checkLVal(o, { in: { type: c } }), this.parseForIn(e, o, t)
            );
          } else this.checkExpressionErrors(a, !0);
          return t !== null && this.unexpected(t), this.parseFor(e, o);
        }
        parseFunctionStatement(e, t, i) {
          return this.next(), this.parseFunction(e, i_ | (i ? 0 : S2), t);
        }
        parseIfStatement(e) {
          return (
            this.next(),
            (e.test = this.parseHeaderExpression()),
            (e.consequent = this.parseStatement("if")),
            (e.alternate = this.eat(66) ? this.parseStatement("if") : null),
            this.finishNode(e, "IfStatement")
          );
        }
        parseReturnStatement(e) {
          return (
            !this.prodParam.hasReturn &&
              !this.options.allowReturnOutsideFunction &&
              this.raise(ne.IllegalReturn, { at: this.state.startLoc }),
            this.next(),
            this.isLineTerminator()
              ? (e.argument = null)
              : ((e.argument = this.parseExpression()), this.semicolon()),
            this.finishNode(e, "ReturnStatement")
          );
        }
        parseSwitchStatement(e) {
          this.next(), (e.discriminant = this.parseHeaderExpression());
          let t = (e.cases = []);
          this.expect(5), this.state.labels.push(Zq), this.scope.enter(Zc);
          let i;
          for (let r; !this.match(8); )
            if (this.match(61) || this.match(65)) {
              let s = this.match(61);
              i && this.finishNode(i, "SwitchCase"),
                t.push((i = this.startNode())),
                (i.consequent = []),
                this.next(),
                s
                  ? (i.test = this.parseExpression())
                  : (r &&
                      this.raise(ne.MultipleDefaultsInSwitch, {
                        at: this.state.lastTokStartLoc,
                      }),
                    (r = !0),
                    (i.test = null)),
                this.expect(14);
            } else
              i
                ? i.consequent.push(this.parseStatement(null))
                : this.unexpected();
          return (
            this.scope.exit(),
            i && this.finishNode(i, "SwitchCase"),
            this.next(),
            this.state.labels.pop(),
            this.finishNode(e, "SwitchStatement")
          );
        }
        parseThrowStatement(e) {
          return (
            this.next(),
            this.hasPrecedingLineBreak() &&
              this.raise(ne.NewlineAfterThrow, {
                at: this.state.lastTokEndLoc,
              }),
            (e.argument = this.parseExpression()),
            this.semicolon(),
            this.finishNode(e, "ThrowStatement")
          );
        }
        parseCatchClauseParam() {
          let e = this.parseBindingAtom(),
            t = e.type === "Identifier";
          return (
            this.scope.enter(t ? O2 : 0),
            this.checkLVal(e, {
              in: { type: "CatchClause" },
              binding: Sa,
              allowingSloppyLetBinding: !0,
            }),
            e
          );
        }
        parseTryStatement(e) {
          if (
            (this.next(),
            (e.block = this.parseBlock()),
            (e.handler = null),
            this.match(62))
          ) {
            let t = this.startNode();
            this.next(),
              this.match(10)
                ? (this.expect(10),
                  (t.param = this.parseCatchClauseParam()),
                  this.expect(11))
                : ((t.param = null), this.scope.enter(Zc)),
              (t.body = this.withSmartMixTopicForbiddingContext(() =>
                this.parseBlock(!1, !1)
              )),
              this.scope.exit(),
              (e.handler = this.finishNode(t, "CatchClause"));
          }
          return (
            (e.finalizer = this.eat(67) ? this.parseBlock() : null),
            !e.handler &&
              !e.finalizer &&
              this.raise(ne.NoCatchOrFinally, { at: e }),
            this.finishNode(e, "TryStatement")
          );
        }
        parseVarStatement(e, t, i = !1) {
          return (
            this.next(),
            this.parseVar(e, !1, t, i),
            this.semicolon(),
            this.finishNode(e, "VariableDeclaration")
          );
        }
        parseWhileStatement(e) {
          return (
            this.next(),
            (e.test = this.parseHeaderExpression()),
            this.state.labels.push(t_),
            (e.body = this.withSmartMixTopicForbiddingContext(() =>
              this.parseStatement("while")
            )),
            this.state.labels.pop(),
            this.finishNode(e, "WhileStatement")
          );
        }
        parseWithStatement(e) {
          return (
            this.state.strict &&
              this.raise(ne.StrictWith, { at: this.state.startLoc }),
            this.next(),
            (e.object = this.parseHeaderExpression()),
            (e.body = this.withSmartMixTopicForbiddingContext(() =>
              this.parseStatement("with")
            )),
            this.finishNode(e, "WithStatement")
          );
        }
        parseEmptyStatement(e) {
          return this.next(), this.finishNode(e, "EmptyStatement");
        }
        parseLabeledStatement(e, t, i, r) {
          for (let a of this.state.labels)
            a.name === t &&
              this.raise(ne.LabelRedeclaration, { at: i, labelName: t });
          let s = $7(this.state.type)
            ? "loop"
            : this.match(71)
            ? "switch"
            : null;
          for (let a = this.state.labels.length - 1; a >= 0; a--) {
            let o = this.state.labels[a];
            if (o.statementStart === e.start)
              (o.statementStart = this.state.start), (o.kind = s);
            else break;
          }
          return (
            this.state.labels.push({
              name: t,
              kind: s,
              statementStart: this.state.start,
            }),
            (e.body = this.parseStatement(
              r ? (r.indexOf("label") === -1 ? r + "label" : r) : "label"
            )),
            this.state.labels.pop(),
            (e.label = i),
            this.finishNode(e, "LabeledStatement")
          );
        }
        parseExpressionStatement(e, t) {
          return (
            (e.expression = t),
            this.semicolon(),
            this.finishNode(e, "ExpressionStatement")
          );
        }
        parseBlock(e = !1, t = !0, i) {
          let r = this.startNode();
          return (
            e && this.state.strictErrors.clear(),
            this.expect(5),
            t && this.scope.enter(Zc),
            this.parseBlockBody(r, e, !1, 8, i),
            t && this.scope.exit(),
            this.finishNode(r, "BlockStatement")
          );
        }
        isValidDirective(e) {
          return (
            e.type === "ExpressionStatement" &&
            e.expression.type === "StringLiteral" &&
            !e.expression.extra.parenthesized
          );
        }
        parseBlockBody(e, t, i, r, s) {
          let a = (e.body = []),
            o = (e.directives = []);
          this.parseBlockOrModuleBlockBody(a, t ? o : void 0, i, r, s);
        }
        parseBlockOrModuleBlockBody(e, t, i, r, s) {
          let a = this.state.strict,
            o = !1,
            l = !1;
          for (; !this.match(r); ) {
            let c = this.parseStatement(null, i);
            if (t && !l) {
              if (this.isValidDirective(c)) {
                let u = this.stmtToDirective(c);
                t.push(u),
                  !o &&
                    u.value.value === "use strict" &&
                    ((o = !0), this.setStrict(!0));
                continue;
              }
              (l = !0), this.state.strictErrors.clear();
            }
            e.push(c);
          }
          s && s.call(this, o), a || this.setStrict(!1), this.next();
        }
        parseFor(e, t) {
          return (
            (e.init = t),
            this.semicolon(!1),
            (e.test = this.match(13) ? null : this.parseExpression()),
            this.semicolon(!1),
            (e.update = this.match(11) ? null : this.parseExpression()),
            this.expect(11),
            (e.body = this.withSmartMixTopicForbiddingContext(() =>
              this.parseStatement("for")
            )),
            this.scope.exit(),
            this.state.labels.pop(),
            this.finishNode(e, "ForStatement")
          );
        }
        parseForIn(e, t, i) {
          let r = this.match(58);
          return (
            this.next(),
            r ? i !== null && this.unexpected(i) : (e.await = i !== null),
            t.type === "VariableDeclaration" &&
              t.declarations[0].init != null &&
              (!r ||
                this.state.strict ||
                t.kind !== "var" ||
                t.declarations[0].id.type !== "Identifier") &&
              this.raise(ne.ForInOfLoopInitializer, {
                at: t,
                type: r ? "ForInStatement" : "ForOfStatement",
              }),
            t.type === "AssignmentPattern" &&
              this.raise(ne.InvalidLhs, {
                at: t,
                ancestor: { type: "ForStatement" },
              }),
            (e.left = t),
            (e.right = r
              ? this.parseExpression()
              : this.parseMaybeAssignAllowIn()),
            this.expect(11),
            (e.body = this.withSmartMixTopicForbiddingContext(() =>
              this.parseStatement("for")
            )),
            this.scope.exit(),
            this.state.labels.pop(),
            this.finishNode(e, r ? "ForInStatement" : "ForOfStatement")
          );
        }
        parseVar(e, t, i, r = !1) {
          let s = (e.declarations = []);
          for (e.kind = i; ; ) {
            let a = this.startNode();
            if (
              (this.parseVarId(a, i),
              (a.init = this.eat(29)
                ? t
                  ? this.parseMaybeAssignDisallowIn()
                  : this.parseMaybeAssignAllowIn()
                : null),
              a.init === null &&
                !r &&
                (a.id.type !== "Identifier" &&
                !(t && (this.match(58) || this.isContextual(101)))
                  ? this.raise(ne.DeclarationMissingInitializer, {
                      at: this.state.lastTokEndLoc,
                      kind: "destructuring",
                    })
                  : i === "const" &&
                    !(this.match(58) || this.isContextual(101)) &&
                    this.raise(ne.DeclarationMissingInitializer, {
                      at: this.state.lastTokEndLoc,
                      kind: "const",
                    })),
              s.push(this.finishNode(a, "VariableDeclarator")),
              !this.eat(12))
            )
              break;
          }
          return e;
        }
        parseVarId(e, t) {
          (e.id = this.parseBindingAtom()),
            this.checkLVal(e.id, {
              in: { type: "VariableDeclarator" },
              binding: t === "var" ? Mm : Sa,
            });
        }
        parseFunction(e, t = Qq, i = !1) {
          let r = t & i_,
            s = t & S2,
            a = !!r && !(t & w2);
          this.initFunction(e, i),
            this.match(55) &&
              s &&
              this.raise(ne.GeneratorInSingleStatementContext, {
                at: this.state.startLoc,
              }),
            (e.generator = this.eat(55)),
            r && (e.id = this.parseFunctionId(a));
          let o = this.state.maybeInArrowParameters;
          return (
            (this.state.maybeInArrowParameters = !1),
            this.scope.enter(Ta),
            this.prodParam.enter(_m(i, e.generator)),
            r || (e.id = this.parseFunctionId()),
            this.parseFunctionParams(e, !1),
            this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(
                e,
                r ? "FunctionDeclaration" : "FunctionExpression"
              );
            }),
            this.prodParam.exit(),
            this.scope.exit(),
            r && !s && this.registerFunctionStatementId(e),
            (this.state.maybeInArrowParameters = o),
            e
          );
        }
        parseFunctionId(e) {
          return e || pi(this.state.type) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(e, t) {
          this.expect(10),
            this.expressionScope.enter(Aq()),
            (e.params = this.parseBindingList(11, 41, !1, t)),
            this.expressionScope.exit();
        }
        registerFunctionStatementId(e) {
          !e.id ||
            this.scope.declareName(
              e.id.name,
              this.state.strict || e.generator || e.async
                ? this.scope.treatFunctionsAsVar
                  ? Mm
                  : Sa
                : z2,
              e.id.loc.start
            );
        }
        parseClass(e, t, i) {
          this.next(), this.takeDecorators(e);
          let r = this.state.strict;
          return (
            (this.state.strict = !0),
            this.parseClassId(e, t, i),
            this.parseClassSuper(e),
            (e.body = this.parseClassBody(!!e.superClass, r)),
            this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression")
          );
        }
        isClassProperty() {
          return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
          return this.match(10);
        }
        isNonstaticConstructor(e) {
          return (
            !e.computed &&
            !e.static &&
            (e.key.name === "constructor" || e.key.value === "constructor")
          );
        }
        parseClassBody(e, t) {
          this.classScope.enter();
          let i = { hadConstructor: !1, hadSuperClass: e },
            r = [],
            s = this.startNode();
          if (
            ((s.body = []),
            this.expect(5),
            this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (r.length > 0)
                    throw this.raise(ne.DecoratorSemicolon, {
                      at: this.state.lastTokEndLoc,
                    });
                  continue;
                }
                if (this.match(26)) {
                  r.push(this.parseDecorator());
                  continue;
                }
                let a = this.startNode();
                r.length &&
                  ((a.decorators = r),
                  this.resetStartLocationFromNode(a, r[0]),
                  (r = [])),
                  this.parseClassMember(s, a, i),
                  a.kind === "constructor" &&
                    a.decorators &&
                    a.decorators.length > 0 &&
                    this.raise(ne.DecoratorConstructor, { at: a });
              }
            }),
            (this.state.strict = t),
            this.next(),
            r.length)
          )
            throw this.raise(ne.TrailingDecorator, { at: this.state.startLoc });
          return this.classScope.exit(), this.finishNode(s, "ClassBody");
        }
        parseClassMemberFromModifier(e, t) {
          let i = this.parseIdentifier(!0);
          if (this.isClassMethod()) {
            let r = t;
            return (
              (r.kind = "method"),
              (r.computed = !1),
              (r.key = i),
              (r.static = !1),
              this.pushClassMethod(e, r, !1, !1, !1, !1),
              !0
            );
          } else if (this.isClassProperty()) {
            let r = t;
            return (
              (r.computed = !1),
              (r.key = i),
              (r.static = !1),
              e.body.push(this.parseClassProperty(r)),
              !0
            );
          }
          return this.resetPreviousNodeTrailingComments(i), !1;
        }
        parseClassMember(e, t, i) {
          let r = this.isContextual(104);
          if (r) {
            if (this.parseClassMemberFromModifier(e, t)) return;
            if (this.eat(5)) {
              this.parseClassStaticBlock(e, t);
              return;
            }
          }
          this.parseClassMemberWithIsStatic(e, t, i, r);
        }
        parseClassMemberWithIsStatic(e, t, i, r) {
          let s = t,
            a = t,
            o = t,
            l = t,
            c = t,
            u = s,
            f = s;
          if (
            ((t.static = r),
            this.parsePropertyNamePrefixOperator(t),
            this.eat(55))
          ) {
            u.kind = "method";
            let g = this.match(134);
            if ((this.parseClassElementName(u), g)) {
              this.pushClassPrivateMethod(e, a, !0, !1);
              return;
            }
            this.isNonstaticConstructor(s) &&
              this.raise(ne.ConstructorIsGenerator, { at: s.key }),
              this.pushClassMethod(e, s, !0, !1, !1, !1);
            return;
          }
          let d = pi(this.state.type) && !this.state.containsEsc,
            m = this.match(134),
            x = this.parseClassElementName(t),
            y = this.state.startLoc;
          if ((this.parsePostMemberNameModifiers(f), this.isClassMethod())) {
            if (((u.kind = "method"), m)) {
              this.pushClassPrivateMethod(e, a, !1, !1);
              return;
            }
            let g = this.isNonstaticConstructor(s),
              b = !1;
            g &&
              ((s.kind = "constructor"),
              i.hadConstructor &&
                !this.hasPlugin("typescript") &&
                this.raise(ne.DuplicateConstructor, { at: x }),
              g &&
                this.hasPlugin("typescript") &&
                t.override &&
                this.raise(ne.OverrideOnConstructor, { at: x }),
              (i.hadConstructor = !0),
              (b = i.hadSuperClass)),
              this.pushClassMethod(e, s, !1, !1, g, b);
          } else if (this.isClassProperty())
            m
              ? this.pushClassPrivateProperty(e, l)
              : this.pushClassProperty(e, o);
          else if (d && x.name === "async" && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(x);
            let g = this.eat(55);
            f.optional && this.unexpected(y), (u.kind = "method");
            let b = this.match(134);
            this.parseClassElementName(u),
              this.parsePostMemberNameModifiers(f),
              b
                ? this.pushClassPrivateMethod(e, a, g, !0)
                : (this.isNonstaticConstructor(s) &&
                    this.raise(ne.ConstructorIsAsync, { at: s.key }),
                  this.pushClassMethod(e, s, g, !0, !1, !1));
          } else if (
            d &&
            (x.name === "get" || x.name === "set") &&
            !(this.match(55) && this.isLineTerminator())
          ) {
            this.resetPreviousNodeTrailingComments(x), (u.kind = x.name);
            let g = this.match(134);
            this.parseClassElementName(s),
              g
                ? this.pushClassPrivateMethod(e, a, !1, !1)
                : (this.isNonstaticConstructor(s) &&
                    this.raise(ne.ConstructorIsAccessor, { at: s.key }),
                  this.pushClassMethod(e, s, !1, !1, !1, !1)),
              this.checkGetterSetterParams(s);
          } else if (d && x.name === "accessor" && !this.isLineTerminator()) {
            this.expectPlugin("decoratorAutoAccessors"),
              this.resetPreviousNodeTrailingComments(x);
            let g = this.match(134);
            this.parseClassElementName(o),
              this.pushClassAccessorProperty(e, c, g);
          } else
            this.isLineTerminator()
              ? m
                ? this.pushClassPrivateProperty(e, l)
                : this.pushClassProperty(e, o)
              : this.unexpected();
        }
        parseClassElementName(e) {
          let { type: t, value: i } = this.state;
          if (
            ((t === 128 || t === 129) &&
              e.static &&
              i === "prototype" &&
              this.raise(ne.StaticPrototype, { at: this.state.startLoc }),
            t === 134)
          ) {
            i === "constructor" &&
              this.raise(ne.ConstructorClassPrivateField, {
                at: this.state.startLoc,
              });
            let r = this.parsePrivateName();
            return (e.key = r), r;
          }
          return this.parsePropertyName(e);
        }
        parseClassStaticBlock(e, t) {
          var i;
          this.scope.enter(Cl | l_ | Sm);
          let r = this.state.labels;
          (this.state.labels = []), this.prodParam.enter(tu);
          let s = (t.body = []);
          this.parseBlockOrModuleBlockBody(s, void 0, !1, 8),
            this.prodParam.exit(),
            this.scope.exit(),
            (this.state.labels = r),
            e.body.push(this.finishNode(t, "StaticBlock")),
            (i = t.decorators) != null &&
              i.length &&
              this.raise(ne.DecoratorStaticBlock, { at: t });
        }
        pushClassProperty(e, t) {
          !t.computed &&
            (t.key.name === "constructor" || t.key.value === "constructor") &&
            this.raise(ne.ConstructorClassField, { at: t.key }),
            e.body.push(this.parseClassProperty(t));
        }
        pushClassPrivateProperty(e, t) {
          let i = this.parseClassPrivateProperty(t);
          e.body.push(i),
            this.classScope.declarePrivateName(
              this.getPrivateNameSV(i.key),
              Zb,
              i.key.loc.start
            );
        }
        pushClassAccessorProperty(e, t, i) {
          if (!i && !t.computed) {
            let s = t.key;
            (s.name === "constructor" || s.value === "constructor") &&
              this.raise(ne.ConstructorClassField, { at: s });
          }
          let r = this.parseClassAccessorProperty(t);
          e.body.push(r),
            i &&
              this.classScope.declarePrivateName(
                this.getPrivateNameSV(r.key),
                Zb,
                r.key.loc.start
              );
        }
        pushClassMethod(e, t, i, r, s, a) {
          e.body.push(this.parseMethod(t, i, r, s, a, "ClassMethod", !0));
        }
        pushClassPrivateMethod(e, t, i, r) {
          let s = this.parseMethod(t, i, r, !1, !1, "ClassPrivateMethod", !0);
          e.body.push(s);
          let a =
            s.kind === "get"
              ? s.static
                ? dq
                : mq
              : s.kind === "set"
              ? s.static
                ? pq
                : gq
              : Zb;
          this.declareClassPrivateMethodInScope(s, a);
        }
        declareClassPrivateMethodInScope(e, t) {
          this.classScope.declarePrivateName(
            this.getPrivateNameSV(e.key),
            t,
            e.key.loc.start
          );
        }
        parsePostMemberNameModifiers(e) {}
        parseClassPrivateProperty(e) {
          return (
            this.parseInitializer(e),
            this.semicolon(),
            this.finishNode(e, "ClassPrivateProperty")
          );
        }
        parseClassProperty(e) {
          return (
            this.parseInitializer(e),
            this.semicolon(),
            this.finishNode(e, "ClassProperty")
          );
        }
        parseClassAccessorProperty(e) {
          return (
            this.parseInitializer(e),
            this.semicolon(),
            this.finishNode(e, "ClassAccessorProperty")
          );
        }
        parseInitializer(e) {
          this.scope.enter(Cl | Sm),
            this.expressionScope.enter(eL()),
            this.prodParam.enter(tu),
            (e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null),
            this.expressionScope.exit(),
            this.prodParam.exit(),
            this.scope.exit();
        }
        parseClassId(e, t, i, r = B2) {
          if (pi(this.state.type))
            (e.id = this.parseIdentifier()),
              t && this.declareNameFromIdentifier(e.id, r);
          else if (i || !t) e.id = null;
          else
            throw this.raise(ne.MissingClassName, { at: this.state.startLoc });
        }
        parseClassSuper(e) {
          e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(e) {
          let t = this.maybeParseExportDefaultSpecifier(e),
            i = !t || this.eat(12),
            r = i && this.eatExportStar(e),
            s = r && this.maybeParseExportNamespaceSpecifier(e),
            a = i && (!s || this.eat(12)),
            o = t || r;
          if (r && !s)
            return (
              t && this.unexpected(),
              this.parseExportFrom(e, !0),
              this.finishNode(e, "ExportAllDeclaration")
            );
          let l = this.maybeParseExportNamedSpecifiers(e);
          if ((t && i && !r && !l) || (s && a && !l))
            throw this.unexpected(null, 5);
          let c;
          if (
            (o || l
              ? ((c = !1), this.parseExportFrom(e, o))
              : (c = this.maybeParseExportDeclaration(e)),
            o || l || c)
          )
            return (
              this.checkExport(e, !0, !1, !!e.source),
              this.finishNode(e, "ExportNamedDeclaration")
            );
          if (this.eat(65))
            return (
              (e.declaration = this.parseExportDefaultExpression()),
              this.checkExport(e, !0, !0),
              this.finishNode(e, "ExportDefaultDeclaration")
            );
          throw this.unexpected(null, 5);
        }
        eatExportStar(e) {
          return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(e) {
          if (this.isExportDefaultSpecifier()) {
            this.expectPlugin("exportDefaultFrom");
            let t = this.startNode();
            return (
              (t.exported = this.parseIdentifier(!0)),
              (e.specifiers = [this.finishNode(t, "ExportDefaultSpecifier")]),
              !0
            );
          }
          return !1;
        }
        maybeParseExportNamespaceSpecifier(e) {
          if (this.isContextual(93)) {
            e.specifiers || (e.specifiers = []);
            let t = this.startNodeAt(
              this.state.lastTokStart,
              this.state.lastTokStartLoc
            );
            return (
              this.next(),
              (t.exported = this.parseModuleExportName()),
              e.specifiers.push(this.finishNode(t, "ExportNamespaceSpecifier")),
              !0
            );
          }
          return !1;
        }
        maybeParseExportNamedSpecifiers(e) {
          if (this.match(5)) {
            e.specifiers || (e.specifiers = []);
            let t = e.exportKind === "type";
            return (
              e.specifiers.push(...this.parseExportSpecifiers(t)),
              (e.source = null),
              (e.declaration = null),
              this.hasPlugin("importAssertions") && (e.assertions = []),
              !0
            );
          }
          return !1;
        }
        maybeParseExportDeclaration(e) {
          return this.shouldParseExportDeclaration()
            ? ((e.specifiers = []),
              (e.source = null),
              this.hasPlugin("importAssertions") && (e.assertions = []),
              (e.declaration = this.parseExportDeclaration(e)),
              !0)
            : !1;
        }
        isAsyncFunction() {
          if (!this.isContextual(95)) return !1;
          let e = this.nextTokenStart();
          return (
            !A_.test(this.input.slice(this.state.pos, e)) &&
            this.isUnparsedContextual(e, "function")
          );
        }
        parseExportDefaultExpression() {
          let e = this.startNode(),
            t = this.isAsyncFunction();
          if (this.match(68) || t)
            return (
              this.next(), t && this.next(), this.parseFunction(e, i_ | w2, t)
            );
          if (this.match(80)) return this.parseClass(e, !0, !0);
          if (this.match(26))
            return (
              this.hasPlugin("decorators") &&
                this.getPluginOption("decorators", "decoratorsBeforeExport") &&
                this.raise(ne.DecoratorBeforeExport, {
                  at: this.state.startLoc,
                }),
              this.parseDecorators(!1),
              this.parseClass(e, !0, !0)
            );
          if (this.match(75) || this.match(74) || this.isLet())
            throw this.raise(ne.UnsupportedDefaultExport, {
              at: this.state.startLoc,
            });
          let i = this.parseMaybeAssignAllowIn();
          return this.semicolon(), i;
        }
        parseExportDeclaration(e) {
          return this.parseStatement(null);
        }
        isExportDefaultSpecifier() {
          let { type: e } = this.state;
          if (pi(e)) {
            if ((e === 95 && !this.state.containsEsc) || e === 99) return !1;
            if ((e === 126 || e === 125) && !this.state.containsEsc) {
              let { type: r } = this.lookahead();
              if ((pi(r) && r !== 97) || r === 5)
                return this.expectOnePlugin(["flow", "typescript"]), !1;
            }
          } else if (!this.match(65)) return !1;
          let t = this.nextTokenStart(),
            i = this.isUnparsedContextual(t, "from");
          if (this.input.charCodeAt(t) === 44 || (pi(this.state.type) && i))
            return !0;
          if (this.match(65) && i) {
            let r = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
            return r === 34 || r === 39;
          }
          return !1;
        }
        parseExportFrom(e, t) {
          if (this.eatContextual(97)) {
            (e.source = this.parseImportSource()), this.checkExport(e);
            let i = this.maybeParseImportAssertions();
            i && ((e.assertions = i), this.checkJSONModuleImport(e));
          } else t && this.unexpected();
          this.semicolon();
        }
        shouldParseExportDeclaration() {
          let { type: e } = this.state;
          if (
            e === 26 &&
            (this.expectOnePlugin(["decorators", "decorators-legacy"]),
            this.hasPlugin("decorators"))
          ) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport"))
              throw this.raise(ne.DecoratorBeforeExport, {
                at: this.state.startLoc,
              });
            return !0;
          }
          return (
            e === 74 ||
            e === 75 ||
            e === 68 ||
            e === 80 ||
            this.isLet() ||
            this.isAsyncFunction()
          );
        }
        checkExport(e, t, i, r) {
          if (t) {
            if (i) {
              if (
                (this.checkDuplicateExports(e, "default"),
                this.hasPlugin("exportDefaultFrom"))
              ) {
                var s;
                let o = e.declaration;
                o.type === "Identifier" &&
                  o.name === "from" &&
                  o.end - o.start === 4 &&
                  !((s = o.extra) != null && s.parenthesized) &&
                  this.raise(ne.ExportDefaultFromAsIdentifier, { at: o });
              }
            } else if (e.specifiers && e.specifiers.length)
              for (let o of e.specifiers) {
                let { exported: l } = o,
                  c = l.type === "Identifier" ? l.name : l.value;
                if ((this.checkDuplicateExports(o, c), !r && o.local)) {
                  let { local: u } = o;
                  u.type !== "Identifier"
                    ? this.raise(ne.ExportBindingIsString, {
                        at: o,
                        localName: u.value,
                        exportName: c,
                      })
                    : (this.checkReservedWord(u.name, u.loc.start, !0, !1),
                      this.scope.checkLocalExport(u));
                }
              }
            else if (e.declaration) {
              if (
                e.declaration.type === "FunctionDeclaration" ||
                e.declaration.type === "ClassDeclaration"
              ) {
                let o = e.declaration.id;
                if (!o) throw new Error("Assertion failure");
                this.checkDuplicateExports(e, o.name);
              } else if (e.declaration.type === "VariableDeclaration")
                for (let o of e.declaration.declarations)
                  this.checkDeclaration(o.id);
            }
          }
          if (
            this.state.decoratorStack[this.state.decoratorStack.length - 1]
              .length
          )
            throw this.raise(ne.UnsupportedDecoratorExport, { at: e });
        }
        checkDeclaration(e) {
          if (e.type === "Identifier") this.checkDuplicateExports(e, e.name);
          else if (e.type === "ObjectPattern")
            for (let t of e.properties) this.checkDeclaration(t);
          else if (e.type === "ArrayPattern")
            for (let t of e.elements) t && this.checkDeclaration(t);
          else
            e.type === "ObjectProperty"
              ? this.checkDeclaration(e.value)
              : e.type === "RestElement"
              ? this.checkDeclaration(e.argument)
              : e.type === "AssignmentPattern" && this.checkDeclaration(e.left);
        }
        checkDuplicateExports(e, t) {
          this.exportedIdentifiers.has(t) &&
            (t === "default"
              ? this.raise(ne.DuplicateDefaultExport, { at: e })
              : this.raise(ne.DuplicateExport, { at: e, exportName: t })),
            this.exportedIdentifiers.add(t);
        }
        parseExportSpecifiers(e) {
          let t = [],
            i = !0;
          for (this.expect(5); !this.eat(8); ) {
            if (i) i = !1;
            else if ((this.expect(12), this.eat(8))) break;
            let r = this.isContextual(126),
              s = this.match(129),
              a = this.startNode();
            (a.local = this.parseModuleExportName()),
              t.push(this.parseExportSpecifier(a, s, e, r));
          }
          return t;
        }
        parseExportSpecifier(e, t, i, r) {
          return (
            this.eatContextual(93)
              ? (e.exported = this.parseModuleExportName())
              : t
              ? (e.exported = Iq(e.local))
              : e.exported || (e.exported = Ma(e.local)),
            this.finishNode(e, "ExportSpecifier")
          );
        }
        parseModuleExportName() {
          if (this.match(129)) {
            let e = this.parseStringLiteral(this.state.value),
              t = e.value.match(ej);
            return (
              t &&
                this.raise(ne.ModuleExportNameHasLoneSurrogate, {
                  at: e,
                  surrogateCharCode: t[0].charCodeAt(0),
                }),
              e
            );
          }
          return this.parseIdentifier(!0);
        }
        isJSONModuleImport(e) {
          return e.assertions != null
            ? e.assertions.some(
                ({ key: t, value: i }) =>
                  i.value === "json" &&
                  (t.type === "Identifier"
                    ? t.name === "type"
                    : t.value === "type")
              )
            : !1;
        }
        checkJSONModuleImport(e) {
          if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
            let { specifiers: t } = e;
            if (e.specifiers != null) {
              let i = t.find((r) => {
                let s;
                if (
                  (r.type === "ExportSpecifier"
                    ? (s = r.local)
                    : r.type === "ImportSpecifier" && (s = r.imported),
                  s !== void 0)
                )
                  return s.type === "Identifier"
                    ? s.name !== "default"
                    : s.value !== "default";
              });
              i !== void 0 &&
                this.raise(ne.ImportJSONBindingNotDefault, { at: i.loc.start });
            }
          }
        }
        parseImport(e) {
          if (((e.specifiers = []), !this.match(129))) {
            let r = !this.maybeParseDefaultImportSpecifier(e) || this.eat(12),
              s = r && this.maybeParseStarImportSpecifier(e);
            r && !s && this.parseNamedImportSpecifiers(e),
              this.expectContextual(97);
          }
          e.source = this.parseImportSource();
          let t = this.maybeParseImportAssertions();
          if (t) e.assertions = t;
          else {
            let i = this.maybeParseModuleAttributes();
            i && (e.attributes = i);
          }
          return (
            this.checkJSONModuleImport(e),
            this.semicolon(),
            this.finishNode(e, "ImportDeclaration")
          );
        }
        parseImportSource() {
          return this.match(129) || this.unexpected(), this.parseExprAtom();
        }
        shouldParseDefaultImport(e) {
          return pi(this.state.type);
        }
        parseImportSpecifierLocal(e, t, i) {
          (t.local = this.parseIdentifier()),
            e.specifiers.push(this.finishImportSpecifier(t, i));
        }
        finishImportSpecifier(e, t) {
          return (
            this.checkLVal(e.local, { in: e, binding: Sa }),
            this.finishNode(e, t)
          );
        }
        parseAssertEntries() {
          let e = [],
            t = new Set();
          do {
            if (this.match(8)) break;
            let i = this.startNode(),
              r = this.state.value;
            if (
              (t.has(r) &&
                this.raise(ne.ModuleAttributesWithDuplicateKeys, {
                  at: this.state.startLoc,
                  key: r,
                }),
              t.add(r),
              this.match(129)
                ? (i.key = this.parseStringLiteral(r))
                : (i.key = this.parseIdentifier(!0)),
              this.expect(14),
              !this.match(129))
            )
              throw this.raise(ne.ModuleAttributeInvalidValue, {
                at: this.state.startLoc,
              });
            (i.value = this.parseStringLiteral(this.state.value)),
              e.push(this.finishNode(i, "ImportAttribute"));
          } while (this.eat(12));
          return e;
        }
        maybeParseModuleAttributes() {
          if (this.match(76) && !this.hasPrecedingLineBreak())
            this.expectPlugin("moduleAttributes"), this.next();
          else return this.hasPlugin("moduleAttributes") ? [] : null;
          let e = [],
            t = new Set();
          do {
            let i = this.startNode();
            if (
              ((i.key = this.parseIdentifier(!0)),
              i.key.name !== "type" &&
                this.raise(ne.ModuleAttributeDifferentFromType, { at: i.key }),
              t.has(i.key.name) &&
                this.raise(ne.ModuleAttributesWithDuplicateKeys, {
                  at: i.key,
                  key: i.key.name,
                }),
              t.add(i.key.name),
              this.expect(14),
              !this.match(129))
            )
              throw this.raise(ne.ModuleAttributeInvalidValue, {
                at: this.state.startLoc,
              });
            (i.value = this.parseStringLiteral(this.state.value)),
              this.finishNode(i, "ImportAttribute"),
              e.push(i);
          } while (this.eat(12));
          return e;
        }
        maybeParseImportAssertions() {
          if (this.isContextual(94) && !this.hasPrecedingLineBreak())
            this.expectPlugin("importAssertions"), this.next();
          else return this.hasPlugin("importAssertions") ? [] : null;
          this.eat(5);
          let e = this.parseAssertEntries();
          return this.eat(8), e;
        }
        maybeParseDefaultImportSpecifier(e) {
          return this.shouldParseDefaultImport(e)
            ? (this.parseImportSpecifierLocal(
                e,
                this.startNode(),
                "ImportDefaultSpecifier"
              ),
              !0)
            : !1;
        }
        maybeParseStarImportSpecifier(e) {
          if (this.match(55)) {
            let t = this.startNode();
            return (
              this.next(),
              this.expectContextual(93),
              this.parseImportSpecifierLocal(e, t, "ImportNamespaceSpecifier"),
              !0
            );
          }
          return !1;
        }
        parseNamedImportSpecifiers(e) {
          let t = !0;
          for (this.expect(5); !this.eat(8); ) {
            if (t) t = !1;
            else {
              if (this.eat(14))
                throw this.raise(ne.DestructureNamedImport, {
                  at: this.state.startLoc,
                });
              if ((this.expect(12), this.eat(8))) break;
            }
            let i = this.startNode(),
              r = this.match(129),
              s = this.isContextual(126);
            i.imported = this.parseModuleExportName();
            let a = this.parseImportSpecifier(
              i,
              r,
              e.importKind === "type" || e.importKind === "typeof",
              s
            );
            e.specifiers.push(a);
          }
        }
        parseImportSpecifier(e, t, i, r) {
          if (this.eatContextual(93)) e.local = this.parseIdentifier();
          else {
            let { imported: s } = e;
            if (t)
              throw this.raise(ne.ImportBindingIsString, {
                at: e,
                importName: s.value,
              });
            this.checkReservedWord(s.name, e.loc.start, !0, !0),
              e.local || (e.local = Ma(s));
          }
          return this.finishImportSpecifier(e, "ImportSpecifier");
        }
        isThisParam(e) {
          return e.type === "Identifier" && e.name === "this";
        }
      },
      I_ = class extends dL {
        constructor(e, t) {
          e = Kq(e);
          super(e, t);
          (this.options = e),
            this.initializeScopes(),
            (this.plugins = ij(this.options.plugins)),
            (this.filename = e.sourceFilename);
        }
        getScopeHandler() {
          return Dm;
        }
        parse() {
          this.enterInitialScopes();
          let e = this.startNode(),
            t = this.startNode();
          return (
            this.nextToken(),
            (e.errors = null),
            this.parseTopLevel(e, t),
            (e.errors = this.state.errors),
            e
          );
        }
      };
    function ij(n) {
      let e = new Map();
      for (let t of n) {
        let [i, r] = Array.isArray(t) ? t : [t, {}];
        e.has(i) || e.set(i, r || {});
      }
      return e;
    }
    function nj(n, e) {
      var t;
      if (((t = e) == null ? void 0 : t.sourceType) === "unambiguous") {
        e = Object.assign({}, e);
        try {
          e.sourceType = "module";
          let i = cf(e, n),
            r = i.parse();
          if (i.sawUnambiguousESM) return r;
          if (i.ambiguousScriptDifferentAst)
            try {
              return (e.sourceType = "script"), cf(e, n).parse();
            } catch (s) {}
          else r.program.sourceType = "script";
          return r;
        } catch (i) {
          try {
            return (e.sourceType = "script"), cf(e, n).parse();
          } catch (r) {}
          throw i;
        }
      } else return cf(e, n).parse();
    }
    function rj(n, e) {
      let t = cf(e, n);
      return t.options.strictMode && (t.state.strict = !0), t.getExpression();
    }
    function sj(n) {
      let e = {};
      for (let t of Object.keys(n)) e[t] = va(n[t]);
      return e;
    }
    var aj = sj(U7);
    function cf(n, e) {
      let t = I_;
      return (
        n != null && n.plugins && (Xq(n.plugins), (t = oj(n.plugins))),
        new t(n, e)
      );
    }
    var M2 = {};
    function oj(n) {
      let e = Yq.filter((r) => On(n, r)),
        t = e.join("/"),
        i = M2[t];
      if (!i) {
        i = I_;
        for (let r of e) i = cL[r](i);
        M2[t] = i;
      }
      return i;
    }
    vf.parse = nj;
    vf.parseExpression = rj;
    vf.tokTypes = aj;
  });
  var gL = jt((L_) => {
    var mL =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
        ""
      );
    L_.encode = function (n) {
      if (0 <= n && n < mL.length) return mL[n];
      throw new TypeError("Must be between 0 and 63: " + n);
    };
    L_.decode = function (n) {
      var e = 65,
        t = 90,
        i = 97,
        r = 122,
        s = 48,
        a = 57,
        o = 43,
        l = 47,
        c = 26,
        u = 52;
      return e <= n && n <= t
        ? n - e
        : i <= n && n <= r
        ? n - i + c
        : s <= n && n <= a
        ? n - s + u
        : n == o
        ? 62
        : n == l
        ? 63
        : -1;
    };
  });
  var N_ = jt((O_) => {
    var yL = gL(),
      R_ = 5,
      vL = 1 << R_,
      xL = vL - 1,
      bL = vL;
    function lj(n) {
      return n < 0 ? (-n << 1) + 1 : (n << 1) + 0;
    }
    function cj(n) {
      var e = (n & 1) === 1,
        t = n >> 1;
      return e ? -t : t;
    }
    O_.encode = function (e) {
      var t = "",
        i,
        r = lj(e);
      do (i = r & xL), (r >>>= R_), r > 0 && (i |= bL), (t += yL.encode(i));
      while (r > 0);
      return t;
    };
    O_.decode = function (e, t, i) {
      var r = e.length,
        s = 0,
        a = 0,
        o,
        l;
      do {
        if (t >= r)
          throw new Error("Expected more digits in base 64 VLQ value.");
        if (((l = yL.decode(e.charCodeAt(t++))), l === -1))
          throw new Error("Invalid base64 digit: " + e.charAt(t - 1));
        (o = !!(l & bL)), (l &= xL), (s = s + (l << a)), (a += R_);
      } while (o);
      (i.value = cj(s)), (i.rest = t);
    };
  });
  var su = jt((Nn) => {
    function uj(n, e, t) {
      if (e in n) return n[e];
      if (arguments.length === 3) return t;
      throw new Error('"' + e + '" is a required argument.');
    }
    Nn.getArg = uj;
    var _L = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,
      hj = /^data:.+\,.+$/;
    function xf(n) {
      var e = n.match(_L);
      return e
        ? { scheme: e[1], auth: e[2], host: e[3], port: e[4], path: e[5] }
        : null;
    }
    Nn.urlParse = xf;
    function nu(n) {
      var e = "";
      return (
        n.scheme && (e += n.scheme + ":"),
        (e += "//"),
        n.auth && (e += n.auth + "@"),
        n.host && (e += n.host),
        n.port && (e += ":" + n.port),
        n.path && (e += n.path),
        e
      );
    }
    Nn.urlGenerate = nu;
    function k_(n) {
      var e = n,
        t = xf(n);
      if (t) {
        if (!t.path) return n;
        e = t.path;
      }
      for (
        var i = Nn.isAbsolute(e),
          r = e.split(/\/+/),
          s,
          a = 0,
          o = r.length - 1;
        o >= 0;
        o--
      )
        (s = r[o]),
          s === "."
            ? r.splice(o, 1)
            : s === ".."
            ? a++
            : a > 0 &&
              (s === ""
                ? (r.splice(o + 1, a), (a = 0))
                : (r.splice(o, 2), a--));
      return (
        (e = r.join("/")),
        e === "" && (e = i ? "/" : "."),
        t ? ((t.path = e), nu(t)) : e
      );
    }
    Nn.normalize = k_;
    function EL(n, e) {
      n === "" && (n = "."), e === "" && (e = ".");
      var t = xf(e),
        i = xf(n);
      if ((i && (n = i.path || "/"), t && !t.scheme))
        return i && (t.scheme = i.scheme), nu(t);
      if (t || e.match(hj)) return e;
      if (i && !i.host && !i.path) return (i.host = e), nu(i);
      var r = e.charAt(0) === "/" ? e : k_(n.replace(/\/+$/, "") + "/" + e);
      return i ? ((i.path = r), nu(i)) : r;
    }
    Nn.join = EL;
    Nn.isAbsolute = function (n) {
      return n.charAt(0) === "/" || _L.test(n);
    };
    function fj(n, e) {
      n === "" && (n = "."), (n = n.replace(/\/$/, ""));
      for (var t = 0; e.indexOf(n + "/") !== 0; ) {
        var i = n.lastIndexOf("/");
        if (i < 0 || ((n = n.slice(0, i)), n.match(/^([^\/]+:\/)?\/*$/)))
          return e;
        ++t;
      }
      return Array(t + 1).join("../") + e.substr(n.length + 1);
    }
    Nn.relative = fj;
    var TL = (function () {
      var n = Object.create(null);
      return !("__proto__" in n);
    })();
    function SL(n) {
      return n;
    }
    function dj(n) {
      return wL(n) ? "$" + n : n;
    }
    Nn.toSetString = TL ? SL : dj;
    function pj(n) {
      return wL(n) ? n.slice(1) : n;
    }
    Nn.fromSetString = TL ? SL : pj;
    function wL(n) {
      if (!n) return !1;
      var e = n.length;
      if (
        e < 9 ||
        n.charCodeAt(e - 1) !== 95 ||
        n.charCodeAt(e - 2) !== 95 ||
        n.charCodeAt(e - 3) !== 111 ||
        n.charCodeAt(e - 4) !== 116 ||
        n.charCodeAt(e - 5) !== 111 ||
        n.charCodeAt(e - 6) !== 114 ||
        n.charCodeAt(e - 7) !== 112 ||
        n.charCodeAt(e - 8) !== 95 ||
        n.charCodeAt(e - 9) !== 95
      )
        return !1;
      for (var t = e - 10; t >= 0; t--) if (n.charCodeAt(t) !== 36) return !1;
      return !0;
    }
    function mj(n, e, t) {
      var i = ru(n.source, e.source);
      return i !== 0 ||
        ((i = n.originalLine - e.originalLine), i !== 0) ||
        ((i = n.originalColumn - e.originalColumn), i !== 0 || t) ||
        ((i = n.generatedColumn - e.generatedColumn), i !== 0) ||
        ((i = n.generatedLine - e.generatedLine), i !== 0)
        ? i
        : ru(n.name, e.name);
    }
    Nn.compareByOriginalPositions = mj;
    function gj(n, e, t) {
      var i = n.generatedLine - e.generatedLine;
      return i !== 0 ||
        ((i = n.generatedColumn - e.generatedColumn), i !== 0 || t) ||
        ((i = ru(n.source, e.source)), i !== 0) ||
        ((i = n.originalLine - e.originalLine), i !== 0) ||
        ((i = n.originalColumn - e.originalColumn), i !== 0)
        ? i
        : ru(n.name, e.name);
    }
    Nn.compareByGeneratedPositionsDeflated = gj;
    function ru(n, e) {
      return n === e ? 0 : n === null ? 1 : e === null ? -1 : n > e ? 1 : -1;
    }
    function yj(n, e) {
      var t = n.generatedLine - e.generatedLine;
      return t !== 0 ||
        ((t = n.generatedColumn - e.generatedColumn), t !== 0) ||
        ((t = ru(n.source, e.source)), t !== 0) ||
        ((t = n.originalLine - e.originalLine), t !== 0) ||
        ((t = n.originalColumn - e.originalColumn), t !== 0)
        ? t
        : ru(n.name, e.name);
    }
    Nn.compareByGeneratedPositionsInflated = yj;
    function vj(n) {
      return JSON.parse(n.replace(/^\)]}'[^\n]*\n/, ""));
    }
    Nn.parseSourceMapInput = vj;
    function xj(n, e, t) {
      if (
        ((e = e || ""),
        n &&
          (n[n.length - 1] !== "/" && e[0] !== "/" && (n += "/"), (e = n + e)),
        t)
      ) {
        var i = xf(t);
        if (!i) throw new Error("sourceMapURL could not be parsed");
        if (i.path) {
          var r = i.path.lastIndexOf("/");
          r >= 0 && (i.path = i.path.substring(0, r + 1));
        }
        e = EL(nu(i), e);
      }
      return k_(e);
    }
    Nn.computeSourceURL = xj;
  });
  var z_ = jt((ML) => {
    var F_ = su(),
      B_ = Object.prototype.hasOwnProperty,
      Pl = typeof Map != "undefined";
    function Pa() {
      (this._array = []), (this._set = Pl ? new Map() : Object.create(null));
    }
    Pa.fromArray = function (e, t) {
      for (var i = new Pa(), r = 0, s = e.length; r < s; r++) i.add(e[r], t);
      return i;
    };
    Pa.prototype.size = function () {
      return Pl ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    Pa.prototype.add = function (e, t) {
      var i = Pl ? e : F_.toSetString(e),
        r = Pl ? this.has(e) : B_.call(this._set, i),
        s = this._array.length;
      (!r || t) && this._array.push(e),
        r || (Pl ? this._set.set(e, s) : (this._set[i] = s));
    };
    Pa.prototype.has = function (e) {
      if (Pl) return this._set.has(e);
      var t = F_.toSetString(e);
      return B_.call(this._set, t);
    };
    Pa.prototype.indexOf = function (e) {
      if (Pl) {
        var t = this._set.get(e);
        if (t >= 0) return t;
      } else {
        var i = F_.toSetString(e);
        if (B_.call(this._set, i)) return this._set[i];
      }
      throw new Error('"' + e + '" is not in the set.');
    };
    Pa.prototype.at = function (e) {
      if (e >= 0 && e < this._array.length) return this._array[e];
      throw new Error("No element indexed by " + e);
    };
    Pa.prototype.toArray = function () {
      return this._array.slice();
    };
    ML.ArraySet = Pa;
  });
  var PL = jt((CL) => {
    var AL = su();
    function bj(n, e) {
      var t = n.generatedLine,
        i = e.generatedLine,
        r = n.generatedColumn,
        s = e.generatedColumn;
      return (
        i > t ||
        (i == t && s >= r) ||
        AL.compareByGeneratedPositionsInflated(n, e) <= 0
      );
    }
    function Lm() {
      (this._array = []),
        (this._sorted = !0),
        (this._last = { generatedLine: -1, generatedColumn: 0 });
    }
    Lm.prototype.unsortedForEach = function (e, t) {
      this._array.forEach(e, t);
    };
    Lm.prototype.add = function (e) {
      bj(this._last, e)
        ? ((this._last = e), this._array.push(e))
        : ((this._sorted = !1), this._array.push(e));
    };
    Lm.prototype.toArray = function () {
      return (
        this._sorted ||
          (this._array.sort(AL.compareByGeneratedPositionsInflated),
          (this._sorted = !0)),
        this._array
      );
    };
    CL.MappingList = Lm;
  });
  var U_ = jt((DL) => {
    var bf = N_(),
      tn = su(),
      Rm = z_().ArraySet,
      _j = PL().MappingList;
    function es(n) {
      n || (n = {}),
        (this._file = tn.getArg(n, "file", null)),
        (this._sourceRoot = tn.getArg(n, "sourceRoot", null)),
        (this._skipValidation = tn.getArg(n, "skipValidation", !1)),
        (this._sources = new Rm()),
        (this._names = new Rm()),
        (this._mappings = new _j()),
        (this._sourcesContents = null);
    }
    es.prototype._version = 3;
    es.fromSourceMap = function (e) {
      var t = e.sourceRoot,
        i = new es({ file: e.file, sourceRoot: t });
      return (
        e.eachMapping(function (r) {
          var s = {
            generated: { line: r.generatedLine, column: r.generatedColumn },
          };
          r.source != null &&
            ((s.source = r.source),
            t != null && (s.source = tn.relative(t, s.source)),
            (s.original = { line: r.originalLine, column: r.originalColumn }),
            r.name != null && (s.name = r.name)),
            i.addMapping(s);
        }),
        e.sources.forEach(function (r) {
          var s = r;
          t !== null && (s = tn.relative(t, r)),
            i._sources.has(s) || i._sources.add(s);
          var a = e.sourceContentFor(r);
          a != null && i.setSourceContent(r, a);
        }),
        i
      );
    };
    es.prototype.addMapping = function (e) {
      var t = tn.getArg(e, "generated"),
        i = tn.getArg(e, "original", null),
        r = tn.getArg(e, "source", null),
        s = tn.getArg(e, "name", null);
      this._skipValidation || this._validateMapping(t, i, r, s),
        r != null &&
          ((r = String(r)), this._sources.has(r) || this._sources.add(r)),
        s != null &&
          ((s = String(s)), this._names.has(s) || this._names.add(s)),
        this._mappings.add({
          generatedLine: t.line,
          generatedColumn: t.column,
          originalLine: i != null && i.line,
          originalColumn: i != null && i.column,
          source: r,
          name: s,
        });
    };
    es.prototype.setSourceContent = function (e, t) {
      var i = e;
      this._sourceRoot != null && (i = tn.relative(this._sourceRoot, i)),
        t != null
          ? (this._sourcesContents ||
              (this._sourcesContents = Object.create(null)),
            (this._sourcesContents[tn.toSetString(i)] = t))
          : this._sourcesContents &&
            (delete this._sourcesContents[tn.toSetString(i)],
            Object.keys(this._sourcesContents).length === 0 &&
              (this._sourcesContents = null));
    };
    es.prototype.applySourceMap = function (e, t, i) {
      var r = t;
      if (t == null) {
        if (e.file == null)
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        r = e.file;
      }
      var s = this._sourceRoot;
      s != null && (r = tn.relative(s, r));
      var a = new Rm(),
        o = new Rm();
      this._mappings.unsortedForEach(function (l) {
        if (l.source === r && l.originalLine != null) {
          var c = e.originalPositionFor({
            line: l.originalLine,
            column: l.originalColumn,
          });
          c.source != null &&
            ((l.source = c.source),
            i != null && (l.source = tn.join(i, l.source)),
            s != null && (l.source = tn.relative(s, l.source)),
            (l.originalLine = c.line),
            (l.originalColumn = c.column),
            c.name != null && (l.name = c.name));
        }
        var u = l.source;
        u != null && !a.has(u) && a.add(u);
        var f = l.name;
        f != null && !o.has(f) && o.add(f);
      }, this),
        (this._sources = a),
        (this._names = o),
        e.sources.forEach(function (l) {
          var c = e.sourceContentFor(l);
          c != null &&
            (i != null && (l = tn.join(i, l)),
            s != null && (l = tn.relative(s, l)),
            this.setSourceContent(l, c));
        }, this);
    };
    es.prototype._validateMapping = function (e, t, i, r) {
      if (t && typeof t.line != "number" && typeof t.column != "number")
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      if (
        !(
          e &&
          "line" in e &&
          "column" in e &&
          e.line > 0 &&
          e.column >= 0 &&
          !t &&
          !i &&
          !r
        )
      ) {
        if (
          e &&
          "line" in e &&
          "column" in e &&
          t &&
          "line" in t &&
          "column" in t &&
          e.line > 0 &&
          e.column >= 0 &&
          t.line > 0 &&
          t.column >= 0 &&
          i
        )
          return;
        throw new Error(
          "Invalid mapping: " +
            JSON.stringify({ generated: e, source: i, original: t, name: r })
        );
      }
    };
    es.prototype._serializeMappings = function () {
      for (
        var e = 0,
          t = 1,
          i = 0,
          r = 0,
          s = 0,
          a = 0,
          o = "",
          l,
          c,
          u,
          f,
          d = this._mappings.toArray(),
          m = 0,
          x = d.length;
        m < x;
        m++
      ) {
        if (((c = d[m]), (l = ""), c.generatedLine !== t))
          for (e = 0; c.generatedLine !== t; ) (l += ";"), t++;
        else if (m > 0) {
          if (!tn.compareByGeneratedPositionsInflated(c, d[m - 1])) continue;
          l += ",";
        }
        (l += bf.encode(c.generatedColumn - e)),
          (e = c.generatedColumn),
          c.source != null &&
            ((f = this._sources.indexOf(c.source)),
            (l += bf.encode(f - a)),
            (a = f),
            (l += bf.encode(c.originalLine - 1 - r)),
            (r = c.originalLine - 1),
            (l += bf.encode(c.originalColumn - i)),
            (i = c.originalColumn),
            c.name != null &&
              ((u = this._names.indexOf(c.name)),
              (l += bf.encode(u - s)),
              (s = u))),
          (o += l);
      }
      return o;
    };
    es.prototype._generateSourcesContent = function (e, t) {
      return e.map(function (i) {
        if (!this._sourcesContents) return null;
        t != null && (i = tn.relative(t, i));
        var r = tn.toSetString(i);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, r)
          ? this._sourcesContents[r]
          : null;
      }, this);
    };
    es.prototype.toJSON = function () {
      var e = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings(),
      };
      return (
        this._file != null && (e.file = this._file),
        this._sourceRoot != null && (e.sourceRoot = this._sourceRoot),
        this._sourcesContents &&
          (e.sourcesContent = this._generateSourcesContent(
            e.sources,
            e.sourceRoot
          )),
        e
      );
    };
    es.prototype.toString = function () {
      return JSON.stringify(this.toJSON());
    };
    DL.SourceMapGenerator = es;
  });
  var IL = jt((Dl) => {
    Dl.GREATEST_LOWER_BOUND = 1;
    Dl.LEAST_UPPER_BOUND = 2;
    function V_(n, e, t, i, r, s) {
      var a = Math.floor((e - n) / 2) + n,
        o = r(t, i[a], !0);
      return o === 0
        ? a
        : o > 0
        ? e - a > 1
          ? V_(a, e, t, i, r, s)
          : s == Dl.LEAST_UPPER_BOUND
          ? e < i.length
            ? e
            : -1
          : a
        : a - n > 1
        ? V_(n, a, t, i, r, s)
        : s == Dl.LEAST_UPPER_BOUND
        ? a
        : n < 0
        ? -1
        : n;
    }
    Dl.search = function (e, t, i, r) {
      if (t.length === 0) return -1;
      var s = V_(-1, t.length, e, t, i, r || Dl.GREATEST_LOWER_BOUND);
      if (s < 0) return -1;
      for (; s - 1 >= 0 && i(t[s], t[s - 1], !0) === 0; ) --s;
      return s;
    };
  });
  var RL = jt((LL) => {
    function G_(n, e, t) {
      var i = n[e];
      (n[e] = n[t]), (n[t] = i);
    }
    function Ej(n, e) {
      return Math.round(n + Math.random() * (e - n));
    }
    function H_(n, e, t, i) {
      if (t < i) {
        var r = Ej(t, i),
          s = t - 1;
        G_(n, r, i);
        for (var a = n[i], o = t; o < i; o++)
          e(n[o], a) <= 0 && ((s += 1), G_(n, s, o));
        G_(n, s + 1, o);
        var l = s + 1;
        H_(n, e, t, l - 1), H_(n, e, l + 1, i);
      }
    }
    LL.quickSort = function (n, e) {
      H_(n, e, 0, n.length - 1);
    };
  });
  var NL = jt((Om) => {
    var pt = su(),
      $_ = IL(),
      au = z_().ArraySet,
      Tj = N_(),
      _f = RL().quickSort;
    function Ii(n, e) {
      var t = n;
      return (
        typeof n == "string" && (t = pt.parseSourceMapInput(n)),
        t.sections != null ? new ys(t, e) : new Sn(t, e)
      );
    }
    Ii.fromSourceMap = function (n, e) {
      return Sn.fromSourceMap(n, e);
    };
    Ii.prototype._version = 3;
    Ii.prototype.__generatedMappings = null;
    Object.defineProperty(Ii.prototype, "_generatedMappings", {
      configurable: !0,
      enumerable: !0,
      get: function () {
        return (
          this.__generatedMappings ||
            this._parseMappings(this._mappings, this.sourceRoot),
          this.__generatedMappings
        );
      },
    });
    Ii.prototype.__originalMappings = null;
    Object.defineProperty(Ii.prototype, "_originalMappings", {
      configurable: !0,
      enumerable: !0,
      get: function () {
        return (
          this.__originalMappings ||
            this._parseMappings(this._mappings, this.sourceRoot),
          this.__originalMappings
        );
      },
    });
    Ii.prototype._charIsMappingSeparator = function (e, t) {
      var i = e.charAt(t);
      return i === ";" || i === ",";
    };
    Ii.prototype._parseMappings = function (e, t) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    Ii.GENERATED_ORDER = 1;
    Ii.ORIGINAL_ORDER = 2;
    Ii.GREATEST_LOWER_BOUND = 1;
    Ii.LEAST_UPPER_BOUND = 2;
    Ii.prototype.eachMapping = function (e, t, i) {
      var r = t || null,
        s = i || Ii.GENERATED_ORDER,
        a;
      switch (s) {
        case Ii.GENERATED_ORDER:
          a = this._generatedMappings;
          break;
        case Ii.ORIGINAL_ORDER:
          a = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var o = this.sourceRoot;
      a.map(function (l) {
        var c = l.source === null ? null : this._sources.at(l.source);
        return (
          (c = pt.computeSourceURL(o, c, this._sourceMapURL)),
          {
            source: c,
            generatedLine: l.generatedLine,
            generatedColumn: l.generatedColumn,
            originalLine: l.originalLine,
            originalColumn: l.originalColumn,
            name: l.name === null ? null : this._names.at(l.name),
          }
        );
      }, this).forEach(e, r);
    };
    Ii.prototype.allGeneratedPositionsFor = function (e) {
      var t = pt.getArg(e, "line"),
        i = {
          source: pt.getArg(e, "source"),
          originalLine: t,
          originalColumn: pt.getArg(e, "column", 0),
        };
      if (((i.source = this._findSourceIndex(i.source)), i.source < 0))
        return [];
      var r = [],
        s = this._findMapping(
          i,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          pt.compareByOriginalPositions,
          $_.LEAST_UPPER_BOUND
        );
      if (s >= 0) {
        var a = this._originalMappings[s];
        if (e.column === void 0)
          for (var o = a.originalLine; a && a.originalLine === o; )
            r.push({
              line: pt.getArg(a, "generatedLine", null),
              column: pt.getArg(a, "generatedColumn", null),
              lastColumn: pt.getArg(a, "lastGeneratedColumn", null),
            }),
              (a = this._originalMappings[++s]);
        else
          for (
            var l = a.originalColumn;
            a && a.originalLine === t && a.originalColumn == l;

          )
            r.push({
              line: pt.getArg(a, "generatedLine", null),
              column: pt.getArg(a, "generatedColumn", null),
              lastColumn: pt.getArg(a, "lastGeneratedColumn", null),
            }),
              (a = this._originalMappings[++s]);
      }
      return r;
    };
    Om.SourceMapConsumer = Ii;
    function Sn(n, e) {
      var t = n;
      typeof n == "string" && (t = pt.parseSourceMapInput(n));
      var i = pt.getArg(t, "version"),
        r = pt.getArg(t, "sources"),
        s = pt.getArg(t, "names", []),
        a = pt.getArg(t, "sourceRoot", null),
        o = pt.getArg(t, "sourcesContent", null),
        l = pt.getArg(t, "mappings"),
        c = pt.getArg(t, "file", null);
      if (i != this._version) throw new Error("Unsupported version: " + i);
      a && (a = pt.normalize(a)),
        (r = r
          .map(String)
          .map(pt.normalize)
          .map(function (u) {
            return a && pt.isAbsolute(a) && pt.isAbsolute(u)
              ? pt.relative(a, u)
              : u;
          })),
        (this._names = au.fromArray(s.map(String), !0)),
        (this._sources = au.fromArray(r, !0)),
        (this._absoluteSources = this._sources.toArray().map(function (u) {
          return pt.computeSourceURL(a, u, e);
        })),
        (this.sourceRoot = a),
        (this.sourcesContent = o),
        (this._mappings = l),
        (this._sourceMapURL = e),
        (this.file = c);
    }
    Sn.prototype = Object.create(Ii.prototype);
    Sn.prototype.consumer = Ii;
    Sn.prototype._findSourceIndex = function (n) {
      var e = n;
      if (
        (this.sourceRoot != null && (e = pt.relative(this.sourceRoot, e)),
        this._sources.has(e))
      )
        return this._sources.indexOf(e);
      var t;
      for (t = 0; t < this._absoluteSources.length; ++t)
        if (this._absoluteSources[t] == n) return t;
      return -1;
    };
    Sn.fromSourceMap = function (e, t) {
      var i = Object.create(Sn.prototype),
        r = (i._names = au.fromArray(e._names.toArray(), !0)),
        s = (i._sources = au.fromArray(e._sources.toArray(), !0));
      (i.sourceRoot = e._sourceRoot),
        (i.sourcesContent = e._generateSourcesContent(
          i._sources.toArray(),
          i.sourceRoot
        )),
        (i.file = e._file),
        (i._sourceMapURL = t),
        (i._absoluteSources = i._sources.toArray().map(function (m) {
          return pt.computeSourceURL(i.sourceRoot, m, t);
        }));
      for (
        var a = e._mappings.toArray().slice(),
          o = (i.__generatedMappings = []),
          l = (i.__originalMappings = []),
          c = 0,
          u = a.length;
        c < u;
        c++
      ) {
        var f = a[c],
          d = new OL();
        (d.generatedLine = f.generatedLine),
          (d.generatedColumn = f.generatedColumn),
          f.source &&
            ((d.source = s.indexOf(f.source)),
            (d.originalLine = f.originalLine),
            (d.originalColumn = f.originalColumn),
            f.name && (d.name = r.indexOf(f.name)),
            l.push(d)),
          o.push(d);
      }
      return _f(i.__originalMappings, pt.compareByOriginalPositions), i;
    };
    Sn.prototype._version = 3;
    Object.defineProperty(Sn.prototype, "sources", {
      get: function () {
        return this._absoluteSources.slice();
      },
    });
    function OL() {
      (this.generatedLine = 0),
        (this.generatedColumn = 0),
        (this.source = null),
        (this.originalLine = null),
        (this.originalColumn = null),
        (this.name = null);
    }
    Sn.prototype._parseMappings = function (e, t) {
      for (
        var i = 1,
          r = 0,
          s = 0,
          a = 0,
          o = 0,
          l = 0,
          c = e.length,
          u = 0,
          f = {},
          d = {},
          m = [],
          x = [],
          y,
          g,
          b,
          _,
          E;
        u < c;

      )
        if (e.charAt(u) === ";") i++, u++, (r = 0);
        else if (e.charAt(u) === ",") u++;
        else {
          for (
            y = new OL(), y.generatedLine = i, _ = u;
            _ < c && !this._charIsMappingSeparator(e, _);
            _++
          );
          if (((g = e.slice(u, _)), (b = f[g]), b)) u += g.length;
          else {
            for (b = []; u < _; )
              Tj.decode(e, u, d), (E = d.value), (u = d.rest), b.push(E);
            if (b.length === 2)
              throw new Error("Found a source, but no line and column");
            if (b.length === 3)
              throw new Error("Found a source and line, but no column");
            f[g] = b;
          }
          (y.generatedColumn = r + b[0]),
            (r = y.generatedColumn),
            b.length > 1 &&
              ((y.source = o + b[1]),
              (o += b[1]),
              (y.originalLine = s + b[2]),
              (s = y.originalLine),
              (y.originalLine += 1),
              (y.originalColumn = a + b[3]),
              (a = y.originalColumn),
              b.length > 4 && ((y.name = l + b[4]), (l += b[4]))),
            x.push(y),
            typeof y.originalLine == "number" && m.push(y);
        }
      _f(x, pt.compareByGeneratedPositionsDeflated),
        (this.__generatedMappings = x),
        _f(m, pt.compareByOriginalPositions),
        (this.__originalMappings = m);
    };
    Sn.prototype._findMapping = function (e, t, i, r, s, a) {
      if (e[i] <= 0)
        throw new TypeError(
          "Line must be greater than or equal to 1, got " + e[i]
        );
      if (e[r] < 0)
        throw new TypeError(
          "Column must be greater than or equal to 0, got " + e[r]
        );
      return $_.search(e, t, s, a);
    };
    Sn.prototype.computeColumnSpans = function () {
      for (var e = 0; e < this._generatedMappings.length; ++e) {
        var t = this._generatedMappings[e];
        if (e + 1 < this._generatedMappings.length) {
          var i = this._generatedMappings[e + 1];
          if (t.generatedLine === i.generatedLine) {
            t.lastGeneratedColumn = i.generatedColumn - 1;
            continue;
          }
        }
        t.lastGeneratedColumn = 1 / 0;
      }
    };
    Sn.prototype.originalPositionFor = function (e) {
      var t = {
          generatedLine: pt.getArg(e, "line"),
          generatedColumn: pt.getArg(e, "column"),
        },
        i = this._findMapping(
          t,
          this._generatedMappings,
          "generatedLine",
          "generatedColumn",
          pt.compareByGeneratedPositionsDeflated,
          pt.getArg(e, "bias", Ii.GREATEST_LOWER_BOUND)
        );
      if (i >= 0) {
        var r = this._generatedMappings[i];
        if (r.generatedLine === t.generatedLine) {
          var s = pt.getArg(r, "source", null);
          s !== null &&
            ((s = this._sources.at(s)),
            (s = pt.computeSourceURL(this.sourceRoot, s, this._sourceMapURL)));
          var a = pt.getArg(r, "name", null);
          return (
            a !== null && (a = this._names.at(a)),
            {
              source: s,
              line: pt.getArg(r, "originalLine", null),
              column: pt.getArg(r, "originalColumn", null),
              name: a,
            }
          );
        }
      }
      return { source: null, line: null, column: null, name: null };
    };
    Sn.prototype.hasContentsOfAllSources = function () {
      return this.sourcesContent
        ? this.sourcesContent.length >= this._sources.size() &&
            !this.sourcesContent.some(function (e) {
              return e == null;
            })
        : !1;
    };
    Sn.prototype.sourceContentFor = function (e, t) {
      if (!this.sourcesContent) return null;
      var i = this._findSourceIndex(e);
      if (i >= 0) return this.sourcesContent[i];
      var r = e;
      this.sourceRoot != null && (r = pt.relative(this.sourceRoot, r));
      var s;
      if (this.sourceRoot != null && (s = pt.urlParse(this.sourceRoot))) {
        var a = r.replace(/^file:\/\//, "");
        if (s.scheme == "file" && this._sources.has(a))
          return this.sourcesContent[this._sources.indexOf(a)];
        if ((!s.path || s.path == "/") && this._sources.has("/" + r))
          return this.sourcesContent[this._sources.indexOf("/" + r)];
      }
      if (t) return null;
      throw new Error('"' + r + '" is not in the SourceMap.');
    };
    Sn.prototype.generatedPositionFor = function (e) {
      var t = pt.getArg(e, "source");
      if (((t = this._findSourceIndex(t)), t < 0))
        return { line: null, column: null, lastColumn: null };
      var i = {
          source: t,
          originalLine: pt.getArg(e, "line"),
          originalColumn: pt.getArg(e, "column"),
        },
        r = this._findMapping(
          i,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          pt.compareByOriginalPositions,
          pt.getArg(e, "bias", Ii.GREATEST_LOWER_BOUND)
        );
      if (r >= 0) {
        var s = this._originalMappings[r];
        if (s.source === i.source)
          return {
            line: pt.getArg(s, "generatedLine", null),
            column: pt.getArg(s, "generatedColumn", null),
            lastColumn: pt.getArg(s, "lastGeneratedColumn", null),
          };
      }
      return { line: null, column: null, lastColumn: null };
    };
    Om.BasicSourceMapConsumer = Sn;
    function ys(n, e) {
      var t = n;
      typeof n == "string" && (t = pt.parseSourceMapInput(n));
      var i = pt.getArg(t, "version"),
        r = pt.getArg(t, "sections");
      if (i != this._version) throw new Error("Unsupported version: " + i);
      (this._sources = new au()), (this._names = new au());
      var s = { line: -1, column: 0 };
      this._sections = r.map(function (a) {
        if (a.url)
          throw new Error("Support for url field in sections not implemented.");
        var o = pt.getArg(a, "offset"),
          l = pt.getArg(o, "line"),
          c = pt.getArg(o, "column");
        if (l < s.line || (l === s.line && c < s.column))
          throw new Error(
            "Section offsets must be ordered and non-overlapping."
          );
        return (
          (s = o),
          {
            generatedOffset: { generatedLine: l + 1, generatedColumn: c + 1 },
            consumer: new Ii(pt.getArg(a, "map"), e),
          }
        );
      });
    }
    ys.prototype = Object.create(Ii.prototype);
    ys.prototype.constructor = Ii;
    ys.prototype._version = 3;
    Object.defineProperty(ys.prototype, "sources", {
      get: function () {
        for (var n = [], e = 0; e < this._sections.length; e++)
          for (var t = 0; t < this._sections[e].consumer.sources.length; t++)
            n.push(this._sections[e].consumer.sources[t]);
        return n;
      },
    });
    ys.prototype.originalPositionFor = function (e) {
      var t = {
          generatedLine: pt.getArg(e, "line"),
          generatedColumn: pt.getArg(e, "column"),
        },
        i = $_.search(t, this._sections, function (s, a) {
          var o = s.generatedLine - a.generatedOffset.generatedLine;
          return o || s.generatedColumn - a.generatedOffset.generatedColumn;
        }),
        r = this._sections[i];
      return r
        ? r.consumer.originalPositionFor({
            line: t.generatedLine - (r.generatedOffset.generatedLine - 1),
            column:
              t.generatedColumn -
              (r.generatedOffset.generatedLine === t.generatedLine
                ? r.generatedOffset.generatedColumn - 1
                : 0),
            bias: e.bias,
          })
        : { source: null, line: null, column: null, name: null };
    };
    ys.prototype.hasContentsOfAllSources = function () {
      return this._sections.every(function (e) {
        return e.consumer.hasContentsOfAllSources();
      });
    };
    ys.prototype.sourceContentFor = function (e, t) {
      for (var i = 0; i < this._sections.length; i++) {
        var r = this._sections[i],
          s = r.consumer.sourceContentFor(e, !0);
        if (s) return s;
      }
      if (t) return null;
      throw new Error('"' + e + '" is not in the SourceMap.');
    };
    ys.prototype.generatedPositionFor = function (e) {
      for (var t = 0; t < this._sections.length; t++) {
        var i = this._sections[t];
        if (i.consumer._findSourceIndex(pt.getArg(e, "source")) !== -1) {
          var r = i.consumer.generatedPositionFor(e);
          if (r) {
            var s = {
              line: r.line + (i.generatedOffset.generatedLine - 1),
              column:
                r.column +
                (i.generatedOffset.generatedLine === r.line
                  ? i.generatedOffset.generatedColumn - 1
                  : 0),
            };
            return s;
          }
        }
      }
      return { line: null, column: null };
    };
    ys.prototype._parseMappings = function (e, t) {
      (this.__generatedMappings = []), (this.__originalMappings = []);
      for (var i = 0; i < this._sections.length; i++)
        for (
          var r = this._sections[i], s = r.consumer._generatedMappings, a = 0;
          a < s.length;
          a++
        ) {
          var o = s[a],
            l = r.consumer._sources.at(o.source);
          (l = pt.computeSourceURL(
            r.consumer.sourceRoot,
            l,
            this._sourceMapURL
          )),
            this._sources.add(l),
            (l = this._sources.indexOf(l));
          var c = null;
          o.name &&
            ((c = r.consumer._names.at(o.name)),
            this._names.add(c),
            (c = this._names.indexOf(c)));
          var u = {
            source: l,
            generatedLine:
              o.generatedLine + (r.generatedOffset.generatedLine - 1),
            generatedColumn:
              o.generatedColumn +
              (r.generatedOffset.generatedLine === o.generatedLine
                ? r.generatedOffset.generatedColumn - 1
                : 0),
            originalLine: o.originalLine,
            originalColumn: o.originalColumn,
            name: c,
          };
          this.__generatedMappings.push(u),
            typeof u.originalLine == "number" &&
              this.__originalMappings.push(u);
        }
      _f(this.__generatedMappings, pt.compareByGeneratedPositionsDeflated),
        _f(this.__originalMappings, pt.compareByOriginalPositions);
    };
    Om.IndexedSourceMapConsumer = ys;
  });
  var FL = jt((kL) => {
    var Sj = U_().SourceMapGenerator,
      Nm = su(),
      wj = /(\r?\n)/,
      Mj = 10,
      ou = "$$$isSourceNode$$$";
    function wr(n, e, t, i, r) {
      (this.children = []),
        (this.sourceContents = {}),
        (this.line = n == null ? null : n),
        (this.column = e == null ? null : e),
        (this.source = t == null ? null : t),
        (this.name = r == null ? null : r),
        (this[ou] = !0),
        i != null && this.add(i);
    }
    wr.fromStringWithSourceMap = function (e, t, i) {
      var r = new wr(),
        s = e.split(wj),
        a = 0,
        o = function () {
          var d = x(),
            m = x() || "";
          return d + m;
          function x() {
            return a < s.length ? s[a++] : void 0;
          }
        },
        l = 1,
        c = 0,
        u = null;
      return (
        t.eachMapping(function (d) {
          if (u !== null)
            if (l < d.generatedLine) f(u, o()), l++, (c = 0);
            else {
              var m = s[a] || "",
                x = m.substr(0, d.generatedColumn - c);
              (s[a] = m.substr(d.generatedColumn - c)),
                (c = d.generatedColumn),
                f(u, x),
                (u = d);
              return;
            }
          for (; l < d.generatedLine; ) r.add(o()), l++;
          if (c < d.generatedColumn) {
            var m = s[a] || "";
            r.add(m.substr(0, d.generatedColumn)),
              (s[a] = m.substr(d.generatedColumn)),
              (c = d.generatedColumn);
          }
          u = d;
        }, this),
        a < s.length && (u && f(u, o()), r.add(s.splice(a).join(""))),
        t.sources.forEach(function (d) {
          var m = t.sourceContentFor(d);
          m != null &&
            (i != null && (d = Nm.join(i, d)), r.setSourceContent(d, m));
        }),
        r
      );
      function f(d, m) {
        if (d === null || d.source === void 0) r.add(m);
        else {
          var x = i ? Nm.join(i, d.source) : d.source;
          r.add(new wr(d.originalLine, d.originalColumn, x, m, d.name));
        }
      }
    };
    wr.prototype.add = function (e) {
      if (Array.isArray(e))
        e.forEach(function (t) {
          this.add(t);
        }, this);
      else if (e[ou] || typeof e == "string") e && this.children.push(e);
      else
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
            e
        );
      return this;
    };
    wr.prototype.prepend = function (e) {
      if (Array.isArray(e))
        for (var t = e.length - 1; t >= 0; t--) this.prepend(e[t]);
      else if (e[ou] || typeof e == "string") this.children.unshift(e);
      else
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
            e
        );
      return this;
    };
    wr.prototype.walk = function (e) {
      for (var t, i = 0, r = this.children.length; i < r; i++)
        (t = this.children[i]),
          t[ou]
            ? t.walk(e)
            : t !== "" &&
              e(t, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name,
              });
    };
    wr.prototype.join = function (e) {
      var t,
        i,
        r = this.children.length;
      if (r > 0) {
        for (t = [], i = 0; i < r - 1; i++) t.push(this.children[i]), t.push(e);
        t.push(this.children[i]), (this.children = t);
      }
      return this;
    };
    wr.prototype.replaceRight = function (e, t) {
      var i = this.children[this.children.length - 1];
      return (
        i[ou]
          ? i.replaceRight(e, t)
          : typeof i == "string"
          ? (this.children[this.children.length - 1] = i.replace(e, t))
          : this.children.push("".replace(e, t)),
        this
      );
    };
    wr.prototype.setSourceContent = function (e, t) {
      this.sourceContents[Nm.toSetString(e)] = t;
    };
    wr.prototype.walkSourceContents = function (e) {
      for (var t = 0, i = this.children.length; t < i; t++)
        this.children[t][ou] && this.children[t].walkSourceContents(e);
      for (
        var r = Object.keys(this.sourceContents), t = 0, i = r.length;
        t < i;
        t++
      )
        e(Nm.fromSetString(r[t]), this.sourceContents[r[t]]);
    };
    wr.prototype.toString = function () {
      var e = "";
      return (
        this.walk(function (t) {
          e += t;
        }),
        e
      );
    };
    wr.prototype.toStringWithSourceMap = function (e) {
      var t = { code: "", line: 1, column: 0 },
        i = new Sj(e),
        r = !1,
        s = null,
        a = null,
        o = null,
        l = null;
      return (
        this.walk(function (c, u) {
          (t.code += c),
            u.source !== null && u.line !== null && u.column !== null
              ? ((s !== u.source ||
                  a !== u.line ||
                  o !== u.column ||
                  l !== u.name) &&
                  i.addMapping({
                    source: u.source,
                    original: { line: u.line, column: u.column },
                    generated: { line: t.line, column: t.column },
                    name: u.name,
                  }),
                (s = u.source),
                (a = u.line),
                (o = u.column),
                (l = u.name),
                (r = !0))
              : r &&
                (i.addMapping({
                  generated: { line: t.line, column: t.column },
                }),
                (s = null),
                (r = !1));
          for (var f = 0, d = c.length; f < d; f++)
            c.charCodeAt(f) === Mj
              ? (t.line++,
                (t.column = 0),
                f + 1 === d
                  ? ((s = null), (r = !1))
                  : r &&
                    i.addMapping({
                      source: u.source,
                      original: { line: u.line, column: u.column },
                      generated: { line: t.line, column: t.column },
                      name: u.name,
                    }))
              : t.column++;
        }),
        this.walkSourceContents(function (c, u) {
          i.setSourceContent(c, u);
        }),
        { code: t.code, map: i }
      );
    };
    kL.SourceNode = wr;
  });
  var BL = jt((km) => {
    km.SourceMapGenerator = U_().SourceMapGenerator;
    km.SourceMapConsumer = NL().SourceMapConsumer;
    km.SourceNode = FL().SourceNode;
  });
  var UL = jt((Fm, zL) => {
    (function (n, e) {
      typeof Fm == "object" && typeof zL != "undefined"
        ? e(Fm)
        : typeof define == "function" && define.amd
        ? define(["exports"], e)
        : ((n = n || self), e((n.estreeWalker = {})));
    })(Fm, function (n) {
      "use strict";
      class e {
        constructor() {
          (this.should_skip = !1),
            (this.should_remove = !1),
            (this.replacement = null),
            (this.context = {
              skip: () => (this.should_skip = !0),
              remove: () => (this.should_remove = !0),
              replace: (o) => (this.replacement = o),
            });
        }
        replace(o, l, c, u) {
          o && (c !== null ? (o[l][c] = u) : (o[l] = u));
        }
        remove(o, l, c) {
          o && (c !== null ? o[l].splice(c, 1) : delete o[l]);
        }
      }
      class t extends e {
        constructor(o, l) {
          super();
          (this.enter = o), (this.leave = l);
        }
        visit(o, l, c, u) {
          if (o) {
            if (this.enter) {
              let f = this.should_skip,
                d = this.should_remove,
                m = this.replacement;
              (this.should_skip = !1),
                (this.should_remove = !1),
                (this.replacement = null),
                this.enter.call(this.context, o, l, c, u),
                this.replacement &&
                  ((o = this.replacement), this.replace(l, c, u, o)),
                this.should_remove && this.remove(l, c, u);
              let x = this.should_skip,
                y = this.should_remove;
              if (
                ((this.should_skip = f),
                (this.should_remove = d),
                (this.replacement = m),
                x)
              )
                return o;
              if (y) return null;
            }
            for (let f in o) {
              let d = o[f];
              if (typeof d == "object")
                if (Array.isArray(d))
                  for (let m = 0; m < d.length; m += 1)
                    d[m] !== null &&
                      typeof d[m].type == "string" &&
                      (this.visit(d[m], o, f, m) || m--);
                else
                  d !== null &&
                    typeof d.type == "string" &&
                    this.visit(d, o, f, null);
            }
            if (this.leave) {
              let f = this.replacement,
                d = this.should_remove;
              (this.replacement = null),
                (this.should_remove = !1),
                this.leave.call(this.context, o, l, c, u),
                this.replacement &&
                  ((o = this.replacement), this.replace(l, c, u, o)),
                this.should_remove && this.remove(l, c, u);
              let m = this.should_remove;
              if (((this.replacement = f), (this.should_remove = d), m))
                return null;
            }
          }
          return o;
        }
      }
      class i extends e {
        constructor(o, l) {
          super();
          (this.enter = o), (this.leave = l);
        }
        visit(o, l, c, u) {
          return Fr(this, null, function* () {
            if (o) {
              if (this.enter) {
                let f = this.should_skip,
                  d = this.should_remove,
                  m = this.replacement;
                (this.should_skip = !1),
                  (this.should_remove = !1),
                  (this.replacement = null),
                  yield this.enter.call(this.context, o, l, c, u),
                  this.replacement &&
                    ((o = this.replacement), this.replace(l, c, u, o)),
                  this.should_remove && this.remove(l, c, u);
                let x = this.should_skip,
                  y = this.should_remove;
                if (
                  ((this.should_skip = f),
                  (this.should_remove = d),
                  (this.replacement = m),
                  x)
                )
                  return o;
                if (y) return null;
              }
              for (let f in o) {
                let d = o[f];
                if (typeof d == "object")
                  if (Array.isArray(d))
                    for (let m = 0; m < d.length; m += 1)
                      d[m] !== null &&
                        typeof d[m].type == "string" &&
                        ((yield this.visit(d[m], o, f, m)) || m--);
                  else
                    d !== null &&
                      typeof d.type == "string" &&
                      (yield this.visit(d, o, f, null));
              }
              if (this.leave) {
                let f = this.replacement,
                  d = this.should_remove;
                (this.replacement = null),
                  (this.should_remove = !1),
                  yield this.leave.call(this.context, o, l, c, u),
                  this.replacement &&
                    ((o = this.replacement), this.replace(l, c, u, o)),
                  this.should_remove && this.remove(l, c, u);
                let m = this.should_remove;
                if (((this.replacement = f), (this.should_remove = d), m))
                  return null;
              }
            }
            return o;
          });
        }
      }
      function r(a, { enter: o, leave: l }) {
        return new t(o, l).visit(a, null);
      }
      function s(c, u) {
        return Fr(this, arguments, function* (a, { enter: o, leave: l }) {
          return yield new i(o, l).visit(a, null);
        });
      }
      (n.asyncWalk = s),
        (n.walk = r),
        Object.defineProperty(n, "__esModule", { value: !0 });
    });
  });
  var YR = jt((Ae) => {
    "use strict";
    Object.defineProperty(Ae, "__esModule", { value: !0 });
    var nt = lo(),
      nR = pL(),
      Aj = BL(),
      Cj = UL();
    function Z_(n) {
      throw n;
    }
    function rR(n) {}
    function Li(n, e, t, i) {
      let r = (t || Pj)[n] + (i || ""),
        s = new SyntaxError(String(r));
      return (s.code = n), (s.loc = e), s;
    }
    var Pj = {
        [0]: "Illegal comment.",
        [1]: "CDATA section is allowed only in XML context.",
        [2]: "Duplicate attribute.",
        [3]: "End tag cannot have attributes.",
        [4]: "Illegal '/' in tags.",
        [5]: "Unexpected EOF in tag.",
        [6]: "Unexpected EOF in CDATA section.",
        [7]: "Unexpected EOF in comment.",
        [8]: "Unexpected EOF in script.",
        [9]: "Unexpected EOF in tag.",
        [10]: "Incorrectly closed comment.",
        [11]: "Incorrectly opened comment.",
        [12]: "Illegal tag name. Use '&lt;' to print '<'.",
        [13]: "Attribute value was expected.",
        [14]: "End tag name was expected.",
        [15]: "Whitespace was expected.",
        [16]: "Unexpected '<!--' in comment.",
        [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
        [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
        [19]: "Attribute name cannot start with '='.",
        [21]: "'<?' is allowed only in XML context.",
        [20]: "Unexpected null character.",
        [22]: "Illegal '/' in tags.",
        [23]: "Invalid end tag.",
        [24]: "Element is missing end tag.",
        [25]: "Interpolation end sign was not found.",
        [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
        [26]: "Legal directive name was expected.",
        [28]: "v-if/v-else-if is missing expression.",
        [29]: "v-if/else branches must use unique keys.",
        [30]: "v-else/v-else-if has no adjacent v-if or v-else-if.",
        [31]: "v-for is missing expression.",
        [32]: "v-for has invalid expression.",
        [33]: "<template v-for> key should be placed on the <template> tag.",
        [34]: "v-bind is missing expression.",
        [35]: "v-on is missing expression.",
        [36]: "Unexpected custom directive on <slot> outlet.",
        [37]: "Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",
        [38]: "Duplicate slot names found. ",
        [39]: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.",
        [40]: "v-slot can only be used on components or <template> tags.",
        [41]: "v-model is missing expression.",
        [42]: "v-model value must be a valid JavaScript member expression.",
        [43]: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.",
        [44]: "Error parsing JavaScript expression: ",
        [45]: "<KeepAlive> expects exactly one child component.",
        [46]: '"prefixIdentifiers" option is not supported in this build of compiler.',
        [47]: "ES module mode is not supported in this build of compiler.",
        [48]: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',
        [49]: '"scopeId" option is only supported in module mode.',
        [50]: "",
      },
      cu = Symbol(""),
      lu = Symbol(""),
      Km = Symbol(""),
      wf = Symbol(""),
      Q_ = Symbol(""),
      Co = Symbol(""),
      eE = Symbol(""),
      tE = Symbol(""),
      Jm = Symbol(""),
      Zm = Symbol(""),
      pu = Symbol(""),
      Qm = Symbol(""),
      iE = Symbol(""),
      Mf = Symbol(""),
      Af = Symbol(""),
      eg = Symbol(""),
      tg = Symbol(""),
      ig = Symbol(""),
      ng = Symbol(""),
      nE = Symbol(""),
      rE = Symbol(""),
      rg = Symbol(""),
      Cf = Symbol(""),
      sg = Symbol(""),
      ag = Symbol(""),
      uu = Symbol(""),
      mu = Symbol(""),
      og = Symbol(""),
      Wm = Symbol(""),
      sR = Symbol(""),
      qm = Symbol(""),
      Pf = Symbol(""),
      lg = Symbol(""),
      cg = Symbol(""),
      ug = Symbol(""),
      Df = Symbol(""),
      If = Symbol(""),
      hg = Symbol(""),
      sE = Symbol(""),
      ur = {
        [cu]: "Fragment",
        [lu]: "Teleport",
        [Km]: "Suspense",
        [wf]: "KeepAlive",
        [Q_]: "BaseTransition",
        [Co]: "openBlock",
        [eE]: "createBlock",
        [tE]: "createElementBlock",
        [Jm]: "createVNode",
        [Zm]: "createElementVNode",
        [pu]: "createCommentVNode",
        [Qm]: "createTextVNode",
        [iE]: "createStaticVNode",
        [Mf]: "resolveComponent",
        [Af]: "resolveDynamicComponent",
        [eg]: "resolveDirective",
        [tg]: "resolveFilter",
        [ig]: "withDirectives",
        [ng]: "renderList",
        [nE]: "renderSlot",
        [rE]: "createSlots",
        [rg]: "toDisplayString",
        [Cf]: "mergeProps",
        [sg]: "normalizeClass",
        [ag]: "normalizeStyle",
        [uu]: "normalizeProps",
        [mu]: "guardReactiveProps",
        [og]: "toHandlers",
        [Wm]: "camelize",
        [sR]: "capitalize",
        [qm]: "toHandlerKey",
        [Pf]: "setBlockTracking",
        [lg]: "pushScopeId",
        [cg]: "popScopeId",
        [ug]: "withCtx",
        [Df]: "unref",
        [If]: "isRef",
        [hg]: "withMemo",
        [sE]: "isMemoSame",
      };
    function Dj(n) {
      Object.getOwnPropertySymbols(n).forEach((e) => {
        ur[e] = n[e];
      });
    }
    var rn = {
      source: "",
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 },
    };
    function aR(n, e = rn) {
      return {
        type: 0,
        children: n,
        helpers: [],
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: void 0,
        loc: e,
      };
    }
    function hu(n, e, t, i, r, s, a, o = !1, l = !1, c = !1, u = rn) {
      return (
        n &&
          (o
            ? (n.helper(Co), n.helper(Nl(n.inSSR, c)))
            : n.helper(Ol(n.inSSR, c)),
          a && n.helper(ig)),
        {
          type: 13,
          tag: e,
          props: t,
          children: i,
          patchFlag: r,
          dynamicProps: s,
          directives: a,
          isBlock: o,
          disableTracking: l,
          isComponent: c,
          loc: u,
        }
      );
    }
    function gu(n, e = rn) {
      return { type: 17, loc: e, elements: n };
    }
    function Ar(n, e = rn) {
      return { type: 15, loc: e, properties: n };
    }
    function nn(n, e) {
      return {
        type: 16,
        loc: rn,
        key: nt.isString(n) ? Yt(n, !0) : n,
        value: e,
      };
    }
    function Yt(n, e = !1, t = rn, i = 0) {
      return { type: 4, loc: t, content: n, isStatic: e, constType: e ? 3 : i };
    }
    function Ij(n, e) {
      return { type: 5, loc: e, content: nt.isString(n) ? Yt(n, !1, e) : n };
    }
    function Mr(n, e = rn) {
      return { type: 8, loc: e, children: n };
    }
    function vn(n, e = [], t = rn) {
      return { type: 14, loc: t, callee: n, arguments: e };
    }
    function Ll(n, e = void 0, t = !1, i = !1, r = rn) {
      return { type: 18, params: n, returns: e, newline: t, isSlot: i, loc: r };
    }
    function jm(n, e, t, i = !0) {
      return {
        type: 19,
        test: n,
        consequent: e,
        alternate: t,
        newline: i,
        loc: rn,
      };
    }
    function oR(n, e, t = !1) {
      return { type: 20, index: n, value: e, isVNode: t, loc: rn };
    }
    function lR(n) {
      return { type: 21, body: n, loc: rn };
    }
    function Lj(n) {
      return { type: 22, elements: n, loc: rn };
    }
    function Rj(n, e, t) {
      return { type: 23, test: n, consequent: e, alternate: t, loc: rn };
    }
    function Oj(n, e) {
      return { type: 24, left: n, right: e, loc: rn };
    }
    function Nj(n) {
      return { type: 25, expressions: n, loc: rn };
    }
    function kj(n) {
      return { type: 26, returns: n, loc: rn };
    }
    var ks = (n) => n.type === 4 && n.isStatic,
      Tf = (n, e) => n === e || n === nt.hyphenate(e);
    function aE(n) {
      if (Tf(n, "Teleport")) return lu;
      if (Tf(n, "Suspense")) return Km;
      if (Tf(n, "KeepAlive")) return wf;
      if (Tf(n, "BaseTransition")) return Q_;
    }
    var Fj = /^\d|[^\$\w]/,
      Po = (n) => !Fj.test(n),
      Bj = /[A-Za-z_$\xA0-\uFFFF]/,
      zj = /[\.\?\w$\xA0-\uFFFF]/,
      Uj = /\s+[.[]\s*|\s*[.[]\s+/g,
      Vj = (n) => {
        n = n.trim().replace(Uj, (a) => a.trim());
        let e = 0,
          t = [],
          i = 0,
          r = 0,
          s = null;
        for (let a = 0; a < n.length; a++) {
          let o = n.charAt(a);
          switch (e) {
            case 0:
              if (o === "[") t.push(e), (e = 1), i++;
              else if (o === "(") t.push(e), (e = 2), r++;
              else if (!(a === 0 ? Bj : zj).test(o)) return !1;
              break;
            case 1:
              o === "'" || o === '"' || o === "`"
                ? (t.push(e), (e = 3), (s = o))
                : o === "["
                ? i++
                : o === "]" && (--i || (e = t.pop()));
              break;
            case 2:
              if (o === "'" || o === '"' || o === "`")
                t.push(e), (e = 3), (s = o);
              else if (o === "(") r++;
              else if (o === ")") {
                if (a === n.length - 1) return !1;
                --r || (e = t.pop());
              }
              break;
            case 3:
              o === s && ((e = t.pop()), (s = null));
              break;
          }
        }
        return !i && !r;
      },
      cR = (n, e) => {
        try {
          let t = nR.parseExpression(n, { plugins: e.expressionPlugins });
          return (
            (t.type === "TSAsExpression" || t.type === "TSTypeAssertion") &&
              (t = t.expression),
            t.type === "MemberExpression" ||
              t.type === "OptionalMemberExpression" ||
              t.type === "Identifier"
          );
        } catch (t) {
          return !1;
        }
      },
      oE = cR;
    function lE(n, e, t) {
      let r = {
        source: n.source.slice(e, e + t),
        start: Rl(n.start, n.source, e),
        end: n.end,
      };
      return t != null && (r.end = Rl(n.start, n.source, e + t)), r;
    }
    function Rl(n, e, t = e.length) {
      return fu(nt.extend({}, n), e, t);
    }
    function fu(n, e, t = e.length) {
      let i = 0,
        r = -1;
      for (let s = 0; s < t; s++) e.charCodeAt(s) === 10 && (i++, (r = s));
      return (
        (n.offset += t),
        (n.line += i),
        (n.column = r === -1 ? n.column + t : t - r),
        n
      );
    }
    function Gj(n, e) {
      if (!n) throw new Error(e || "unexpected compiler condition");
    }
    function hr(n, e, t = !1) {
      for (let i = 0; i < n.props.length; i++) {
        let r = n.props[i];
        if (
          r.type === 7 &&
          (t || r.exp) &&
          (nt.isString(e) ? r.name === e : e.test(r.name))
        )
          return r;
      }
    }
    function Lf(n, e, t = !1, i = !1) {
      for (let r = 0; r < n.props.length; r++) {
        let s = n.props[r];
        if (s.type === 6) {
          if (t) continue;
          if (s.name === e && (s.value || i)) return s;
        } else if (s.name === "bind" && (s.exp || i) && Ao(s.arg, e)) return s;
      }
    }
    function Ao(n, e) {
      return !!(n && ks(n) && n.content === e);
    }
    function Hj(n) {
      return n.props.some(
        (e) =>
          e.type === 7 &&
          e.name === "bind" &&
          (!e.arg || e.arg.type !== 4 || !e.arg.isStatic)
      );
    }
    function Vm(n) {
      return n.type === 5 || n.type === 2;
    }
    function cE(n) {
      return n.type === 7 && n.name === "slot";
    }
    function du(n) {
      return n.type === 1 && n.tagType === 3;
    }
    function Rf(n) {
      return n.type === 1 && n.tagType === 2;
    }
    function Ol(n, e) {
      return n || e ? Jm : Zm;
    }
    function Nl(n, e) {
      return n || e ? eE : tE;
    }
    var $j = new Set([uu, mu]);
    function uR(n, e = []) {
      if (n && !nt.isString(n) && n.type === 14) {
        let t = n.callee;
        if (!nt.isString(t) && $j.has(t))
          return uR(n.arguments[0], e.concat(n));
      }
      return [n, e];
    }
    function Of(n, e, t) {
      let i,
        r = n.type === 13 ? n.props : n.arguments[2],
        s = [],
        a;
      if (r && !nt.isString(r) && r.type === 14) {
        let o = uR(r);
        (r = o[0]), (s = o[1]), (a = s[s.length - 1]);
      }
      if (r == null || nt.isString(r)) i = Ar([e]);
      else if (r.type === 14) {
        let o = r.arguments[0];
        !nt.isString(o) && o.type === 15
          ? o.properties.unshift(e)
          : r.callee === og
          ? (i = vn(t.helper(Cf), [Ar([e]), r]))
          : r.arguments.unshift(Ar([e])),
          !i && (i = r);
      } else if (r.type === 15) {
        let o = !1;
        if (e.key.type === 4) {
          let l = e.key.content;
          o = r.properties.some((c) => c.key.type === 4 && c.key.content === l);
        }
        o || r.properties.unshift(e), (i = r);
      } else
        (i = vn(t.helper(Cf), [Ar([e]), r])),
          a && a.callee === mu && (a = s[s.length - 2]);
      n.type === 13
        ? a
          ? (a.arguments[0] = i)
          : (n.props = i)
        : a
        ? (a.arguments[0] = i)
        : (n.arguments[2] = i);
    }
    function kl(n, e) {
      return `_${e}_${n.replace(/[^\w]/g, (t, i) =>
        t === "-" ? "_" : n.charCodeAt(i).toString()
      )}`;
    }
    function cr(n, e) {
      if (!n || Object.keys(e).length === 0) return !1;
      switch (n.type) {
        case 1:
          for (let t = 0; t < n.props.length; t++) {
            let i = n.props[t];
            if (i.type === 7 && (cr(i.arg, e) || cr(i.exp, e))) return !0;
          }
          return n.children.some((t) => cr(t, e));
        case 11:
          return cr(n.source, e) ? !0 : n.children.some((t) => cr(t, e));
        case 9:
          return n.branches.some((t) => cr(t, e));
        case 10:
          return cr(n.condition, e) ? !0 : n.children.some((t) => cr(t, e));
        case 4:
          return !n.isStatic && Po(n.content) && !!e[n.content];
        case 8:
          return n.children.some((t) => nt.isObject(t) && cr(t, e));
        case 5:
        case 12:
          return cr(n.content, e);
        case 2:
        case 3:
          return !1;
        default:
          return !1;
      }
    }
    function hR(n) {
      return n.type === 14 && n.callee === hg ? n.arguments[1].returns : n;
    }
    function fg(n, { helper: e, removeHelper: t, inSSR: i }) {
      n.isBlock ||
        ((n.isBlock = !0),
        t(Ol(i, n.isComponent)),
        e(Co),
        e(Nl(i, n.isComponent)));
    }
    var Wj = {
      COMPILER_IS_ON_ELEMENT: {
        message:
          'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
        link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html",
      },
      COMPILER_V_BIND_SYNC: {
        message: (n) =>
          `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${n}.sync\` should be changed to \`v-model:${n}\`.`,
        link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html",
      },
      COMPILER_V_BIND_PROP: {
        message:
          ".prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.",
      },
      COMPILER_V_BIND_OBJECT_ORDER: {
        message:
          'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
        link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html",
      },
      COMPILER_V_ON_NATIVE: {
        message:
          ".native modifier for v-on has been removed as is no longer necessary.",
        link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html",
      },
      COMPILER_V_IF_V_FOR_PRECEDENCE: {
        message:
          "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",
        link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html",
      },
      COMPILER_NATIVE_TEMPLATE: {
        message:
          "<template> with no special directives will render as a native template element instead of its inner content in Vue 3.",
      },
      COMPILER_INLINE_TEMPLATE: {
        message: '"inline-template" has been removed in Vue 3.',
        link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html",
      },
      COMPILER_FILTER: {
        message:
          'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
        link: "https://v3-migration.vuejs.org/breaking-changes/filters.html",
      },
    };
    function j_(n, e) {
      let t = e.options ? e.options.compatConfig : e.compatConfig,
        i = t && t[n];
      return n === "MODE" ? i || 3 : i;
    }
    function Il(n, e) {
      let t = j_("MODE", e),
        i = j_(n, e);
      return t === 3 ? i === !0 : i !== !1;
    }
    function Nf(n, e, t, ...i) {
      return Il(n, e);
    }
    function qj(n, e, t, ...i) {
      if (j_(n, e) === "suppress-warning") return;
      let { message: s, link: a } = Wj[n],
        o = `(deprecation ${n}) ${typeof s == "function" ? s(...i) : s}${
          a
            ? `
  Details: ${a}`
            : ""
        }`,
        l = new SyntaxError(o);
      (l.code = n), t && (l.loc = t), e.onWarn(l);
    }
    var jj = /&(gt|lt|amp|apos|quot);/g,
      Xj = { gt: ">", lt: "<", amp: "&", apos: "'", quot: '"' },
      VL = {
        delimiters: ["{{", "}}"],
        getNamespace: () => 0,
        getTextMode: () => 0,
        isVoidTag: nt.NO,
        isPreTag: nt.NO,
        isCustomElement: nt.NO,
        decodeEntities: (n) => n.replace(jj, (e, t) => Xj[t]),
        onError: Z_,
        onWarn: rR,
        comments: !1,
      };
    function fR(n, e = {}) {
      let t = Yj(n, e),
        i = Dr(t);
      return aR(uE(t, 0, []), ts(t, i));
    }
    function Yj(n, e) {
      let t = nt.extend({}, VL),
        i;
      for (i in e) t[i] = e[i] === void 0 ? VL[i] : e[i];
      return {
        options: t,
        column: 1,
        line: 1,
        offset: 0,
        originalSource: n,
        source: n,
        inPre: !1,
        inVPre: !1,
        onWarn: t.onWarn,
      };
    }
    function uE(n, e, t) {
      let i = dg(t),
        r = i ? i.ns : 0,
        s = [];
      for (; !rX(n, e, t); ) {
        let o = n.source,
          l;
        if (e === 0 || e === 1) {
          if (!n.inVPre && kn(o, n.options.delimiters[0])) l = iX(n, e);
          else if (e === 0 && o[0] === "<")
            if (o.length === 1) _i(n, 5, 1);
            else if (o[1] === "!")
              kn(o, "<!--")
                ? (l = Jj(n))
                : kn(o, "<!DOCTYPE")
                ? (l = Ef(n))
                : kn(o, "<![CDATA[")
                ? r !== 0
                  ? (l = Kj(n, t))
                  : (_i(n, 1), (l = Ef(n)))
                : (_i(n, 11), (l = Ef(n)));
            else if (o[1] === "/")
              if (o.length === 2) _i(n, 5, 2);
              else if (o[2] === ">") {
                _i(n, 14, 2), mn(n, 3);
                continue;
              } else if (/[a-z]/i.test(o[2])) {
                _i(n, 23), X_(n, 1, i);
                continue;
              } else _i(n, 12, 2), (l = Ef(n));
            else
              /[a-z]/i.test(o[1])
                ? ((l = Zj(n, t)),
                  Il("COMPILER_NATIVE_TEMPLATE", n) &&
                    l &&
                    l.tag === "template" &&
                    !l.props.some((c) => c.type === 7 && dR(c.name)) &&
                    (l = l.children))
                : o[1] === "?"
                ? (_i(n, 21, 1), (l = Ef(n)))
                : _i(n, 12, 1);
        }
        if ((l || (l = nX(n, e)), nt.isArray(l)))
          for (let c = 0; c < l.length; c++) GL(s, l[c]);
        else GL(s, l);
      }
      let a = !1;
      if (e !== 2 && e !== 1) {
        let o = n.options.whitespace !== "preserve";
        for (let l = 0; l < s.length; l++) {
          let c = s[l];
          if (!n.inPre && c.type === 2)
            if (/[^\t\r\n\f ]/.test(c.content))
              o && (c.content = c.content.replace(/[\t\r\n\f ]+/g, " "));
            else {
              let u = s[l - 1],
                f = s[l + 1];
              !u ||
              !f ||
              (o &&
                (u.type === 3 ||
                  f.type === 3 ||
                  (u.type === 1 && f.type === 1 && /[\r\n]/.test(c.content))))
                ? ((a = !0), (s[l] = null))
                : (c.content = " ");
            }
          else c.type === 3 && !n.options.comments && ((a = !0), (s[l] = null));
        }
        if (n.inPre && i && n.options.isPreTag(i.tag)) {
          let l = s[0];
          l && l.type === 2 && (l.content = l.content.replace(/^\r?\n/, ""));
        }
      }
      return a ? s.filter(Boolean) : s;
    }
    function GL(n, e) {
      if (e.type === 2) {
        let t = dg(n);
        if (t && t.type === 2 && t.loc.end.offset === e.loc.start.offset) {
          (t.content += e.content),
            (t.loc.end = e.loc.end),
            (t.loc.source += e.loc.source);
          return;
        }
      }
      n.push(e);
    }
    function Kj(n, e) {
      mn(n, 9);
      let t = uE(n, 3, e);
      return n.source.length === 0 ? _i(n, 6) : mn(n, 3), t;
    }
    function Jj(n) {
      let e = Dr(n),
        t,
        i = /--(\!)?>/.exec(n.source);
      if (!i) (t = n.source.slice(4)), mn(n, n.source.length), _i(n, 7);
      else {
        i.index <= 3 && _i(n, 0),
          i[1] && _i(n, 10),
          (t = n.source.slice(4, i.index));
        let r = n.source.slice(0, i.index),
          s = 1,
          a = 0;
        for (; (a = r.indexOf("<!--", s)) !== -1; )
          mn(n, a - s + 1), a + 4 < r.length && _i(n, 16), (s = a + 1);
        mn(n, i.index + i[0].length - s + 1);
      }
      return { type: 3, content: t, loc: ts(n, e) };
    }
    function Ef(n) {
      let e = Dr(n),
        t = n.source[1] === "?" ? 1 : 2,
        i,
        r = n.source.indexOf(">");
      return (
        r === -1
          ? ((i = n.source.slice(t)), mn(n, n.source.length))
          : ((i = n.source.slice(t, r)), mn(n, r + 1)),
        { type: 3, content: i, loc: ts(n, e) }
      );
    }
    function Zj(n, e) {
      let t = n.inPre,
        i = n.inVPre,
        r = dg(e),
        s = X_(n, 0, r),
        a = n.inPre && !t,
        o = n.inVPre && !i;
      if (s.isSelfClosing || n.options.isVoidTag(s.tag))
        return a && (n.inPre = !1), o && (n.inVPre = !1), s;
      e.push(s);
      let l = n.options.getTextMode(s, r),
        c = uE(n, l, e);
      e.pop();
      {
        let u = s.props.find(
          (f) => f.type === 6 && f.name === "inline-template"
        );
        if (u && Nf("COMPILER_INLINE_TEMPLATE", n, u.loc)) {
          let f = ts(n, s.loc.end);
          u.value = { type: 2, content: f.source, loc: f };
        }
      }
      if (((s.children = c), Y_(n.source, s.tag))) X_(n, 1, r);
      else if (
        (_i(n, 24, 0, s.loc.start),
        n.source.length === 0 && s.tag.toLowerCase() === "script")
      ) {
        let u = c[0];
        u && kn(u.loc.source, "<!--") && _i(n, 8);
      }
      return (
        (s.loc = ts(n, s.loc.start)),
        a && (n.inPre = !1),
        o && (n.inVPre = !1),
        s
      );
    }
    var dR = nt.makeMap("if,else,else-if,for,slot");
    function X_(n, e, t) {
      let i = Dr(n),
        r = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(n.source),
        s = r[1],
        a = n.options.getNamespace(s, t);
      mn(n, r[0].length), kf(n);
      let o = Dr(n),
        l = n.source;
      n.options.isPreTag(s) && (n.inPre = !0);
      let c = HL(n, e);
      e === 0 &&
        !n.inVPre &&
        c.some((d) => d.type === 7 && d.name === "pre") &&
        ((n.inVPre = !0),
        nt.extend(n, o),
        (n.source = l),
        (c = HL(n, e).filter((d) => d.name !== "v-pre")));
      let u = !1;
      if (
        (n.source.length === 0
          ? _i(n, 9)
          : ((u = kn(n.source, "/>")),
            e === 1 && u && _i(n, 4),
            mn(n, u ? 2 : 1)),
        e === 1)
      )
        return;
      let f = 0;
      return (
        n.inVPre ||
          (s === "slot"
            ? (f = 2)
            : s === "template"
            ? c.some((d) => d.type === 7 && dR(d.name)) && (f = 3)
            : Qj(s, c, n) && (f = 1)),
        {
          type: 1,
          ns: a,
          tag: s,
          tagType: f,
          props: c,
          isSelfClosing: u,
          children: [],
          loc: ts(n, i),
          codegenNode: void 0,
        }
      );
    }
    function Qj(n, e, t) {
      let i = t.options;
      if (i.isCustomElement(n)) return !1;
      if (
        n === "component" ||
        /^[A-Z]/.test(n) ||
        aE(n) ||
        (i.isBuiltInComponent && i.isBuiltInComponent(n)) ||
        (i.isNativeTag && !i.isNativeTag(n))
      )
        return !0;
      for (let r = 0; r < e.length; r++) {
        let s = e[r];
        if (s.type === 6) {
          if (s.name === "is" && s.value) {
            if (s.value.content.startsWith("vue:")) return !0;
            if (Nf("COMPILER_IS_ON_ELEMENT", t, s.loc)) return !0;
          }
        } else {
          if (s.name === "is") return !0;
          if (
            s.name === "bind" &&
            Ao(s.arg, "is") &&
            !0 &&
            Nf("COMPILER_IS_ON_ELEMENT", t, s.loc)
          )
            return !0;
        }
      }
    }
    function HL(n, e) {
      let t = [],
        i = new Set();
      for (
        ;
        n.source.length > 0 && !kn(n.source, ">") && !kn(n.source, "/>");

      ) {
        if (kn(n.source, "/")) {
          _i(n, 22), mn(n, 1), kf(n);
          continue;
        }
        e === 1 && _i(n, 3);
        let r = eX(n, i);
        r.type === 6 &&
          r.value &&
          r.name === "class" &&
          (r.value.content = r.value.content.replace(/\s+/g, " ").trim()),
          e === 0 && t.push(r),
          /^[^\t\r\n\f />]/.test(n.source) && _i(n, 15),
          kf(n);
      }
      return t;
    }
    function eX(n, e) {
      let t = Dr(n),
        r = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(n.source)[0];
      e.has(r) && _i(n, 2), e.add(r), r[0] === "=" && _i(n, 19);
      {
        let o = /["'<]/g,
          l;
        for (; (l = o.exec(r)); ) _i(n, 17, l.index);
      }
      mn(n, r.length);
      let s;
      /^[\t\r\n\f ]*=/.test(n.source) &&
        (kf(n), mn(n, 1), kf(n), (s = tX(n)), s || _i(n, 13));
      let a = ts(n, t);
      if (!n.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(r)) {
        let o =
            /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
              r
            ),
          l = kn(r, "."),
          c = o[1] || (l || kn(r, ":") ? "bind" : kn(r, "@") ? "on" : "slot"),
          u;
        if (o[2]) {
          let d = c === "slot",
            m = r.lastIndexOf(o[2]),
            x = ts(
              n,
              $L(n, t, m),
              $L(n, t, m + o[2].length + ((d && o[3]) || "").length)
            ),
            y = o[2],
            g = !0;
          y.startsWith("[")
            ? ((g = !1),
              y.endsWith("]")
                ? (y = y.slice(1, y.length - 1))
                : (_i(n, 27), (y = y.slice(1))))
            : d && (y += o[3] || ""),
            (u = {
              type: 4,
              content: y,
              isStatic: g,
              constType: g ? 3 : 0,
              loc: x,
            });
        }
        if (s && s.isQuoted) {
          let d = s.loc;
          d.start.offset++,
            d.start.column++,
            (d.end = Rl(d.start, s.content)),
            (d.source = d.source.slice(1, -1));
        }
        let f = o[3] ? o[3].slice(1).split(".") : [];
        return (
          l && f.push("prop"),
          c === "bind" &&
            u &&
            f.includes("sync") &&
            Nf("COMPILER_V_BIND_SYNC", n, a, u.loc.source) &&
            ((c = "model"), f.splice(f.indexOf("sync"), 1)),
          {
            type: 7,
            name: c,
            exp: s && {
              type: 4,
              content: s.content,
              isStatic: !1,
              constType: 0,
              loc: s.loc,
            },
            arg: u,
            modifiers: f,
            loc: a,
          }
        );
      }
      return (
        !n.inVPre && kn(r, "v-") && _i(n, 26),
        {
          type: 6,
          name: r,
          value: s && { type: 2, content: s.content, loc: s.loc },
          loc: a,
        }
      );
    }
    function tX(n) {
      let e = Dr(n),
        t,
        i = n.source[0],
        r = i === '"' || i === "'";
      if (r) {
        mn(n, 1);
        let s = n.source.indexOf(i);
        s === -1
          ? (t = Sf(n, n.source.length, 4))
          : ((t = Sf(n, s, 4)), mn(n, 1));
      } else {
        let s = /^[^\t\r\n\f >]+/.exec(n.source);
        if (!s) return;
        let a = /["'<=`]/g,
          o;
        for (; (o = a.exec(s[0])); ) _i(n, 18, o.index);
        t = Sf(n, s[0].length, 4);
      }
      return { content: t, isQuoted: r, loc: ts(n, e) };
    }
    function iX(n, e) {
      let [t, i] = n.options.delimiters,
        r = n.source.indexOf(i, t.length);
      if (r === -1) {
        _i(n, 25);
        return;
      }
      let s = Dr(n);
      mn(n, t.length);
      let a = Dr(n),
        o = Dr(n),
        l = r - t.length,
        c = n.source.slice(0, l),
        u = Sf(n, l, e),
        f = u.trim(),
        d = u.indexOf(f);
      d > 0 && fu(a, c, d);
      let m = l - (u.length - f.length - d);
      return (
        fu(o, c, m),
        mn(n, i.length),
        {
          type: 5,
          content: {
            type: 4,
            isStatic: !1,
            constType: 0,
            content: f,
            loc: ts(n, a, o),
          },
          loc: ts(n, s),
        }
      );
    }
    function nX(n, e) {
      let t = e === 3 ? ["]]>"] : ["<", n.options.delimiters[0]],
        i = n.source.length;
      for (let a = 0; a < t.length; a++) {
        let o = n.source.indexOf(t[a], 1);
        o !== -1 && i > o && (i = o);
      }
      let r = Dr(n),
        s = Sf(n, i, e);
      return { type: 2, content: s, loc: ts(n, r) };
    }
    function Sf(n, e, t) {
      let i = n.source.slice(0, e);
      return (
        mn(n, e),
        t === 2 || t === 3 || !i.includes("&")
          ? i
          : n.options.decodeEntities(i, t === 4)
      );
    }
    function Dr(n) {
      let { column: e, line: t, offset: i } = n;
      return { column: e, line: t, offset: i };
    }
    function ts(n, e, t) {
      return (
        (t = t || Dr(n)),
        { start: e, end: t, source: n.originalSource.slice(e.offset, t.offset) }
      );
    }
    function dg(n) {
      return n[n.length - 1];
    }
    function kn(n, e) {
      return n.startsWith(e);
    }
    function mn(n, e) {
      let { source: t } = n;
      fu(n, t, e), (n.source = t.slice(e));
    }
    function kf(n) {
      let e = /^[\t\r\n\f ]+/.exec(n.source);
      e && mn(n, e[0].length);
    }
    function $L(n, e, t) {
      return Rl(e, n.originalSource.slice(e.offset, t), t);
    }
    function _i(n, e, t, i = Dr(n)) {
      t && ((i.offset += t), (i.column += t)),
        n.options.onError(Li(e, { start: i, end: i, source: "" }));
    }
    function rX(n, e, t) {
      let i = n.source;
      switch (e) {
        case 0:
          if (kn(i, "</")) {
            for (let r = t.length - 1; r >= 0; --r)
              if (Y_(i, t[r].tag)) return !0;
          }
          break;
        case 1:
        case 2: {
          let r = dg(t);
          if (r && Y_(i, r.tag)) return !0;
          break;
        }
        case 3:
          if (kn(i, "]]>")) return !0;
          break;
      }
      return !i;
    }
    function Y_(n, e) {
      return (
        kn(n, "</") &&
        n.slice(2, 2 + e.length).toLowerCase() === e.toLowerCase() &&
        /[\t\r\n\f />]/.test(n[2 + e.length] || ">")
      );
    }
    function sX(n, e) {
      Gm(n, e, pR(n, n.children[0]));
    }
    function pR(n, e) {
      let { children: t } = n;
      return t.length === 1 && e.type === 1 && !Rf(e);
    }
    function Gm(n, e, t = !1) {
      let { children: i } = n,
        r = i.length,
        s = 0;
      for (let a = 0; a < i.length; a++) {
        let o = i[a];
        if (o.type === 1 && o.tagType === 0) {
          let l = t ? 0 : Cr(o, e);
          if (l > 0) {
            if (l >= 2) {
              (o.codegenNode.patchFlag = -1 + ""),
                (o.codegenNode = e.hoist(o.codegenNode)),
                s++;
              continue;
            }
          } else {
            let c = o.codegenNode;
            if (c.type === 13) {
              let u = vR(c);
              if ((!u || u === 512 || u === 1) && gR(o, e) >= 2) {
                let f = yR(o);
                f && (c.props = e.hoist(f));
              }
              c.dynamicProps && (c.dynamicProps = e.hoist(c.dynamicProps));
            }
          }
        } else
          o.type === 12 &&
            Cr(o.content, e) >= 2 &&
            ((o.codegenNode = e.hoist(o.codegenNode)), s++);
        if (o.type === 1) {
          let l = o.tagType === 1;
          l && e.scopes.vSlot++, Gm(o, e), l && e.scopes.vSlot--;
        } else if (o.type === 11) Gm(o, e, o.children.length === 1);
        else if (o.type === 9)
          for (let l = 0; l < o.branches.length; l++)
            Gm(o.branches[l], e, o.branches[l].children.length === 1);
      }
      s && e.transformHoist && e.transformHoist(i, e, n),
        s &&
          s === r &&
          n.type === 1 &&
          n.tagType === 0 &&
          n.codegenNode &&
          n.codegenNode.type === 13 &&
          nt.isArray(n.codegenNode.children) &&
          (n.codegenNode.children = e.hoist(gu(n.codegenNode.children)));
    }
    function Cr(n, e) {
      let { constantCache: t } = e;
      switch (n.type) {
        case 1:
          if (n.tagType !== 0) return 0;
          let i = t.get(n);
          if (i !== void 0) return i;
          let r = n.codegenNode;
          if (
            r.type !== 13 ||
            (r.isBlock && n.tag !== "svg" && n.tag !== "foreignObject")
          )
            return 0;
          if (vR(r)) return t.set(n, 0), 0;
          {
            let o = 3,
              l = gR(n, e);
            if (l === 0) return t.set(n, 0), 0;
            l < o && (o = l);
            for (let c = 0; c < n.children.length; c++) {
              let u = Cr(n.children[c], e);
              if (u === 0) return t.set(n, 0), 0;
              u < o && (o = u);
            }
            if (o > 1)
              for (let c = 0; c < n.props.length; c++) {
                let u = n.props[c];
                if (u.type === 7 && u.name === "bind" && u.exp) {
                  let f = Cr(u.exp, e);
                  if (f === 0) return t.set(n, 0), 0;
                  f < o && (o = f);
                }
              }
            if (r.isBlock) {
              for (let c = 0; c < n.props.length; c++)
                if (n.props[c].type === 7) return t.set(n, 0), 0;
              e.removeHelper(Co),
                e.removeHelper(Nl(e.inSSR, r.isComponent)),
                (r.isBlock = !1),
                e.helper(Ol(e.inSSR, r.isComponent));
            }
            return t.set(n, o), o;
          }
        case 2:
        case 3:
          return 3;
        case 9:
        case 11:
        case 10:
          return 0;
        case 5:
        case 12:
          return Cr(n.content, e);
        case 4:
          return n.constType;
        case 8:
          let a = 3;
          for (let o = 0; o < n.children.length; o++) {
            let l = n.children[o];
            if (nt.isString(l) || nt.isSymbol(l)) continue;
            let c = Cr(l, e);
            if (c === 0) return 0;
            c < a && (a = c);
          }
          return a;
        default:
          return 0;
      }
    }
    var aX = new Set([sg, ag, uu, mu]);
    function mR(n, e) {
      if (n.type === 14 && !nt.isString(n.callee) && aX.has(n.callee)) {
        let t = n.arguments[0];
        if (t.type === 4) return Cr(t, e);
        if (t.type === 14) return mR(t, e);
      }
      return 0;
    }
    function gR(n, e) {
      let t = 3,
        i = yR(n);
      if (i && i.type === 15) {
        let { properties: r } = i;
        for (let s = 0; s < r.length; s++) {
          let { key: a, value: o } = r[s],
            l = Cr(a, e);
          if (l === 0) return l;
          l < t && (t = l);
          let c;
          if (
            (o.type === 4
              ? (c = Cr(o, e))
              : o.type === 14
              ? (c = mR(o, e))
              : (c = 0),
            c === 0)
          )
            return c;
          c < t && (t = c);
        }
      }
      return t;
    }
    function yR(n) {
      let e = n.codegenNode;
      if (e.type === 13) return e.props;
    }
    function vR(n) {
      let e = n.patchFlag;
      return e ? parseInt(e, 10) : void 0;
    }
    function xR(
      n,
      {
        filename: e = "",
        prefixIdentifiers: t = !1,
        hoistStatic: i = !1,
        cacheHandlers: r = !1,
        nodeTransforms: s = [],
        directiveTransforms: a = {},
        transformHoist: o = null,
        isBuiltInComponent: l = nt.NOOP,
        isCustomElement: c = nt.NOOP,
        expressionPlugins: u = [],
        scopeId: f = null,
        slotted: d = !0,
        ssr: m = !1,
        inSSR: x = !1,
        ssrCssVars: y = "",
        bindingMetadata: g = nt.EMPTY_OBJ,
        inline: b = !1,
        isTS: _ = !1,
        onError: E = Z_,
        onWarn: w = rR,
        compatConfig: P,
      }
    ) {
      let L = e.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/),
        I = {
          selfName: L && nt.capitalize(nt.camelize(L[1])),
          prefixIdentifiers: t,
          hoistStatic: i,
          cacheHandlers: r,
          nodeTransforms: s,
          directiveTransforms: a,
          transformHoist: o,
          isBuiltInComponent: l,
          isCustomElement: c,
          expressionPlugins: u,
          scopeId: f,
          slotted: d,
          ssr: m,
          inSSR: x,
          ssrCssVars: y,
          bindingMetadata: g,
          inline: b,
          isTS: _,
          onError: E,
          onWarn: w,
          compatConfig: P,
          root: n,
          helpers: new Map(),
          components: new Set(),
          directives: new Set(),
          hoists: [],
          imports: [],
          constantCache: new Map(),
          temps: 0,
          cached: 0,
          identifiers: Object.create(null),
          scopes: { vFor: 0, vSlot: 0, vPre: 0, vOnce: 0 },
          parent: null,
          currentNode: n,
          childIndex: 0,
          inVOnce: !1,
          helper(O) {
            let U = I.helpers.get(O) || 0;
            return I.helpers.set(O, U + 1), O;
          },
          removeHelper(O) {
            let U = I.helpers.get(O);
            if (U) {
              let X = U - 1;
              X ? I.helpers.set(O, X) : I.helpers.delete(O);
            }
          },
          helperString(O) {
            return `_${ur[I.helper(O)]}`;
          },
          replaceNode(O) {
            I.parent.children[I.childIndex] = I.currentNode = O;
          },
          removeNode(O) {
            let U = I.parent.children,
              X = O ? U.indexOf(O) : I.currentNode ? I.childIndex : -1;
            !O || O === I.currentNode
              ? ((I.currentNode = null), I.onNodeRemoved())
              : I.childIndex > X && (I.childIndex--, I.onNodeRemoved()),
              I.parent.children.splice(X, 1);
          },
          onNodeRemoved: () => {},
          addIdentifiers(O) {
            nt.isString(O)
              ? M(O)
              : O.identifiers
              ? O.identifiers.forEach(M)
              : O.type === 4 && M(O.content);
          },
          removeIdentifiers(O) {
            nt.isString(O)
              ? R(O)
              : O.identifiers
              ? O.identifiers.forEach(R)
              : O.type === 4 && R(O.content);
          },
          hoist(O) {
            nt.isString(O) && (O = Yt(O)), I.hoists.push(O);
            let U = Yt(`_hoisted_${I.hoists.length}`, !1, O.loc, 2);
            return (U.hoisted = O), U;
          },
          cache(O, U = !1) {
            return oR(I.cached++, O, U);
          },
        };
      I.filters = new Set();
      function M(O) {
        let { identifiers: U } = I;
        U[O] === void 0 && (U[O] = 0), U[O]++;
      }
      function R(O) {
        I.identifiers[O]--;
      }
      return I;
    }
    function bR(n, e) {
      let t = xR(n, e);
      Ff(n, t),
        e.hoistStatic && sX(n, t),
        e.ssr || oX(n, t),
        (n.helpers = [...t.helpers.keys()]),
        (n.components = [...t.components]),
        (n.directives = [...t.directives]),
        (n.imports = t.imports),
        (n.hoists = t.hoists),
        (n.temps = t.temps),
        (n.cached = t.cached),
        (n.filters = [...t.filters]);
    }
    function oX(n, e) {
      let { helper: t } = e,
        { children: i } = n;
      if (i.length === 1) {
        let r = i[0];
        if (pR(n, r) && r.codegenNode) {
          let s = r.codegenNode;
          s.type === 13 && fg(s, e), (n.codegenNode = s);
        } else n.codegenNode = r;
      } else if (i.length > 1) {
        let r = 64;
        nt.PatchFlagNames[64],
          (n.codegenNode = hu(
            e,
            t(cu),
            void 0,
            n.children,
            r + "",
            void 0,
            void 0,
            !0,
            void 0,
            !1
          ));
      }
    }
    function lX(n, e) {
      let t = 0,
        i = () => {
          t--;
        };
      for (; t < n.children.length; t++) {
        let r = n.children[t];
        nt.isString(r) ||
          ((e.parent = n), (e.childIndex = t), (e.onNodeRemoved = i), Ff(r, e));
      }
    }
    function Ff(n, e) {
      e.currentNode = n;
      let { nodeTransforms: t } = e,
        i = [];
      for (let s = 0; s < t.length; s++) {
        let a = t[s](n, e);
        if ((a && (nt.isArray(a) ? i.push(...a) : i.push(a)), e.currentNode))
          n = e.currentNode;
        else return;
      }
      switch (n.type) {
        case 3:
          e.ssr || e.helper(pu);
          break;
        case 5:
          e.ssr || e.helper(rg);
          break;
        case 9:
          for (let s = 0; s < n.branches.length; s++) Ff(n.branches[s], e);
          break;
        case 10:
        case 11:
        case 1:
        case 0:
          lX(n, e);
          break;
      }
      e.currentNode = n;
      let r = i.length;
      for (; r--; ) i[r]();
    }
    function hE(n, e) {
      let t = nt.isString(n) ? (i) => i === n : (i) => n.test(i);
      return (i, r) => {
        if (i.type === 1) {
          let { props: s } = i;
          if (i.tagType === 3 && s.some(cE)) return;
          let a = [];
          for (let o = 0; o < s.length; o++) {
            let l = s[o];
            if (l.type === 7 && t(l.name)) {
              s.splice(o, 1), o--;
              let c = e(i, l, r);
              c && a.push(c);
            }
          }
          return a;
        }
      };
    }
    var Bf = "/*#__PURE__*/",
      Hm = (n) => `${ur[n]}: _${ur[n]}`;
    function WL(
      n,
      {
        mode: e = "function",
        prefixIdentifiers: t = e === "module",
        sourceMap: i = !1,
        filename: r = "template.vue.html",
        scopeId: s = null,
        optimizeImports: a = !1,
        runtimeGlobalName: o = "Vue",
        runtimeModuleName: l = "vue",
        ssrRuntimeModuleName: c = "vue/server-renderer",
        ssr: u = !1,
        isTS: f = !1,
        inSSR: d = !1,
      }
    ) {
      let m = {
        mode: e,
        prefixIdentifiers: t,
        sourceMap: i,
        filename: r,
        scopeId: s,
        optimizeImports: a,
        runtimeGlobalName: o,
        runtimeModuleName: l,
        ssrRuntimeModuleName: c,
        ssr: u,
        isTS: f,
        inSSR: d,
        source: n.loc.source,
        code: "",
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: !1,
        map: void 0,
        helper(g) {
          return `_${ur[g]}`;
        },
        push(g, b) {
          if (((m.code += g), m.map)) {
            if (b) {
              let _;
              if (b.type === 4 && !b.isStatic) {
                let E = b.content.replace(/^_ctx\./, "");
                E !== b.content && Po(E) && (_ = E);
              }
              y(b.loc.start, _);
            }
            fu(m, g), b && b.loc !== rn && y(b.loc.end);
          }
        },
        indent() {
          x(++m.indentLevel);
        },
        deindent(g = !1) {
          g ? --m.indentLevel : x(--m.indentLevel);
        },
        newline() {
          x(m.indentLevel);
        },
      };
      function x(g) {
        m.push(
          `
` + "  ".repeat(g)
        );
      }
      function y(g, b) {
        m.map.addMapping({
          name: b,
          source: m.filename,
          original: { line: g.line, column: g.column - 1 },
          generated: { line: m.line, column: m.column - 1 },
        });
      }
      return (
        i &&
          ((m.map = new Aj.SourceMapGenerator()),
          m.map.setSourceContent(r, m.source)),
        m
      );
    }
    function _R(n, e = {}) {
      let t = WL(n, e);
      e.onContextCreated && e.onContextCreated(t);
      let {
          mode: i,
          push: r,
          prefixIdentifiers: s,
          indent: a,
          deindent: o,
          newline: l,
          scopeId: c,
          ssr: u,
        } = t,
        f = n.helpers.length > 0,
        d = !s && i !== "module",
        m = c != null && i === "module",
        x = !!e.inline,
        y = x ? WL(n, e) : t;
      i === "module" ? uX(n, y, m, x) : cX(n, y);
      let g = u ? "ssrRender" : "render",
        b = u ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
      e.bindingMetadata &&
        !e.inline &&
        b.push("$props", "$setup", "$data", "$options");
      let _ = e.isTS ? b.map((E) => `${E}: any`).join(",") : b.join(", ");
      if (
        (r(x ? `(${_}) => {` : `function ${g}(${_}) {`),
        a(),
        d &&
          (r("with (_ctx) {"),
          a(),
          f &&
            (r(`const { ${n.helpers.map(Hm).join(", ")} } = _Vue`),
            r(`
`),
            l())),
        n.components.length &&
          (W_(n.components, "component", t),
          (n.directives.length || n.temps > 0) && l()),
        n.directives.length &&
          (W_(n.directives, "directive", t), n.temps > 0 && l()),
        n.filters && n.filters.length && (l(), W_(n.filters, "filter", t), l()),
        n.temps > 0)
      ) {
        r("let ");
        for (let E = 0; E < n.temps; E++) r(`${E > 0 ? ", " : ""}_temp${E}`);
      }
      return (
        (n.components.length || n.directives.length || n.temps) &&
          (r(`
`),
          l()),
        u || r("return "),
        n.codegenNode ? Oi(n.codegenNode, t) : r("null"),
        d && (o(), r("}")),
        o(),
        r("}"),
        {
          ast: n,
          code: t.code,
          preamble: x ? y.code : "",
          map: t.map ? t.map.toJSON() : void 0,
        }
      );
    }
    function cX(n, e) {
      let {
          ssr: t,
          prefixIdentifiers: i,
          push: r,
          newline: s,
          runtimeModuleName: a,
          runtimeGlobalName: o,
          ssrRuntimeModuleName: l,
        } = e,
        c = t ? `require(${JSON.stringify(a)})` : o;
      if (n.helpers.length > 0) {
        if (i)
          r(`const { ${n.helpers.map(Hm).join(", ")} } = ${c}
`);
        else if (
          (r(`const _Vue = ${c}
`),
          n.hoists.length)
        ) {
          let u = [Jm, Zm, pu, Qm, iE]
            .filter((f) => n.helpers.includes(f))
            .map(Hm)
            .join(", ");
          r(`const { ${u} } = _Vue
`);
        }
      }
      n.ssrHelpers &&
        n.ssrHelpers.length &&
        r(`const { ${n.ssrHelpers.map(Hm).join(", ")} } = require("${l}")
`),
        ER(n.hoists, e),
        s(),
        r("return ");
    }
    function uX(n, e, t, i) {
      let {
        push: r,
        newline: s,
        optimizeImports: a,
        runtimeModuleName: o,
        ssrRuntimeModuleName: l,
      } = e;
      t && n.hoists.length && n.helpers.push(lg, cg),
        n.helpers.length &&
          (a
            ? (r(`import { ${n.helpers
                .map((c) => ur[c])
                .join(", ")} } from ${JSON.stringify(o)}
`),
              r(`
// Binding optimization for webpack code-split
const ${n.helpers.map((c) => `_${ur[c]} = ${ur[c]}`).join(", ")}
`))
            : r(`import { ${n.helpers
                .map((c) => `${ur[c]} as _${ur[c]}`)
                .join(", ")} } from ${JSON.stringify(o)}
`)),
        n.ssrHelpers &&
          n.ssrHelpers.length &&
          r(`import { ${n.ssrHelpers
            .map((c) => `${ur[c]} as _${ur[c]}`)
            .join(", ")} } from "${l}"
`),
        n.imports.length && (hX(n.imports, e), s()),
        ER(n.hoists, e),
        s(),
        i || r("export ");
    }
    function W_(n, e, { helper: t, push: i, newline: r, isTS: s }) {
      let a = t(e === "filter" ? tg : e === "component" ? Mf : eg);
      for (let o = 0; o < n.length; o++) {
        let l = n[o],
          c = l.endsWith("__self");
        c && (l = l.slice(0, -6)),
          i(
            `const ${kl(l, e)} = ${a}(${JSON.stringify(l)}${
              c ? ", true" : ""
            })${s ? "!" : ""}`
          ),
          o < n.length - 1 && r();
      }
    }
    function ER(n, e) {
      if (!n.length) return;
      e.pure = !0;
      let { push: t, newline: i, helper: r, scopeId: s, mode: a } = e,
        o = s != null && a !== "function";
      i(),
        o &&
          (t(`const _withScopeId = n => (${r(lg)}("${s}"),n=n(),${r(cg)}(),n)`),
          i());
      for (let l = 0; l < n.length; l++) {
        let c = n[l];
        if (c) {
          let u = o && c.type === 13;
          t(
            `const _hoisted_${l + 1} = ${u ? `${Bf} _withScopeId(() => ` : ""}`
          ),
            Oi(c, e),
            u && t(")"),
            i();
        }
      }
      e.pure = !1;
    }
    function hX(n, e) {
      !n.length ||
        n.forEach((t) => {
          e.push("import "),
            Oi(t.exp, e),
            e.push(` from '${t.path}'`),
            e.newline();
        });
    }
    function fX(n) {
      return (
        nt.isString(n) ||
        n.type === 4 ||
        n.type === 2 ||
        n.type === 5 ||
        n.type === 8
      );
    }
    function pg(n, e) {
      let t = n.length > 3 || n.some((i) => nt.isArray(i) || !fX(i));
      e.push("["), t && e.indent(), yu(n, e, t), t && e.deindent(), e.push("]");
    }
    function yu(n, e, t = !1, i = !0) {
      let { push: r, newline: s } = e;
      for (let a = 0; a < n.length; a++) {
        let o = n[a];
        nt.isString(o) ? r(o) : nt.isArray(o) ? pg(o, e) : Oi(o, e),
          a < n.length - 1 && (t ? (i && r(","), s()) : i && r(", "));
      }
    }
    function Oi(n, e) {
      if (nt.isString(n)) {
        e.push(n);
        return;
      }
      if (nt.isSymbol(n)) {
        e.push(e.helper(n));
        return;
      }
      switch (n.type) {
        case 1:
        case 9:
        case 11:
          Oi(n.codegenNode, e);
          break;
        case 2:
          dX(n, e);
          break;
        case 4:
          TR(n, e);
          break;
        case 5:
          pX(n, e);
          break;
        case 12:
          Oi(n.codegenNode, e);
          break;
        case 8:
          SR(n, e);
          break;
        case 3:
          gX(n, e);
          break;
        case 13:
          yX(n, e);
          break;
        case 14:
          xX(n, e);
          break;
        case 15:
          bX(n, e);
          break;
        case 17:
          _X(n, e);
          break;
        case 18:
          EX(n, e);
          break;
        case 19:
          TX(n, e);
          break;
        case 20:
          SX(n, e);
          break;
        case 21:
          yu(n.body, e, !0, !1);
          break;
        case 22:
          wX(n, e);
          break;
        case 23:
          wR(n, e);
          break;
        case 24:
          MX(n, e);
          break;
        case 25:
          AX(n, e);
          break;
        case 26:
          CX(n, e);
          break;
      }
    }
    function dX(n, e) {
      e.push(JSON.stringify(n.content), n);
    }
    function TR(n, e) {
      let { content: t, isStatic: i } = n;
      e.push(i ? JSON.stringify(t) : t, n);
    }
    function pX(n, e) {
      let { push: t, helper: i, pure: r } = e;
      r && t(Bf), t(`${i(rg)}(`), Oi(n.content, e), t(")");
    }
    function SR(n, e) {
      for (let t = 0; t < n.children.length; t++) {
        let i = n.children[t];
        nt.isString(i) ? e.push(i) : Oi(i, e);
      }
    }
    function mX(n, e) {
      let { push: t } = e;
      if (n.type === 8) t("["), SR(n, e), t("]");
      else if (n.isStatic) {
        let i = Po(n.content) ? n.content : JSON.stringify(n.content);
        t(i, n);
      } else t(`[${n.content}]`, n);
    }
    function gX(n, e) {
      let { push: t, helper: i, pure: r } = e;
      r && t(Bf), t(`${i(pu)}(${JSON.stringify(n.content)})`, n);
    }
    function yX(n, e) {
      let { push: t, helper: i, pure: r } = e,
        {
          tag: s,
          props: a,
          children: o,
          patchFlag: l,
          dynamicProps: c,
          directives: u,
          isBlock: f,
          disableTracking: d,
          isComponent: m,
        } = n;
      u && t(i(ig) + "("),
        f && t(`(${i(Co)}(${d ? "true" : ""}), `),
        r && t(Bf);
      let x = f ? Nl(e.inSSR, m) : Ol(e.inSSR, m);
      t(i(x) + "(", n),
        yu(vX([s, a, o, l, c]), e),
        t(")"),
        f && t(")"),
        u && (t(", "), Oi(u, e), t(")"));
    }
    function vX(n) {
      let e = n.length;
      for (; e-- && n[e] == null; );
      return n.slice(0, e + 1).map((t) => t || "null");
    }
    function xX(n, e) {
      let { push: t, helper: i, pure: r } = e,
        s = nt.isString(n.callee) ? n.callee : i(n.callee);
      r && t(Bf), t(s + "(", n), yu(n.arguments, e), t(")");
    }
    function bX(n, e) {
      let { push: t, indent: i, deindent: r, newline: s } = e,
        { properties: a } = n;
      if (!a.length) {
        t("{}", n);
        return;
      }
      let o = a.length > 1 || a.some((l) => l.value.type !== 4);
      t(o ? "{" : "{ "), o && i();
      for (let l = 0; l < a.length; l++) {
        let { key: c, value: u } = a[l];
        mX(c, e), t(": "), Oi(u, e), l < a.length - 1 && (t(","), s());
      }
      o && r(), t(o ? "}" : " }");
    }
    function _X(n, e) {
      pg(n.elements, e);
    }
    function EX(n, e) {
      let { push: t, indent: i, deindent: r } = e,
        { params: s, returns: a, body: o, newline: l, isSlot: c } = n;
      c && t(`_${ur[ug]}(`),
        t("(", n),
        nt.isArray(s) ? yu(s, e) : s && Oi(s, e),
        t(") => "),
        (l || o) && (t("{"), i()),
        a
          ? (l && t("return "), nt.isArray(a) ? pg(a, e) : Oi(a, e))
          : o && Oi(o, e),
        (l || o) && (r(), t("}")),
        c && (n.isNonScopedSlot && t(", undefined, true"), t(")"));
    }
    function TX(n, e) {
      let { test: t, consequent: i, alternate: r, newline: s } = n,
        { push: a, indent: o, deindent: l, newline: c } = e;
      if (t.type === 4) {
        let f = !Po(t.content);
        f && a("("), TR(t, e), f && a(")");
      } else a("("), Oi(t, e), a(")");
      s && o(),
        e.indentLevel++,
        s || a(" "),
        a("? "),
        Oi(i, e),
        e.indentLevel--,
        s && c(),
        s || a(" "),
        a(": ");
      let u = r.type === 19;
      u || e.indentLevel++, Oi(r, e), u || e.indentLevel--, s && l(!0);
    }
    function SX(n, e) {
      let { push: t, helper: i, indent: r, deindent: s, newline: a } = e;
      t(`_cache[${n.index}] || (`),
        n.isVNode && (r(), t(`${i(Pf)}(-1),`), a()),
        t(`_cache[${n.index}] = `),
        Oi(n.value, e),
        n.isVNode &&
          (t(","), a(), t(`${i(Pf)}(1),`), a(), t(`_cache[${n.index}]`), s()),
        t(")");
    }
    function wX(n, e) {
      let { push: t, indent: i, deindent: r } = e;
      t("`");
      let s = n.elements.length,
        a = s > 3;
      for (let o = 0; o < s; o++) {
        let l = n.elements[o];
        nt.isString(l)
          ? t(l.replace(/(`|\$|\\)/g, "\\$1"))
          : (t("${"), a && i(), Oi(l, e), a && r(), t("}"));
      }
      t("`");
    }
    function wR(n, e) {
      let { push: t, indent: i, deindent: r } = e,
        { test: s, consequent: a, alternate: o } = n;
      t("if ("),
        Oi(s, e),
        t(") {"),
        i(),
        Oi(a, e),
        r(),
        t("}"),
        o &&
          (t(" else "),
          o.type === 23 ? wR(o, e) : (t("{"), i(), Oi(o, e), r(), t("}")));
    }
    function MX(n, e) {
      Oi(n.left, e), e.push(" = "), Oi(n.right, e);
    }
    function AX(n, e) {
      e.push("("), yu(n.expressions, e), e.push(")");
    }
    function CX({ returns: n }, e) {
      e.push("return "), nt.isArray(n) ? pg(n, e) : Oi(n, e);
    }
    function MR(n, e, t = !1, i = [], r = Object.create(null)) {
      let s =
        n.type === "Program" &&
        n.body[0].type === "ExpressionStatement" &&
        n.body[0].expression;
      Cj.walk(n, {
        enter(a, o) {
          if (
            (o && i.push(o),
            o &&
              o.type.startsWith("TS") &&
              o.type !== "TSAsExpression" &&
              o.type !== "TSNonNullExpression" &&
              o.type !== "TSTypeAssertion")
          )
            return this.skip();
          if (a.type === "Identifier") {
            let l = !!r[a.name],
              c = AR(a, o, i);
            (t || (c && !l)) && e(a, o, i, c, l);
          } else
            a.type === "ObjectProperty" && o.type === "ObjectPattern"
              ? (a.inPattern = !0)
              : DR(a)
              ? CR(a, (l) => qL(a, l, r))
              : a.type === "BlockStatement" && PR(a, (l) => qL(a, l, r));
        },
        leave(a, o) {
          if ((o && i.pop(), a !== s && a.scopeIds))
            for (let l of a.scopeIds) r[l]--, r[l] === 0 && delete r[l];
        },
      });
    }
    function AR(n, e, t) {
      if (!e) return !0;
      if (n.name === "arguments") return !1;
      if (PX(n, e)) return !0;
      switch (e.type) {
        case "AssignmentExpression":
        case "AssignmentPattern":
          return !0;
        case "ObjectPattern":
        case "ArrayPattern":
          return fE(e, t);
      }
      return !1;
    }
    function fE(n, e) {
      if (n && (n.type === "ObjectProperty" || n.type === "ArrayPattern")) {
        let t = e.length;
        for (; t--; ) {
          let i = e[t];
          if (i.type === "AssignmentExpression") return !0;
          if (i.type !== "ObjectProperty" && !i.type.endsWith("Pattern")) break;
        }
      }
      return !1;
    }
    function CR(n, e) {
      for (let t of n.params) for (let i of Mo(t)) e(i);
    }
    function PR(n, e) {
      for (let t of n.body)
        if (t.type === "VariableDeclaration") {
          if (t.declare) continue;
          for (let i of t.declarations) for (let r of Mo(i.id)) e(r);
        } else if (
          t.type === "FunctionDeclaration" ||
          t.type === "ClassDeclaration"
        ) {
          if (t.declare || !t.id) continue;
          e(t.id);
        }
    }
    function Mo(n, e = []) {
      switch (n.type) {
        case "Identifier":
          e.push(n);
          break;
        case "MemberExpression":
          let t = n;
          for (; t.type === "MemberExpression"; ) t = t.object;
          e.push(t);
          break;
        case "ObjectPattern":
          for (let i of n.properties)
            i.type === "RestElement" ? Mo(i.argument, e) : Mo(i.value, e);
          break;
        case "ArrayPattern":
          n.elements.forEach((i) => {
            i && Mo(i, e);
          });
          break;
        case "RestElement":
          Mo(n.argument, e);
          break;
        case "AssignmentPattern":
          Mo(n.left, e);
          break;
      }
      return e;
    }
    function qL(n, e, t) {
      let { name: i } = e;
      (n.scopeIds && n.scopeIds.has(i)) ||
        (i in t ? t[i]++ : (t[i] = 1),
        (n.scopeIds || (n.scopeIds = new Set())).add(i));
    }
    var DR = (n) => /Function(?:Expression|Declaration)$|Method$/.test(n.type),
      dE = (n) =>
        n &&
        (n.type === "ObjectProperty" || n.type === "ObjectMethod") &&
        !n.computed,
      IR = (n, e) => dE(e) && e.key === n;
    function PX(n, e, t) {
      switch (e.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          return e.property === n ? !!e.computed : e.object === n;
        case "JSXMemberExpression":
          return e.object === n;
        case "VariableDeclarator":
          return e.init === n;
        case "ArrowFunctionExpression":
          return e.body === n;
        case "PrivateName":
          return !1;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          return e.key === n ? !!e.computed : !1;
        case "ObjectProperty":
          return e.key === n ? !!e.computed : !t || t.type !== "ObjectPattern";
        case "ClassProperty":
          return e.key === n ? !!e.computed : !0;
        case "ClassPrivateProperty":
          return e.key !== n;
        case "ClassDeclaration":
        case "ClassExpression":
          return e.superClass === n;
        case "AssignmentExpression":
          return e.right === n;
        case "AssignmentPattern":
          return e.right === n;
        case "LabeledStatement":
          return !1;
        case "CatchClause":
          return !1;
        case "RestElement":
          return !1;
        case "BreakStatement":
        case "ContinueStatement":
          return !1;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return !1;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return !1;
        case "ExportSpecifier":
          return t != null && t.source ? !1 : e.local === n;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return !1;
        case "ImportAttribute":
          return !1;
        case "JSXAttribute":
          return !1;
        case "ObjectPattern":
        case "ArrayPattern":
          return !1;
        case "MetaProperty":
          return !1;
        case "ObjectTypeProperty":
          return e.key !== n;
        case "TSEnumMember":
          return e.id !== n;
        case "TSPropertySignature":
          return e.key === n ? !!e.computed : !0;
      }
      return !0;
    }
    var DX = nt.makeMap("true,false,null,this"),
      LR = (n, e) => {
        if (n.type === 5) n.content = Pr(n.content, e);
        else if (n.type === 1)
          for (let t = 0; t < n.props.length; t++) {
            let i = n.props[t];
            if (i.type === 7 && i.name !== "for") {
              let r = i.exp,
                s = i.arg;
              r &&
                r.type === 4 &&
                !(i.name === "on" && s) &&
                (i.exp = Pr(r, e, i.name === "slot")),
                s && s.type === 4 && !s.isStatic && (i.arg = Pr(s, e));
            }
          }
      };
    function Pr(n, e, t = !1, i = !1, r = Object.create(e.identifiers)) {
      if (!e.prefixIdentifiers || !n.content.trim()) return n;
      let { inline: s, bindingMetadata: a } = e,
        o = (b, _, E) => {
          let w = nt.hasOwn(a, b) && a[b];
          if (s) {
            let P = _ && _.type === "AssignmentExpression" && _.left === E,
              L = _ && _.type === "UpdateExpression" && _.argument === E,
              I = _ && fE(_, m);
            if (w === "setup-const" || w === "setup-reactive-const" || r[b])
              return b;
            if (w === "setup-ref") return `${b}.value`;
            if (w === "setup-maybe-ref")
              return P || L || I ? `${b}.value` : `${e.helperString(Df)}(${b})`;
            if (w === "setup-let")
              if (P) {
                let { right: M, operator: R } = _,
                  O = l.slice(M.start - 1, M.end - 1),
                  U = RR(Pr(Yt(O, !1), e, !1, !1, x));
                return `${e.helperString(If)}(${b})${
                  e.isTS
                    ? ` //@ts-ignore
`
                    : ""
                } ? ${b}.value ${R} ${U} : ${b}`;
              } else if (L) {
                (E.start = _.start), (E.end = _.end);
                let { prefix: M, operator: R } = _,
                  O = M ? R : "",
                  U = M ? "" : R;
                return `${e.helperString(If)}(${b})${
                  e.isTS
                    ? ` //@ts-ignore
`
                    : ""
                } ? ${O}${b}.value${U} : ${O}${b}${U}`;
              } else return I ? b : `${e.helperString(Df)}(${b})`;
            else {
              if (w === "props") return nt.genPropsAccessExp(b);
              if (w === "props-aliased")
                return nt.genPropsAccessExp(a.__propsAliases[b]);
            }
          } else {
            if (w && w.startsWith("setup")) return `$setup.${b}`;
            if (w === "props-aliased")
              return `$props['${a.__propsAliases[b]}']`;
            if (w) return `$${w}.${b}`;
          }
          return `_ctx.${b}`;
        },
        l = n.content,
        c = l.indexOf("(") > -1 || l.indexOf(".") > 0;
      if (Po(l)) {
        let b = e.identifiers[l],
          _ = nt.isGloballyWhitelisted(l),
          E = DX(l);
        return (
          !t && !b && !_ && !E
            ? (a[n.content] === "setup-const" && (n.constType = 1),
              (n.content = o(l)))
            : b || (E ? (n.constType = 3) : (n.constType = 2)),
          n
        );
      }
      let u,
        f = i ? ` ${l} ` : `(${l})${t ? "=>{}" : ""}`;
      try {
        u = nR.parse(f, { plugins: e.expressionPlugins }).program;
      } catch (b) {
        return e.onError(Li(44, n.loc, void 0, b.message)), n;
      }
      let d = [],
        m = [],
        x = Object.create(e.identifiers);
      MR(
        u,
        (b, _, E, w, P) => {
          if (IR(b, _) || b.name.startsWith("_filter_")) return;
          let L = w && IX(b);
          L && !P
            ? (dE(_) && _.shorthand && (b.prefix = `${b.name}: `),
              (b.name = o(b.name, _, b)),
              d.push(b))
            : (!(L && P) && !c && (b.isConstant = !0), d.push(b));
        },
        !0,
        m,
        x
      );
      let y = [];
      d.sort((b, _) => b.start - _.start),
        d.forEach((b, _) => {
          let E = b.start - 1,
            w = b.end - 1,
            P = d[_ - 1],
            L = l.slice(P ? P.end - 1 : 0, E);
          (L.length || b.prefix) && y.push(L + (b.prefix || ""));
          let I = l.slice(E, w);
          y.push(
            Yt(
              b.name,
              !1,
              {
                source: I,
                start: Rl(n.loc.start, I, E),
                end: Rl(n.loc.start, I, w),
              },
              b.isConstant ? 3 : 0
            )
          ),
            _ === d.length - 1 && w < l.length && y.push(l.slice(w));
        });
      let g;
      return (
        y.length ? (g = Mr(y, n.loc)) : ((g = n), (g.constType = c ? 0 : 3)),
        (g.identifiers = Object.keys(x)),
        g
      );
    }
    function IX(n) {
      return !(nt.isGloballyWhitelisted(n.name) || n.name === "require");
    }
    function RR(n) {
      return nt.isString(n)
        ? n
        : n.type === 4
        ? n.content
        : n.children.map(RR).join("");
    }
    var LX = hE(/^(if|else|else-if)$/, (n, e, t) =>
      OR(n, e, t, (i, r, s) => {
        let a = t.parent.children,
          o = a.indexOf(i),
          l = 0;
        for (; o-- >= 0; ) {
          let c = a[o];
          c && c.type === 9 && (l += c.branches.length);
        }
        return () => {
          if (s) i.codegenNode = XL(r, l, t);
          else {
            let c = OX(i.codegenNode);
            c.alternate = XL(r, l + i.branches.length - 1, t);
          }
        };
      })
    );
    function OR(n, e, t, i) {
      if (e.name !== "else" && (!e.exp || !e.exp.content.trim())) {
        let r = e.exp ? e.exp.loc : n.loc;
        t.onError(Li(28, e.loc)), (e.exp = Yt("true", !1, r));
      }
      if (
        (t.prefixIdentifiers && e.exp && (e.exp = Pr(e.exp, t)),
        e.name === "if")
      ) {
        let r = jL(n, e),
          s = { type: 9, loc: n.loc, branches: [r] };
        if ((t.replaceNode(s), i)) return i(s, r, !0);
      } else {
        let r = t.parent.children,
          s = r.indexOf(n);
        for (; s-- >= -1; ) {
          let a = r[s];
          if (a && a.type === 2 && !a.content.trim().length) {
            t.removeNode(a);
            continue;
          }
          if (a && a.type === 9) {
            e.name === "else-if" &&
              a.branches[a.branches.length - 1].condition === void 0 &&
              t.onError(Li(30, n.loc)),
              t.removeNode();
            let o = jL(n, e);
            {
              let c = o.userKey;
              c &&
                a.branches.forEach(({ userKey: u }) => {
                  RX(u, c) && t.onError(Li(29, o.userKey.loc));
                });
            }
            a.branches.push(o);
            let l = i && i(a, o, !1);
            Ff(o, t), l && l(), (t.currentNode = null);
          } else t.onError(Li(30, n.loc));
          break;
        }
      }
    }
    function jL(n, e) {
      let t = n.tagType === 3;
      return {
        type: 10,
        loc: n.loc,
        condition: e.name === "else" ? void 0 : e.exp,
        children: t && !hr(n, "for") ? n.children : [n],
        userKey: Lf(n, "key"),
        isTemplateIf: t,
      };
    }
    function XL(n, e, t) {
      return n.condition
        ? jm(n.condition, YL(n, e, t), vn(t.helper(pu), ['""', "true"]))
        : YL(n, e, t);
    }
    function YL(n, e, t) {
      let { helper: i } = t,
        r = nn("key", Yt(`${e}`, !1, rn, 2)),
        { children: s } = n,
        a = s[0];
      if (s.length !== 1 || a.type !== 1)
        if (s.length === 1 && a.type === 11) {
          let l = a.codegenNode;
          return Of(l, r, t), l;
        } else {
          let l = 64;
          return (
            nt.PatchFlagNames[64],
            hu(t, i(cu), Ar([r]), s, l + "", void 0, void 0, !0, !1, !1, n.loc)
          );
        }
      else {
        let l = a.codegenNode,
          c = hR(l);
        return c.type === 13 && fg(c, t), Of(c, r, t), l;
      }
    }
    function RX(n, e) {
      if (!n || n.type !== e.type) return !1;
      if (n.type === 6) {
        if (n.value.content !== e.value.content) return !1;
      } else {
        let t = n.exp,
          i = e.exp;
        if (
          t.type !== i.type ||
          t.type !== 4 ||
          t.isStatic !== i.isStatic ||
          t.content !== i.content
        )
          return !1;
      }
      return !0;
    }
    function OX(n) {
      for (;;)
        if (n.type === 19)
          if (n.alternate.type === 19) n = n.alternate;
          else return n;
        else n.type === 20 && (n = n.value);
    }
    var NX = hE("for", (n, e, t) => {
      let { helper: i, removeHelper: r } = t;
      return NR(n, e, t, (s) => {
        let a = vn(i(ng), [s.source]),
          o = du(n),
          l = hr(n, "memo"),
          c = Lf(n, "key"),
          u = c && (c.type === 6 ? Yt(c.value.content, !0) : c.exp),
          f = c ? nn("key", u) : null;
        o &&
          (l && (l.exp = Pr(l.exp, t)),
          f && c.type !== 6 && (f.value = Pr(f.value, t)));
        let d = s.source.type === 4 && s.source.constType > 0,
          m = d ? 64 : c ? 128 : 256;
        return (
          (s.codegenNode = hu(
            t,
            i(cu),
            void 0,
            a,
            m + "",
            void 0,
            void 0,
            !0,
            !d,
            !1,
            n.loc
          )),
          () => {
            let x,
              { children: y } = s;
            o &&
              n.children.some((_) => {
                if (_.type === 1) {
                  let E = Lf(_, "key");
                  if (E) return t.onError(Li(33, E.loc)), !0;
                }
              });
            let g = y.length !== 1 || y[0].type !== 1,
              b = Rf(n)
                ? n
                : o && n.children.length === 1 && Rf(n.children[0])
                ? n.children[0]
                : null;
            if (
              (b
                ? ((x = b.codegenNode), o && f && Of(x, f, t))
                : g
                ? (x = hu(
                    t,
                    i(cu),
                    f ? Ar([f]) : void 0,
                    n.children,
                    64 + "",
                    void 0,
                    void 0,
                    !0,
                    void 0,
                    !1
                  ))
                : ((x = y[0].codegenNode),
                  o && f && Of(x, f, t),
                  x.isBlock !== !d &&
                    (x.isBlock
                      ? (r(Co), r(Nl(t.inSSR, x.isComponent)))
                      : r(Ol(t.inSSR, x.isComponent))),
                  (x.isBlock = !d),
                  x.isBlock
                    ? (i(Co), i(Nl(t.inSSR, x.isComponent)))
                    : i(Ol(t.inSSR, x.isComponent))),
              l)
            ) {
              let _ = Ll(Xm(s.parseResult, [Yt("_cached")]));
              (_.body = lR([
                Mr(["const _memo = (", l.exp, ")"]),
                Mr([
                  "if (_cached",
                  ...(u ? [" && _cached.key === ", u] : []),
                  ` && ${t.helperString(sE)}(_cached, _memo)) return _cached`,
                ]),
                Mr(["const _item = ", x]),
                Yt("_item.memo = _memo"),
                Yt("return _item"),
              ])),
                a.arguments.push(_, Yt("_cache"), Yt(String(t.cached++)));
            } else a.arguments.push(Ll(Xm(s.parseResult), x, !0));
          }
        );
      });
    });
    function NR(n, e, t, i) {
      if (!e.exp) {
        t.onError(Li(31, e.loc));
        return;
      }
      let r = pE(e.exp, t);
      if (!r) {
        t.onError(Li(32, e.loc));
        return;
      }
      let { addIdentifiers: s, removeIdentifiers: a, scopes: o } = t,
        { source: l, value: c, key: u, index: f } = r,
        d = {
          type: 11,
          loc: e.loc,
          source: l,
          valueAlias: c,
          keyAlias: u,
          objectIndexAlias: f,
          parseResult: r,
          children: du(n) ? n.children : [n],
        };
      t.replaceNode(d),
        o.vFor++,
        t.prefixIdentifiers && (c && s(c), u && s(u), f && s(f));
      let m = i && i(d);
      return () => {
        o.vFor--,
          t.prefixIdentifiers && (c && a(c), u && a(u), f && a(f)),
          m && m();
      };
    }
    var kX = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,
      KL = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,
      FX = /^\(|\)$/g;
    function pE(n, e) {
      let t = n.loc,
        i = n.content,
        r = i.match(kX);
      if (!r) return;
      let [, s, a] = r,
        o = {
          source: Bm(t, a.trim(), i.indexOf(a, s.length)),
          value: void 0,
          key: void 0,
          index: void 0,
        };
      e.prefixIdentifiers && (o.source = Pr(o.source, e));
      let l = s.trim().replace(FX, "").trim(),
        c = s.indexOf(l),
        u = l.match(KL);
      if (u) {
        l = l.replace(KL, "").trim();
        let f = u[1].trim(),
          d;
        if (
          (f &&
            ((d = i.indexOf(f, c + l.length)),
            (o.key = Bm(t, f, d)),
            e.prefixIdentifiers && (o.key = Pr(o.key, e, !0))),
          u[2])
        ) {
          let m = u[2].trim();
          m &&
            ((o.index = Bm(
              t,
              m,
              i.indexOf(m, o.key ? d + f.length : c + l.length)
            )),
            e.prefixIdentifiers && (o.index = Pr(o.index, e, !0)));
        }
      }
      return (
        l &&
          ((o.value = Bm(t, l, c)),
          e.prefixIdentifiers && (o.value = Pr(o.value, e, !0))),
        o
      );
    }
    function Bm(n, e, t) {
      return Yt(e, !1, lE(n, t, e.length));
    }
    function Xm({ value: n, key: e, index: t }, i = []) {
      return BX([n, e, t, ...i]);
    }
    function BX(n) {
      let e = n.length;
      for (; e-- && !n[e]; );
      return n.slice(0, e + 1).map((t, i) => t || Yt("_".repeat(i + 1), !1));
    }
    var JL = Yt("undefined", !1),
      kR = (n, e) => {
        if (n.type === 1 && (n.tagType === 1 || n.tagType === 3)) {
          let t = hr(n, "slot");
          if (t) {
            let i = t.exp;
            return (
              e.prefixIdentifiers && i && e.addIdentifiers(i),
              e.scopes.vSlot++,
              () => {
                e.prefixIdentifiers && i && e.removeIdentifiers(i),
                  e.scopes.vSlot--;
              }
            );
          }
        }
      },
      FR = (n, e) => {
        let t;
        if (du(n) && n.props.some(cE) && (t = hr(n, "for"))) {
          let i = (t.parseResult = pE(t.exp, e));
          if (i) {
            let { value: r, key: s, index: a } = i,
              { addIdentifiers: o, removeIdentifiers: l } = e;
            return (
              r && o(r),
              s && o(s),
              a && o(a),
              () => {
                r && l(r), s && l(s), a && l(a);
              }
            );
          }
        }
      },
      zX = (n, e, t) => Ll(n, e, !1, !0, e.length ? e[0].loc : t);
    function BR(n, e, t = zX) {
      e.helper(ug);
      let { children: i, loc: r } = n,
        s = [],
        a = [],
        o = e.scopes.vSlot > 0 || e.scopes.vFor > 0;
      !e.ssr && e.prefixIdentifiers && (o = cr(n, e.identifiers));
      let l = hr(n, "slot", !0);
      if (l) {
        let { arg: y, exp: g } = l;
        y && !ks(y) && (o = !0), s.push(nn(y || Yt("default", !0), t(g, i, r)));
      }
      let c = !1,
        u = !1,
        f = [],
        d = new Set();
      for (let y = 0; y < i.length; y++) {
        let g = i[y],
          b;
        if (!du(g) || !(b = hr(g, "slot", !0))) {
          g.type !== 3 && f.push(g);
          continue;
        }
        if (l) {
          e.onError(Li(37, b.loc));
          break;
        }
        c = !0;
        let { children: _, loc: E } = g,
          { arg: w = Yt("default", !0), exp: P, loc: L } = b,
          I;
        ks(w) ? (I = w ? w.content : "default") : (o = !0);
        let M = t(P, _, E),
          R,
          O,
          U;
        if ((R = hr(g, "if"))) (o = !0), a.push(jm(R.exp, zm(w, M), JL));
        else if ((O = hr(g, /^else(-if)?$/, !0))) {
          let X = y,
            $;
          for (; X-- && (($ = i[X]), $.type === 3); );
          if ($ && du($) && hr($, "if")) {
            i.splice(y, 1), y--;
            let W = a[a.length - 1];
            for (; W.alternate.type === 19; ) W = W.alternate;
            W.alternate = O.exp ? jm(O.exp, zm(w, M), JL) : zm(w, M);
          } else e.onError(Li(30, O.loc));
        } else if ((U = hr(g, "for"))) {
          o = !0;
          let X = U.parseResult || pE(U.exp, e);
          X
            ? a.push(vn(e.helper(ng), [X.source, Ll(Xm(X), zm(w, M), !0)]))
            : e.onError(Li(32, U.loc));
        } else {
          if (I) {
            if (d.has(I)) {
              e.onError(Li(38, L));
              continue;
            }
            d.add(I), I === "default" && (u = !0);
          }
          s.push(nn(w, M));
        }
      }
      if (!l) {
        let y = (g, b) => {
          let _ = t(g, b, r);
          return e.compatConfig && (_.isNonScopedSlot = !0), nn("default", _);
        };
        c
          ? f.length &&
            f.some((g) => zR(g)) &&
            (u ? e.onError(Li(39, f[0].loc)) : s.push(y(void 0, f)))
          : s.push(y(void 0, i));
      }
      let m = o ? 2 : $m(n.children) ? 3 : 1,
        x = Ar(s.concat(nn("_", Yt(m + "", !1))), r);
      return (
        a.length && (x = vn(e.helper(rE), [x, gu(a)])),
        { slots: x, hasDynamicSlots: o }
      );
    }
    function zm(n, e) {
      return Ar([nn("name", n), nn("fn", e)]);
    }
    function $m(n) {
      for (let e = 0; e < n.length; e++) {
        let t = n[e];
        switch (t.type) {
          case 1:
            if (t.tagType === 2 || $m(t.children)) return !0;
            break;
          case 9:
            if ($m(t.branches)) return !0;
            break;
          case 10:
          case 11:
            if ($m(t.children)) return !0;
            break;
        }
      }
      return !1;
    }
    function zR(n) {
      return n.type !== 2 && n.type !== 12
        ? !0
        : n.type === 2
        ? !!n.content.trim()
        : zR(n.content);
    }
    var UR = new WeakMap(),
      VR = (n, e) =>
        function () {
          if (
            ((n = e.currentNode),
            !(n.type === 1 && (n.tagType === 0 || n.tagType === 1)))
          )
            return;
          let { tag: i, props: r } = n,
            s = n.tagType === 1,
            a = s ? GR(n, e) : `"${i}"`,
            o = nt.isObject(a) && a.callee === Af,
            l,
            c,
            u,
            f = 0,
            d,
            m,
            x,
            y =
              o ||
              a === lu ||
              a === Km ||
              (!s && (i === "svg" || i === "foreignObject"));
          if (r.length > 0) {
            let g = mE(n, e, void 0, s, o);
            (l = g.props), (f = g.patchFlag), (m = g.dynamicPropNames);
            let b = g.directives;
            (x = b && b.length ? gu(b.map((_) => HR(_, e))) : void 0),
              g.shouldUseBlock && (y = !0);
          }
          if (n.children.length > 0)
            if (
              (a === wf && ((y = !0), (f |= 1024)), s && a !== lu && a !== wf)
            ) {
              let { slots: b, hasDynamicSlots: _ } = BR(n, e);
              (c = b), _ && (f |= 1024);
            } else if (n.children.length === 1 && a !== lu) {
              let b = n.children[0],
                _ = b.type,
                E = _ === 5 || _ === 8;
              E && Cr(b, e) === 0 && (f |= 1),
                E || _ === 2 ? (c = b) : (c = n.children);
            } else c = n.children;
          f !== 0 && ((u = String(f)), m && m.length && (d = VX(m))),
            (n.codegenNode = hu(e, a, l, c, u, d, x, !!y, !1, s, n.loc));
        };
    function GR(n, e, t = !1) {
      let { tag: i } = n,
        r = J_(i),
        s = Lf(n, "is");
      if (s)
        if (r || Il("COMPILER_IS_ON_ELEMENT", e)) {
          let l = s.type === 6 ? s.value && Yt(s.value.content, !0) : s.exp;
          if (l) return vn(e.helper(Af), [l]);
        } else
          s.type === 6 &&
            s.value.content.startsWith("vue:") &&
            (i = s.value.content.slice(4));
      let a = !r && hr(n, "is");
      if (a && a.exp) return vn(e.helper(Af), [a.exp]);
      let o = aE(i) || e.isBuiltInComponent(i);
      if (o) return t || e.helper(o), o;
      {
        let l = K_(i, e);
        if (l) return l;
        let c = i.indexOf(".");
        if (c > 0) {
          let u = K_(i.slice(0, c), e);
          if (u) return u + i.slice(c);
        }
      }
      return e.selfName && nt.capitalize(nt.camelize(i)) === e.selfName
        ? (e.helper(Mf), e.components.add(i + "__self"), kl(i, "component"))
        : (e.helper(Mf), e.components.add(i), kl(i, "component"));
    }
    function K_(n, e) {
      let t = e.bindingMetadata;
      if (!t || t.__isScriptSetup === !1) return;
      let i = nt.camelize(n),
        r = nt.capitalize(i),
        s = (l) => {
          if (t[n] === l) return n;
          if (t[i] === l) return i;
          if (t[r] === l) return r;
        },
        a = s("setup-const") || s("setup-reactive-const");
      if (a) return e.inline ? a : `$setup[${JSON.stringify(a)}]`;
      let o = s("setup-let") || s("setup-ref") || s("setup-maybe-ref");
      if (o)
        return e.inline
          ? `${e.helperString(Df)}(${o})`
          : `$setup[${JSON.stringify(o)}]`;
    }
    function mE(n, e, t = n.props, i, r, s = !1) {
      let { tag: a, loc: o, children: l } = n,
        c = [],
        u = [],
        f = [],
        d = l.length > 0,
        m = !1,
        x = 0,
        y = !1,
        g = !1,
        b = !1,
        _ = !1,
        E = !1,
        w = !1,
        P = [],
        L = ({ key: M, value: R }) => {
          if (ks(M)) {
            let O = M.content,
              U = nt.isOn(O);
            if (
              (U &&
                (!i || r) &&
                O.toLowerCase() !== "onclick" &&
                O !== "onUpdate:modelValue" &&
                !nt.isReservedProp(O) &&
                (_ = !0),
              U && nt.isReservedProp(O) && (w = !0),
              R.type === 20 || ((R.type === 4 || R.type === 8) && Cr(R, e) > 0))
            )
              return;
            O === "ref"
              ? (y = !0)
              : O === "class"
              ? (g = !0)
              : O === "style"
              ? (b = !0)
              : O !== "key" && !P.includes(O) && P.push(O),
              i &&
                (O === "class" || O === "style") &&
                !P.includes(O) &&
                P.push(O);
          } else E = !0;
        };
      for (let M = 0; M < t.length; M++) {
        let R = t[M];
        if (R.type === 6) {
          let { loc: O, name: U, value: X } = R,
            $ = !0;
          if (
            (U === "ref" &&
              ((y = !0),
              e.scopes.vFor > 0 && c.push(nn(Yt("ref_for", !0), Yt("true"))),
              X &&
                e.inline &&
                e.bindingMetadata[X.content] &&
                (($ = !1),
                c.push(nn(Yt("ref_key", !0), Yt(X.content, !0, X.loc))))),
            U === "is" &&
              (J_(a) ||
                (X && X.content.startsWith("vue:")) ||
                Il("COMPILER_IS_ON_ELEMENT", e)))
          )
            continue;
          c.push(
            nn(
              Yt(U, !0, lE(O, 0, U.length)),
              Yt(X ? X.content : "", $, X ? X.loc : O)
            )
          );
        } else {
          let { name: O, arg: U, exp: X, loc: $ } = R,
            W = O === "bind",
            ue = O === "on";
          if (O === "slot") {
            i || e.onError(Li(40, $));
            continue;
          }
          if (
            O === "once" ||
            O === "memo" ||
            O === "is" ||
            (W && Ao(U, "is") && (J_(a) || Il("COMPILER_IS_ON_ELEMENT", e))) ||
            (ue && s)
          )
            continue;
          if (
            (((W && Ao(U, "key")) || (ue && d && Ao(U, "vue:before-update"))) &&
              (m = !0),
            W &&
              Ao(U, "ref") &&
              e.scopes.vFor > 0 &&
              c.push(nn(Yt("ref_for", !0), Yt("true"))),
            !U && (W || ue))
          ) {
            if (((E = !0), X))
              if ((c.length && (u.push(Ar(q_(c), o)), (c = [])), W)) {
                if (Il("COMPILER_V_BIND_OBJECT_ORDER", e)) {
                  u.unshift(X);
                  continue;
                }
                u.push(X);
              } else
                u.push({
                  type: 14,
                  loc: $,
                  callee: e.helper(og),
                  arguments: [X],
                });
            else e.onError(Li(W ? 34 : 35, $));
            continue;
          }
          let ae = e.directiveTransforms[O];
          if (ae) {
            let { props: he, needRuntime: ce } = ae(R, n, e);
            !s && he.forEach(L),
              c.push(...he),
              ce && (f.push(R), nt.isSymbol(ce) && UR.set(R, ce));
          } else nt.isBuiltInDirective(O) || (f.push(R), d && (m = !0));
        }
      }
      let I;
      if (
        (u.length
          ? (c.length && u.push(Ar(q_(c), o)),
            u.length > 1 ? (I = vn(e.helper(Cf), u, o)) : (I = u[0]))
          : c.length && (I = Ar(q_(c), o)),
        E
          ? (x |= 16)
          : (g && !i && (x |= 2),
            b && !i && (x |= 4),
            P.length && (x |= 8),
            _ && (x |= 32)),
        !m && (x === 0 || x === 32) && (y || w || f.length > 0) && (x |= 512),
        !e.inSSR && I)
      )
        switch (I.type) {
          case 15:
            let M = -1,
              R = -1,
              O = !1;
            for (let $ = 0; $ < I.properties.length; $++) {
              let W = I.properties[$].key;
              ks(W)
                ? W.content === "class"
                  ? (M = $)
                  : W.content === "style" && (R = $)
                : W.isHandlerKey || (O = !0);
            }
            let U = I.properties[M],
              X = I.properties[R];
            O
              ? (I = vn(e.helper(uu), [I]))
              : (U && !ks(U.value) && (U.value = vn(e.helper(sg), [U.value])),
                X &&
                  (b ||
                    (X.value.type === 4 && X.value.content.trim()[0] === "[") ||
                    X.value.type === 17) &&
                  (X.value = vn(e.helper(ag), [X.value])));
            break;
          case 14:
            break;
          default:
            I = vn(e.helper(uu), [vn(e.helper(mu), [I])]);
            break;
        }
      return {
        props: I,
        directives: f,
        patchFlag: x,
        dynamicPropNames: P,
        shouldUseBlock: m,
      };
    }
    function q_(n) {
      let e = new Map(),
        t = [];
      for (let i = 0; i < n.length; i++) {
        let r = n[i];
        if (r.key.type === 8 || !r.key.isStatic) {
          t.push(r);
          continue;
        }
        let s = r.key.content,
          a = e.get(s);
        a
          ? (s === "style" || s === "class" || nt.isOn(s)) && UX(a, r)
          : (e.set(s, r), t.push(r));
      }
      return t;
    }
    function UX(n, e) {
      n.value.type === 17
        ? n.value.elements.push(e.value)
        : (n.value = gu([n.value, e.value], n.loc));
    }
    function HR(n, e) {
      let t = [],
        i = UR.get(n);
      if (i) t.push(e.helperString(i));
      else {
        let s = K_("v-" + n.name, e);
        s
          ? t.push(s)
          : (e.helper(eg),
            e.directives.add(n.name),
            t.push(kl(n.name, "directive")));
      }
      let { loc: r } = n;
      if (
        (n.exp && t.push(n.exp),
        n.arg && (n.exp || t.push("void 0"), t.push(n.arg)),
        Object.keys(n.modifiers).length)
      ) {
        n.arg || (n.exp || t.push("void 0"), t.push("void 0"));
        let s = Yt("true", !1, r);
        t.push(
          Ar(
            n.modifiers.map((a) => nn(a, s)),
            r
          )
        );
      }
      return gu(t, n.loc);
    }
    function VX(n) {
      let e = "[";
      for (let t = 0, i = n.length; t < i; t++)
        (e += JSON.stringify(n[t])), t < i - 1 && (e += ", ");
      return e + "]";
    }
    function J_(n) {
      return n === "component" || n === "Component";
    }
    var GX = (n) => {
        let e = Object.create(null);
        return (t) => e[t] || (e[t] = n(t));
      },
      HX = /-(\w)/g,
      ZL = GX((n) => n.replace(HX, (e, t) => (t ? t.toUpperCase() : ""))),
      $X = (n, e) => {
        if (Rf(n)) {
          let { children: t, loc: i } = n,
            { slotName: r, slotProps: s } = $R(n, e),
            a = [
              e.prefixIdentifiers ? "_ctx.$slots" : "$slots",
              r,
              "{}",
              "undefined",
              "true",
            ],
            o = 2;
          s && ((a[2] = s), (o = 3)),
            t.length && ((a[3] = Ll([], t, !1, !1, i)), (o = 4)),
            e.scopeId && !e.slotted && (o = 5),
            a.splice(o),
            (n.codegenNode = vn(e.helper(nE), a, i));
        }
      };
    function $R(n, e) {
      let t = '"default"',
        i,
        r = [];
      for (let s = 0; s < n.props.length; s++) {
        let a = n.props[s];
        a.type === 6
          ? a.value &&
            (a.name === "name"
              ? (t = JSON.stringify(a.value.content))
              : ((a.name = ZL(a.name)), r.push(a)))
          : a.name === "bind" && Ao(a.arg, "name")
          ? a.exp && (t = a.exp)
          : (a.name === "bind" &&
              a.arg &&
              ks(a.arg) &&
              (a.arg.content = ZL(a.arg.content)),
            r.push(a));
      }
      if (r.length > 0) {
        let { props: s, directives: a } = mE(n, e, r, !1, !1);
        (i = s), a.length && e.onError(Li(36, a[0].loc));
      }
      return { slotName: t, slotProps: i };
    }
    var WX =
        /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/,
      WR = (n, e, t, i) => {
        let { loc: r, modifiers: s, arg: a } = n;
        !n.exp && !s.length && t.onError(Li(35, r));
        let o;
        if (a.type === 4)
          if (a.isStatic) {
            let f = a.content;
            f.startsWith("vue:") && (f = `vnode-${f.slice(4)}`),
              (o = Yt(nt.toHandlerKey(nt.camelize(f)), !0, a.loc));
          } else o = Mr([`${t.helperString(qm)}(`, a, ")"]);
        else
          (o = a),
            o.children.unshift(`${t.helperString(qm)}(`),
            o.children.push(")");
        let l = n.exp;
        l && !l.content.trim() && (l = void 0);
        let c = t.cacheHandlers && !l && !t.inVOnce;
        if (l) {
          let f = oE(l.content, t),
            d = !(f || WX.test(l.content)),
            m = l.content.includes(";");
          t.prefixIdentifiers &&
            (d && t.addIdentifiers("$event"),
            (l = n.exp = Pr(l, t, !1, m)),
            d && t.removeIdentifiers("$event"),
            (c =
              t.cacheHandlers &&
              !t.inVOnce &&
              !(l.type === 4 && l.constType > 0) &&
              !(f && e.tagType === 1) &&
              !cr(l, t.identifiers)),
            c &&
              f &&
              (l.type === 4
                ? (l.content = `${l.content} && ${l.content}(...args)`)
                : (l.children = [
                    ...l.children,
                    " && ",
                    ...l.children,
                    "(...args)",
                  ]))),
            (d || (c && f)) &&
              (l = Mr([
                `${
                  d
                    ? t.isTS
                      ? "($event: any)"
                      : "$event"
                    : `${
                        t.isTS
                          ? `
//@ts-ignore
`
                          : ""
                      }(...args)`
                } => ${m ? "{" : "("}`,
                l,
                m ? "}" : ")",
              ]));
        }
        let u = { props: [nn(o, l || Yt("() => {}", !1, r))] };
        return (
          i && (u = i(u)),
          c && (u.props[0].value = t.cache(u.props[0].value)),
          u.props.forEach((f) => (f.key.isHandlerKey = !0)),
          u
        );
      },
      qR = (n, e, t) => {
        let { exp: i, modifiers: r, loc: s } = n,
          a = n.arg;
        return (
          a.type !== 4
            ? (a.children.unshift("("), a.children.push(') || ""'))
            : a.isStatic || (a.content = `${a.content} || ""`),
          r.includes("camel") &&
            (a.type === 4
              ? a.isStatic
                ? (a.content = nt.camelize(a.content))
                : (a.content = `${t.helperString(Wm)}(${a.content})`)
              : (a.children.unshift(`${t.helperString(Wm)}(`),
                a.children.push(")"))),
          t.inSSR ||
            (r.includes("prop") && QL(a, "."),
            r.includes("attr") && QL(a, "^")),
          !i || (i.type === 4 && !i.content.trim())
            ? (t.onError(Li(34, s)), { props: [nn(a, Yt("", !0, s))] })
            : { props: [nn(a, i)] }
        );
      },
      QL = (n, e) => {
        n.type === 4
          ? n.isStatic
            ? (n.content = e + n.content)
            : (n.content = `\`${e}\${${n.content}}\``)
          : (n.children.unshift(`'${e}' + (`), n.children.push(")"));
      },
      qX = (n, e) => {
        if (n.type === 0 || n.type === 1 || n.type === 11 || n.type === 10)
          return () => {
            let t = n.children,
              i,
              r = !1;
            for (let s = 0; s < t.length; s++) {
              let a = t[s];
              if (Vm(a)) {
                r = !0;
                for (let o = s + 1; o < t.length; o++) {
                  let l = t[o];
                  if (Vm(l))
                    i || (i = t[s] = Mr([a], a.loc)),
                      i.children.push(" + ", l),
                      t.splice(o, 1),
                      o--;
                  else {
                    i = void 0;
                    break;
                  }
                }
              }
            }
            if (
              !(
                !r ||
                (t.length === 1 &&
                  (n.type === 0 ||
                    (n.type === 1 &&
                      n.tagType === 0 &&
                      !n.props.find(
                        (s) => s.type === 7 && !e.directiveTransforms[s.name]
                      ) &&
                      n.tag !== "template")))
              )
            )
              for (let s = 0; s < t.length; s++) {
                let a = t[s];
                if (Vm(a) || a.type === 8) {
                  let o = [];
                  (a.type !== 2 || a.content !== " ") && o.push(a),
                    !e.ssr && Cr(a, e) === 0 && o.push(1 + ""),
                    (t[s] = {
                      type: 12,
                      content: a,
                      loc: a.loc,
                      codegenNode: vn(e.helper(Qm), o),
                    });
                }
              }
          };
      },
      eR = new WeakSet(),
      jX = (n, e) => {
        if (n.type === 1 && hr(n, "once", !0))
          return eR.has(n) || e.inVOnce
            ? void 0
            : (eR.add(n),
              (e.inVOnce = !0),
              e.helper(Pf),
              () => {
                e.inVOnce = !1;
                let t = e.currentNode;
                t.codegenNode && (t.codegenNode = e.cache(t.codegenNode, !0));
              });
      },
      jR = (n, e, t) => {
        let { exp: i, arg: r } = n;
        if (!i) return t.onError(Li(41, n.loc)), Um();
        let s = i.loc.source,
          a = i.type === 4 ? i.content : s,
          o = t.bindingMetadata[s],
          l = t.inline && o && o !== "setup-const";
        if (!a.trim() || (!oE(a, t) && !l))
          return t.onError(Li(42, i.loc)), Um();
        if (t.prefixIdentifiers && Po(a) && t.identifiers[a])
          return t.onError(Li(43, i.loc)), Um();
        let c = r || Yt("modelValue", !0),
          u = r
            ? ks(r)
              ? `onUpdate:${r.content}`
              : Mr(['"onUpdate:" + ', r])
            : "onUpdate:modelValue",
          f,
          d = t.isTS ? "($event: any)" : "$event";
        if (l)
          if (o === "setup-ref")
            f = Mr([`${d} => ((`, Yt(s, !1, i.loc), ").value = $event)"]);
          else {
            let x = o === "setup-let" ? `${s} = $event` : "null";
            f = Mr([
              `${d} => (${t.helperString(If)}(${s}) ? (`,
              Yt(s, !1, i.loc),
              `).value = $event : ${x})`,
            ]);
          }
        else f = Mr([`${d} => ((`, i, ") = $event)"]);
        let m = [nn(c, n.exp), nn(u, f)];
        if (
          (t.prefixIdentifiers &&
            !t.inVOnce &&
            t.cacheHandlers &&
            !cr(i, t.identifiers) &&
            (m[1].value = t.cache(m[1].value)),
          n.modifiers.length && e.tagType === 1)
        ) {
          let x = n.modifiers
              .map((g) => (Po(g) ? g : JSON.stringify(g)) + ": true")
              .join(", "),
            y = r
              ? ks(r)
                ? `${r.content}Modifiers`
                : Mr([r, ' + "Modifiers"'])
              : "modelModifiers";
          m.push(nn(y, Yt(`{ ${x} }`, !1, n.loc, 2)));
        }
        return Um(m);
      };
    function Um(n = []) {
      return { props: n };
    }
    var XX = /[\w).+\-_$\]]/,
      YX = (n, e) => {
        !Il("COMPILER_FILTER", e) ||
          (n.type === 5 && Ym(n.content, e),
          n.type === 1 &&
            n.props.forEach((t) => {
              t.type === 7 && t.name !== "for" && t.exp && Ym(t.exp, e);
            }));
      };
    function Ym(n, e) {
      if (n.type === 4) tR(n, e);
      else
        for (let t = 0; t < n.children.length; t++) {
          let i = n.children[t];
          typeof i == "object" &&
            (i.type === 4
              ? tR(i, e)
              : i.type === 8
              ? Ym(n, e)
              : i.type === 5 && Ym(i.content, e));
        }
    }
    function tR(n, e) {
      let t = n.content,
        i = !1,
        r = !1,
        s = !1,
        a = !1,
        o = 0,
        l = 0,
        c = 0,
        u = 0,
        f,
        d,
        m,
        x,
        y = [];
      for (m = 0; m < t.length; m++)
        if (((d = f), (f = t.charCodeAt(m)), i))
          f === 39 && d !== 92 && (i = !1);
        else if (r) f === 34 && d !== 92 && (r = !1);
        else if (s) f === 96 && d !== 92 && (s = !1);
        else if (a) f === 47 && d !== 92 && (a = !1);
        else if (
          f === 124 &&
          t.charCodeAt(m + 1) !== 124 &&
          t.charCodeAt(m - 1) !== 124 &&
          !o &&
          !l &&
          !c
        )
          x === void 0 ? ((u = m + 1), (x = t.slice(0, m).trim())) : g();
        else {
          switch (f) {
            case 34:
              r = !0;
              break;
            case 39:
              i = !0;
              break;
            case 96:
              s = !0;
              break;
            case 40:
              c++;
              break;
            case 41:
              c--;
              break;
            case 91:
              l++;
              break;
            case 93:
              l--;
              break;
            case 123:
              o++;
              break;
            case 125:
              o--;
              break;
          }
          if (f === 47) {
            let b = m - 1,
              _;
            for (; b >= 0 && ((_ = t.charAt(b)), _ === " "); b--);
            (!_ || !XX.test(_)) && (a = !0);
          }
        }
      x === void 0 ? (x = t.slice(0, m).trim()) : u !== 0 && g();
      function g() {
        y.push(t.slice(u, m).trim()), (u = m + 1);
      }
      if (y.length) {
        for (m = 0; m < y.length; m++) x = KX(x, y[m], e);
        n.content = x;
      }
    }
    function KX(n, e, t) {
      t.helper(tg);
      let i = e.indexOf("(");
      if (i < 0) return t.filters.add(e), `${kl(e, "filter")}(${n})`;
      {
        let r = e.slice(0, i),
          s = e.slice(i + 1);
        return (
          t.filters.add(r), `${kl(r, "filter")}(${n}${s !== ")" ? "," + s : s}`
        );
      }
    }
    var iR = new WeakSet(),
      JX = (n, e) => {
        if (n.type === 1) {
          let t = hr(n, "memo");
          return !t || iR.has(n)
            ? void 0
            : (iR.add(n),
              () => {
                let i = n.codegenNode || e.currentNode.codegenNode;
                i &&
                  i.type === 13 &&
                  (n.tagType !== 1 && fg(i, e),
                  (n.codegenNode = vn(e.helper(hg), [
                    t.exp,
                    Ll(void 0, i),
                    "_cache",
                    String(e.cached++),
                  ])));
              });
        }
      };
    function XR(n) {
      return [
        [jX, LX, JX, NX, YX, ...(n ? [FR, LR] : []), $X, VR, kR, qX],
        { on: WR, bind: qR, model: jR },
      ];
    }
    function ZX(n, e = {}) {
      let t = e.onError || Z_,
        i = e.mode === "module",
        r = e.prefixIdentifiers === !0 || i;
      !r && e.cacheHandlers && t(Li(48)), e.scopeId && !i && t(Li(49));
      let s = nt.isString(n) ? fR(n, e) : n,
        [a, o] = XR(r);
      if (e.isTS) {
        let { expressionPlugins: l } = e;
        (!l || !l.includes("typescript")) &&
          (e.expressionPlugins = [...(l || []), "typescript"]);
      }
      return (
        bR(
          s,
          nt.extend({}, e, {
            prefixIdentifiers: r,
            nodeTransforms: [...a, ...(e.nodeTransforms || [])],
            directiveTransforms: nt.extend({}, o, e.directiveTransforms || {}),
          })
        ),
        _R(s, nt.extend({}, e, { prefixIdentifiers: r }))
      );
    }
    var QX = () => ({ props: [] });
    Ae.generateCodeFrame = nt.generateCodeFrame;
    Ae.BASE_TRANSITION = Q_;
    Ae.CAMELIZE = Wm;
    Ae.CAPITALIZE = sR;
    Ae.CREATE_BLOCK = eE;
    Ae.CREATE_COMMENT = pu;
    Ae.CREATE_ELEMENT_BLOCK = tE;
    Ae.CREATE_ELEMENT_VNODE = Zm;
    Ae.CREATE_SLOTS = rE;
    Ae.CREATE_STATIC = iE;
    Ae.CREATE_TEXT = Qm;
    Ae.CREATE_VNODE = Jm;
    Ae.FRAGMENT = cu;
    Ae.GUARD_REACTIVE_PROPS = mu;
    Ae.IS_MEMO_SAME = sE;
    Ae.IS_REF = If;
    Ae.KEEP_ALIVE = wf;
    Ae.MERGE_PROPS = Cf;
    Ae.NORMALIZE_CLASS = sg;
    Ae.NORMALIZE_PROPS = uu;
    Ae.NORMALIZE_STYLE = ag;
    Ae.OPEN_BLOCK = Co;
    Ae.POP_SCOPE_ID = cg;
    Ae.PUSH_SCOPE_ID = lg;
    Ae.RENDER_LIST = ng;
    Ae.RENDER_SLOT = nE;
    Ae.RESOLVE_COMPONENT = Mf;
    Ae.RESOLVE_DIRECTIVE = eg;
    Ae.RESOLVE_DYNAMIC_COMPONENT = Af;
    Ae.RESOLVE_FILTER = tg;
    Ae.SET_BLOCK_TRACKING = Pf;
    Ae.SUSPENSE = Km;
    Ae.TELEPORT = lu;
    Ae.TO_DISPLAY_STRING = rg;
    Ae.TO_HANDLERS = og;
    Ae.TO_HANDLER_KEY = qm;
    Ae.UNREF = Df;
    Ae.WITH_CTX = ug;
    Ae.WITH_DIRECTIVES = ig;
    Ae.WITH_MEMO = hg;
    Ae.advancePositionWithClone = Rl;
    Ae.advancePositionWithMutation = fu;
    Ae.assert = Gj;
    Ae.baseCompile = ZX;
    Ae.baseParse = fR;
    Ae.buildDirectiveArgs = HR;
    Ae.buildProps = mE;
    Ae.buildSlots = BR;
    Ae.checkCompatEnabled = Nf;
    Ae.createArrayExpression = gu;
    Ae.createAssignmentExpression = Oj;
    Ae.createBlockStatement = lR;
    Ae.createCacheExpression = oR;
    Ae.createCallExpression = vn;
    Ae.createCompilerError = Li;
    Ae.createCompoundExpression = Mr;
    Ae.createConditionalExpression = jm;
    Ae.createForLoopParams = Xm;
    Ae.createFunctionExpression = Ll;
    Ae.createIfStatement = Rj;
    Ae.createInterpolation = Ij;
    Ae.createObjectExpression = Ar;
    Ae.createObjectProperty = nn;
    Ae.createReturnStatement = kj;
    Ae.createRoot = aR;
    Ae.createSequenceExpression = Nj;
    Ae.createSimpleExpression = Yt;
    Ae.createStructuralDirectiveTransform = hE;
    Ae.createTemplateLiteral = Lj;
    Ae.createTransformContext = xR;
    Ae.createVNodeCall = hu;
    Ae.extractIdentifiers = Mo;
    Ae.findDir = hr;
    Ae.findProp = Lf;
    Ae.generate = _R;
    Ae.getBaseTransformPreset = XR;
    Ae.getConstantType = Cr;
    Ae.getInnerRange = lE;
    Ae.getMemoedVNodeCall = hR;
    Ae.getVNodeBlockHelper = Nl;
    Ae.getVNodeHelper = Ol;
    Ae.hasDynamicKeyVBind = Hj;
    Ae.hasScopeRef = cr;
    Ae.helperNameMap = ur;
    Ae.injectProp = Of;
    Ae.isBuiltInType = Tf;
    Ae.isCoreComponent = aE;
    Ae.isFunctionType = DR;
    Ae.isInDestructureAssignment = fE;
    Ae.isMemberExpression = oE;
    Ae.isMemberExpressionBrowser = Vj;
    Ae.isMemberExpressionNode = cR;
    Ae.isReferencedIdentifier = AR;
    Ae.isSimpleIdentifier = Po;
    Ae.isSlotOutlet = Rf;
    Ae.isStaticArgOf = Ao;
    Ae.isStaticExp = ks;
    Ae.isStaticProperty = dE;
    Ae.isStaticPropertyKey = IR;
    Ae.isTemplateNode = du;
    Ae.isText = Vm;
    Ae.isVSlot = cE;
    Ae.locStub = rn;
    Ae.makeBlock = fg;
    Ae.noopDirectiveTransform = QX;
    Ae.processExpression = Pr;
    Ae.processFor = NR;
    Ae.processIf = OR;
    Ae.processSlotOutlet = $R;
    Ae.registerRuntimeHelpers = Dj;
    Ae.resolveComponentType = GR;
    Ae.toValidAssetId = kl;
    Ae.trackSlotScopes = kR;
    Ae.trackVForSlotScopes = FR;
    Ae.transform = bR;
    Ae.transformBind = qR;
    Ae.transformElement = VR;
    Ae.transformExpression = LR;
    Ae.transformModel = jR;
    Ae.transformOn = WR;
    Ae.traverseNode = Ff;
    Ae.walkBlockDeclarations = PR;
    Ae.walkFunctionParams = CR;
    Ae.walkIdentifiers = MR;
    Ae.warnDeprecation = qj;
  });
  var JR = jt((Rse, KR) => {
    "use strict";
    KR.exports = YR();
  });
  var aO = jt((sn) => {
    "use strict";
    Object.defineProperty(sn, "__esModule", { value: !0 });
    var Kt = JR(),
      hi = lo(),
      yE = Symbol(""),
      vE = Symbol(""),
      xE = Symbol(""),
      bE = Symbol(""),
      mg = Symbol(""),
      _E = Symbol(""),
      EE = Symbol(""),
      TE = Symbol(""),
      SE = Symbol(""),
      wE = Symbol("");
    Kt.registerRuntimeHelpers({
      [yE]: "vModelRadio",
      [vE]: "vModelCheckbox",
      [xE]: "vModelText",
      [bE]: "vModelSelect",
      [mg]: "vModelDynamic",
      [_E]: "withModifiers",
      [EE]: "withKeys",
      [TE]: "vShow",
      [SE]: "Transition",
      [wE]: "TransitionGroup",
    });
    var ZR = {
        GT: ">",
        gt: ">",
        LT: "<",
        lt: "<",
        "ac;": "\u223E",
        "af;": "\u2061",
        AMP: "&",
        amp: "&",
        "ap;": "\u2248",
        "DD;": "\u2145",
        "dd;": "\u2146",
        deg: "\xB0",
        "ee;": "\u2147",
        "eg;": "\u2A9A",
        "el;": "\u2A99",
        ETH: "\xD0",
        eth: "\xF0",
        "gE;": "\u2267",
        "ge;": "\u2265",
        "Gg;": "\u22D9",
        "gg;": "\u226B",
        "gl;": "\u2277",
        "GT;": ">",
        "Gt;": "\u226B",
        "gt;": ">",
        "ic;": "\u2063",
        "ii;": "\u2148",
        "Im;": "\u2111",
        "in;": "\u2208",
        "it;": "\u2062",
        "lE;": "\u2266",
        "le;": "\u2264",
        "lg;": "\u2276",
        "Ll;": "\u22D8",
        "ll;": "\u226A",
        "LT;": "<",
        "Lt;": "\u226A",
        "lt;": "<",
        "mp;": "\u2213",
        "Mu;": "\u039C",
        "mu;": "\u03BC",
        "ne;": "\u2260",
        "ni;": "\u220B",
        not: "\xAC",
        "Nu;": "\u039D",
        "nu;": "\u03BD",
        "Or;": "\u2A54",
        "or;": "\u2228",
        "oS;": "\u24C8",
        "Pi;": "\u03A0",
        "pi;": "\u03C0",
        "pm;": "\xB1",
        "Pr;": "\u2ABB",
        "pr;": "\u227A",
        "Re;": "\u211C",
        REG: "\xAE",
        reg: "\xAE",
        "rx;": "\u211E",
        "Sc;": "\u2ABC",
        "sc;": "\u227B",
        shy: "\xAD",
        uml: "\xA8",
        "wp;": "\u2118",
        "wr;": "\u2240",
        "Xi;": "\u039E",
        "xi;": "\u03BE",
        yen: "\xA5",
        "acd;": "\u223F",
        "acE;": "\u223E\u0333",
        "Acy;": "\u0410",
        "acy;": "\u0430",
        "Afr;": "\u{1D504}",
        "afr;": "\u{1D51E}",
        "AMP;": "&",
        "amp;": "&",
        "And;": "\u2A53",
        "and;": "\u2227",
        "ang;": "\u2220",
        "apE;": "\u2A70",
        "ape;": "\u224A",
        "ast;": "*",
        Auml: "\xC4",
        auml: "\xE4",
        "Bcy;": "\u0411",
        "bcy;": "\u0431",
        "Bfr;": "\u{1D505}",
        "bfr;": "\u{1D51F}",
        "bne;": "=\u20E5",
        "bot;": "\u22A5",
        "Cap;": "\u22D2",
        "cap;": "\u2229",
        cent: "\xA2",
        "Cfr;": "\u212D",
        "cfr;": "\u{1D520}",
        "Chi;": "\u03A7",
        "chi;": "\u03C7",
        "cir;": "\u25CB",
        COPY: "\xA9",
        copy: "\xA9",
        "Cup;": "\u22D3",
        "cup;": "\u222A",
        "Dcy;": "\u0414",
        "dcy;": "\u0434",
        "deg;": "\xB0",
        "Del;": "\u2207",
        "Dfr;": "\u{1D507}",
        "dfr;": "\u{1D521}",
        "die;": "\xA8",
        "div;": "\xF7",
        "Dot;": "\xA8",
        "dot;": "\u02D9",
        "Ecy;": "\u042D",
        "ecy;": "\u044D",
        "Efr;": "\u{1D508}",
        "efr;": "\u{1D522}",
        "egs;": "\u2A96",
        "ell;": "\u2113",
        "els;": "\u2A95",
        "ENG;": "\u014A",
        "eng;": "\u014B",
        "Eta;": "\u0397",
        "eta;": "\u03B7",
        "ETH;": "\xD0",
        "eth;": "\xF0",
        Euml: "\xCB",
        euml: "\xEB",
        "Fcy;": "\u0424",
        "fcy;": "\u0444",
        "Ffr;": "\u{1D509}",
        "ffr;": "\u{1D523}",
        "gap;": "\u2A86",
        "Gcy;": "\u0413",
        "gcy;": "\u0433",
        "gEl;": "\u2A8C",
        "gel;": "\u22DB",
        "geq;": "\u2265",
        "ges;": "\u2A7E",
        "Gfr;": "\u{1D50A}",
        "gfr;": "\u{1D524}",
        "ggg;": "\u22D9",
        "gla;": "\u2AA5",
        "glE;": "\u2A92",
        "glj;": "\u2AA4",
        "gnE;": "\u2269",
        "gne;": "\u2A88",
        "Hat;": "^",
        "Hfr;": "\u210C",
        "hfr;": "\u{1D525}",
        "Icy;": "\u0418",
        "icy;": "\u0438",
        "iff;": "\u21D4",
        "Ifr;": "\u2111",
        "ifr;": "\u{1D526}",
        "Int;": "\u222C",
        "int;": "\u222B",
        Iuml: "\xCF",
        iuml: "\xEF",
        "Jcy;": "\u0419",
        "jcy;": "\u0439",
        "Jfr;": "\u{1D50D}",
        "jfr;": "\u{1D527}",
        "Kcy;": "\u041A",
        "kcy;": "\u043A",
        "Kfr;": "\u{1D50E}",
        "kfr;": "\u{1D528}",
        "lap;": "\u2A85",
        "lat;": "\u2AAB",
        "Lcy;": "\u041B",
        "lcy;": "\u043B",
        "lEg;": "\u2A8B",
        "leg;": "\u22DA",
        "leq;": "\u2264",
        "les;": "\u2A7D",
        "Lfr;": "\u{1D50F}",
        "lfr;": "\u{1D529}",
        "lgE;": "\u2A91",
        "lnE;": "\u2268",
        "lne;": "\u2A87",
        "loz;": "\u25CA",
        "lrm;": "\u200E",
        "Lsh;": "\u21B0",
        "lsh;": "\u21B0",
        macr: "\xAF",
        "Map;": "\u2905",
        "map;": "\u21A6",
        "Mcy;": "\u041C",
        "mcy;": "\u043C",
        "Mfr;": "\u{1D510}",
        "mfr;": "\u{1D52A}",
        "mho;": "\u2127",
        "mid;": "\u2223",
        "nap;": "\u2249",
        nbsp: "\xA0",
        "Ncy;": "\u041D",
        "ncy;": "\u043D",
        "Nfr;": "\u{1D511}",
        "nfr;": "\u{1D52B}",
        "ngE;": "\u2267\u0338",
        "nge;": "\u2271",
        "nGg;": "\u22D9\u0338",
        "nGt;": "\u226B\u20D2",
        "ngt;": "\u226F",
        "nis;": "\u22FC",
        "niv;": "\u220B",
        "nlE;": "\u2266\u0338",
        "nle;": "\u2270",
        "nLl;": "\u22D8\u0338",
        "nLt;": "\u226A\u20D2",
        "nlt;": "\u226E",
        "Not;": "\u2AEC",
        "not;": "\xAC",
        "npr;": "\u2280",
        "nsc;": "\u2281",
        "num;": "#",
        "Ocy;": "\u041E",
        "ocy;": "\u043E",
        "Ofr;": "\u{1D512}",
        "ofr;": "\u{1D52C}",
        "ogt;": "\u29C1",
        "ohm;": "\u03A9",
        "olt;": "\u29C0",
        "ord;": "\u2A5D",
        ordf: "\xAA",
        ordm: "\xBA",
        "orv;": "\u2A5B",
        Ouml: "\xD6",
        ouml: "\xF6",
        "par;": "\u2225",
        para: "\xB6",
        "Pcy;": "\u041F",
        "pcy;": "\u043F",
        "Pfr;": "\u{1D513}",
        "pfr;": "\u{1D52D}",
        "Phi;": "\u03A6",
        "phi;": "\u03C6",
        "piv;": "\u03D6",
        "prE;": "\u2AB3",
        "pre;": "\u2AAF",
        "Psi;": "\u03A8",
        "psi;": "\u03C8",
        "Qfr;": "\u{1D514}",
        "qfr;": "\u{1D52E}",
        QUOT: '"',
        quot: '"',
        "Rcy;": "\u0420",
        "rcy;": "\u0440",
        "REG;": "\xAE",
        "reg;": "\xAE",
        "Rfr;": "\u211C",
        "rfr;": "\u{1D52F}",
        "Rho;": "\u03A1",
        "rho;": "\u03C1",
        "rlm;": "\u200F",
        "Rsh;": "\u21B1",
        "rsh;": "\u21B1",
        "scE;": "\u2AB4",
        "sce;": "\u2AB0",
        "Scy;": "\u0421",
        "scy;": "\u0441",
        sect: "\xA7",
        "Sfr;": "\u{1D516}",
        "sfr;": "\u{1D530}",
        "shy;": "\xAD",
        "sim;": "\u223C",
        "smt;": "\u2AAA",
        "sol;": "/",
        "squ;": "\u25A1",
        "Sub;": "\u22D0",
        "sub;": "\u2282",
        "Sum;": "\u2211",
        "sum;": "\u2211",
        "Sup;": "\u22D1",
        "sup;": "\u2283",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        "Tab;": "	",
        "Tau;": "\u03A4",
        "tau;": "\u03C4",
        "Tcy;": "\u0422",
        "tcy;": "\u0442",
        "Tfr;": "\u{1D517}",
        "tfr;": "\u{1D531}",
        "top;": "\u22A4",
        "Ucy;": "\u0423",
        "ucy;": "\u0443",
        "Ufr;": "\u{1D518}",
        "ufr;": "\u{1D532}",
        "uml;": "\xA8",
        Uuml: "\xDC",
        uuml: "\xFC",
        "Vcy;": "\u0412",
        "vcy;": "\u0432",
        "Vee;": "\u22C1",
        "vee;": "\u2228",
        "Vfr;": "\u{1D519}",
        "vfr;": "\u{1D533}",
        "Wfr;": "\u{1D51A}",
        "wfr;": "\u{1D534}",
        "Xfr;": "\u{1D51B}",
        "xfr;": "\u{1D535}",
        "Ycy;": "\u042B",
        "ycy;": "\u044B",
        "yen;": "\xA5",
        "Yfr;": "\u{1D51C}",
        "yfr;": "\u{1D536}",
        yuml: "\xFF",
        "Zcy;": "\u0417",
        "zcy;": "\u0437",
        "Zfr;": "\u2128",
        "zfr;": "\u{1D537}",
        "zwj;": "\u200D",
        Acirc: "\xC2",
        acirc: "\xE2",
        acute: "\xB4",
        AElig: "\xC6",
        aelig: "\xE6",
        "andd;": "\u2A5C",
        "andv;": "\u2A5A",
        "ange;": "\u29A4",
        "Aopf;": "\u{1D538}",
        "aopf;": "\u{1D552}",
        "apid;": "\u224B",
        "apos;": "'",
        Aring: "\xC5",
        aring: "\xE5",
        "Ascr;": "\u{1D49C}",
        "ascr;": "\u{1D4B6}",
        "Auml;": "\xC4",
        "auml;": "\xE4",
        "Barv;": "\u2AE7",
        "bbrk;": "\u23B5",
        "Beta;": "\u0392",
        "beta;": "\u03B2",
        "beth;": "\u2136",
        "bNot;": "\u2AED",
        "bnot;": "\u2310",
        "Bopf;": "\u{1D539}",
        "bopf;": "\u{1D553}",
        "boxH;": "\u2550",
        "boxh;": "\u2500",
        "boxV;": "\u2551",
        "boxv;": "\u2502",
        "Bscr;": "\u212C",
        "bscr;": "\u{1D4B7}",
        "bsim;": "\u223D",
        "bsol;": "\\",
        "bull;": "\u2022",
        "bump;": "\u224E",
        "caps;": "\u2229\uFE00",
        "Cdot;": "\u010A",
        "cdot;": "\u010B",
        cedil: "\xB8",
        "cent;": "\xA2",
        "CHcy;": "\u0427",
        "chcy;": "\u0447",
        "circ;": "\u02C6",
        "cirE;": "\u29C3",
        "cire;": "\u2257",
        "comp;": "\u2201",
        "cong;": "\u2245",
        "Copf;": "\u2102",
        "copf;": "\u{1D554}",
        "COPY;": "\xA9",
        "copy;": "\xA9",
        "Cscr;": "\u{1D49E}",
        "cscr;": "\u{1D4B8}",
        "csub;": "\u2ACF",
        "csup;": "\u2AD0",
        "cups;": "\u222A\uFE00",
        "Darr;": "\u21A1",
        "dArr;": "\u21D3",
        "darr;": "\u2193",
        "dash;": "\u2010",
        "dHar;": "\u2965",
        "diam;": "\u22C4",
        "DJcy;": "\u0402",
        "djcy;": "\u0452",
        "Dopf;": "\u{1D53B}",
        "dopf;": "\u{1D555}",
        "Dscr;": "\u{1D49F}",
        "dscr;": "\u{1D4B9}",
        "DScy;": "\u0405",
        "dscy;": "\u0455",
        "dsol;": "\u29F6",
        "dtri;": "\u25BF",
        "DZcy;": "\u040F",
        "dzcy;": "\u045F",
        "ecir;": "\u2256",
        Ecirc: "\xCA",
        ecirc: "\xEA",
        "Edot;": "\u0116",
        "eDot;": "\u2251",
        "edot;": "\u0117",
        "emsp;": "\u2003",
        "ensp;": "\u2002",
        "Eopf;": "\u{1D53C}",
        "eopf;": "\u{1D556}",
        "epar;": "\u22D5",
        "epsi;": "\u03B5",
        "Escr;": "\u2130",
        "escr;": "\u212F",
        "Esim;": "\u2A73",
        "esim;": "\u2242",
        "Euml;": "\xCB",
        "euml;": "\xEB",
        "euro;": "\u20AC",
        "excl;": "!",
        "flat;": "\u266D",
        "fnof;": "\u0192",
        "Fopf;": "\u{1D53D}",
        "fopf;": "\u{1D557}",
        "fork;": "\u22D4",
        "Fscr;": "\u2131",
        "fscr;": "\u{1D4BB}",
        "Gdot;": "\u0120",
        "gdot;": "\u0121",
        "geqq;": "\u2267",
        "gesl;": "\u22DB\uFE00",
        "GJcy;": "\u0403",
        "gjcy;": "\u0453",
        "gnap;": "\u2A8A",
        "gneq;": "\u2A88",
        "Gopf;": "\u{1D53E}",
        "gopf;": "\u{1D558}",
        "Gscr;": "\u{1D4A2}",
        "gscr;": "\u210A",
        "gsim;": "\u2273",
        "gtcc;": "\u2AA7",
        "gvnE;": "\u2269\uFE00",
        "half;": "\xBD",
        "hArr;": "\u21D4",
        "harr;": "\u2194",
        "hbar;": "\u210F",
        "Hopf;": "\u210D",
        "hopf;": "\u{1D559}",
        "Hscr;": "\u210B",
        "hscr;": "\u{1D4BD}",
        Icirc: "\xCE",
        icirc: "\xEE",
        "Idot;": "\u0130",
        "IEcy;": "\u0415",
        "iecy;": "\u0435",
        iexcl: "\xA1",
        "imof;": "\u22B7",
        "IOcy;": "\u0401",
        "iocy;": "\u0451",
        "Iopf;": "\u{1D540}",
        "iopf;": "\u{1D55A}",
        "Iota;": "\u0399",
        "iota;": "\u03B9",
        "Iscr;": "\u2110",
        "iscr;": "\u{1D4BE}",
        "isin;": "\u2208",
        "Iuml;": "\xCF",
        "iuml;": "\xEF",
        "Jopf;": "\u{1D541}",
        "jopf;": "\u{1D55B}",
        "Jscr;": "\u{1D4A5}",
        "jscr;": "\u{1D4BF}",
        "KHcy;": "\u0425",
        "khcy;": "\u0445",
        "KJcy;": "\u040C",
        "kjcy;": "\u045C",
        "Kopf;": "\u{1D542}",
        "kopf;": "\u{1D55C}",
        "Kscr;": "\u{1D4A6}",
        "kscr;": "\u{1D4C0}",
        "Lang;": "\u27EA",
        "lang;": "\u27E8",
        laquo: "\xAB",
        "Larr;": "\u219E",
        "lArr;": "\u21D0",
        "larr;": "\u2190",
        "late;": "\u2AAD",
        "lcub;": "{",
        "ldca;": "\u2936",
        "ldsh;": "\u21B2",
        "leqq;": "\u2266",
        "lesg;": "\u22DA\uFE00",
        "lHar;": "\u2962",
        "LJcy;": "\u0409",
        "ljcy;": "\u0459",
        "lnap;": "\u2A89",
        "lneq;": "\u2A87",
        "Lopf;": "\u{1D543}",
        "lopf;": "\u{1D55D}",
        "lozf;": "\u29EB",
        "lpar;": "(",
        "Lscr;": "\u2112",
        "lscr;": "\u{1D4C1}",
        "lsim;": "\u2272",
        "lsqb;": "[",
        "ltcc;": "\u2AA6",
        "ltri;": "\u25C3",
        "lvnE;": "\u2268\uFE00",
        "macr;": "\xAF",
        "male;": "\u2642",
        "malt;": "\u2720",
        micro: "\xB5",
        "mlcp;": "\u2ADB",
        "mldr;": "\u2026",
        "Mopf;": "\u{1D544}",
        "mopf;": "\u{1D55E}",
        "Mscr;": "\u2133",
        "mscr;": "\u{1D4C2}",
        "nang;": "\u2220\u20D2",
        "napE;": "\u2A70\u0338",
        "nbsp;": "\xA0",
        "ncap;": "\u2A43",
        "ncup;": "\u2A42",
        "ngeq;": "\u2271",
        "nges;": "\u2A7E\u0338",
        "ngtr;": "\u226F",
        "nGtv;": "\u226B\u0338",
        "nisd;": "\u22FA",
        "NJcy;": "\u040A",
        "njcy;": "\u045A",
        "nldr;": "\u2025",
        "nleq;": "\u2270",
        "nles;": "\u2A7D\u0338",
        "nLtv;": "\u226A\u0338",
        "nmid;": "\u2224",
        "Nopf;": "\u2115",
        "nopf;": "\u{1D55F}",
        "npar;": "\u2226",
        "npre;": "\u2AAF\u0338",
        "nsce;": "\u2AB0\u0338",
        "Nscr;": "\u{1D4A9}",
        "nscr;": "\u{1D4C3}",
        "nsim;": "\u2241",
        "nsub;": "\u2284",
        "nsup;": "\u2285",
        "ntgl;": "\u2279",
        "ntlg;": "\u2278",
        "nvap;": "\u224D\u20D2",
        "nvge;": "\u2265\u20D2",
        "nvgt;": ">\u20D2",
        "nvle;": "\u2264\u20D2",
        "nvlt;": "<\u20D2",
        "oast;": "\u229B",
        "ocir;": "\u229A",
        Ocirc: "\xD4",
        ocirc: "\xF4",
        "odiv;": "\u2A38",
        "odot;": "\u2299",
        "ogon;": "\u02DB",
        "oint;": "\u222E",
        "omid;": "\u29B6",
        "Oopf;": "\u{1D546}",
        "oopf;": "\u{1D560}",
        "opar;": "\u29B7",
        "ordf;": "\xAA",
        "ordm;": "\xBA",
        "oror;": "\u2A56",
        "Oscr;": "\u{1D4AA}",
        "oscr;": "\u2134",
        "osol;": "\u2298",
        "Ouml;": "\xD6",
        "ouml;": "\xF6",
        "para;": "\xB6",
        "part;": "\u2202",
        "perp;": "\u22A5",
        "phiv;": "\u03D5",
        "plus;": "+",
        "Popf;": "\u2119",
        "popf;": "\u{1D561}",
        pound: "\xA3",
        "prap;": "\u2AB7",
        "prec;": "\u227A",
        "prnE;": "\u2AB5",
        "prod;": "\u220F",
        "prop;": "\u221D",
        "Pscr;": "\u{1D4AB}",
        "pscr;": "\u{1D4C5}",
        "qint;": "\u2A0C",
        "Qopf;": "\u211A",
        "qopf;": "\u{1D562}",
        "Qscr;": "\u{1D4AC}",
        "qscr;": "\u{1D4C6}",
        "QUOT;": '"',
        "quot;": '"',
        "race;": "\u223D\u0331",
        "Rang;": "\u27EB",
        "rang;": "\u27E9",
        raquo: "\xBB",
        "Rarr;": "\u21A0",
        "rArr;": "\u21D2",
        "rarr;": "\u2192",
        "rcub;": "}",
        "rdca;": "\u2937",
        "rdsh;": "\u21B3",
        "real;": "\u211C",
        "rect;": "\u25AD",
        "rHar;": "\u2964",
        "rhov;": "\u03F1",
        "ring;": "\u02DA",
        "Ropf;": "\u211D",
        "ropf;": "\u{1D563}",
        "rpar;": ")",
        "Rscr;": "\u211B",
        "rscr;": "\u{1D4C7}",
        "rsqb;": "]",
        "rtri;": "\u25B9",
        "scap;": "\u2AB8",
        "scnE;": "\u2AB6",
        "sdot;": "\u22C5",
        "sect;": "\xA7",
        "semi;": ";",
        "sext;": "\u2736",
        "SHcy;": "\u0428",
        "shcy;": "\u0448",
        "sime;": "\u2243",
        "simg;": "\u2A9E",
        "siml;": "\u2A9D",
        "smid;": "\u2223",
        "smte;": "\u2AAC",
        "solb;": "\u29C4",
        "Sopf;": "\u{1D54A}",
        "sopf;": "\u{1D564}",
        "spar;": "\u2225",
        "Sqrt;": "\u221A",
        "squf;": "\u25AA",
        "Sscr;": "\u{1D4AE}",
        "sscr;": "\u{1D4C8}",
        "Star;": "\u22C6",
        "star;": "\u2606",
        "subE;": "\u2AC5",
        "sube;": "\u2286",
        "succ;": "\u227B",
        "sung;": "\u266A",
        "sup1;": "\xB9",
        "sup2;": "\xB2",
        "sup3;": "\xB3",
        "supE;": "\u2AC6",
        "supe;": "\u2287",
        szlig: "\xDF",
        "tbrk;": "\u23B4",
        "tdot;": "\u20DB",
        THORN: "\xDE",
        thorn: "\xFE",
        times: "\xD7",
        "tint;": "\u222D",
        "toea;": "\u2928",
        "Topf;": "\u{1D54B}",
        "topf;": "\u{1D565}",
        "tosa;": "\u2929",
        "trie;": "\u225C",
        "Tscr;": "\u{1D4AF}",
        "tscr;": "\u{1D4C9}",
        "TScy;": "\u0426",
        "tscy;": "\u0446",
        "Uarr;": "\u219F",
        "uArr;": "\u21D1",
        "uarr;": "\u2191",
        Ucirc: "\xDB",
        ucirc: "\xFB",
        "uHar;": "\u2963",
        "Uopf;": "\u{1D54C}",
        "uopf;": "\u{1D566}",
        "Upsi;": "\u03D2",
        "upsi;": "\u03C5",
        "Uscr;": "\u{1D4B0}",
        "uscr;": "\u{1D4CA}",
        "utri;": "\u25B5",
        "Uuml;": "\xDC",
        "uuml;": "\xFC",
        "vArr;": "\u21D5",
        "varr;": "\u2195",
        "Vbar;": "\u2AEB",
        "vBar;": "\u2AE8",
        "Vert;": "\u2016",
        "vert;": "|",
        "Vopf;": "\u{1D54D}",
        "vopf;": "\u{1D567}",
        "Vscr;": "\u{1D4B1}",
        "vscr;": "\u{1D4CB}",
        "Wopf;": "\u{1D54E}",
        "wopf;": "\u{1D568}",
        "Wscr;": "\u{1D4B2}",
        "wscr;": "\u{1D4CC}",
        "xcap;": "\u22C2",
        "xcup;": "\u22C3",
        "xmap;": "\u27FC",
        "xnis;": "\u22FB",
        "Xopf;": "\u{1D54F}",
        "xopf;": "\u{1D569}",
        "Xscr;": "\u{1D4B3}",
        "xscr;": "\u{1D4CD}",
        "xvee;": "\u22C1",
        "YAcy;": "\u042F",
        "yacy;": "\u044F",
        "YIcy;": "\u0407",
        "yicy;": "\u0457",
        "Yopf;": "\u{1D550}",
        "yopf;": "\u{1D56A}",
        "Yscr;": "\u{1D4B4}",
        "yscr;": "\u{1D4CE}",
        "YUcy;": "\u042E",
        "yucy;": "\u044E",
        "Yuml;": "\u0178",
        "yuml;": "\xFF",
        "Zdot;": "\u017B",
        "zdot;": "\u017C",
        "Zeta;": "\u0396",
        "zeta;": "\u03B6",
        "ZHcy;": "\u0416",
        "zhcy;": "\u0436",
        "Zopf;": "\u2124",
        "zopf;": "\u{1D56B}",
        "Zscr;": "\u{1D4B5}",
        "zscr;": "\u{1D4CF}",
        "zwnj;": "\u200C",
        Aacute: "\xC1",
        aacute: "\xE1",
        "Acirc;": "\xC2",
        "acirc;": "\xE2",
        "acute;": "\xB4",
        "AElig;": "\xC6",
        "aelig;": "\xE6",
        Agrave: "\xC0",
        agrave: "\xE0",
        "aleph;": "\u2135",
        "Alpha;": "\u0391",
        "alpha;": "\u03B1",
        "Amacr;": "\u0100",
        "amacr;": "\u0101",
        "amalg;": "\u2A3F",
        "angle;": "\u2220",
        "angrt;": "\u221F",
        "angst;": "\xC5",
        "Aogon;": "\u0104",
        "aogon;": "\u0105",
        "Aring;": "\xC5",
        "aring;": "\xE5",
        "asymp;": "\u2248",
        Atilde: "\xC3",
        atilde: "\xE3",
        "awint;": "\u2A11",
        "bcong;": "\u224C",
        "bdquo;": "\u201E",
        "bepsi;": "\u03F6",
        "blank;": "\u2423",
        "blk12;": "\u2592",
        "blk14;": "\u2591",
        "blk34;": "\u2593",
        "block;": "\u2588",
        "boxDL;": "\u2557",
        "boxDl;": "\u2556",
        "boxdL;": "\u2555",
        "boxdl;": "\u2510",
        "boxDR;": "\u2554",
        "boxDr;": "\u2553",
        "boxdR;": "\u2552",
        "boxdr;": "\u250C",
        "boxHD;": "\u2566",
        "boxHd;": "\u2564",
        "boxhD;": "\u2565",
        "boxhd;": "\u252C",
        "boxHU;": "\u2569",
        "boxHu;": "\u2567",
        "boxhU;": "\u2568",
        "boxhu;": "\u2534",
        "boxUL;": "\u255D",
        "boxUl;": "\u255C",
        "boxuL;": "\u255B",
        "boxul;": "\u2518",
        "boxUR;": "\u255A",
        "boxUr;": "\u2559",
        "boxuR;": "\u2558",
        "boxur;": "\u2514",
        "boxVH;": "\u256C",
        "boxVh;": "\u256B",
        "boxvH;": "\u256A",
        "boxvh;": "\u253C",
        "boxVL;": "\u2563",
        "boxVl;": "\u2562",
        "boxvL;": "\u2561",
        "boxvl;": "\u2524",
        "boxVR;": "\u2560",
        "boxVr;": "\u255F",
        "boxvR;": "\u255E",
        "boxvr;": "\u251C",
        "Breve;": "\u02D8",
        "breve;": "\u02D8",
        brvbar: "\xA6",
        "bsemi;": "\u204F",
        "bsime;": "\u22CD",
        "bsolb;": "\u29C5",
        "bumpE;": "\u2AAE",
        "bumpe;": "\u224F",
        "caret;": "\u2041",
        "caron;": "\u02C7",
        "ccaps;": "\u2A4D",
        Ccedil: "\xC7",
        ccedil: "\xE7",
        "Ccirc;": "\u0108",
        "ccirc;": "\u0109",
        "ccups;": "\u2A4C",
        "cedil;": "\xB8",
        "check;": "\u2713",
        "clubs;": "\u2663",
        "Colon;": "\u2237",
        "colon;": ":",
        "comma;": ",",
        "crarr;": "\u21B5",
        "Cross;": "\u2A2F",
        "cross;": "\u2717",
        "csube;": "\u2AD1",
        "csupe;": "\u2AD2",
        "ctdot;": "\u22EF",
        "cuepr;": "\u22DE",
        "cuesc;": "\u22DF",
        "cupor;": "\u2A45",
        curren: "\xA4",
        "cuvee;": "\u22CE",
        "cuwed;": "\u22CF",
        "cwint;": "\u2231",
        "Dashv;": "\u2AE4",
        "dashv;": "\u22A3",
        "dblac;": "\u02DD",
        "ddarr;": "\u21CA",
        "Delta;": "\u0394",
        "delta;": "\u03B4",
        "dharl;": "\u21C3",
        "dharr;": "\u21C2",
        "diams;": "\u2666",
        "disin;": "\u22F2",
        divide: "\xF7",
        "doteq;": "\u2250",
        "dtdot;": "\u22F1",
        "dtrif;": "\u25BE",
        "duarr;": "\u21F5",
        "duhar;": "\u296F",
        Eacute: "\xC9",
        eacute: "\xE9",
        "Ecirc;": "\xCA",
        "ecirc;": "\xEA",
        "eDDot;": "\u2A77",
        "efDot;": "\u2252",
        Egrave: "\xC8",
        egrave: "\xE8",
        "Emacr;": "\u0112",
        "emacr;": "\u0113",
        "empty;": "\u2205",
        "Eogon;": "\u0118",
        "eogon;": "\u0119",
        "eplus;": "\u2A71",
        "epsiv;": "\u03F5",
        "eqsim;": "\u2242",
        "Equal;": "\u2A75",
        "equiv;": "\u2261",
        "erarr;": "\u2971",
        "erDot;": "\u2253",
        "esdot;": "\u2250",
        "exist;": "\u2203",
        "fflig;": "\uFB00",
        "filig;": "\uFB01",
        "fjlig;": "fj",
        "fllig;": "\uFB02",
        "fltns;": "\u25B1",
        "forkv;": "\u2AD9",
        frac12: "\xBD",
        frac14: "\xBC",
        frac34: "\xBE",
        "frasl;": "\u2044",
        "frown;": "\u2322",
        "Gamma;": "\u0393",
        "gamma;": "\u03B3",
        "Gcirc;": "\u011C",
        "gcirc;": "\u011D",
        "gescc;": "\u2AA9",
        "gimel;": "\u2137",
        "gneqq;": "\u2269",
        "gnsim;": "\u22E7",
        "grave;": "`",
        "gsime;": "\u2A8E",
        "gsiml;": "\u2A90",
        "gtcir;": "\u2A7A",
        "gtdot;": "\u22D7",
        "Hacek;": "\u02C7",
        "harrw;": "\u21AD",
        "Hcirc;": "\u0124",
        "hcirc;": "\u0125",
        "hoarr;": "\u21FF",
        Iacute: "\xCD",
        iacute: "\xED",
        "Icirc;": "\xCE",
        "icirc;": "\xEE",
        "iexcl;": "\xA1",
        Igrave: "\xCC",
        igrave: "\xEC",
        "iiint;": "\u222D",
        "iiota;": "\u2129",
        "IJlig;": "\u0132",
        "ijlig;": "\u0133",
        "Imacr;": "\u012A",
        "imacr;": "\u012B",
        "image;": "\u2111",
        "imath;": "\u0131",
        "imped;": "\u01B5",
        "infin;": "\u221E",
        "Iogon;": "\u012E",
        "iogon;": "\u012F",
        "iprod;": "\u2A3C",
        iquest: "\xBF",
        "isinE;": "\u22F9",
        "isins;": "\u22F4",
        "isinv;": "\u2208",
        "Iukcy;": "\u0406",
        "iukcy;": "\u0456",
        "Jcirc;": "\u0134",
        "jcirc;": "\u0135",
        "jmath;": "\u0237",
        "Jukcy;": "\u0404",
        "jukcy;": "\u0454",
        "Kappa;": "\u039A",
        "kappa;": "\u03BA",
        "lAarr;": "\u21DA",
        "langd;": "\u2991",
        "laquo;": "\xAB",
        "larrb;": "\u21E4",
        "lates;": "\u2AAD\uFE00",
        "lBarr;": "\u290E",
        "lbarr;": "\u290C",
        "lbbrk;": "\u2772",
        "lbrke;": "\u298B",
        "lceil;": "\u2308",
        "ldquo;": "\u201C",
        "lescc;": "\u2AA8",
        "lhard;": "\u21BD",
        "lharu;": "\u21BC",
        "lhblk;": "\u2584",
        "llarr;": "\u21C7",
        "lltri;": "\u25FA",
        "lneqq;": "\u2268",
        "lnsim;": "\u22E6",
        "loang;": "\u27EC",
        "loarr;": "\u21FD",
        "lobrk;": "\u27E6",
        "lopar;": "\u2985",
        "lrarr;": "\u21C6",
        "lrhar;": "\u21CB",
        "lrtri;": "\u22BF",
        "lsime;": "\u2A8D",
        "lsimg;": "\u2A8F",
        "lsquo;": "\u2018",
        "ltcir;": "\u2A79",
        "ltdot;": "\u22D6",
        "ltrie;": "\u22B4",
        "ltrif;": "\u25C2",
        "mdash;": "\u2014",
        "mDDot;": "\u223A",
        "micro;": "\xB5",
        middot: "\xB7",
        "minus;": "\u2212",
        "mumap;": "\u22B8",
        "nabla;": "\u2207",
        "napid;": "\u224B\u0338",
        "napos;": "\u0149",
        "natur;": "\u266E",
        "nbump;": "\u224E\u0338",
        "ncong;": "\u2247",
        "ndash;": "\u2013",
        "neArr;": "\u21D7",
        "nearr;": "\u2197",
        "nedot;": "\u2250\u0338",
        "nesim;": "\u2242\u0338",
        "ngeqq;": "\u2267\u0338",
        "ngsim;": "\u2275",
        "nhArr;": "\u21CE",
        "nharr;": "\u21AE",
        "nhpar;": "\u2AF2",
        "nlArr;": "\u21CD",
        "nlarr;": "\u219A",
        "nleqq;": "\u2266\u0338",
        "nless;": "\u226E",
        "nlsim;": "\u2274",
        "nltri;": "\u22EA",
        "notin;": "\u2209",
        "notni;": "\u220C",
        "npart;": "\u2202\u0338",
        "nprec;": "\u2280",
        "nrArr;": "\u21CF",
        "nrarr;": "\u219B",
        "nrtri;": "\u22EB",
        "nsime;": "\u2244",
        "nsmid;": "\u2224",
        "nspar;": "\u2226",
        "nsubE;": "\u2AC5\u0338",
        "nsube;": "\u2288",
        "nsucc;": "\u2281",
        "nsupE;": "\u2AC6\u0338",
        "nsupe;": "\u2289",
        Ntilde: "\xD1",
        ntilde: "\xF1",
        "numsp;": "\u2007",
        "nvsim;": "\u223C\u20D2",
        "nwArr;": "\u21D6",
        "nwarr;": "\u2196",
        Oacute: "\xD3",
        oacute: "\xF3",
        "Ocirc;": "\xD4",
        "ocirc;": "\xF4",
        "odash;": "\u229D",
        "OElig;": "\u0152",
        "oelig;": "\u0153",
        "ofcir;": "\u29BF",
        Ograve: "\xD2",
        ograve: "\xF2",
        "ohbar;": "\u29B5",
        "olarr;": "\u21BA",
        "olcir;": "\u29BE",
        "oline;": "\u203E",
        "Omacr;": "\u014C",
        "omacr;": "\u014D",
        "Omega;": "\u03A9",
        "omega;": "\u03C9",
        "operp;": "\u29B9",
        "oplus;": "\u2295",
        "orarr;": "\u21BB",
        "order;": "\u2134",
        Oslash: "\xD8",
        oslash: "\xF8",
        Otilde: "\xD5",
        otilde: "\xF5",
        "ovbar;": "\u233D",
        "parsl;": "\u2AFD",
        "phone;": "\u260E",
        "plusb;": "\u229E",
        "pluse;": "\u2A72",
        plusmn: "\xB1",
        "pound;": "\xA3",
        "prcue;": "\u227C",
        "Prime;": "\u2033",
        "prime;": "\u2032",
        "prnap;": "\u2AB9",
        "prsim;": "\u227E",
        "quest;": "?",
        "rAarr;": "\u21DB",
        "radic;": "\u221A",
        "rangd;": "\u2992",
        "range;": "\u29A5",
        "raquo;": "\xBB",
        "rarrb;": "\u21E5",
        "rarrc;": "\u2933",
        "rarrw;": "\u219D",
        "ratio;": "\u2236",
        "RBarr;": "\u2910",
        "rBarr;": "\u290F",
        "rbarr;": "\u290D",
        "rbbrk;": "\u2773",
        "rbrke;": "\u298C",
        "rceil;": "\u2309",
        "rdquo;": "\u201D",
        "reals;": "\u211D",
        "rhard;": "\u21C1",
        "rharu;": "\u21C0",
        "rlarr;": "\u21C4",
        "rlhar;": "\u21CC",
        "rnmid;": "\u2AEE",
        "roang;": "\u27ED",
        "roarr;": "\u21FE",
        "robrk;": "\u27E7",
        "ropar;": "\u2986",
        "rrarr;": "\u21C9",
        "rsquo;": "\u2019",
        "rtrie;": "\u22B5",
        "rtrif;": "\u25B8",
        "sbquo;": "\u201A",
        "sccue;": "\u227D",
        "Scirc;": "\u015C",
        "scirc;": "\u015D",
        "scnap;": "\u2ABA",
        "scsim;": "\u227F",
        "sdotb;": "\u22A1",
        "sdote;": "\u2A66",
        "seArr;": "\u21D8",
        "searr;": "\u2198",
        "setmn;": "\u2216",
        "sharp;": "\u266F",
        "Sigma;": "\u03A3",
        "sigma;": "\u03C3",
        "simeq;": "\u2243",
        "simgE;": "\u2AA0",
        "simlE;": "\u2A9F",
        "simne;": "\u2246",
        "slarr;": "\u2190",
        "smile;": "\u2323",
        "smtes;": "\u2AAC\uFE00",
        "sqcap;": "\u2293",
        "sqcup;": "\u2294",
        "sqsub;": "\u228F",
        "sqsup;": "\u2290",
        "srarr;": "\u2192",
        "starf;": "\u2605",
        "strns;": "\xAF",
        "subnE;": "\u2ACB",
        "subne;": "\u228A",
        "supnE;": "\u2ACC",
        "supne;": "\u228B",
        "swArr;": "\u21D9",
        "swarr;": "\u2199",
        "szlig;": "\xDF",
        "Theta;": "\u0398",
        "theta;": "\u03B8",
        "thkap;": "\u2248",
        "THORN;": "\xDE",
        "thorn;": "\xFE",
        "Tilde;": "\u223C",
        "tilde;": "\u02DC",
        "times;": "\xD7",
        "TRADE;": "\u2122",
        "trade;": "\u2122",
        "trisb;": "\u29CD",
        "TSHcy;": "\u040B",
        "tshcy;": "\u045B",
        "twixt;": "\u226C",
        Uacute: "\xDA",
        uacute: "\xFA",
        "Ubrcy;": "\u040E",
        "ubrcy;": "\u045E",
        "Ucirc;": "\xDB",
        "ucirc;": "\xFB",
        "udarr;": "\u21C5",
        "udhar;": "\u296E",
        Ugrave: "\xD9",
        ugrave: "\xF9",
        "uharl;": "\u21BF",
        "uharr;": "\u21BE",
        "uhblk;": "\u2580",
        "ultri;": "\u25F8",
        "Umacr;": "\u016A",
        "umacr;": "\u016B",
        "Union;": "\u22C3",
        "Uogon;": "\u0172",
        "uogon;": "\u0173",
        "uplus;": "\u228E",
        "upsih;": "\u03D2",
        "UpTee;": "\u22A5",
        "Uring;": "\u016E",
        "uring;": "\u016F",
        "urtri;": "\u25F9",
        "utdot;": "\u22F0",
        "utrif;": "\u25B4",
        "uuarr;": "\u21C8",
        "varpi;": "\u03D6",
        "vBarv;": "\u2AE9",
        "VDash;": "\u22AB",
        "Vdash;": "\u22A9",
        "vDash;": "\u22A8",
        "vdash;": "\u22A2",
        "veeeq;": "\u225A",
        "vltri;": "\u22B2",
        "vnsub;": "\u2282\u20D2",
        "vnsup;": "\u2283\u20D2",
        "vprop;": "\u221D",
        "vrtri;": "\u22B3",
        "Wcirc;": "\u0174",
        "wcirc;": "\u0175",
        "Wedge;": "\u22C0",
        "wedge;": "\u2227",
        "xcirc;": "\u25EF",
        "xdtri;": "\u25BD",
        "xhArr;": "\u27FA",
        "xharr;": "\u27F7",
        "xlArr;": "\u27F8",
        "xlarr;": "\u27F5",
        "xodot;": "\u2A00",
        "xrArr;": "\u27F9",
        "xrarr;": "\u27F6",
        "xutri;": "\u25B3",
        Yacute: "\xDD",
        yacute: "\xFD",
        "Ycirc;": "\u0176",
        "ycirc;": "\u0177",
        "Aacute;": "\xC1",
        "aacute;": "\xE1",
        "Abreve;": "\u0102",
        "abreve;": "\u0103",
        "Agrave;": "\xC0",
        "agrave;": "\xE0",
        "andand;": "\u2A55",
        "angmsd;": "\u2221",
        "angsph;": "\u2222",
        "apacir;": "\u2A6F",
        "approx;": "\u2248",
        "Assign;": "\u2254",
        "Atilde;": "\xC3",
        "atilde;": "\xE3",
        "barvee;": "\u22BD",
        "Barwed;": "\u2306",
        "barwed;": "\u2305",
        "becaus;": "\u2235",
        "bernou;": "\u212C",
        "bigcap;": "\u22C2",
        "bigcup;": "\u22C3",
        "bigvee;": "\u22C1",
        "bkarow;": "\u290D",
        "bottom;": "\u22A5",
        "bowtie;": "\u22C8",
        "boxbox;": "\u29C9",
        "bprime;": "\u2035",
        "brvbar;": "\xA6",
        "bullet;": "\u2022",
        "Bumpeq;": "\u224E",
        "bumpeq;": "\u224F",
        "Cacute;": "\u0106",
        "cacute;": "\u0107",
        "capand;": "\u2A44",
        "capcap;": "\u2A4B",
        "capcup;": "\u2A47",
        "capdot;": "\u2A40",
        "Ccaron;": "\u010C",
        "ccaron;": "\u010D",
        "Ccedil;": "\xC7",
        "ccedil;": "\xE7",
        "circeq;": "\u2257",
        "cirmid;": "\u2AEF",
        "Colone;": "\u2A74",
        "colone;": "\u2254",
        "commat;": "@",
        "compfn;": "\u2218",
        "Conint;": "\u222F",
        "conint;": "\u222E",
        "coprod;": "\u2210",
        "copysr;": "\u2117",
        "cularr;": "\u21B6",
        "CupCap;": "\u224D",
        "cupcap;": "\u2A46",
        "cupcup;": "\u2A4A",
        "cupdot;": "\u228D",
        "curarr;": "\u21B7",
        "curren;": "\xA4",
        "cylcty;": "\u232D",
        "Dagger;": "\u2021",
        "dagger;": "\u2020",
        "daleth;": "\u2138",
        "Dcaron;": "\u010E",
        "dcaron;": "\u010F",
        "dfisht;": "\u297F",
        "divide;": "\xF7",
        "divonx;": "\u22C7",
        "dlcorn;": "\u231E",
        "dlcrop;": "\u230D",
        "dollar;": "$",
        "DotDot;": "\u20DC",
        "drcorn;": "\u231F",
        "drcrop;": "\u230C",
        "Dstrok;": "\u0110",
        "dstrok;": "\u0111",
        "Eacute;": "\xC9",
        "eacute;": "\xE9",
        "easter;": "\u2A6E",
        "Ecaron;": "\u011A",
        "ecaron;": "\u011B",
        "ecolon;": "\u2255",
        "Egrave;": "\xC8",
        "egrave;": "\xE8",
        "egsdot;": "\u2A98",
        "elsdot;": "\u2A97",
        "emptyv;": "\u2205",
        "emsp13;": "\u2004",
        "emsp14;": "\u2005",
        "eparsl;": "\u29E3",
        "eqcirc;": "\u2256",
        "equals;": "=",
        "equest;": "\u225F",
        "Exists;": "\u2203",
        "female;": "\u2640",
        "ffilig;": "\uFB03",
        "ffllig;": "\uFB04",
        "ForAll;": "\u2200",
        "forall;": "\u2200",
        "frac12;": "\xBD",
        "frac13;": "\u2153",
        "frac14;": "\xBC",
        "frac15;": "\u2155",
        "frac16;": "\u2159",
        "frac18;": "\u215B",
        "frac23;": "\u2154",
        "frac25;": "\u2156",
        "frac34;": "\xBE",
        "frac35;": "\u2157",
        "frac38;": "\u215C",
        "frac45;": "\u2158",
        "frac56;": "\u215A",
        "frac58;": "\u215D",
        "frac78;": "\u215E",
        "gacute;": "\u01F5",
        "Gammad;": "\u03DC",
        "gammad;": "\u03DD",
        "Gbreve;": "\u011E",
        "gbreve;": "\u011F",
        "Gcedil;": "\u0122",
        "gesdot;": "\u2A80",
        "gesles;": "\u2A94",
        "gtlPar;": "\u2995",
        "gtrarr;": "\u2978",
        "gtrdot;": "\u22D7",
        "gtrsim;": "\u2273",
        "hairsp;": "\u200A",
        "hamilt;": "\u210B",
        "HARDcy;": "\u042A",
        "hardcy;": "\u044A",
        "hearts;": "\u2665",
        "hellip;": "\u2026",
        "hercon;": "\u22B9",
        "homtht;": "\u223B",
        "horbar;": "\u2015",
        "hslash;": "\u210F",
        "Hstrok;": "\u0126",
        "hstrok;": "\u0127",
        "hybull;": "\u2043",
        "hyphen;": "\u2010",
        "Iacute;": "\xCD",
        "iacute;": "\xED",
        "Igrave;": "\xCC",
        "igrave;": "\xEC",
        "iiiint;": "\u2A0C",
        "iinfin;": "\u29DC",
        "incare;": "\u2105",
        "inodot;": "\u0131",
        "intcal;": "\u22BA",
        "iquest;": "\xBF",
        "isinsv;": "\u22F3",
        "Itilde;": "\u0128",
        "itilde;": "\u0129",
        "Jsercy;": "\u0408",
        "jsercy;": "\u0458",
        "kappav;": "\u03F0",
        "Kcedil;": "\u0136",
        "kcedil;": "\u0137",
        "kgreen;": "\u0138",
        "Lacute;": "\u0139",
        "lacute;": "\u013A",
        "lagran;": "\u2112",
        "Lambda;": "\u039B",
        "lambda;": "\u03BB",
        "langle;": "\u27E8",
        "larrfs;": "\u291D",
        "larrhk;": "\u21A9",
        "larrlp;": "\u21AB",
        "larrpl;": "\u2939",
        "larrtl;": "\u21A2",
        "lAtail;": "\u291B",
        "latail;": "\u2919",
        "lbrace;": "{",
        "lbrack;": "[",
        "Lcaron;": "\u013D",
        "lcaron;": "\u013E",
        "Lcedil;": "\u013B",
        "lcedil;": "\u013C",
        "ldquor;": "\u201E",
        "lesdot;": "\u2A7F",
        "lesges;": "\u2A93",
        "lfisht;": "\u297C",
        "lfloor;": "\u230A",
        "lharul;": "\u296A",
        "llhard;": "\u296B",
        "Lmidot;": "\u013F",
        "lmidot;": "\u0140",
        "lmoust;": "\u23B0",
        "loplus;": "\u2A2D",
        "lowast;": "\u2217",
        "lowbar;": "_",
        "lparlt;": "\u2993",
        "lrhard;": "\u296D",
        "lsaquo;": "\u2039",
        "lsquor;": "\u201A",
        "Lstrok;": "\u0141",
        "lstrok;": "\u0142",
        "lthree;": "\u22CB",
        "ltimes;": "\u22C9",
        "ltlarr;": "\u2976",
        "ltrPar;": "\u2996",
        "mapsto;": "\u21A6",
        "marker;": "\u25AE",
        "mcomma;": "\u2A29",
        "midast;": "*",
        "midcir;": "\u2AF0",
        "middot;": "\xB7",
        "minusb;": "\u229F",
        "minusd;": "\u2238",
        "mnplus;": "\u2213",
        "models;": "\u22A7",
        "mstpos;": "\u223E",
        "Nacute;": "\u0143",
        "nacute;": "\u0144",
        "nbumpe;": "\u224F\u0338",
        "Ncaron;": "\u0147",
        "ncaron;": "\u0148",
        "Ncedil;": "\u0145",
        "ncedil;": "\u0146",
        "nearhk;": "\u2924",
        "nequiv;": "\u2262",
        "nesear;": "\u2928",
        "nexist;": "\u2204",
        "nltrie;": "\u22EC",
        "notinE;": "\u22F9\u0338",
        "nparsl;": "\u2AFD\u20E5",
        "nprcue;": "\u22E0",
        "nrarrc;": "\u2933\u0338",
        "nrarrw;": "\u219D\u0338",
        "nrtrie;": "\u22ED",
        "nsccue;": "\u22E1",
        "nsimeq;": "\u2244",
        "Ntilde;": "\xD1",
        "ntilde;": "\xF1",
        "numero;": "\u2116",
        "nVDash;": "\u22AF",
        "nVdash;": "\u22AE",
        "nvDash;": "\u22AD",
        "nvdash;": "\u22AC",
        "nvHarr;": "\u2904",
        "nvlArr;": "\u2902",
        "nvrArr;": "\u2903",
        "nwarhk;": "\u2923",
        "nwnear;": "\u2927",
        "Oacute;": "\xD3",
        "oacute;": "\xF3",
        "Odblac;": "\u0150",
        "odblac;": "\u0151",
        "odsold;": "\u29BC",
        "Ograve;": "\xD2",
        "ograve;": "\xF2",
        "ominus;": "\u2296",
        "origof;": "\u22B6",
        "Oslash;": "\xD8",
        "oslash;": "\xF8",
        "Otilde;": "\xD5",
        "otilde;": "\xF5",
        "Otimes;": "\u2A37",
        "otimes;": "\u2297",
        "parsim;": "\u2AF3",
        "percnt;": "%",
        "period;": ".",
        "permil;": "\u2030",
        "phmmat;": "\u2133",
        "planck;": "\u210F",
        "plankv;": "\u210F",
        "plusdo;": "\u2214",
        "plusdu;": "\u2A25",
        "plusmn;": "\xB1",
        "preceq;": "\u2AAF",
        "primes;": "\u2119",
        "prnsim;": "\u22E8",
        "propto;": "\u221D",
        "prurel;": "\u22B0",
        "puncsp;": "\u2008",
        "qprime;": "\u2057",
        "Racute;": "\u0154",
        "racute;": "\u0155",
        "rangle;": "\u27E9",
        "rarrap;": "\u2975",
        "rarrfs;": "\u291E",
        "rarrhk;": "\u21AA",
        "rarrlp;": "\u21AC",
        "rarrpl;": "\u2945",
        "Rarrtl;": "\u2916",
        "rarrtl;": "\u21A3",
        "rAtail;": "\u291C",
        "ratail;": "\u291A",
        "rbrace;": "}",
        "rbrack;": "]",
        "Rcaron;": "\u0158",
        "rcaron;": "\u0159",
        "Rcedil;": "\u0156",
        "rcedil;": "\u0157",
        "rdquor;": "\u201D",
        "rfisht;": "\u297D",
        "rfloor;": "\u230B",
        "rharul;": "\u296C",
        "rmoust;": "\u23B1",
        "roplus;": "\u2A2E",
        "rpargt;": "\u2994",
        "rsaquo;": "\u203A",
        "rsquor;": "\u2019",
        "rthree;": "\u22CC",
        "rtimes;": "\u22CA",
        "Sacute;": "\u015A",
        "sacute;": "\u015B",
        "Scaron;": "\u0160",
        "scaron;": "\u0161",
        "Scedil;": "\u015E",
        "scedil;": "\u015F",
        "scnsim;": "\u22E9",
        "searhk;": "\u2925",
        "seswar;": "\u2929",
        "sfrown;": "\u2322",
        "SHCHcy;": "\u0429",
        "shchcy;": "\u0449",
        "sigmaf;": "\u03C2",
        "sigmav;": "\u03C2",
        "simdot;": "\u2A6A",
        "smashp;": "\u2A33",
        "SOFTcy;": "\u042C",
        "softcy;": "\u044C",
        "solbar;": "\u233F",
        "spades;": "\u2660",
        "sqcaps;": "\u2293\uFE00",
        "sqcups;": "\u2294\uFE00",
        "sqsube;": "\u2291",
        "sqsupe;": "\u2292",
        "Square;": "\u25A1",
        "square;": "\u25A1",
        "squarf;": "\u25AA",
        "ssetmn;": "\u2216",
        "ssmile;": "\u2323",
        "sstarf;": "\u22C6",
        "subdot;": "\u2ABD",
        "Subset;": "\u22D0",
        "subset;": "\u2282",
        "subsim;": "\u2AC7",
        "subsub;": "\u2AD5",
        "subsup;": "\u2AD3",
        "succeq;": "\u2AB0",
        "supdot;": "\u2ABE",
        "Supset;": "\u22D1",
        "supset;": "\u2283",
        "supsim;": "\u2AC8",
        "supsub;": "\u2AD4",
        "supsup;": "\u2AD6",
        "swarhk;": "\u2926",
        "swnwar;": "\u292A",
        "target;": "\u2316",
        "Tcaron;": "\u0164",
        "tcaron;": "\u0165",
        "Tcedil;": "\u0162",
        "tcedil;": "\u0163",
        "telrec;": "\u2315",
        "there4;": "\u2234",
        "thetav;": "\u03D1",
        "thinsp;": "\u2009",
        "thksim;": "\u223C",
        "timesb;": "\u22A0",
        "timesd;": "\u2A30",
        "topbot;": "\u2336",
        "topcir;": "\u2AF1",
        "tprime;": "\u2034",
        "tridot;": "\u25EC",
        "Tstrok;": "\u0166",
        "tstrok;": "\u0167",
        "Uacute;": "\xDA",
        "uacute;": "\xFA",
        "Ubreve;": "\u016C",
        "ubreve;": "\u016D",
        "Udblac;": "\u0170",
        "udblac;": "\u0171",
        "ufisht;": "\u297E",
        "Ugrave;": "\xD9",
        "ugrave;": "\xF9",
        "ulcorn;": "\u231C",
        "ulcrop;": "\u230F",
        "urcorn;": "\u231D",
        "urcrop;": "\u230E",
        "Utilde;": "\u0168",
        "utilde;": "\u0169",
        "vangrt;": "\u299C",
        "varphi;": "\u03D5",
        "varrho;": "\u03F1",
        "Vdashl;": "\u2AE6",
        "veebar;": "\u22BB",
        "vellip;": "\u22EE",
        "Verbar;": "\u2016",
        "verbar;": "|",
        "vsubnE;": "\u2ACB\uFE00",
        "vsubne;": "\u228A\uFE00",
        "vsupnE;": "\u2ACC\uFE00",
        "vsupne;": "\u228B\uFE00",
        "Vvdash;": "\u22AA",
        "wedbar;": "\u2A5F",
        "wedgeq;": "\u2259",
        "weierp;": "\u2118",
        "wreath;": "\u2240",
        "xoplus;": "\u2A01",
        "xotime;": "\u2A02",
        "xsqcup;": "\u2A06",
        "xuplus;": "\u2A04",
        "xwedge;": "\u22C0",
        "Yacute;": "\xDD",
        "yacute;": "\xFD",
        "Zacute;": "\u0179",
        "zacute;": "\u017A",
        "Zcaron;": "\u017D",
        "zcaron;": "\u017E",
        "zeetrf;": "\u2128",
        "alefsym;": "\u2135",
        "angrtvb;": "\u22BE",
        "angzarr;": "\u237C",
        "asympeq;": "\u224D",
        "backsim;": "\u223D",
        "Because;": "\u2235",
        "because;": "\u2235",
        "bemptyv;": "\u29B0",
        "between;": "\u226C",
        "bigcirc;": "\u25EF",
        "bigodot;": "\u2A00",
        "bigstar;": "\u2605",
        "bnequiv;": "\u2261\u20E5",
        "boxplus;": "\u229E",
        "Cayleys;": "\u212D",
        "Cconint;": "\u2230",
        "ccupssm;": "\u2A50",
        "Cedilla;": "\xB8",
        "cemptyv;": "\u29B2",
        "cirscir;": "\u29C2",
        "coloneq;": "\u2254",
        "congdot;": "\u2A6D",
        "cudarrl;": "\u2938",
        "cudarrr;": "\u2935",
        "cularrp;": "\u293D",
        "curarrm;": "\u293C",
        "dbkarow;": "\u290F",
        "ddagger;": "\u2021",
        "ddotseq;": "\u2A77",
        "demptyv;": "\u29B1",
        "Diamond;": "\u22C4",
        "diamond;": "\u22C4",
        "digamma;": "\u03DD",
        "dotplus;": "\u2214",
        "DownTee;": "\u22A4",
        "dwangle;": "\u29A6",
        "Element;": "\u2208",
        "Epsilon;": "\u0395",
        "epsilon;": "\u03B5",
        "eqcolon;": "\u2255",
        "equivDD;": "\u2A78",
        "gesdoto;": "\u2A82",
        "gtquest;": "\u2A7C",
        "gtrless;": "\u2277",
        "harrcir;": "\u2948",
        "Implies;": "\u21D2",
        "intprod;": "\u2A3C",
        "isindot;": "\u22F5",
        "larrbfs;": "\u291F",
        "larrsim;": "\u2973",
        "lbrksld;": "\u298F",
        "lbrkslu;": "\u298D",
        "ldrdhar;": "\u2967",
        "LeftTee;": "\u22A3",
        "lesdoto;": "\u2A81",
        "lessdot;": "\u22D6",
        "lessgtr;": "\u2276",
        "lesssim;": "\u2272",
        "lotimes;": "\u2A34",
        "lozenge;": "\u25CA",
        "ltquest;": "\u2A7B",
        "luruhar;": "\u2966",
        "maltese;": "\u2720",
        "minusdu;": "\u2A2A",
        "napprox;": "\u2249",
        "natural;": "\u266E",
        "nearrow;": "\u2197",
        "NewLine;": `
`,
        "nexists;": "\u2204",
        "NoBreak;": "\u2060",
        "notinva;": "\u2209",
        "notinvb;": "\u22F7",
        "notinvc;": "\u22F6",
        "NotLess;": "\u226E",
        "notniva;": "\u220C",
        "notnivb;": "\u22FE",
        "notnivc;": "\u22FD",
        "npolint;": "\u2A14",
        "npreceq;": "\u2AAF\u0338",
        "nsqsube;": "\u22E2",
        "nsqsupe;": "\u22E3",
        "nsubset;": "\u2282\u20D2",
        "nsucceq;": "\u2AB0\u0338",
        "nsupset;": "\u2283\u20D2",
        "nvinfin;": "\u29DE",
        "nvltrie;": "\u22B4\u20D2",
        "nvrtrie;": "\u22B5\u20D2",
        "nwarrow;": "\u2196",
        "olcross;": "\u29BB",
        "Omicron;": "\u039F",
        "omicron;": "\u03BF",
        "orderof;": "\u2134",
        "orslope;": "\u2A57",
        "OverBar;": "\u203E",
        "pertenk;": "\u2031",
        "planckh;": "\u210E",
        "pluscir;": "\u2A22",
        "plussim;": "\u2A26",
        "plustwo;": "\u2A27",
        "precsim;": "\u227E",
        "Product;": "\u220F",
        "quatint;": "\u2A16",
        "questeq;": "\u225F",
        "rarrbfs;": "\u2920",
        "rarrsim;": "\u2974",
        "rbrksld;": "\u298E",
        "rbrkslu;": "\u2990",
        "rdldhar;": "\u2969",
        "realine;": "\u211B",
        "rotimes;": "\u2A35",
        "ruluhar;": "\u2968",
        "searrow;": "\u2198",
        "simplus;": "\u2A24",
        "simrarr;": "\u2972",
        "subedot;": "\u2AC3",
        "submult;": "\u2AC1",
        "subplus;": "\u2ABF",
        "subrarr;": "\u2979",
        "succsim;": "\u227F",
        "supdsub;": "\u2AD8",
        "supedot;": "\u2AC4",
        "suphsol;": "\u27C9",
        "suphsub;": "\u2AD7",
        "suplarr;": "\u297B",
        "supmult;": "\u2AC2",
        "supplus;": "\u2AC0",
        "swarrow;": "\u2199",
        "topfork;": "\u2ADA",
        "triplus;": "\u2A39",
        "tritime;": "\u2A3B",
        "UpArrow;": "\u2191",
        "Uparrow;": "\u21D1",
        "uparrow;": "\u2191",
        "Upsilon;": "\u03A5",
        "upsilon;": "\u03C5",
        "uwangle;": "\u29A7",
        "vzigzag;": "\u299A",
        "zigrarr;": "\u21DD",
        "andslope;": "\u2A58",
        "angmsdaa;": "\u29A8",
        "angmsdab;": "\u29A9",
        "angmsdac;": "\u29AA",
        "angmsdad;": "\u29AB",
        "angmsdae;": "\u29AC",
        "angmsdaf;": "\u29AD",
        "angmsdag;": "\u29AE",
        "angmsdah;": "\u29AF",
        "angrtvbd;": "\u299D",
        "approxeq;": "\u224A",
        "awconint;": "\u2233",
        "backcong;": "\u224C",
        "barwedge;": "\u2305",
        "bbrktbrk;": "\u23B6",
        "bigoplus;": "\u2A01",
        "bigsqcup;": "\u2A06",
        "biguplus;": "\u2A04",
        "bigwedge;": "\u22C0",
        "boxminus;": "\u229F",
        "boxtimes;": "\u22A0",
        "bsolhsub;": "\u27C8",
        "capbrcup;": "\u2A49",
        "circledR;": "\xAE",
        "circledS;": "\u24C8",
        "cirfnint;": "\u2A10",
        "clubsuit;": "\u2663",
        "cupbrcap;": "\u2A48",
        "curlyvee;": "\u22CE",
        "cwconint;": "\u2232",
        "DDotrahd;": "\u2911",
        "doteqdot;": "\u2251",
        "DotEqual;": "\u2250",
        "dotminus;": "\u2238",
        "drbkarow;": "\u2910",
        "dzigrarr;": "\u27FF",
        "elinters;": "\u23E7",
        "emptyset;": "\u2205",
        "eqvparsl;": "\u29E5",
        "fpartint;": "\u2A0D",
        "geqslant;": "\u2A7E",
        "gesdotol;": "\u2A84",
        "gnapprox;": "\u2A8A",
        "hksearow;": "\u2925",
        "hkswarow;": "\u2926",
        "imagline;": "\u2110",
        "imagpart;": "\u2111",
        "infintie;": "\u29DD",
        "integers;": "\u2124",
        "Integral;": "\u222B",
        "intercal;": "\u22BA",
        "intlarhk;": "\u2A17",
        "laemptyv;": "\u29B4",
        "ldrushar;": "\u294B",
        "leqslant;": "\u2A7D",
        "lesdotor;": "\u2A83",
        "LessLess;": "\u2AA1",
        "llcorner;": "\u231E",
        "lnapprox;": "\u2A89",
        "lrcorner;": "\u231F",
        "lurdshar;": "\u294A",
        "mapstoup;": "\u21A5",
        "multimap;": "\u22B8",
        "naturals;": "\u2115",
        "ncongdot;": "\u2A6D\u0338",
        "NotEqual;": "\u2260",
        "notindot;": "\u22F5\u0338",
        "NotTilde;": "\u2241",
        "otimesas;": "\u2A36",
        "parallel;": "\u2225",
        "PartialD;": "\u2202",
        "plusacir;": "\u2A23",
        "pointint;": "\u2A15",
        "Precedes;": "\u227A",
        "precneqq;": "\u2AB5",
        "precnsim;": "\u22E8",
        "profalar;": "\u232E",
        "profline;": "\u2312",
        "profsurf;": "\u2313",
        "raemptyv;": "\u29B3",
        "realpart;": "\u211C",
        "RightTee;": "\u22A2",
        "rppolint;": "\u2A12",
        "rtriltri;": "\u29CE",
        "scpolint;": "\u2A13",
        "setminus;": "\u2216",
        "shortmid;": "\u2223",
        "smeparsl;": "\u29E4",
        "sqsubset;": "\u228F",
        "sqsupset;": "\u2290",
        "subseteq;": "\u2286",
        "Succeeds;": "\u227B",
        "succneqq;": "\u2AB6",
        "succnsim;": "\u22E9",
        "SuchThat;": "\u220B",
        "Superset;": "\u2283",
        "supseteq;": "\u2287",
        "thetasym;": "\u03D1",
        "thicksim;": "\u223C",
        "timesbar;": "\u2A31",
        "triangle;": "\u25B5",
        "triminus;": "\u2A3A",
        "trpezium;": "\u23E2",
        "Uarrocir;": "\u2949",
        "ulcorner;": "\u231C",
        "UnderBar;": "_",
        "urcorner;": "\u231D",
        "varkappa;": "\u03F0",
        "varsigma;": "\u03C2",
        "vartheta;": "\u03D1",
        "backprime;": "\u2035",
        "backsimeq;": "\u22CD",
        "Backslash;": "\u2216",
        "bigotimes;": "\u2A02",
        "CenterDot;": "\xB7",
        "centerdot;": "\xB7",
        "checkmark;": "\u2713",
        "CircleDot;": "\u2299",
        "complexes;": "\u2102",
        "Congruent;": "\u2261",
        "Coproduct;": "\u2210",
        "dotsquare;": "\u22A1",
        "DoubleDot;": "\xA8",
        "DownArrow;": "\u2193",
        "Downarrow;": "\u21D3",
        "downarrow;": "\u2193",
        "DownBreve;": "\u0311",
        "gtrapprox;": "\u2A86",
        "gtreqless;": "\u22DB",
        "gvertneqq;": "\u2269\uFE00",
        "heartsuit;": "\u2665",
        "HumpEqual;": "\u224F",
        "LeftArrow;": "\u2190",
        "Leftarrow;": "\u21D0",
        "leftarrow;": "\u2190",
        "LeftFloor;": "\u230A",
        "lesseqgtr;": "\u22DA",
        "LessTilde;": "\u2272",
        "lvertneqq;": "\u2268\uFE00",
        "Mellintrf;": "\u2133",
        "MinusPlus;": "\u2213",
        "ngeqslant;": "\u2A7E\u0338",
        "nleqslant;": "\u2A7D\u0338",
        "NotCupCap;": "\u226D",
        "NotExists;": "\u2204",
        "NotSubset;": "\u2282\u20D2",
        "nparallel;": "\u2226",
        "nshortmid;": "\u2224",
        "nsubseteq;": "\u2288",
        "nsupseteq;": "\u2289",
        "OverBrace;": "\u23DE",
        "pitchfork;": "\u22D4",
        "PlusMinus;": "\xB1",
        "rationals;": "\u211A",
        "spadesuit;": "\u2660",
        "subseteqq;": "\u2AC5",
        "subsetneq;": "\u228A",
        "supseteqq;": "\u2AC6",
        "supsetneq;": "\u228B",
        "Therefore;": "\u2234",
        "therefore;": "\u2234",
        "ThinSpace;": "\u2009",
        "triangleq;": "\u225C",
        "TripleDot;": "\u20DB",
        "UnionPlus;": "\u228E",
        "varpropto;": "\u221D",
        "Bernoullis;": "\u212C",
        "circledast;": "\u229B",
        "CirclePlus;": "\u2295",
        "complement;": "\u2201",
        "curlywedge;": "\u22CF",
        "eqslantgtr;": "\u2A96",
        "EqualTilde;": "\u2242",
        "Fouriertrf;": "\u2131",
        "gtreqqless;": "\u2A8C",
        "ImaginaryI;": "\u2148",
        "Laplacetrf;": "\u2112",
        "LeftVector;": "\u21BC",
        "lessapprox;": "\u2A85",
        "lesseqqgtr;": "\u2A8B",
        "Lleftarrow;": "\u21DA",
        "lmoustache;": "\u23B0",
        "longmapsto;": "\u27FC",
        "mapstodown;": "\u21A7",
        "mapstoleft;": "\u21A4",
        "nLeftarrow;": "\u21CD",
        "nleftarrow;": "\u219A",
        "NotElement;": "\u2209",
        "NotGreater;": "\u226F",
        "nsubseteqq;": "\u2AC5\u0338",
        "nsupseteqq;": "\u2AC6\u0338",
        "precapprox;": "\u2AB7",
        "Proportion;": "\u2237",
        "RightArrow;": "\u2192",
        "Rightarrow;": "\u21D2",
        "rightarrow;": "\u2192",
        "RightFloor;": "\u230B",
        "rmoustache;": "\u23B1",
        "sqsubseteq;": "\u2291",
        "sqsupseteq;": "\u2292",
        "subsetneqq;": "\u2ACB",
        "succapprox;": "\u2AB8",
        "supsetneqq;": "\u2ACC",
        "ThickSpace;": "\u205F\u200A",
        "TildeEqual;": "\u2243",
        "TildeTilde;": "\u2248",
        "UnderBrace;": "\u23DF",
        "UpArrowBar;": "\u2912",
        "UpTeeArrow;": "\u21A5",
        "upuparrows;": "\u21C8",
        "varepsilon;": "\u03F5",
        "varnothing;": "\u2205",
        "backepsilon;": "\u03F6",
        "blacksquare;": "\u25AA",
        "circledcirc;": "\u229A",
        "circleddash;": "\u229D",
        "CircleMinus;": "\u2296",
        "CircleTimes;": "\u2297",
        "curlyeqprec;": "\u22DE",
        "curlyeqsucc;": "\u22DF",
        "diamondsuit;": "\u2666",
        "eqslantless;": "\u2A95",
        "Equilibrium;": "\u21CC",
        "expectation;": "\u2130",
        "GreaterLess;": "\u2277",
        "LeftCeiling;": "\u2308",
        "LessGreater;": "\u2276",
        "MediumSpace;": "\u205F",
        "NotLessLess;": "\u226A\u0338",
        "NotPrecedes;": "\u2280",
        "NotSucceeds;": "\u2281",
        "NotSuperset;": "\u2283\u20D2",
        "nRightarrow;": "\u21CF",
        "nrightarrow;": "\u219B",
        "OverBracket;": "\u23B4",
        "preccurlyeq;": "\u227C",
        "precnapprox;": "\u2AB9",
        "quaternions;": "\u210D",
        "RightVector;": "\u21C0",
        "Rrightarrow;": "\u21DB",
        "RuleDelayed;": "\u29F4",
        "SmallCircle;": "\u2218",
        "SquareUnion;": "\u2294",
        "straightphi;": "\u03D5",
        "SubsetEqual;": "\u2286",
        "succcurlyeq;": "\u227D",
        "succnapprox;": "\u2ABA",
        "thickapprox;": "\u2248",
        "UpDownArrow;": "\u2195",
        "Updownarrow;": "\u21D5",
        "updownarrow;": "\u2195",
        "VerticalBar;": "\u2223",
        "blacklozenge;": "\u29EB",
        "DownArrowBar;": "\u2913",
        "DownTeeArrow;": "\u21A7",
        "ExponentialE;": "\u2147",
        "exponentiale;": "\u2147",
        "GreaterEqual;": "\u2265",
        "GreaterTilde;": "\u2273",
        "HilbertSpace;": "\u210B",
        "HumpDownHump;": "\u224E",
        "Intersection;": "\u22C2",
        "LeftArrowBar;": "\u21E4",
        "LeftTeeArrow;": "\u21A4",
        "LeftTriangle;": "\u22B2",
        "LeftUpVector;": "\u21BF",
        "NotCongruent;": "\u2262",
        "NotHumpEqual;": "\u224F\u0338",
        "NotLessEqual;": "\u2270",
        "NotLessTilde;": "\u2274",
        "Proportional;": "\u221D",
        "RightCeiling;": "\u2309",
        "risingdotseq;": "\u2253",
        "RoundImplies;": "\u2970",
        "ShortUpArrow;": "\u2191",
        "SquareSubset;": "\u228F",
        "triangledown;": "\u25BF",
        "triangleleft;": "\u25C3",
        "UnderBracket;": "\u23B5",
        "varsubsetneq;": "\u228A\uFE00",
        "varsupsetneq;": "\u228B\uFE00",
        "VerticalLine;": "|",
        "ApplyFunction;": "\u2061",
        "bigtriangleup;": "\u25B3",
        "blacktriangle;": "\u25B4",
        "DifferentialD;": "\u2146",
        "divideontimes;": "\u22C7",
        "DoubleLeftTee;": "\u2AE4",
        "DoubleUpArrow;": "\u21D1",
        "fallingdotseq;": "\u2252",
        "hookleftarrow;": "\u21A9",
        "leftarrowtail;": "\u21A2",
        "leftharpoonup;": "\u21BC",
        "LeftTeeVector;": "\u295A",
        "LeftVectorBar;": "\u2952",
        "LessFullEqual;": "\u2266",
        "LongLeftArrow;": "\u27F5",
        "Longleftarrow;": "\u27F8",
        "longleftarrow;": "\u27F5",
        "looparrowleft;": "\u21AB",
        "measuredangle;": "\u2221",
        "NotEqualTilde;": "\u2242\u0338",
        "NotTildeEqual;": "\u2244",
        "NotTildeTilde;": "\u2249",
        "ntriangleleft;": "\u22EA",
        "Poincareplane;": "\u210C",
        "PrecedesEqual;": "\u2AAF",
        "PrecedesTilde;": "\u227E",
        "RightArrowBar;": "\u21E5",
        "RightTeeArrow;": "\u21A6",
        "RightTriangle;": "\u22B3",
        "RightUpVector;": "\u21BE",
        "shortparallel;": "\u2225",
        "smallsetminus;": "\u2216",
        "SucceedsEqual;": "\u2AB0",
        "SucceedsTilde;": "\u227F",
        "SupersetEqual;": "\u2287",
        "triangleright;": "\u25B9",
        "UpEquilibrium;": "\u296E",
        "upharpoonleft;": "\u21BF",
        "varsubsetneqq;": "\u2ACB\uFE00",
        "varsupsetneqq;": "\u2ACC\uFE00",
        "VerticalTilde;": "\u2240",
        "VeryThinSpace;": "\u200A",
        "curvearrowleft;": "\u21B6",
        "DiacriticalDot;": "\u02D9",
        "doublebarwedge;": "\u2306",
        "DoubleRightTee;": "\u22A8",
        "downdownarrows;": "\u21CA",
        "DownLeftVector;": "\u21BD",
        "GreaterGreater;": "\u2AA2",
        "hookrightarrow;": "\u21AA",
        "HorizontalLine;": "\u2500",
        "InvisibleComma;": "\u2063",
        "InvisibleTimes;": "\u2062",
        "LeftDownVector;": "\u21C3",
        "leftleftarrows;": "\u21C7",
        "LeftRightArrow;": "\u2194",
        "Leftrightarrow;": "\u21D4",
        "leftrightarrow;": "\u2194",
        "leftthreetimes;": "\u22CB",
        "LessSlantEqual;": "\u2A7D",
        "LongRightArrow;": "\u27F6",
        "Longrightarrow;": "\u27F9",
        "longrightarrow;": "\u27F6",
        "looparrowright;": "\u21AC",
        "LowerLeftArrow;": "\u2199",
        "NestedLessLess;": "\u226A",
        "NotGreaterLess;": "\u2279",
        "NotLessGreater;": "\u2278",
        "NotSubsetEqual;": "\u2288",
        "NotVerticalBar;": "\u2224",
        "nshortparallel;": "\u2226",
        "ntriangleright;": "\u22EB",
        "OpenCurlyQuote;": "\u2018",
        "ReverseElement;": "\u220B",
        "rightarrowtail;": "\u21A3",
        "rightharpoonup;": "\u21C0",
        "RightTeeVector;": "\u295B",
        "RightVectorBar;": "\u2953",
        "ShortDownArrow;": "\u2193",
        "ShortLeftArrow;": "\u2190",
        "SquareSuperset;": "\u2290",
        "TildeFullEqual;": "\u2245",
        "trianglelefteq;": "\u22B4",
        "upharpoonright;": "\u21BE",
        "UpperLeftArrow;": "\u2196",
        "ZeroWidthSpace;": "\u200B",
        "bigtriangledown;": "\u25BD",
        "circlearrowleft;": "\u21BA",
        "CloseCurlyQuote;": "\u2019",
        "ContourIntegral;": "\u222E",
        "curvearrowright;": "\u21B7",
        "DoubleDownArrow;": "\u21D3",
        "DoubleLeftArrow;": "\u21D0",
        "downharpoonleft;": "\u21C3",
        "DownRightVector;": "\u21C1",
        "leftharpoondown;": "\u21BD",
        "leftrightarrows;": "\u21C6",
        "LeftRightVector;": "\u294E",
        "LeftTriangleBar;": "\u29CF",
        "LeftUpTeeVector;": "\u2960",
        "LeftUpVectorBar;": "\u2958",
        "LowerRightArrow;": "\u2198",
        "nLeftrightarrow;": "\u21CE",
        "nleftrightarrow;": "\u21AE",
        "NotGreaterEqual;": "\u2271",
        "NotGreaterTilde;": "\u2275",
        "NotHumpDownHump;": "\u224E\u0338",
        "NotLeftTriangle;": "\u22EA",
        "NotSquareSubset;": "\u228F\u0338",
        "ntrianglelefteq;": "\u22EC",
        "OverParenthesis;": "\u23DC",
        "RightDownVector;": "\u21C2",
        "rightleftarrows;": "\u21C4",
        "rightsquigarrow;": "\u219D",
        "rightthreetimes;": "\u22CC",
        "ShortRightArrow;": "\u2192",
        "straightepsilon;": "\u03F5",
        "trianglerighteq;": "\u22B5",
        "UpperRightArrow;": "\u2197",
        "vartriangleleft;": "\u22B2",
        "circlearrowright;": "\u21BB",
        "DiacriticalAcute;": "\xB4",
        "DiacriticalGrave;": "`",
        "DiacriticalTilde;": "\u02DC",
        "DoubleRightArrow;": "\u21D2",
        "DownArrowUpArrow;": "\u21F5",
        "downharpoonright;": "\u21C2",
        "EmptySmallSquare;": "\u25FB",
        "GreaterEqualLess;": "\u22DB",
        "GreaterFullEqual;": "\u2267",
        "LeftAngleBracket;": "\u27E8",
        "LeftUpDownVector;": "\u2951",
        "LessEqualGreater;": "\u22DA",
        "NonBreakingSpace;": "\xA0",
        "NotPrecedesEqual;": "\u2AAF\u0338",
        "NotRightTriangle;": "\u22EB",
        "NotSucceedsEqual;": "\u2AB0\u0338",
        "NotSucceedsTilde;": "\u227F\u0338",
        "NotSupersetEqual;": "\u2289",
        "ntrianglerighteq;": "\u22ED",
        "rightharpoondown;": "\u21C1",
        "rightrightarrows;": "\u21C9",
        "RightTriangleBar;": "\u29D0",
        "RightUpTeeVector;": "\u295C",
        "RightUpVectorBar;": "\u2954",
        "twoheadleftarrow;": "\u219E",
        "UnderParenthesis;": "\u23DD",
        "UpArrowDownArrow;": "\u21C5",
        "vartriangleright;": "\u22B3",
        "blacktriangledown;": "\u25BE",
        "blacktriangleleft;": "\u25C2",
        "DoubleUpDownArrow;": "\u21D5",
        "DoubleVerticalBar;": "\u2225",
        "DownLeftTeeVector;": "\u295E",
        "DownLeftVectorBar;": "\u2956",
        "FilledSmallSquare;": "\u25FC",
        "GreaterSlantEqual;": "\u2A7E",
        "LeftDoubleBracket;": "\u27E6",
        "LeftDownTeeVector;": "\u2961",
        "LeftDownVectorBar;": "\u2959",
        "leftrightharpoons;": "\u21CB",
        "LeftTriangleEqual;": "\u22B4",
        "NegativeThinSpace;": "\u200B",
        "NotGreaterGreater;": "\u226B\u0338",
        "NotLessSlantEqual;": "\u2A7D\u0338",
        "NotNestedLessLess;": "\u2AA1\u0338",
        "NotReverseElement;": "\u220C",
        "NotSquareSuperset;": "\u2290\u0338",
        "NotTildeFullEqual;": "\u2247",
        "RightAngleBracket;": "\u27E9",
        "rightleftharpoons;": "\u21CC",
        "RightUpDownVector;": "\u294F",
        "SquareSubsetEqual;": "\u2291",
        "twoheadrightarrow;": "\u21A0",
        "VerticalSeparator;": "\u2758",
        "blacktriangleright;": "\u25B8",
        "DownRightTeeVector;": "\u295F",
        "DownRightVectorBar;": "\u2957",
        "LongLeftRightArrow;": "\u27F7",
        "Longleftrightarrow;": "\u27FA",
        "longleftrightarrow;": "\u27F7",
        "NegativeThickSpace;": "\u200B",
        "NotLeftTriangleBar;": "\u29CF\u0338",
        "PrecedesSlantEqual;": "\u227C",
        "ReverseEquilibrium;": "\u21CB",
        "RightDoubleBracket;": "\u27E7",
        "RightDownTeeVector;": "\u295D",
        "RightDownVectorBar;": "\u2955",
        "RightTriangleEqual;": "\u22B5",
        "SquareIntersection;": "\u2293",
        "SucceedsSlantEqual;": "\u227D",
        "DoubleLongLeftArrow;": "\u27F8",
        "DownLeftRightVector;": "\u2950",
        "LeftArrowRightArrow;": "\u21C6",
        "leftrightsquigarrow;": "\u21AD",
        "NegativeMediumSpace;": "\u200B",
        "NotGreaterFullEqual;": "\u2267\u0338",
        "NotRightTriangleBar;": "\u29D0\u0338",
        "RightArrowLeftArrow;": "\u21C4",
        "SquareSupersetEqual;": "\u2292",
        "CapitalDifferentialD;": "\u2145",
        "DoubleLeftRightArrow;": "\u21D4",
        "DoubleLongRightArrow;": "\u27F9",
        "EmptyVerySmallSquare;": "\u25AB",
        "NestedGreaterGreater;": "\u226B",
        "NotDoubleVerticalBar;": "\u2226",
        "NotGreaterSlantEqual;": "\u2A7E\u0338",
        "NotLeftTriangleEqual;": "\u22EC",
        "NotSquareSubsetEqual;": "\u22E2",
        "OpenCurlyDoubleQuote;": "\u201C",
        "ReverseUpEquilibrium;": "\u296F",
        "CloseCurlyDoubleQuote;": "\u201D",
        "DoubleContourIntegral;": "\u222F",
        "FilledVerySmallSquare;": "\u25AA",
        "NegativeVeryThinSpace;": "\u200B",
        "NotPrecedesSlantEqual;": "\u22E0",
        "NotRightTriangleEqual;": "\u22ED",
        "NotSucceedsSlantEqual;": "\u22E1",
        "DiacriticalDoubleAcute;": "\u02DD",
        "NotSquareSupersetEqual;": "\u22E3",
        "NotNestedGreaterGreater;": "\u2AA2\u0338",
        "ClockwiseContourIntegral;": "\u2232",
        "DoubleLongLeftRightArrow;": "\u27FA",
        "CounterClockwiseContourIntegral;": "\u2233",
      },
      gE,
      eY = (n, e) => {
        let t = 0,
          i = n.length,
          r = "";
        function s(a) {
          (t += a), (n = n.slice(a));
        }
        for (; t < i; ) {
          let a = /&(?:#x?)?/i.exec(n);
          if (!a || t + a.index >= i) {
            let o = i - t;
            (r += n.slice(0, o)), s(o);
            break;
          }
          if (((r += n.slice(0, a.index)), s(a.index), a[0] === "&")) {
            let o = "",
              l;
            if (/[0-9a-z]/i.test(n[1])) {
              gE ||
                (gE = Object.keys(ZR).reduce(
                  (c, u) => Math.max(c, u.length),
                  0
                ));
              for (let c = gE; !l && c > 0; --c)
                (o = n.slice(1, 1 + c)), (l = ZR[o]);
              if (l) {
                let c = o.endsWith(";");
                e && !c && /[=a-z0-9]/i.test(n[o.length + 1] || "")
                  ? ((r += "&" + o), s(1 + o.length))
                  : ((r += l), s(1 + o.length));
              } else (r += "&" + o), s(1 + o.length);
            } else (r += "&"), s(1);
          } else {
            let o = a[0] === "&#x",
              c = (o ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/).exec(n);
            if (!c) (r += a[0]), s(a[0].length);
            else {
              let u = Number.parseInt(c[1], o ? 16 : 10);
              u === 0 || u > 1114111 || (u >= 55296 && u <= 57343)
                ? (u = 65533)
                : (u >= 64976 && u <= 65007) ||
                  (u & 65534) === 65534 ||
                  (((u >= 1 && u <= 8) ||
                    u === 11 ||
                    (u >= 13 && u <= 31) ||
                    (u >= 127 && u <= 159)) &&
                    (u = tY[u] || u)),
                (r += String.fromCodePoint(u)),
                s(c[0].length);
            }
          }
        }
        return r;
      },
      tY = {
        128: 8364,
        130: 8218,
        131: 402,
        132: 8222,
        133: 8230,
        134: 8224,
        135: 8225,
        136: 710,
        137: 8240,
        138: 352,
        139: 8249,
        140: 338,
        142: 381,
        145: 8216,
        146: 8217,
        147: 8220,
        148: 8221,
        149: 8226,
        150: 8211,
        151: 8212,
        152: 732,
        153: 8482,
        154: 353,
        155: 8250,
        156: 339,
        158: 382,
        159: 376,
      },
      iY = hi.makeMap("style,iframe,script,noscript", !0),
      ME = {
        isVoidTag: hi.isVoidTag,
        isNativeTag: (n) => hi.isHTMLTag(n) || hi.isSVGTag(n),
        isPreTag: (n) => n === "pre",
        decodeEntities: eY,
        isBuiltInComponent: (n) => {
          if (Kt.isBuiltInType(n, "Transition")) return SE;
          if (Kt.isBuiltInType(n, "TransitionGroup")) return wE;
        },
        getNamespace(n, e) {
          let t = e ? e.ns : 0;
          if (e && t === 2)
            if (e.tag === "annotation-xml") {
              if (n === "svg") return 1;
              e.props.some(
                (i) =>
                  i.type === 6 &&
                  i.name === "encoding" &&
                  i.value != null &&
                  (i.value.content === "text/html" ||
                    i.value.content === "application/xhtml+xml")
              ) && (t = 0);
            } else
              /^m(?:[ions]|text)$/.test(e.tag) &&
                n !== "mglyph" &&
                n !== "malignmark" &&
                (t = 0);
          else
            e &&
              t === 1 &&
              (e.tag === "foreignObject" ||
                e.tag === "desc" ||
                e.tag === "title") &&
              (t = 0);
          if (t === 0) {
            if (n === "svg") return 1;
            if (n === "math") return 2;
          }
          return t;
        },
        getTextMode({ tag: n, ns: e }) {
          if (e === 0) {
            if (n === "textarea" || n === "title") return 1;
            if (iY(n)) return 2;
          }
          return 0;
        },
      },
      iO = (n) => {
        n.type === 1 &&
          n.props.forEach((e, t) => {
            e.type === 6 &&
              e.name === "style" &&
              e.value &&
              (n.props[t] = {
                type: 7,
                name: "bind",
                arg: Kt.createSimpleExpression("style", !0, e.loc),
                exp: nY(e.value.content, e.loc),
                modifiers: [],
                loc: e.loc,
              });
          });
      },
      nY = (n, e) => {
        let t = hi.parseStringStyle(n);
        return Kt.createSimpleExpression(JSON.stringify(t), !1, e, 3);
      };
    function Fs(n, e) {
      return Kt.createCompilerError(n, e, rY);
    }
    var rY = {
        [50]: "v-html is missing expression.",
        [51]: "v-html will override element children.",
        [52]: "v-text is missing expression.",
        [53]: "v-text will override element children.",
        [54]: "v-model can only be used on <input>, <textarea> and <select> elements.",
        [55]: "v-model argument is not supported on plain elements.",
        [56]: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",
        [57]: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",
        [58]: "v-show is missing expression.",
        [59]: "<Transition> expects exactly one child element or component.",
        [60]: "Tags with side effect (<script> and <style>) are ignored in client component templates.",
      },
      sY = (n, e, t) => {
        let { exp: i, loc: r } = n;
        return (
          i || t.onError(Fs(50, r)),
          e.children.length && (t.onError(Fs(51, r)), (e.children.length = 0)),
          {
            props: [
              Kt.createObjectProperty(
                Kt.createSimpleExpression("innerHTML", !0, r),
                i || Kt.createSimpleExpression("", !0)
              ),
            ],
          }
        );
      },
      aY = (n, e, t) => {
        let { exp: i, loc: r } = n;
        return (
          i || t.onError(Fs(52, r)),
          e.children.length && (t.onError(Fs(53, r)), (e.children.length = 0)),
          {
            props: [
              Kt.createObjectProperty(
                Kt.createSimpleExpression("textContent", !0),
                i
                  ? Kt.getConstantType(i, t) > 0
                    ? i
                    : Kt.createCallExpression(
                        t.helperString(Kt.TO_DISPLAY_STRING),
                        [i],
                        r
                      )
                  : Kt.createSimpleExpression("", !0)
              ),
            ],
          }
        );
      },
      oY = (n, e, t) => {
        let i = Kt.transformModel(n, e, t);
        if (!i.props.length || e.tagType === 1) return i;
        n.arg && t.onError(Fs(55, n.arg.loc));
        let { tag: r } = e,
          s = t.isCustomElement(r);
        if (r === "input" || r === "textarea" || r === "select" || s) {
          let a = xE,
            o = !1;
          if (r === "input" || s) {
            let l = Kt.findProp(e, "type");
            if (l) {
              if (l.type === 7) a = mg;
              else if (l.value)
                switch (l.value.content) {
                  case "radio":
                    a = yE;
                    break;
                  case "checkbox":
                    a = vE;
                    break;
                  case "file":
                    (o = !0), t.onError(Fs(56, n.loc));
                    break;
                }
            } else Kt.hasDynamicKeyVBind(e) && (a = mg);
          } else r === "select" && (a = bE);
          o || (i.needRuntime = t.helper(a));
        } else t.onError(Fs(54, n.loc));
        return (
          (i.props = i.props.filter(
            (a) => !(a.key.type === 4 && a.key.content === "modelValue")
          )),
          i
        );
      },
      lY = hi.makeMap("passive,once,capture"),
      cY = hi.makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"),
      uY = hi.makeMap("left,right"),
      nO = hi.makeMap("onkeyup,onkeydown,onkeypress", !0),
      hY = (n, e, t, i) => {
        let r = [],
          s = [],
          a = [];
        for (let o = 0; o < e.length; o++) {
          let l = e[o];
          (l === "native" &&
            Kt.checkCompatEnabled("COMPILER_V_ON_NATIVE", t, i)) ||
          lY(l)
            ? a.push(l)
            : uY(l)
            ? Kt.isStaticExp(n)
              ? nO(n.content)
                ? r.push(l)
                : s.push(l)
              : (r.push(l), s.push(l))
            : cY(l)
            ? s.push(l)
            : r.push(l);
        }
        return { keyModifiers: r, nonKeyModifiers: s, eventOptionModifiers: a };
      },
      QR = (n, e) =>
        Kt.isStaticExp(n) && n.content.toLowerCase() === "onclick"
          ? Kt.createSimpleExpression(e, !0)
          : n.type !== 4
          ? Kt.createCompoundExpression([
              "(",
              n,
              `) === "onClick" ? "${e}" : (`,
              n,
              ")",
            ])
          : n,
      fY = (n, e, t) =>
        Kt.transformOn(n, e, t, (i) => {
          let { modifiers: r } = n;
          if (!r.length) return i;
          let { key: s, value: a } = i.props[0],
            {
              keyModifiers: o,
              nonKeyModifiers: l,
              eventOptionModifiers: c,
            } = hY(s, r, t, n.loc);
          if (
            (l.includes("right") && (s = QR(s, "onContextmenu")),
            l.includes("middle") && (s = QR(s, "onMouseup")),
            l.length &&
              (a = Kt.createCallExpression(t.helper(_E), [
                a,
                JSON.stringify(l),
              ])),
            o.length &&
              (!Kt.isStaticExp(s) || nO(s.content)) &&
              (a = Kt.createCallExpression(t.helper(EE), [
                a,
                JSON.stringify(o),
              ])),
            c.length)
          ) {
            let u = c.map(hi.capitalize).join("");
            s = Kt.isStaticExp(s)
              ? Kt.createSimpleExpression(`${s.content}${u}`, !0)
              : Kt.createCompoundExpression(["(", s, `) + "${u}"`]);
          }
          return { props: [Kt.createObjectProperty(s, a)] };
        }),
      dY = (n, e, t) => {
        let { exp: i, loc: r } = n;
        return (
          i || t.onError(Fs(58, r)), { props: [], needRuntime: t.helper(TE) }
        );
      },
      pY = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g,
      mY = (n, e, t) => {
        if (e.scopes.vSlot > 0) return;
        let i = 0,
          r = 0,
          s = [],
          a = (l) => {
            if (i >= 20 || r >= 5) {
              let c = Kt.createCallExpression(e.helper(Kt.CREATE_STATIC), [
                JSON.stringify(s.map((u) => AE(u, e)).join("")).replace(
                  pY,
                  '" + $1 + "'
                ),
                String(s.length),
              ]);
              if ((tO(s[0], c, e), s.length > 1)) {
                for (let f = 1; f < s.length; f++) tO(s[f], null, e);
                let u = s.length - 1;
                return n.splice(l - s.length + 1, u), u;
              }
            }
            return 0;
          },
          o = 0;
        for (; o < n.length; o++) {
          let l = n[o];
          if (gY(l)) {
            let u = l,
              f = xY(u);
            if (f) {
              (i += f[0]), (r += f[1]), s.push(u);
              continue;
            }
          }
          (o -= a(o)), (i = 0), (r = 0), (s.length = 0);
        }
        a(o);
      },
      gY = (n) =>
        ((n.type === 1 && n.tagType === 0) || n.type == 12) &&
        n.codegenNode &&
        n.codegenNode.type === 4 &&
        n.codegenNode.hoisted,
      yY = /^(data|aria)-/,
      eO = (n, e) =>
        (e === 0
          ? hi.isKnownHtmlAttr(n)
          : e === 1
          ? hi.isKnownSvgAttr(n)
          : !1) || yY.test(n),
      tO = (n, e, t) => {
        let i = n.codegenNode.hoisted;
        t.hoists[t.hoists.indexOf(i)] = e;
      },
      vY = hi.makeMap("caption,thead,tr,th,tbody,td,tfoot,colgroup,col");
    function xY(n) {
      if (n.type === 1 && vY(n.tag)) return !1;
      if (n.type === 12) return [1, 0];
      let e = 1,
        t = n.props.length > 0 ? 1 : 0,
        i = !1,
        r = () => ((i = !0), !1);
      function s(a) {
        for (let o = 0; o < a.props.length; o++) {
          let l = a.props[o];
          if (
            (l.type === 6 && !eO(l.name, a.ns)) ||
            (l.type === 7 &&
              l.name === "bind" &&
              ((l.arg &&
                (l.arg.type === 8 ||
                  (l.arg.isStatic && !eO(l.arg.content, a.ns)))) ||
                (l.exp && (l.exp.type === 8 || l.exp.constType < 3))))
          )
            return r();
        }
        for (let o = 0; o < a.children.length; o++) {
          e++;
          let l = a.children[o];
          if (l.type === 1 && (l.props.length > 0 && t++, s(l), i)) return !1;
        }
        return !0;
      }
      return s(n) ? [e, t] : !1;
    }
    function AE(n, e) {
      if (hi.isString(n)) return n;
      if (hi.isSymbol(n)) return "";
      switch (n.type) {
        case 1:
          return bY(n, e);
        case 2:
          return hi.escapeHtml(n.content);
        case 3:
          return `<!--${hi.escapeHtml(n.content)}-->`;
        case 5:
          return hi.escapeHtml(hi.toDisplayString(Fl(n.content)));
        case 8:
          return hi.escapeHtml(Fl(n));
        case 12:
          return AE(n.content, e);
        default:
          return "";
      }
    }
    function bY(n, e) {
      let t = `<${n.tag}`,
        i = "";
      for (let r = 0; r < n.props.length; r++) {
        let s = n.props[r];
        if (s.type === 6)
          (t += ` ${s.name}`),
            s.value && (t += `="${hi.escapeHtml(s.value.content)}"`);
        else if (s.type === 7)
          if (s.name === "bind") {
            let a = s.exp;
            if (a.content[0] === "_") {
              t += ` ${s.arg.content}="__VUE_EXP_START__${a.content}__VUE_EXP_END__"`;
              continue;
            }
            let o = Fl(a);
            if (o != null) {
              let l = s.arg && s.arg.content;
              l === "class"
                ? (o = hi.normalizeClass(o))
                : l === "style" &&
                  (o = hi.stringifyStyle(hi.normalizeStyle(o))),
                (t += ` ${s.arg.content}="${hi.escapeHtml(o)}"`);
            }
          } else
            s.name === "html"
              ? (i = Fl(s.exp))
              : s.name === "text" &&
                (i = hi.escapeHtml(hi.toDisplayString(Fl(s.exp))));
      }
      if ((e.scopeId && (t += ` ${e.scopeId}`), (t += ">"), i)) t += i;
      else
        for (let r = 0; r < n.children.length; r++) t += AE(n.children[r], e);
      return hi.isVoidTag(n.tag) || (t += `</${n.tag}>`), t;
    }
    function Fl(n) {
      if (n.type === 4) return new Function(`return ${n.content}`)();
      {
        let e = "";
        return (
          n.children.forEach((t) => {
            hi.isString(t) ||
              hi.isSymbol(t) ||
              (t.type === 2
                ? (e += t.content)
                : t.type === 5
                ? (e += hi.toDisplayString(Fl(t.content)))
                : (e += Fl(t)));
          }),
          e
        );
      }
    }
    var _Y = (n, e) => {
        n.type === 1 &&
          n.tagType === 0 &&
          (n.tag === "script" || n.tag === "style") &&
          (e.onError(Fs(60, n.loc)), e.removeNode());
      },
      rO = [iO],
      sO = {
        cloak: Kt.noopDirectiveTransform,
        html: sY,
        text: aY,
        model: oY,
        on: fY,
        show: dY,
      };
    function EY(n, e = {}) {
      return Kt.baseCompile(
        n,
        hi.extend({}, ME, e, {
          nodeTransforms: [_Y, ...rO, ...(e.nodeTransforms || [])],
          directiveTransforms: hi.extend({}, sO, e.directiveTransforms || {}),
          transformHoist: mY,
        })
      );
    }
    function TY(n, e = {}) {
      return Kt.baseParse(n, hi.extend({}, ME, e));
    }
    Object.keys(Kt).forEach(function (n) {
      n !== "default" && (sn[n] = Kt[n]);
    });
    sn.DOMDirectiveTransforms = sO;
    sn.DOMNodeTransforms = rO;
    sn.TRANSITION = SE;
    sn.TRANSITION_GROUP = wE;
    sn.V_MODEL_CHECKBOX = vE;
    sn.V_MODEL_DYNAMIC = mg;
    sn.V_MODEL_RADIO = yE;
    sn.V_MODEL_SELECT = bE;
    sn.V_MODEL_TEXT = xE;
    sn.V_ON_WITH_KEYS = EE;
    sn.V_ON_WITH_MODIFIERS = _E;
    sn.V_SHOW = TE;
    sn.compile = EY;
    sn.createDOMCompilerError = Fs;
    sn.parse = TY;
    sn.parserOptions = ME;
    sn.transformStyle = iO;
  });
  var CE = jt((Nse, oO) => {
    "use strict";
    oO.exports = aO();
  });
  var mO = jt((vg) => {
    "use strict";
    Object.defineProperty(vg, "__esModule", { value: !0 });
    var wY = CE(),
      yg = Yc(),
      gg = lo();
    function MY(n) {
      if (n && n.__esModule) return n;
      var e = Object.create(null);
      return (
        n &&
          Object.keys(n).forEach(function (t) {
            e[t] = n[t];
          }),
        (e.default = n),
        Object.freeze(e)
      );
    }
    var AY = MY(yg),
      dO = Object.create(null);
    function pO(n, e) {
      if (!gg.isString(n))
        if (n.nodeType) n = n.innerHTML;
        else return gg.NOOP;
      let t = n,
        i = dO[t];
      if (i) return i;
      if (n[0] === "#") {
        let a = document.querySelector(n);
        n = a ? a.innerHTML : "";
      }
      let { code: r } = wY.compile(
          n,
          gg.extend({ hoistStatic: !0, onError: void 0, onWarn: gg.NOOP }, e)
        ),
        s = new Function("Vue", r)(AY);
      return (s._rc = !0), (dO[t] = s);
    }
    yg.registerRuntimeCompiler(pO);
    Object.keys(yg).forEach(function (n) {
      n !== "default" && (vg[n] = yg[n]);
    });
    vg.compile = pO;
  });
  var yO = jt(($se, gO) => {
    "use strict";
    gO.exports = mO();
  });
  var xO = jt((xg, vO) => {
    (function (n, e) {
      typeof xg == "object" && typeof vO != "undefined"
        ? e(xg)
        : typeof define == "function" && define.amd
        ? define(["exports"], e)
        : ((n = n || self), e((n.FilePond = {})));
    })(xg, function (n) {
      "use strict";
      var e = function (h) {
          return h instanceof HTMLElement;
        },
        t = function (h) {
          var p =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : [],
            v =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : [],
            T = Object.assign({}, h),
            C = [],
            N = [],
            k = function () {
              return Object.assign({}, T);
            },
            z = function () {
              var Ce = [].concat(C);
              return (C.length = 0), Ce;
            },
            G = function () {
              var Ce = [].concat(N);
              (N.length = 0),
                Ce.forEach(function (Xe) {
                  var at = Xe.type,
                    ht = Xe.data;
                  H(at, ht);
                });
            },
            H = function (Ce, Xe, at) {
              if (at && !document.hidden) {
                N.push({ type: Ce, data: Xe });
                return;
              }
              $e[Ce] && $e[Ce](Xe), C.push({ type: Ce, data: Xe });
            },
            se = function (Ce) {
              for (
                var Xe,
                  at = arguments.length,
                  ht = new Array(at > 1 ? at - 1 : 0),
                  Ke = 1;
                Ke < at;
                Ke++
              )
                ht[Ke - 1] = arguments[Ke];
              return ke[Ce] ? (Xe = ke)[Ce].apply(Xe, ht) : null;
            },
            oe = {
              getState: k,
              processActionQueue: z,
              processDispatchQueue: G,
              dispatch: H,
              query: se,
            },
            ke = {};
          p.forEach(function (je) {
            ke = Object.assign({}, je(T), {}, ke);
          });
          var $e = {};
          return (
            v.forEach(function (je) {
              $e = Object.assign({}, je(H, se, T), {}, $e);
            }),
            oe
          );
        },
        i = function (h, p, v) {
          if (typeof v == "function") {
            h[p] = v;
            return;
          }
          Object.defineProperty(h, p, Object.assign({}, v));
        },
        r = function (h, p) {
          for (var v in h) !h.hasOwnProperty(v) || p(v, h[v]);
        },
        s = function (h) {
          var p = {};
          return (
            r(h, function (v) {
              i(p, v, h[v]);
            }),
            p
          );
        },
        a = function (h, p) {
          var v =
            arguments.length > 2 && arguments[2] !== void 0
              ? arguments[2]
              : null;
          if (v === null) return h.getAttribute(p) || h.hasAttribute(p);
          h.setAttribute(p, v);
        },
        o = "http://www.w3.org/2000/svg",
        l = ["svg", "path"],
        c = function (h) {
          return l.includes(h);
        },
        u = function (h, p) {
          var v =
            arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          typeof p == "object" && ((v = p), (p = null));
          var T = c(h)
            ? document.createElementNS(o, h)
            : document.createElement(h);
          return (
            p && (c(h) ? a(T, "class", p) : (T.className = p)),
            r(v, function (C, N) {
              a(T, C, N);
            }),
            T
          );
        },
        f = function (h) {
          return function (p, v) {
            typeof v != "undefined" && h.children[v]
              ? h.insertBefore(p, h.children[v])
              : h.appendChild(p);
          };
        },
        d = function (h, p) {
          return function (v, T) {
            return typeof T != "undefined" ? p.splice(T, 0, v) : p.push(v), v;
          };
        },
        m = function (h, p) {
          return function (v) {
            return (
              p.splice(p.indexOf(v), 1),
              v.element.parentNode && h.removeChild(v.element),
              v
            );
          };
        },
        x = (function () {
          return (
            typeof window != "undefined" &&
            typeof window.document != "undefined"
          );
        })(),
        y = function () {
          return x;
        },
        g = y() ? u("svg") : {},
        b =
          "children" in g
            ? function (S) {
                return S.children.length;
              }
            : function (S) {
                return S.childNodes.length;
              },
        _ = function (h, p, v, T) {
          var C = v[0] || h.left,
            N = v[1] || h.top,
            k = C + h.width,
            z = N + h.height * (T[1] || 1),
            G = {
              element: Object.assign({}, h),
              inner: {
                left: h.left,
                top: h.top,
                right: h.right,
                bottom: h.bottom,
              },
              outer: { left: C, top: N, right: k, bottom: z },
            };
          return (
            p
              .filter(function (H) {
                return !H.isRectIgnored();
              })
              .map(function (H) {
                return H.rect;
              })
              .forEach(function (H) {
                E(G.inner, Object.assign({}, H.inner)),
                  E(G.outer, Object.assign({}, H.outer));
              }),
            w(G.inner),
            (G.outer.bottom += G.element.marginBottom),
            (G.outer.right += G.element.marginRight),
            w(G.outer),
            G
          );
        },
        E = function (h, p) {
          (p.top += h.top),
            (p.right += h.left),
            (p.bottom += h.top),
            (p.left += h.left),
            p.bottom > h.bottom && (h.bottom = p.bottom),
            p.right > h.right && (h.right = p.right);
        },
        w = function (h) {
          (h.width = h.right - h.left), (h.height = h.bottom - h.top);
        },
        P = function (h) {
          return typeof h == "number";
        },
        L = function (h, p, v) {
          var T =
            arguments.length > 3 && arguments[3] !== void 0
              ? arguments[3]
              : 0.001;
          return Math.abs(h - p) < T && Math.abs(v) < T;
        },
        I = function () {
          var h =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : {},
            p = h.stiffness,
            v = p === void 0 ? 0.5 : p,
            T = h.damping,
            C = T === void 0 ? 0.75 : T,
            N = h.mass,
            k = N === void 0 ? 10 : N,
            z = null,
            G = null,
            H = 0,
            se = !1,
            oe = function (Ce, Xe) {
              if (!se) {
                if (!(P(z) && P(G))) {
                  (se = !0), (H = 0);
                  return;
                }
                var at = -(G - z) * v;
                (H += at / k),
                  (G += H),
                  (H *= C),
                  L(G, z, H) || Xe
                    ? ((G = z),
                      (H = 0),
                      (se = !0),
                      $e.onupdate(G),
                      $e.oncomplete(G))
                    : $e.onupdate(G);
              }
            },
            ke = function (Ce) {
              if (
                (P(Ce) && !P(G) && (G = Ce),
                z === null && ((z = Ce), (G = Ce)),
                (z = Ce),
                G === z || typeof z == "undefined")
              ) {
                (se = !0), (H = 0), $e.onupdate(G), $e.oncomplete(G);
                return;
              }
              se = !1;
            },
            $e = s({
              interpolate: oe,
              target: {
                set: ke,
                get: function () {
                  return z;
                },
              },
              resting: {
                get: function () {
                  return se;
                },
              },
              onupdate: function (Ce) {},
              oncomplete: function (Ce) {},
            });
          return $e;
        },
        M = function (h) {
          return h;
        },
        R = function (h) {
          return h < 0.5 ? 2 * h * h : -1 + (4 - 2 * h) * h;
        },
        O = function () {
          var h =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : {},
            p = h.duration,
            v = p === void 0 ? 500 : p,
            T = h.easing,
            C = T === void 0 ? R : T,
            N = h.delay,
            k = N === void 0 ? 0 : N,
            z = null,
            G,
            H,
            se = !0,
            oe = !1,
            ke = null,
            $e = function (Xe, at) {
              se ||
                ke === null ||
                (z === null && (z = Xe),
                !(Xe - z < k) &&
                  ((G = Xe - z - k),
                  G >= v || at
                    ? ((G = 1),
                      (H = oe ? 0 : 1),
                      je.onupdate(H * ke),
                      je.oncomplete(H * ke),
                      (se = !0))
                    : ((H = G / v),
                      je.onupdate((G >= 0 ? C(oe ? 1 - H : H) : 0) * ke))));
            },
            je = s({
              interpolate: $e,
              target: {
                get: function () {
                  return oe ? 0 : ke;
                },
                set: function (Xe) {
                  if (ke === null) {
                    (ke = Xe), je.onupdate(Xe), je.oncomplete(Xe);
                    return;
                  }
                  Xe < ke ? ((ke = 1), (oe = !0)) : ((oe = !1), (ke = Xe)),
                    (se = !1),
                    (z = null);
                },
              },
              resting: {
                get: function () {
                  return se;
                },
              },
              onupdate: function (Xe) {},
              oncomplete: function (Xe) {},
            });
          return je;
        },
        U = { spring: I, tween: O },
        X = function (h, p, v) {
          var T = h[p] && typeof h[p][v] == "object" ? h[p][v] : h[p] || h,
            C = typeof T == "string" ? T : T.type,
            N = typeof T == "object" ? Object.assign({}, T) : {};
          return U[C] ? U[C](N) : null;
        },
        $ = function (h, p, v) {
          var T =
            arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
          (p = Array.isArray(p) ? p : [p]),
            p.forEach(function (C) {
              h.forEach(function (N) {
                var k = N,
                  z = function () {
                    return v[N];
                  },
                  G = function (se) {
                    return (v[N] = se);
                  };
                typeof N == "object" &&
                  ((k = N.key), (z = N.getter || z), (G = N.setter || G)),
                  !(C[k] && !T) && (C[k] = { get: z, set: G });
              });
            });
        },
        W = function (h) {
          var p = h.mixinConfig,
            v = h.viewProps,
            T = h.viewInternalAPI,
            C = h.viewExternalAPI,
            N = Object.assign({}, v),
            k = [];
          return (
            r(p, function (z, G) {
              var H = X(G);
              if (!!H) {
                (H.onupdate = function (oe) {
                  v[z] = oe;
                }),
                  (H.target = N[z]);
                var se = {
                  key: z,
                  setter: function (ke) {
                    H.target !== ke && (H.target = ke);
                  },
                  getter: function () {
                    return v[z];
                  },
                };
                $([se], [T, C], v, !0), k.push(H);
              }
            }),
            {
              write: function (G) {
                var H = document.hidden,
                  se = !0;
                return (
                  k.forEach(function (oe) {
                    oe.resting || (se = !1), oe.interpolate(G, H);
                  }),
                  se
                );
              },
              destroy: function () {},
            }
          );
        },
        ue = function (h) {
          return function (p, v) {
            h.addEventListener(p, v);
          };
        },
        ae = function (h) {
          return function (p, v) {
            h.removeEventListener(p, v);
          };
        },
        he = function (h) {
          var p = h.mixinConfig,
            v = h.viewProps,
            T = h.viewInternalAPI,
            C = h.viewExternalAPI,
            N = h.viewState,
            k = h.view,
            z = [],
            G = ue(k.element),
            H = ae(k.element);
          return (
            (C.on = function (se, oe) {
              z.push({ type: se, fn: oe }), G(se, oe);
            }),
            (C.off = function (se, oe) {
              z.splice(
                z.findIndex(function (ke) {
                  return ke.type === se && ke.fn === oe;
                }),
                1
              ),
                H(se, oe);
            }),
            {
              write: function () {
                return !0;
              },
              destroy: function () {
                z.forEach(function (oe) {
                  H(oe.type, oe.fn);
                });
              },
            }
          );
        },
        ce = function (h) {
          var p = h.mixinConfig,
            v = h.viewProps,
            T = h.viewExternalAPI;
          $(p, T, v);
        },
        te = function (h) {
          return h != null;
        },
        Me = {
          opacity: 1,
          scaleX: 1,
          scaleY: 1,
          translateX: 0,
          translateY: 0,
          rotateX: 0,
          rotateY: 0,
          rotateZ: 0,
          originX: 0,
          originY: 0,
        },
        ge = function (h) {
          var p = h.mixinConfig,
            v = h.viewProps,
            T = h.viewInternalAPI,
            C = h.viewExternalAPI,
            N = h.view,
            k = Object.assign({}, v),
            z = {};
          $(p, [T, C], v);
          var G = function () {
              return [v.translateX || 0, v.translateY || 0];
            },
            H = function () {
              return [v.scaleX || 0, v.scaleY || 0];
            },
            se = function () {
              return N.rect ? _(N.rect, N.childViews, G(), H()) : null;
            };
          return (
            (T.rect = { get: se }),
            (C.rect = { get: se }),
            p.forEach(function (oe) {
              v[oe] = typeof k[oe] == "undefined" ? Me[oe] : k[oe];
            }),
            {
              write: function () {
                if (!!pe(z, v))
                  return (
                    We(N.element, v), Object.assign(z, Object.assign({}, v)), !0
                  );
              },
              destroy: function () {},
            }
          );
        },
        pe = function (h, p) {
          if (Object.keys(h).length !== Object.keys(p).length) return !0;
          for (var v in p) if (p[v] !== h[v]) return !0;
          return !1;
        },
        We = function (h, p) {
          var v = p.opacity,
            T = p.perspective,
            C = p.translateX,
            N = p.translateY,
            k = p.scaleX,
            z = p.scaleY,
            G = p.rotateX,
            H = p.rotateY,
            se = p.rotateZ,
            oe = p.originX,
            ke = p.originY,
            $e = p.width,
            je = p.height,
            Ce = "",
            Xe = "";
          (te(oe) || te(ke)) &&
            (Xe +=
              "transform-origin: " + (oe || 0) + "px " + (ke || 0) + "px;"),
            te(T) && (Ce += "perspective(" + T + "px) "),
            (te(C) || te(N)) &&
              (Ce += "translate3d(" + (C || 0) + "px, " + (N || 0) + "px, 0) "),
            (te(k) || te(z)) &&
              (Ce +=
                "scale3d(" +
                (te(k) ? k : 1) +
                ", " +
                (te(z) ? z : 1) +
                ", 1) "),
            te(se) && (Ce += "rotateZ(" + se + "rad) "),
            te(G) && (Ce += "rotateX(" + G + "rad) "),
            te(H) && (Ce += "rotateY(" + H + "rad) "),
            Ce.length && (Xe += "transform:" + Ce + ";"),
            te(v) &&
              ((Xe += "opacity:" + v + ";"),
              v === 0 && (Xe += "visibility:hidden;"),
              v < 1 && (Xe += "pointer-events:none;")),
            te(je) && (Xe += "height:" + je + "px;"),
            te($e) && (Xe += "width:" + $e + "px;");
          var at = h.elementCurrentStyle || "";
          (Xe.length !== at.length || Xe !== at) &&
            ((h.style.cssText = Xe), (h.elementCurrentStyle = Xe));
        },
        Fe = { styles: ge, listeners: he, animations: W, apis: ce },
        Be = function () {
          var h =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : {},
            p =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : {},
            v =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : {};
          return (
            p.layoutCalculated ||
              ((h.paddingTop = parseInt(v.paddingTop, 10) || 0),
              (h.marginTop = parseInt(v.marginTop, 10) || 0),
              (h.marginRight = parseInt(v.marginRight, 10) || 0),
              (h.marginBottom = parseInt(v.marginBottom, 10) || 0),
              (h.marginLeft = parseInt(v.marginLeft, 10) || 0),
              (p.layoutCalculated = !0)),
            (h.left = p.offsetLeft || 0),
            (h.top = p.offsetTop || 0),
            (h.width = p.offsetWidth || 0),
            (h.height = p.offsetHeight || 0),
            (h.right = h.left + h.width),
            (h.bottom = h.top + h.height),
            (h.scrollTop = p.scrollTop),
            (h.hidden = p.offsetParent === null),
            h
          );
        },
        be = function () {
          var h =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : {},
            p = h.tag,
            v = p === void 0 ? "div" : p,
            T = h.name,
            C = T === void 0 ? null : T,
            N = h.attributes,
            k = N === void 0 ? {} : N,
            z = h.read,
            G = z === void 0 ? function () {} : z,
            H = h.write,
            se = H === void 0 ? function () {} : H,
            oe = h.create,
            ke = oe === void 0 ? function () {} : oe,
            $e = h.destroy,
            je = $e === void 0 ? function () {} : $e,
            Ce = h.filterFrameActionsForChild,
            Xe =
              Ce === void 0
                ? function (it, lt) {
                    return lt;
                  }
                : Ce,
            at = h.didCreateView,
            ht = at === void 0 ? function () {} : at,
            Ke = h.didWriteView,
            Nt = Ke === void 0 ? function () {} : Ke,
            et = h.ignoreRect,
            yi = et === void 0 ? !1 : et,
            vi = h.ignoreRectUpdate,
            rt = vi === void 0 ? !1 : vi,
            mt = h.mixins,
            bt = mt === void 0 ? [] : mt;
          return function (it) {
            var lt =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {},
              Tt = u(v, "filepond--" + C, k),
              xi = window.getComputedStyle(Tt, null),
              mi = Be(),
              wt = null,
              Ge = !1,
              xe = [],
              ct = [],
              Lt = {},
              Ft = {},
              ni = [se],
              Zt = [G],
              ui = [je],
              Wl = function () {
                return Tt;
              },
              Pu = function () {
                return xe.concat();
              },
              NF = function () {
                return Lt;
              },
              kF = function (ri) {
                return function (zs, Us) {
                  return zs(ri, Us);
                };
              },
              wS = function () {
                return wt || ((wt = _(mi, xe, [0, 0], [1, 1])), wt);
              },
              FF = function () {
                return xi;
              },
              BF = function () {
                (wt = null),
                  xe.forEach(function (Us) {
                    return Us._read();
                  });
                var ri = !(rt && mi.width && mi.height);
                ri && Be(mi, Tt, xi);
                var zs = { root: ka, props: lt, rect: mi };
                Zt.forEach(function (Us) {
                  return Us(zs);
                });
              },
              zF = function (ri, zs, Us) {
                var ql = zs.length === 0;
                return (
                  ni.forEach(function (Zn) {
                    var Fo = Zn({
                      props: lt,
                      root: ka,
                      actions: zs,
                      timestamp: ri,
                      shouldOptimize: Us,
                    });
                    Fo === !1 && (ql = !1);
                  }),
                  ct.forEach(function (Zn) {
                    var Fo = Zn.write(ri);
                    Fo === !1 && (ql = !1);
                  }),
                  xe
                    .filter(function (Zn) {
                      return !!Zn.element.parentNode;
                    })
                    .forEach(function (Zn) {
                      var Fo = Zn._write(ri, Xe(Zn, zs), Us);
                      Fo || (ql = !1);
                    }),
                  xe.forEach(function (Zn, Fo) {
                    Zn.element.parentNode ||
                      (ka.appendChild(Zn.element, Fo),
                      Zn._read(),
                      Zn._write(ri, Xe(Zn, zs), Us),
                      (ql = !1));
                  }),
                  (Ge = ql),
                  Nt({ props: lt, root: ka, actions: zs, timestamp: ri }),
                  ql
                );
              },
              UF = function () {
                ct.forEach(function (ri) {
                  return ri.destroy();
                }),
                  ui.forEach(function (ri) {
                    ri({ root: ka, props: lt });
                  }),
                  xe.forEach(function (ri) {
                    return ri._destroy();
                  });
              },
              MS = {
                element: { get: Wl },
                style: { get: FF },
                childViews: { get: Pu },
              },
              AS = Object.assign({}, MS, {
                rect: { get: wS },
                ref: { get: NF },
                is: function (ri) {
                  return C === ri;
                },
                appendChild: f(Tt),
                createChildView: kF(it),
                linkView: function (ri) {
                  return xe.push(ri), ri;
                },
                unlinkView: function (ri) {
                  xe.splice(xe.indexOf(ri), 1);
                },
                appendChildView: d(Tt, xe),
                removeChildView: m(Tt, xe),
                registerWriter: function (ri) {
                  return ni.push(ri);
                },
                registerReader: function (ri) {
                  return Zt.push(ri);
                },
                registerDestroyer: function (ri) {
                  return ui.push(ri);
                },
                invalidateLayout: function () {
                  return (Tt.layoutCalculated = !1);
                },
                dispatch: it.dispatch,
                query: it.query,
              }),
              CS = {
                element: { get: Wl },
                childViews: { get: Pu },
                rect: { get: wS },
                resting: {
                  get: function () {
                    return Ge;
                  },
                },
                isRectIgnored: function () {
                  return yi;
                },
                _read: BF,
                _write: zF,
                _destroy: UF,
              },
              VF = Object.assign({}, MS, {
                rect: {
                  get: function () {
                    return mi;
                  },
                },
              });
            Object.keys(bt)
              .sort(function (Di, ri) {
                return Di === "styles" ? 1 : ri === "styles" ? -1 : 0;
              })
              .forEach(function (Di) {
                var ri = Fe[Di]({
                  mixinConfig: bt[Di],
                  viewProps: lt,
                  viewState: Ft,
                  viewInternalAPI: AS,
                  viewExternalAPI: CS,
                  view: s(VF),
                });
                ri && ct.push(ri);
              });
            var ka = s(AS);
            ke({ root: ka, props: lt });
            var GF = b(Tt);
            return (
              xe.forEach(function (Di, ri) {
                ka.appendChild(Di.element, GF + ri);
              }),
              ht(ka),
              s(CS)
            );
          };
        },
        ut = function (h, p) {
          var v =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : 60,
            T = "__framePainter";
          if (window[T]) {
            window[T].readers.push(h), window[T].writers.push(p);
            return;
          }
          window[T] = { readers: [h], writers: [p] };
          var C = window[T],
            N = 1e3 / v,
            k = null,
            z = null,
            G = null,
            H = null,
            se = function () {
              document.hidden
                ? ((G = function () {
                    return window.setTimeout(function () {
                      return oe(performance.now());
                    }, N);
                  }),
                  (H = function () {
                    return window.clearTimeout(z);
                  }))
                : ((G = function () {
                    return window.requestAnimationFrame(oe);
                  }),
                  (H = function () {
                    return window.cancelAnimationFrame(z);
                  }));
            };
          document.addEventListener("visibilitychange", function () {
            H && H(), se(), oe(performance.now());
          });
          var oe = function ke($e) {
            (z = G(ke)), k || (k = $e);
            var je = $e - k;
            je <= N ||
              ((k = $e - (je % N)),
              C.readers.forEach(function (Ce) {
                return Ce();
              }),
              C.writers.forEach(function (Ce) {
                return Ce($e);
              }));
          };
          return (
            se(),
            oe(performance.now()),
            {
              pause: function () {
                H(z);
              },
            }
          );
        },
        Ye = function (h, p) {
          return function (v) {
            var T = v.root,
              C = v.props,
              N = v.actions,
              k = N === void 0 ? [] : N,
              z = v.timestamp,
              G = v.shouldOptimize;
            k
              .filter(function (H) {
                return h[H.type];
              })
              .forEach(function (H) {
                return h[H.type]({
                  root: T,
                  props: C,
                  action: H.data,
                  timestamp: z,
                  shouldOptimize: G,
                });
              }),
              p &&
                p({
                  root: T,
                  props: C,
                  actions: k,
                  timestamp: z,
                  shouldOptimize: G,
                });
          };
        },
        _t = function (h, p) {
          return p.parentNode.insertBefore(h, p);
        },
        Ze = function (h, p) {
          return p.parentNode.insertBefore(h, p.nextSibling);
        },
        kt = function (h) {
          return Array.isArray(h);
        },
        Et = function (h) {
          return h == null;
        },
        Y = function (h) {
          return h.trim();
        },
        ie = function (h) {
          return "" + h;
        },
        ye = function (h) {
          var p =
            arguments.length > 1 && arguments[1] !== void 0
              ? arguments[1]
              : ",";
          return Et(h)
            ? []
            : kt(h)
            ? h
            : ie(h)
                .split(p)
                .map(Y)
                .filter(function (v) {
                  return v.length;
                });
        },
        Pe = function (h) {
          return typeof h == "boolean";
        },
        De = function (h) {
          return Pe(h) ? h : h === "true";
        },
        Ie = function (h) {
          return typeof h == "string";
        },
        Ue = function (h) {
          return P(h) ? h : Ie(h) ? ie(h).replace(/[a-z]+/gi, "") : 0;
        },
        Ve = function (h) {
          return parseInt(Ue(h), 10);
        },
        He = function (h) {
          return parseFloat(Ue(h));
        },
        B = function (h) {
          return P(h) && isFinite(h) && Math.floor(h) === h;
        },
        F = function (h) {
          var p =
            arguments.length > 1 && arguments[1] !== void 0
              ? arguments[1]
              : 1e3;
          if (B(h)) return h;
          var v = ie(h).trim();
          return /MB$/i.test(v)
            ? ((v = v.replace(/MB$i/, "").trim()), Ve(v) * p * p)
            : /KB/i.test(v)
            ? ((v = v.replace(/KB$i/, "").trim()), Ve(v) * p)
            : Ve(v);
        },
        re = function (h) {
          return typeof h == "function";
        },
        ve = function (h) {
          for (var p = self, v = h.split("."), T = null; (T = v.shift()); )
            if (((p = p[T]), !p)) return null;
          return p;
        },
        Te = {
          process: "POST",
          patch: "PATCH",
          revert: "DELETE",
          fetch: "GET",
          restore: "GET",
          load: "GET",
        },
        q = function (h) {
          var p = {};
          return (
            (p.url = Ie(h) ? h : h.url || ""),
            (p.timeout = h.timeout ? parseInt(h.timeout, 10) : 0),
            (p.headers = h.headers ? h.headers : {}),
            r(Te, function (v) {
              p[v] = j(v, h[v], Te[v], p.timeout, p.headers);
            }),
            (p.process = h.process || Ie(h) || h.url ? p.process : null),
            (p.remove = h.remove || null),
            delete p.headers,
            p
          );
        },
        j = function (h, p, v, T, C) {
          if (p === null) return null;
          if (typeof p == "function") return p;
          var N = {
            url: v === "GET" || v === "PATCH" ? "?" + h + "=" : "",
            method: v,
            headers: C,
            withCredentials: !1,
            timeout: T,
            onload: null,
            ondata: null,
            onerror: null,
          };
          if (Ie(p)) return (N.url = p), N;
          if ((Object.assign(N, p), Ie(N.headers))) {
            var k = N.headers.split(/:(.+)/);
            N.headers = { header: k[0], value: k[1] };
          }
          return (N.withCredentials = De(N.withCredentials)), N;
        },
        A = function (h) {
          return q(h);
        },
        D = function (h) {
          return h === null;
        },
        V = function (h) {
          return typeof h == "object" && h !== null;
        },
        Q = function (h) {
          return (
            V(h) &&
            Ie(h.url) &&
            V(h.process) &&
            V(h.revert) &&
            V(h.restore) &&
            V(h.fetch)
          );
        },
        ee = function (h) {
          return kt(h)
            ? "array"
            : D(h)
            ? "null"
            : B(h)
            ? "int"
            : /^[0-9]+ ?(?:GB|MB|KB)$/gi.test(h)
            ? "bytes"
            : Q(h)
            ? "api"
            : typeof h;
        },
        _e = function (h) {
          return h
            .replace(/{\s*'/g, '{"')
            .replace(/'\s*}/g, '"}')
            .replace(/'\s*:/g, '":')
            .replace(/:\s*'/g, ':"')
            .replace(/,\s*'/g, ',"')
            .replace(/'\s*,/g, '",');
        },
        Re = {
          array: ye,
          boolean: De,
          int: function (h) {
            return ee(h) === "bytes" ? F(h) : Ve(h);
          },
          number: He,
          float: He,
          bytes: F,
          string: function (h) {
            return re(h) ? h : ie(h);
          },
          function: function (h) {
            return ve(h);
          },
          serverapi: A,
          object: function (h) {
            try {
              return JSON.parse(_e(h));
            } catch (p) {
              return null;
            }
          },
        },
        Ee = function (h, p) {
          return Re[p](h);
        },
        Se = function (h, p, v) {
          if (h === p) return h;
          var T = ee(h);
          if (T !== v) {
            var C = Ee(h, v);
            if (((T = ee(C)), C === null))
              throw (
                'Trying to assign value with incorrect type to "' +
                option +
                '", allowed type: "' +
                v +
                '"'
              );
            h = C;
          }
          return h;
        },
        st = function (h, p) {
          var v = h;
          return {
            enumerable: !0,
            get: function () {
              return v;
            },
            set: function (C) {
              v = Se(C, h, p);
            },
          };
        },
        Z = function (h) {
          var p = {};
          return (
            r(h, function (v) {
              var T = h[v];
              p[v] = st(T[0], T[1]);
            }),
            s(p)
          );
        },
        fe = function (h) {
          return {
            items: [],
            listUpdateTimeout: null,
            itemUpdateTimeout: null,
            processingQueue: [],
            options: Z(h),
          };
        },
        Le = function (h) {
          var p =
            arguments.length > 1 && arguments[1] !== void 0
              ? arguments[1]
              : "-";
          return h
            .split(/(?=[A-Z])/)
            .map(function (v) {
              return v.toLowerCase();
            })
            .join(p);
        },
        qe = function (h, p) {
          var v = {};
          return (
            r(p, function (T) {
              v[T] = {
                get: function () {
                  return h.getState().options[T];
                },
                set: function (N) {
                  h.dispatch("SET_" + Le(T, "_").toUpperCase(), { value: N });
                },
              };
            }),
            v
          );
        },
        ot = function (h) {
          return function (p, v, T) {
            var C = {};
            return (
              r(h, function (N) {
                var k = Le(N, "_").toUpperCase();
                C["SET_" + k] = function (z) {
                  try {
                    T.options[N] = z.value;
                  } catch (G) {}
                  p("DID_SET_" + k, { value: T.options[N] });
                };
              }),
              C
            );
          };
        },
        Ct = function (h) {
          return function (p) {
            var v = {};
            return (
              r(h, function (T) {
                v["GET_" + Le(T, "_").toUpperCase()] = function (C) {
                  return p.options[T];
                };
              }),
              v
            );
          };
        },
        zt = { API: 1, DROP: 2, BROWSE: 3, PASTE: 4, NONE: 5 },
        gi = function () {
          return Math.random().toString(36).substring(2, 11);
        };
      function Ni(S) {
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (Ni = function (h) {
                return typeof h;
              })
            : (Ni = function (h) {
                return h &&
                  typeof Symbol == "function" &&
                  h.constructor === Symbol &&
                  h !== Symbol.prototype
                  ? "symbol"
                  : typeof h;
              }),
          Ni(S)
        );
      }
      var Pt;
      function Xi(S, h, p, v) {
        Pt ||
          (Pt =
            (typeof Symbol == "function" &&
              Symbol.for &&
              Symbol.for("react.element")) ||
            60103);
        var T = S && S.defaultProps,
          C = arguments.length - 3;
        if ((!h && C !== 0 && (h = { children: void 0 }), h && T))
          for (var N in T) h[N] === void 0 && (h[N] = T[N]);
        else h || (h = T || {});
        if (C === 1) h.children = v;
        else if (C > 1) {
          for (var k = new Array(C), z = 0; z < C; z++) k[z] = arguments[z + 3];
          h.children = k;
        }
        return {
          $$typeof: Pt,
          type: S,
          key: p === void 0 ? null : "" + p,
          ref: null,
          props: h,
          _owner: null,
        };
      }
      function xn(S) {
        var h;
        if (
          typeof Symbol != "undefined" &&
          ((Symbol.asyncIterator &&
            ((h = S[Symbol.asyncIterator]), h != null)) ||
            (Symbol.iterator && ((h = S[Symbol.iterator]), h != null)))
        )
          return h.call(S);
        throw new TypeError("Object is not async iterable");
      }
      function Rr(S) {
        this.wrapped = S;
      }
      function fr(S) {
        var h, p;
        function v(N, k) {
          return new Promise(function (z, G) {
            var H = { key: N, arg: k, resolve: z, reject: G, next: null };
            p ? (p = p.next = H) : ((h = p = H), T(N, k));
          });
        }
        function T(N, k) {
          try {
            var z = S[N](k),
              G = z.value,
              H = G instanceof Rr;
            Promise.resolve(H ? G.wrapped : G).then(
              function (se) {
                if (H) {
                  T("next", se);
                  return;
                }
                C(z.done ? "return" : "normal", se);
              },
              function (se) {
                T("throw", se);
              }
            );
          } catch (se) {
            C("throw", se);
          }
        }
        function C(N, k) {
          switch (N) {
            case "return":
              h.resolve({ value: k, done: !0 });
              break;
            case "throw":
              h.reject(k);
              break;
            default:
              h.resolve({ value: k, done: !1 });
              break;
          }
          (h = h.next), h ? T(h.key, h.arg) : (p = null);
        }
        (this._invoke = v),
          typeof S.return != "function" && (this.return = void 0);
      }
      typeof Symbol == "function" &&
        Symbol.asyncIterator &&
        (fr.prototype[Symbol.asyncIterator] = function () {
          return this;
        }),
        (fr.prototype.next = function (S) {
          return this._invoke("next", S);
        }),
        (fr.prototype.throw = function (S) {
          return this._invoke("throw", S);
        }),
        (fr.prototype.return = function (S) {
          return this._invoke("return", S);
        });
      function oT(S) {
        return function () {
          return new fr(S.apply(this, arguments));
        };
      }
      function lT(S) {
        return new Rr(S);
      }
      function K(S, h) {
        var p = {},
          v = !1;
        function T(C, N) {
          return (
            (v = !0),
            (N = new Promise(function (k) {
              k(S[C](N));
            })),
            { done: !1, value: h(N) }
          );
        }
        return (
          typeof Symbol == "function" &&
            Symbol.iterator &&
            (p[Symbol.iterator] = function () {
              return this;
            }),
          (p.next = function (C) {
            return v ? ((v = !1), C) : T("next", C);
          }),
          typeof S.throw == "function" &&
            (p.throw = function (C) {
              if (v) throw ((v = !1), C);
              return T("throw", C);
            }),
          typeof S.return == "function" &&
            (p.return = function (C) {
              return T("return", C);
            }),
          p
        );
      }
      function me(S, h, p, v, T, C, N) {
        try {
          var k = S[C](N),
            z = k.value;
        } catch (G) {
          p(G);
          return;
        }
        k.done ? h(z) : Promise.resolve(z).then(v, T);
      }
      function Oe(S) {
        return function () {
          var h = this,
            p = arguments;
          return new Promise(function (v, T) {
            var C = S.apply(h, p);
            function N(z) {
              me(C, v, T, N, k, "next", z);
            }
            function k(z) {
              me(C, v, T, N, k, "throw", z);
            }
            N(void 0);
          });
        };
      }
      function de(S, h) {
        if (!(S instanceof h))
          throw new TypeError("Cannot call a class as a function");
      }
      function Ne(S, h) {
        for (var p = 0; p < h.length; p++) {
          var v = h[p];
          (v.enumerable = v.enumerable || !1),
            (v.configurable = !0),
            "value" in v && (v.writable = !0),
            Object.defineProperty(S, v.key, v);
        }
      }
      function At(S, h, p) {
        return h && Ne(S.prototype, h), p && Ne(S, p), S;
      }
      function Rt(S, h) {
        for (var p in h) {
          var v = h[p];
          (v.configurable = v.enumerable = !0),
            "value" in v && (v.writable = !0),
            Object.defineProperty(S, p, v);
        }
        if (Object.getOwnPropertySymbols)
          for (
            var T = Object.getOwnPropertySymbols(h), C = 0;
            C < T.length;
            C++
          ) {
            var N = T[C],
              v = h[N];
            (v.configurable = v.enumerable = !0),
              "value" in v && (v.writable = !0),
              Object.defineProperty(S, N, v);
          }
        return S;
      }
      function Ht(S, h) {
        for (var p = Object.getOwnPropertyNames(h), v = 0; v < p.length; v++) {
          var T = p[v],
            C = Object.getOwnPropertyDescriptor(h, T);
          C &&
            C.configurable &&
            S[T] === void 0 &&
            Object.defineProperty(S, T, C);
        }
        return S;
      }
      function Ut(S, h, p) {
        return (
          h in S
            ? Object.defineProperty(S, h, {
                value: p,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (S[h] = p),
          S
        );
      }
      function ti() {
        return (
          (ti =
            Object.assign ||
            function (S) {
              for (var h = 1; h < arguments.length; h++) {
                var p = arguments[h];
                for (var v in p)
                  Object.prototype.hasOwnProperty.call(p, v) && (S[v] = p[v]);
              }
              return S;
            }),
          ti.apply(this, arguments)
        );
      }
      function ii(S) {
        for (var h = 1; h < arguments.length; h++) {
          var p = arguments[h] != null ? arguments[h] : {},
            v = Object.keys(p);
          typeof Object.getOwnPropertySymbols == "function" &&
            (v = v.concat(
              Object.getOwnPropertySymbols(p).filter(function (T) {
                return Object.getOwnPropertyDescriptor(p, T).enumerable;
              })
            )),
            v.forEach(function (T) {
              Ut(S, T, p[T]);
            });
        }
        return S;
      }
      function Jt(S, h) {
        var p = Object.keys(S);
        if (Object.getOwnPropertySymbols) {
          var v = Object.getOwnPropertySymbols(S);
          h &&
            (v = v.filter(function (T) {
              return Object.getOwnPropertyDescriptor(S, T).enumerable;
            })),
            p.push.apply(p, v);
        }
        return p;
      }
      function Hi(S) {
        for (var h = 1; h < arguments.length; h++) {
          var p = arguments[h] != null ? arguments[h] : {};
          h % 2
            ? Jt(p, !0).forEach(function (v) {
                Ut(S, v, p[v]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(S, Object.getOwnPropertyDescriptors(p))
            : Jt(p).forEach(function (v) {
                Object.defineProperty(
                  S,
                  v,
                  Object.getOwnPropertyDescriptor(p, v)
                );
              });
        }
        return S;
      }
      function Fn(S, h) {
        if (typeof h != "function" && h !== null)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (S.prototype = Object.create(h && h.prototype, {
          constructor: { value: S, writable: !0, configurable: !0 },
        })),
          h && Ci(S, h);
      }
      function vs(S, h) {
        (S.prototype = Object.create(h.prototype)),
          (S.prototype.constructor = S),
          (S.__proto__ = h);
      }
      function Or(S) {
        return (
          (Or = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function (p) {
                return p.__proto__ || Object.getPrototypeOf(p);
              }),
          Or(S)
        );
      }
      function Ci(S, h) {
        return (
          (Ci =
            Object.setPrototypeOf ||
            function (v, T) {
              return (v.__proto__ = T), v;
            }),
          Ci(S, h)
        );
      }
      function Qt() {
        if (
          typeof Reflect == "undefined" ||
          !Reflect.construct ||
          Reflect.construct.sham
        )
          return !1;
        if (typeof Proxy == "function") return !0;
        try {
          return (
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function () {})
            ),
            !0
          );
        } catch (S) {
          return !1;
        }
      }
      function Ra(S, h, p) {
        return (
          Qt()
            ? (Ra = Reflect.construct)
            : (Ra = function (T, C, N) {
                var k = [null];
                k.push.apply(k, C);
                var z = Function.bind.apply(T, k),
                  G = new z();
                return N && Ci(G, N.prototype), G;
              }),
          Ra.apply(null, arguments)
        );
      }
      function Yi(S) {
        return Function.toString.call(S).indexOf("[native code]") !== -1;
      }
      function ns(S) {
        var h = typeof Map == "function" ? new Map() : void 0;
        return (
          (ns = function (v) {
            if (v === null || !Yi(v)) return v;
            if (typeof v != "function")
              throw new TypeError(
                "Super expression must either be null or a function"
              );
            if (typeof h != "undefined") {
              if (h.has(v)) return h.get(v);
              h.set(v, T);
            }
            function T() {
              return Ra(v, arguments, Or(this).constructor);
            }
            return (
              (T.prototype = Object.create(v.prototype, {
                constructor: {
                  value: T,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })),
              Ci(T, v)
            );
          }),
          ns(S)
        );
      }
      function Pg(S, h) {
        return h != null &&
          typeof Symbol != "undefined" &&
          h[Symbol.hasInstance]
          ? !!h[Symbol.hasInstance](S)
          : S instanceof h;
      }
      function Bl(S) {
        return S && S.__esModule ? S : { default: S };
      }
      function Wf(S) {
        if (S && S.__esModule) return S;
        var h = {};
        if (S != null) {
          for (var p in S)
            if (Object.prototype.hasOwnProperty.call(S, p)) {
              var v =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(S, p)
                  : {};
              v.get || v.set ? Object.defineProperty(h, p, v) : (h[p] = S[p]);
            }
        }
        return (h.default = S), h;
      }
      function wn(S, h) {
        if (S !== h)
          throw new TypeError("Cannot instantiate an arrow function");
      }
      function Oa(S) {
        if (S == null) throw new TypeError("Cannot destructure undefined");
      }
      function bu(S, h) {
        if (S == null) return {};
        var p = {},
          v = Object.keys(S),
          T,
          C;
        for (C = 0; C < v.length; C++)
          (T = v[C]), !(h.indexOf(T) >= 0) && (p[T] = S[T]);
        return p;
      }
      function Bn(S, h) {
        if (S == null) return {};
        var p = bu(S, h),
          v,
          T;
        if (Object.getOwnPropertySymbols) {
          var C = Object.getOwnPropertySymbols(S);
          for (T = 0; T < C.length; T++)
            (v = C[T]),
              !(h.indexOf(v) >= 0) &&
                (!Object.prototype.propertyIsEnumerable.call(S, v) ||
                  (p[v] = S[v]));
        }
        return p;
      }
      function _u(S) {
        if (S === void 0)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return S;
      }
      function cT(S, h) {
        return h && (typeof h == "object" || typeof h == "function")
          ? h
          : _u(S);
      }
      function Eu(S, h) {
        for (
          ;
          !Object.prototype.hasOwnProperty.call(S, h) &&
          ((S = Or(S)), S !== null);

        );
        return S;
      }
      function Dg(S, h, p) {
        return (
          typeof Reflect != "undefined" && Reflect.get
            ? (Dg = Reflect.get)
            : (Dg = function (T, C, N) {
                var k = Eu(T, C);
                if (!!k) {
                  var z = Object.getOwnPropertyDescriptor(k, C);
                  return z.get ? z.get.call(N) : z.value;
                }
              }),
          Dg(S, h, p || S)
        );
      }
      function qf(S, h, p, v) {
        return (
          typeof Reflect != "undefined" && Reflect.set
            ? (qf = Reflect.set)
            : (qf = function (C, N, k, z) {
                var G = Eu(C, N),
                  H;
                if (G) {
                  if (((H = Object.getOwnPropertyDescriptor(G, N)), H.set))
                    return H.set.call(z, k), !0;
                  if (!H.writable) return !1;
                }
                if (((H = Object.getOwnPropertyDescriptor(z, N)), H)) {
                  if (!H.writable) return !1;
                  (H.value = k), Object.defineProperty(z, N, H);
                } else Ut(z, N, k);
                return !0;
              }),
          qf(S, h, p, v)
        );
      }
      function dK(S, h, p, v, T) {
        var C = qf(S, h, p, v || S);
        if (!C && T) throw new Error("failed to set property");
        return p;
      }
      function pK(S, h) {
        return (
          h || (h = S.slice(0)),
          Object.freeze(
            Object.defineProperties(S, { raw: { value: Object.freeze(h) } })
          )
        );
      }
      function mK(S, h) {
        return h || (h = S.slice(0)), (S.raw = h), S;
      }
      function gK(S, h) {
        if (S === oN)
          throw new ReferenceError(h + " is not defined - temporal dead zone");
        return S;
      }
      function yK(S) {
        throw new Error('"' + S + '" is read-only');
      }
      function vK(S) {
        throw new Error(
          'Class "' + S + '" cannot be referenced in computed property keys.'
        );
      }
      var oN = {};
      function xK(S, h) {
        return Ig(S) || uN(S, h) || Lg();
      }
      function bK(S, h) {
        return Ig(S) || hN(S, h) || Lg();
      }
      function lN(S) {
        return Ig(S) || uT(S) || Lg();
      }
      function jf(S) {
        return cN(S) || uT(S) || fN();
      }
      function cN(S) {
        if (Array.isArray(S)) {
          for (var h = 0, p = new Array(S.length); h < S.length; h++)
            p[h] = S[h];
          return p;
        }
      }
      function Ig(S) {
        if (Array.isArray(S)) return S;
      }
      function uT(S) {
        if (
          Symbol.iterator in Object(S) ||
          Object.prototype.toString.call(S) === "[object Arguments]"
        )
          return Array.from(S);
      }
      function uN(S, h) {
        var p = [],
          v = !0,
          T = !1,
          C = void 0;
        try {
          for (
            var N = S[Symbol.iterator](), k;
            !(v = (k = N.next()).done) &&
            (p.push(k.value), !(h && p.length === h));
            v = !0
          );
        } catch (z) {
          (T = !0), (C = z);
        } finally {
          try {
            !v && N.return != null && N.return();
          } finally {
            if (T) throw C;
          }
        }
        return p;
      }
      function hN(S, h) {
        for (
          var p = [], v = S[Symbol.iterator](), T;
          !(T = v.next()).done && (p.push(T.value), !(h && p.length === h));

        );
        return p;
      }
      function fN() {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
      }
      function Lg() {
        throw new TypeError(
          "Invalid attempt to destructure non-iterable instance"
        );
      }
      function _K(S) {
        return function () {
          var h = S.apply(this, arguments);
          return h.next(), h;
        };
      }
      function dN(S, h) {
        if (typeof S != "object" || S === null) return S;
        var p = S[Symbol.toPrimitive];
        if (p !== void 0) {
          var v = p.call(S, h || "default");
          if (typeof v != "object") return v;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (h === "string" ? String : Number)(S);
      }
      function hT(S) {
        var h = dN(S, "string");
        return typeof h == "symbol" ? h : String(h);
      }
      function EK(S, h) {
        throw new Error(
          "Decorating class property failed. Please ensure that proposal-class-properties is enabled and set to use loose mode. To use proposal-class-properties in spec mode with decorators, wait for the next major version of decorators in stage 2."
        );
      }
      function TK(S, h, p, v) {
        !p ||
          Object.defineProperty(S, h, {
            enumerable: p.enumerable,
            configurable: p.configurable,
            writable: p.writable,
            value: p.initializer ? p.initializer.call(v) : void 0,
          });
      }
      function SK(S, h, p, v, T) {
        var C = {};
        return (
          Object.keys(v).forEach(function (N) {
            C[N] = v[N];
          }),
          (C.enumerable = !!C.enumerable),
          (C.configurable = !!C.configurable),
          ("value" in C || C.initializer) && (C.writable = !0),
          (C = p
            .slice()
            .reverse()
            .reduce(function (N, k) {
              return k(S, h, N) || N;
            }, C)),
          T &&
            C.initializer !== void 0 &&
            ((C.value = C.initializer ? C.initializer.call(T) : void 0),
            (C.initializer = void 0)),
          C.initializer === void 0 &&
            (Object.defineProperty(S, h, C), (C = null)),
          C
        );
      }
      var pN = 0;
      function wK(S) {
        return "__private_" + pN++ + "_" + S;
      }
      function MK(S, h) {
        if (!Object.prototype.hasOwnProperty.call(S, h))
          throw new TypeError("attempted to use private field on non-instance");
        return S;
      }
      function AK(S, h) {
        var p = h.get(S);
        if (!p)
          throw new TypeError("attempted to get private field on non-instance");
        return p.get ? p.get.call(S) : p.value;
      }
      function CK(S, h, p) {
        var v = h.get(S);
        if (!v)
          throw new TypeError("attempted to set private field on non-instance");
        if (v.set) v.set.call(S, p);
        else {
          if (!v.writable)
            throw new TypeError("attempted to set read only private field");
          v.value = p;
        }
        return p;
      }
      function PK(S, h) {
        if (!h.has(S))
          throw new TypeError("attempted to set private field on non-instance");
        var p = h.get(S);
        if (p.set)
          return (
            "__destrObj" in p ||
              (p.__destrObj = {
                set value(v) {
                  p.set.call(S, v);
                },
              }),
            p.__destrObj
          );
        if (!p.writable)
          throw new TypeError("attempted to set read only private field");
        return p;
      }
      function DK(S, h, p) {
        if (S !== h)
          throw new TypeError("Private static access of wrong provenance");
        return p.value;
      }
      function IK(S, h, p, v) {
        if (S !== h)
          throw new TypeError("Private static access of wrong provenance");
        if (!p.writable)
          throw new TypeError("attempted to set read only private field");
        return (p.value = v), v;
      }
      function LK(S, h, p) {
        if (S !== h)
          throw new TypeError("Private static access of wrong provenance");
        return p;
      }
      function RK() {
        throw new TypeError("attempted to set read only static private field");
      }
      function OK(S, h, p, v) {
        var T = fT();
        if (v) for (var C = 0; C < v.length; C++) T = v[C](T);
        var N = h(function (G) {
            T.initializeInstanceElements(G, k.elements);
          }, p),
          k = T.decorateClass(yN(N.d.map(mN)), S);
        return (
          T.initializeClassElements(N.F, k.elements),
          T.runClassFinishers(N.F, k.finishers)
        );
      }
      function fT() {
        fT = function () {
          return S;
        };
        var S = {
          elementsDefinitionOrder: [["method"], ["field"]],
          initializeInstanceElements: function (h, p) {
            ["method", "field"].forEach(function (v) {
              p.forEach(function (T) {
                T.kind === v &&
                  T.placement === "own" &&
                  this.defineClassElement(h, T);
              }, this);
            }, this);
          },
          initializeClassElements: function (h, p) {
            var v = h.prototype;
            ["method", "field"].forEach(function (T) {
              p.forEach(function (C) {
                var N = C.placement;
                if (C.kind === T && (N === "static" || N === "prototype")) {
                  var k = N === "static" ? h : v;
                  this.defineClassElement(k, C);
                }
              }, this);
            }, this);
          },
          defineClassElement: function (h, p) {
            var v = p.descriptor;
            if (p.kind === "field") {
              var T = p.initializer;
              v = {
                enumerable: v.enumerable,
                writable: v.writable,
                configurable: v.configurable,
                value: T === void 0 ? void 0 : T.call(h),
              };
            }
            Object.defineProperty(h, p.key, v);
          },
          decorateClass: function (h, p) {
            var v = [],
              T = [],
              C = { static: [], prototype: [], own: [] };
            if (
              (h.forEach(function (k) {
                this.addElementPlacement(k, C);
              }, this),
              h.forEach(function (k) {
                if (!Tu(k)) return v.push(k);
                var z = this.decorateElement(k, C);
                v.push(z.element),
                  v.push.apply(v, z.extras),
                  T.push.apply(T, z.finishers);
              }, this),
              !p)
            )
              return { elements: v, finishers: T };
            var N = this.decorateConstructor(v, p);
            return T.push.apply(T, N.finishers), (N.finishers = T), N;
          },
          addElementPlacement: function (h, p, v) {
            var T = p[h.placement];
            if (!v && T.indexOf(h.key) !== -1)
              throw new TypeError("Duplicated element (" + h.key + ")");
            T.push(h.key);
          },
          decorateElement: function (h, p) {
            for (
              var v = [], T = [], C = h.decorators, N = C.length - 1;
              N >= 0;
              N--
            ) {
              var k = p[h.placement];
              k.splice(k.indexOf(h.key), 1);
              var z = this.fromElementDescriptor(h),
                G = this.toElementFinisherExtras((0, C[N])(z) || z);
              (h = G.element),
                this.addElementPlacement(h, p),
                G.finisher && T.push(G.finisher);
              var H = G.extras;
              if (H) {
                for (var se = 0; se < H.length; se++)
                  this.addElementPlacement(H[se], p);
                v.push.apply(v, H);
              }
            }
            return { element: h, finishers: T, extras: v };
          },
          decorateConstructor: function (h, p) {
            for (var v = [], T = p.length - 1; T >= 0; T--) {
              var C = this.fromClassDescriptor(h),
                N = this.toClassDescriptor((0, p[T])(C) || C);
              if (
                (N.finisher !== void 0 && v.push(N.finisher),
                N.elements !== void 0)
              ) {
                h = N.elements;
                for (var k = 0; k < h.length - 1; k++)
                  for (var z = k + 1; z < h.length; z++)
                    if (
                      h[k].key === h[z].key &&
                      h[k].placement === h[z].placement
                    )
                      throw new TypeError(
                        "Duplicated element (" + h[k].key + ")"
                      );
              }
            }
            return { elements: h, finishers: v };
          },
          fromElementDescriptor: function (h) {
            var p = {
                kind: h.kind,
                key: h.key,
                placement: h.placement,
                descriptor: h.descriptor,
              },
              v = { value: "Descriptor", configurable: !0 };
            return (
              Object.defineProperty(p, Symbol.toStringTag, v),
              h.kind === "field" && (p.initializer = h.initializer),
              p
            );
          },
          toElementDescriptors: function (h) {
            if (h !== void 0)
              return lN(h).map(function (p) {
                var v = this.toElementDescriptor(p);
                return (
                  this.disallowProperty(p, "finisher", "An element descriptor"),
                  this.disallowProperty(p, "extras", "An element descriptor"),
                  v
                );
              }, this);
          },
          toElementDescriptor: function (h) {
            var p = String(h.kind);
            if (p !== "method" && p !== "field")
              throw new TypeError(
                `An element descriptor's .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "` +
                  p +
                  '"'
              );
            var v = hT(h.key),
              T = String(h.placement);
            if (T !== "static" && T !== "prototype" && T !== "own")
              throw new TypeError(
                `An element descriptor's .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "` +
                  T +
                  '"'
              );
            var C = h.descriptor;
            this.disallowProperty(h, "elements", "An element descriptor");
            var N = {
              kind: p,
              key: v,
              placement: T,
              descriptor: Object.assign({}, C),
            };
            return (
              p !== "field"
                ? this.disallowProperty(h, "initializer", "A method descriptor")
                : (this.disallowProperty(
                    C,
                    "get",
                    "The property descriptor of a field descriptor"
                  ),
                  this.disallowProperty(
                    C,
                    "set",
                    "The property descriptor of a field descriptor"
                  ),
                  this.disallowProperty(
                    C,
                    "value",
                    "The property descriptor of a field descriptor"
                  ),
                  (N.initializer = h.initializer)),
              N
            );
          },
          toElementFinisherExtras: function (h) {
            var p = this.toElementDescriptor(h),
              v = pT(h, "finisher"),
              T = this.toElementDescriptors(h.extras);
            return { element: p, finisher: v, extras: T };
          },
          fromClassDescriptor: function (h) {
            var p = {
                kind: "class",
                elements: h.map(this.fromElementDescriptor, this),
              },
              v = { value: "Descriptor", configurable: !0 };
            return Object.defineProperty(p, Symbol.toStringTag, v), p;
          },
          toClassDescriptor: function (h) {
            var p = String(h.kind);
            if (p !== "class")
              throw new TypeError(
                `A class descriptor's .kind property must be "class", but a decorator created a class descriptor with .kind "` +
                  p +
                  '"'
              );
            this.disallowProperty(h, "key", "A class descriptor"),
              this.disallowProperty(h, "placement", "A class descriptor"),
              this.disallowProperty(h, "descriptor", "A class descriptor"),
              this.disallowProperty(h, "initializer", "A class descriptor"),
              this.disallowProperty(h, "extras", "A class descriptor");
            var v = pT(h, "finisher"),
              T = this.toElementDescriptors(h.elements);
            return { elements: T, finisher: v };
          },
          runClassFinishers: function (h, p) {
            for (var v = 0; v < p.length; v++) {
              var T = (0, p[v])(h);
              if (T !== void 0) {
                if (typeof T != "function")
                  throw new TypeError("Finishers must return a constructor.");
                h = T;
              }
            }
            return h;
          },
          disallowProperty: function (h, p, v) {
            if (h[p] !== void 0)
              throw new TypeError(v + " can't have a ." + p + " property.");
          },
        };
        return S;
      }
      function mN(S) {
        var h = hT(S.key),
          p;
        S.kind === "method"
          ? (p = {
              value: S.value,
              writable: !0,
              configurable: !0,
              enumerable: !1,
            })
          : S.kind === "get"
          ? (p = { get: S.value, configurable: !0, enumerable: !1 })
          : S.kind === "set"
          ? (p = { set: S.value, configurable: !0, enumerable: !1 })
          : S.kind === "field" &&
            (p = { configurable: !0, writable: !0, enumerable: !0 });
        var v = {
          kind: S.kind === "field" ? "field" : "method",
          key: h,
          placement: S.static
            ? "static"
            : S.kind === "field"
            ? "own"
            : "prototype",
          descriptor: p,
        };
        return (
          S.decorators && (v.decorators = S.decorators),
          S.kind === "field" && (v.initializer = S.value),
          v
        );
      }
      function gN(S, h) {
        S.descriptor.get !== void 0
          ? (h.descriptor.get = S.descriptor.get)
          : (h.descriptor.set = S.descriptor.set);
      }
      function yN(S) {
        for (
          var h = [],
            p = function (N) {
              return (
                N.kind === "method" &&
                N.key === T.key &&
                N.placement === T.placement
              );
            },
            v = 0;
          v < S.length;
          v++
        ) {
          var T = S[v],
            C;
          if (T.kind === "method" && (C = h.find(p)))
            if (dT(T.descriptor) || dT(C.descriptor)) {
              if (Tu(T) || Tu(C))
                throw new ReferenceError(
                  "Duplicated methods (" + T.key + ") can't be decorated."
                );
              C.descriptor = T.descriptor;
            } else {
              if (Tu(T)) {
                if (Tu(C))
                  throw new ReferenceError(
                    "Decorators can't be placed on different accessors with for the same property (" +
                      T.key +
                      ")."
                  );
                C.decorators = T.decorators;
              }
              gN(T, C);
            }
          else h.push(T);
        }
        return h;
      }
      function Tu(S) {
        return S.decorators && S.decorators.length;
      }
      function dT(S) {
        return S !== void 0 && !(S.value === void 0 && S.writable === void 0);
      }
      function pT(S, h) {
        var p = S[h];
        if (p !== void 0 && typeof p != "function")
          throw new TypeError("Expected '" + h + "' to be a function");
        return p;
      }
      function NK(S, h, p) {
        if (!h.has(S))
          throw new TypeError("attempted to get private field on non-instance");
        return p;
      }
      function kK() {
        throw new TypeError("attempted to reassign private method");
      }
      function mT(S, h) {
        mT = function (k, z) {
          return new C(k, z);
        };
        var p = ns(RegExp),
          v = RegExp.prototype,
          T = new WeakMap();
        function C(k, z) {
          var G = p.call(this, k);
          return T.set(G, z), G;
        }
        Fn(C, p),
          (C.prototype.exec = function (k) {
            var z = v.exec.call(this, k);
            return z && (z.groups = N(z, this)), z;
          }),
          (C.prototype[Symbol.replace] = function (k, z) {
            if (typeof z == "string") {
              var G = T.get(this);
              return v[Symbol.replace].call(
                this,
                k,
                z.replace(/\$<([^>]+)>/g, function (se, oe) {
                  return "$" + G[oe];
                })
              );
            } else if (typeof z == "function") {
              var H = this;
              return v[Symbol.replace].call(this, k, function () {
                var se = [];
                return (
                  se.push.apply(se, arguments),
                  typeof se[se.length - 1] != "object" && se.push(N(se, H)),
                  z.apply(this, se)
                );
              });
            } else return v[Symbol.replace].call(this, k, z);
          });
        function N(k, z) {
          var G = T.get(z);
          return Object.keys(G).reduce(function (H, se) {
            return (H[se] = k[G[se]]), H;
          }, Object.create(null));
        }
        return mT.apply(this, arguments);
      }
      var Rg = function (h, p) {
          return h.splice(p, 1);
        },
        vN = function (h, p) {
          p
            ? h()
            : document.hidden
            ? Promise.resolve(1).then(h)
            : setTimeout(h, 0);
        },
        Xf = function () {
          var h = [],
            p = function (C, N) {
              Rg(
                h,
                h.findIndex(function (k) {
                  return k.event === C && (k.cb === N || !N);
                })
              );
            },
            v = function (C, N, k) {
              h.filter(function (z) {
                return z.event === C;
              })
                .map(function (z) {
                  return z.cb;
                })
                .forEach(function (z) {
                  return vN(function () {
                    return z.apply(void 0, jf(N));
                  }, k);
                });
            };
          return {
            fireSync: function (C) {
              for (
                var N = arguments.length,
                  k = new Array(N > 1 ? N - 1 : 0),
                  z = 1;
                z < N;
                z++
              )
                k[z - 1] = arguments[z];
              v(C, k, !0);
            },
            fire: function (C) {
              for (
                var N = arguments.length,
                  k = new Array(N > 1 ? N - 1 : 0),
                  z = 1;
                z < N;
                z++
              )
                k[z - 1] = arguments[z];
              v(C, k, !1);
            },
            on: function (C, N) {
              h.push({ event: C, cb: N });
            },
            onOnce: function (C, N) {
              h.push({
                event: C,
                cb: function () {
                  p(C, N), N.apply(void 0, arguments);
                },
              });
            },
            off: p,
          };
        },
        gT = function (h, p, v) {
          Object.getOwnPropertyNames(h)
            .filter(function (T) {
              return !v.includes(T);
            })
            .forEach(function (T) {
              return Object.defineProperty(
                p,
                T,
                Object.getOwnPropertyDescriptor(h, T)
              );
            });
        },
        xN = [
          "fire",
          "process",
          "revert",
          "load",
          "on",
          "off",
          "onOnce",
          "retryLoad",
          "extend",
          "archive",
          "archived",
          "release",
          "released",
          "requestProcessing",
          "freeze",
        ],
        Jn = function (h) {
          var p = {};
          return gT(h, p, xN), p;
        },
        bN = function (h) {
          h.forEach(function (p, v) {
            p.released && Rg(h, v);
          });
        },
        Ot = {
          INIT: 1,
          IDLE: 2,
          PROCESSING_QUEUED: 9,
          PROCESSING: 3,
          PROCESSING_COMPLETE: 5,
          PROCESSING_ERROR: 6,
          PROCESSING_REVERT_ERROR: 10,
          LOADING: 7,
          LOAD_ERROR: 8,
        },
        on = { INPUT: 1, LIMBO: 2, LOCAL: 3 },
        yT = function (h) {
          return /[^0-9]+/.exec(h);
        },
        vT = function () {
          return yT((1.1).toLocaleString())[0];
        },
        _N = function () {
          var h = vT(),
            p = (1e3).toLocaleString(),
            v = (1e3).toString();
          return p !== v ? yT(p)[0] : h === "." ? "," : ".";
        },
        ze = {
          BOOLEAN: "boolean",
          INT: "int",
          NUMBER: "number",
          STRING: "string",
          ARRAY: "array",
          OBJECT: "object",
          FUNCTION: "function",
          ACTION: "action",
          SERVER_API: "serverapi",
          REGEX: "regex",
        },
        Og = [],
        rs = function (h, p, v) {
          return new Promise(function (T, C) {
            var N = Og.filter(function (z) {
              return z.key === h;
            }).map(function (z) {
              return z.cb;
            });
            if (N.length === 0) {
              T(p);
              return;
            }
            var k = N.shift();
            N.reduce(function (z, G) {
              return z.then(function (H) {
                return G(H, v);
              });
            }, k(p, v))
              .then(function (z) {
                return T(z);
              })
              .catch(function (z) {
                return C(z);
              });
          });
        },
        Io = function (h, p, v) {
          return Og.filter(function (T) {
            return T.key === h;
          }).map(function (T) {
            return T.cb(p, v);
          });
        },
        EN = function (h, p) {
          return Og.push({ key: h, cb: p });
        },
        TN = function (h) {
          return Object.assign(zl, h);
        },
        Yf = function () {
          return Object.assign({}, zl);
        },
        SN = function (h) {
          r(h, function (p, v) {
            !zl[p] || (zl[p][0] = Se(v, zl[p][0], zl[p][1]));
          });
        },
        zl = {
          id: [null, ze.STRING],
          name: ["filepond", ze.STRING],
          disabled: [!1, ze.BOOLEAN],
          className: [null, ze.STRING],
          required: [!1, ze.BOOLEAN],
          captureMethod: [null, ze.STRING],
          allowSyncAcceptAttribute: [!0, ze.BOOLEAN],
          allowDrop: [!0, ze.BOOLEAN],
          allowBrowse: [!0, ze.BOOLEAN],
          allowPaste: [!0, ze.BOOLEAN],
          allowMultiple: [!1, ze.BOOLEAN],
          allowReplace: [!0, ze.BOOLEAN],
          allowRevert: [!0, ze.BOOLEAN],
          allowRemove: [!0, ze.BOOLEAN],
          allowProcess: [!0, ze.BOOLEAN],
          allowReorder: [!1, ze.BOOLEAN],
          allowDirectoriesOnly: [!1, ze.BOOLEAN],
          storeAsFile: [!1, ze.BOOLEAN],
          forceRevert: [!1, ze.BOOLEAN],
          maxFiles: [null, ze.INT],
          checkValidity: [!1, ze.BOOLEAN],
          itemInsertLocationFreedom: [!0, ze.BOOLEAN],
          itemInsertLocation: ["before", ze.STRING],
          itemInsertInterval: [75, ze.INT],
          dropOnPage: [!1, ze.BOOLEAN],
          dropOnElement: [!0, ze.BOOLEAN],
          dropValidation: [!1, ze.BOOLEAN],
          ignoredFiles: [[".ds_store", "thumbs.db", "desktop.ini"], ze.ARRAY],
          instantUpload: [!0, ze.BOOLEAN],
          maxParallelUploads: [2, ze.INT],
          allowMinimumUploadDuration: [!0, ze.BOOLEAN],
          chunkUploads: [!1, ze.BOOLEAN],
          chunkForce: [!1, ze.BOOLEAN],
          chunkSize: [5e6, ze.INT],
          chunkRetryDelays: [[500, 1e3, 3e3], ze.ARRAY],
          server: [null, ze.SERVER_API],
          fileSizeBase: [1e3, ze.INT],
          labelFileSizeBytes: ["bytes", ze.STRING],
          labelFileSizeKilobytes: ["KB", ze.STRING],
          labelFileSizeMegabytes: ["MB", ze.STRING],
          labelFileSizeGigabytes: ["GB", ze.STRING],
          labelDecimalSeparator: [vT(), ze.STRING],
          labelThousandsSeparator: [_N(), ze.STRING],
          labelIdle: [
            'Drag & Drop your files or <span class="filepond--label-action">Browse</span>',
            ze.STRING,
          ],
          labelInvalidField: ["Field contains invalid files", ze.STRING],
          labelFileWaitingForSize: ["Waiting for size", ze.STRING],
          labelFileSizeNotAvailable: ["Size not available", ze.STRING],
          labelFileCountSingular: ["file in list", ze.STRING],
          labelFileCountPlural: ["files in list", ze.STRING],
          labelFileLoading: ["Loading", ze.STRING],
          labelFileAdded: ["Added", ze.STRING],
          labelFileLoadError: ["Error during load", ze.STRING],
          labelFileRemoved: ["Removed", ze.STRING],
          labelFileRemoveError: ["Error during remove", ze.STRING],
          labelFileProcessing: ["Uploading", ze.STRING],
          labelFileProcessingComplete: ["Upload complete", ze.STRING],
          labelFileProcessingAborted: ["Upload cancelled", ze.STRING],
          labelFileProcessingError: ["Error during upload", ze.STRING],
          labelFileProcessingRevertError: ["Error during revert", ze.STRING],
          labelTapToCancel: ["tap to cancel", ze.STRING],
          labelTapToRetry: ["tap to retry", ze.STRING],
          labelTapToUndo: ["tap to undo", ze.STRING],
          labelButtonRemoveItem: ["Remove", ze.STRING],
          labelButtonAbortItemLoad: ["Abort", ze.STRING],
          labelButtonRetryItemLoad: ["Retry", ze.STRING],
          labelButtonAbortItemProcessing: ["Cancel", ze.STRING],
          labelButtonUndoItemProcessing: ["Undo", ze.STRING],
          labelButtonRetryItemProcessing: ["Retry", ze.STRING],
          labelButtonProcessItem: ["Upload", ze.STRING],
          iconRemove: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z" fill="currentColor" fill-rule="nonzero"/></svg>',
            ze.STRING,
          ],
          iconProcess: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z" fill="currentColor" fill-rule="evenodd"/></svg>',
            ze.STRING,
          ],
          iconRetry: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z" fill="currentColor" fill-rule="nonzero"/></svg>',
            ze.STRING,
          ],
          iconUndo: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z" fill="currentColor" fill-rule="nonzero"/></svg>',
            ze.STRING,
          ],
          iconDone: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z" fill="currentColor" fill-rule="nonzero"/></svg>',
            ze.STRING,
          ],
          oninit: [null, ze.FUNCTION],
          onwarning: [null, ze.FUNCTION],
          onerror: [null, ze.FUNCTION],
          onactivatefile: [null, ze.FUNCTION],
          oninitfile: [null, ze.FUNCTION],
          onaddfilestart: [null, ze.FUNCTION],
          onaddfileprogress: [null, ze.FUNCTION],
          onaddfile: [null, ze.FUNCTION],
          onprocessfilestart: [null, ze.FUNCTION],
          onprocessfileprogress: [null, ze.FUNCTION],
          onprocessfileabort: [null, ze.FUNCTION],
          onprocessfilerevert: [null, ze.FUNCTION],
          onprocessfile: [null, ze.FUNCTION],
          onprocessfiles: [null, ze.FUNCTION],
          onremovefile: [null, ze.FUNCTION],
          onpreparefile: [null, ze.FUNCTION],
          onupdatefiles: [null, ze.FUNCTION],
          onreorderfiles: [null, ze.FUNCTION],
          beforeDropFile: [null, ze.FUNCTION],
          beforeAddFile: [null, ze.FUNCTION],
          beforeRemoveFile: [null, ze.FUNCTION],
          beforePrepareFile: [null, ze.FUNCTION],
          stylePanelLayout: [null, ze.STRING],
          stylePanelAspectRatio: [null, ze.STRING],
          styleItemPanelAspectRatio: [null, ze.STRING],
          styleButtonRemoveItemPosition: ["left", ze.STRING],
          styleButtonProcessItemPosition: ["right", ze.STRING],
          styleLoadIndicatorPosition: ["right", ze.STRING],
          styleProgressIndicatorPosition: ["right", ze.STRING],
          styleButtonRemoveItemAlign: [!1, ze.BOOLEAN],
          files: [[], ze.ARRAY],
          credits: [["https://pqina.nl/", "Powered by PQINA"], ze.ARRAY],
        },
        Lo = function (h, p) {
          return Et(p)
            ? h[0] || null
            : B(p)
            ? h[p] || null
            : (typeof p == "object" && (p = p.id),
              h.find(function (v) {
                return v.id === p;
              }) || null);
        },
        xT = function (h) {
          if (Et(h)) return h;
          if (/:/.test(h)) {
            var p = h.split(":");
            return p[1] / p[0];
          }
          return parseFloat(h);
        },
        ss = function (h) {
          return h.filter(function (p) {
            return !p.archived;
          });
        },
        Ul = { EMPTY: 0, IDLE: 1, ERROR: 2, BUSY: 3, READY: 4 },
        Kf = null,
        wN = function () {
          if (Kf === null)
            try {
              var h = new DataTransfer();
              h.items.add(new File(["hello world"], "This_Works.txt"));
              var p = document.createElement("input");
              p.setAttribute("type", "file"),
                (p.files = h.files),
                (Kf = p.files.length === 1);
            } catch (v) {
              Kf = !1;
            }
          return Kf;
        },
        MN = [Ot.LOAD_ERROR, Ot.PROCESSING_ERROR, Ot.PROCESSING_REVERT_ERROR],
        AN = [Ot.LOADING, Ot.PROCESSING, Ot.PROCESSING_QUEUED, Ot.INIT],
        CN = [Ot.PROCESSING_COMPLETE],
        PN = function (h) {
          return MN.includes(h.status);
        },
        DN = function (h) {
          return AN.includes(h.status);
        },
        IN = function (h) {
          return CN.includes(h.status);
        },
        bT = function (h) {
          return (
            V(h.options.server) &&
            (V(h.options.server.process) || re(h.options.server.process))
          );
        },
        LN = function (h) {
          return {
            GET_STATUS: function () {
              var v = ss(h.items),
                T = Ul.EMPTY,
                C = Ul.ERROR,
                N = Ul.BUSY,
                k = Ul.IDLE,
                z = Ul.READY;
              return v.length === 0
                ? T
                : v.some(PN)
                ? C
                : v.some(DN)
                ? N
                : v.some(IN)
                ? z
                : k;
            },
            GET_ITEM: function (v) {
              return Lo(h.items, v);
            },
            GET_ACTIVE_ITEM: function (v) {
              return Lo(ss(h.items), v);
            },
            GET_ACTIVE_ITEMS: function () {
              return ss(h.items);
            },
            GET_ITEMS: function () {
              return h.items;
            },
            GET_ITEM_NAME: function (v) {
              var T = Lo(h.items, v);
              return T ? T.filename : null;
            },
            GET_ITEM_SIZE: function (v) {
              var T = Lo(h.items, v);
              return T ? T.fileSize : null;
            },
            GET_STYLES: function () {
              return Object.keys(h.options)
                .filter(function (v) {
                  return /^style/.test(v);
                })
                .map(function (v) {
                  return { name: v, value: h.options[v] };
                });
            },
            GET_PANEL_ASPECT_RATIO: function () {
              var v = /circle/.test(h.options.stylePanelLayout),
                T = v ? 1 : xT(h.options.stylePanelAspectRatio);
              return T;
            },
            GET_ITEM_PANEL_ASPECT_RATIO: function () {
              return h.options.styleItemPanelAspectRatio;
            },
            GET_ITEMS_BY_STATUS: function (v) {
              return ss(h.items).filter(function (T) {
                return T.status === v;
              });
            },
            GET_TOTAL_ITEMS: function () {
              return ss(h.items).length;
            },
            SHOULD_UPDATE_FILE_INPUT: function () {
              return h.options.storeAsFile && wN() && !bT(h);
            },
            IS_ASYNC: function () {
              return bT(h);
            },
            GET_FILE_SIZE_LABELS: function (v) {
              return {
                labelBytes: v("GET_LABEL_FILE_SIZE_BYTES") || void 0,
                labelKilobytes: v("GET_LABEL_FILE_SIZE_KILOBYTES") || void 0,
                labelMegabytes: v("GET_LABEL_FILE_SIZE_MEGABYTES") || void 0,
                labelGigabytes: v("GET_LABEL_FILE_SIZE_GIGABYTES") || void 0,
              };
            },
          };
        },
        RN = function (h) {
          var p = ss(h.items).length;
          if (!h.options.allowMultiple) return p === 0;
          var v = h.options.maxFiles;
          return v === null || p < v;
        },
        _T = function (h, p, v) {
          return Math.max(Math.min(v, h), p);
        },
        ON = function (h, p, v) {
          return h.splice(p, 0, v);
        },
        NN = function (h, p, v) {
          return Et(p)
            ? null
            : typeof v == "undefined"
            ? (h.push(p), p)
            : ((v = _T(v, 0, h.length)), ON(h, v, p), p);
        },
        Ng = function (h) {
          return /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s]*)\s*$/i.test(
            h
          );
        },
        Su = function (h) {
          return h.split("/").pop().split("?").shift();
        },
        Jf = function (h) {
          return h.split(".").pop();
        },
        kN = function (h) {
          if (typeof h != "string") return "";
          var p = h.split("/").pop();
          return /svg/.test(p)
            ? "svg"
            : /zip|compressed/.test(p)
            ? "zip"
            : /plain/.test(p)
            ? "txt"
            : /msword/.test(p)
            ? "doc"
            : /[a-z]+/.test(p)
            ? p === "jpeg"
              ? "jpg"
              : p
            : "";
        },
        wu = function (h) {
          var p =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          return (p + h).slice(-p.length);
        },
        ET = function () {
          var h =
            arguments.length > 0 && arguments[0] !== void 0
              ? arguments[0]
              : new Date();
          return (
            h.getFullYear() +
            "-" +
            wu(h.getMonth() + 1, "00") +
            "-" +
            wu(h.getDate(), "00") +
            "_" +
            wu(h.getHours(), "00") +
            "-" +
            wu(h.getMinutes(), "00") +
            "-" +
            wu(h.getSeconds(), "00")
          );
        },
        Vl = function (h, p) {
          var v =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : null,
            T =
              arguments.length > 3 && arguments[3] !== void 0
                ? arguments[3]
                : null,
            C =
              typeof v == "string"
                ? h.slice(0, h.size, v)
                : h.slice(0, h.size, h.type);
          return (
            (C.lastModifiedDate = new Date()),
            h._relativePath && (C._relativePath = h._relativePath),
            Ie(p) || (p = ET()),
            p && T === null && Jf(p)
              ? (C.name = p)
              : ((T = T || kN(C.type)), (C.name = p + (T ? "." + T : ""))),
            C
          );
        },
        FN = function () {
          return (window.BlobBuilder =
            window.BlobBuilder ||
            window.WebKitBlobBuilder ||
            window.MozBlobBuilder ||
            window.MSBlobBuilder);
        },
        TT = function (h, p) {
          var v = FN();
          if (v) {
            var T = new v();
            return T.append(h), T.getBlob(p);
          }
          return new Blob([h], { type: p });
        },
        BN = function (h, p) {
          for (
            var v = new ArrayBuffer(h.length), T = new Uint8Array(v), C = 0;
            C < h.length;
            C++
          )
            T[C] = h.charCodeAt(C);
          return TT(v, p);
        },
        ST = function (h) {
          return (/^data:(.+);/.exec(h) || [])[1] || null;
        },
        zN = function (h) {
          var p = h.split(",")[1];
          return p.replace(/\s/g, "");
        },
        UN = function (h) {
          return atob(zN(h));
        },
        VN = function (h) {
          var p = ST(h),
            v = UN(h);
          return BN(v, p);
        },
        GN = function (h, p, v) {
          return Vl(VN(h), p, null, v);
        },
        HN = function (h) {
          if (!/^content-disposition:/i.test(h)) return null;
          var p = h
            .split(/filename=|filename\*=.+''/)
            .splice(1)
            .map(function (v) {
              return v.trim().replace(/^["']|[;"']{0,2}$/g, "");
            })
            .filter(function (v) {
              return v.length;
            });
          return p.length ? decodeURI(p[p.length - 1]) : null;
        },
        $N = function (h) {
          if (/content-length:/i.test(h)) {
            var p = h.match(/[0-9]+/)[0];
            return p ? parseInt(p, 10) : null;
          }
          return null;
        },
        WN = function (h) {
          if (/x-content-transfer-id:/i.test(h)) {
            var p = (h.split(":")[1] || "").trim();
            return p || null;
          }
          return null;
        },
        kg = function (h) {
          var p = { source: null, name: null, size: null },
            v = h.split(`
`),
            T = !0,
            C = !1,
            N = void 0;
          try {
            for (
              var k = v[Symbol.iterator](), z;
              !(T = (z = k.next()).done);
              T = !0
            ) {
              var G = z.value,
                H = HN(G);
              if (H) {
                p.name = H;
                continue;
              }
              var se = $N(G);
              if (se) {
                p.size = se;
                continue;
              }
              var oe = WN(G);
              if (oe) {
                p.source = oe;
                continue;
              }
            }
          } catch (ke) {
            (C = !0), (N = ke);
          } finally {
            try {
              !T && k.return != null && k.return();
            } finally {
              if (C) throw N;
            }
          }
          return p;
        },
        qN = function (h) {
          var p = {
              source: null,
              complete: !1,
              progress: 0,
              size: null,
              timestamp: null,
              duration: 0,
              request: null,
            },
            v = function () {
              return p.progress;
            },
            T = function () {
              p.request && p.request.abort && p.request.abort();
            },
            C = function () {
              var G = p.source;
              k.fire("init", G),
                G instanceof File
                  ? k.fire("load", G)
                  : G instanceof Blob
                  ? k.fire("load", Vl(G, G.name))
                  : Ng(G)
                  ? k.fire("load", GN(G))
                  : N(G);
            },
            N = function (G) {
              if (!h) {
                k.fire("error", {
                  type: "error",
                  body: "Can't load URL",
                  code: 400,
                });
                return;
              }
              (p.timestamp = Date.now()),
                (p.request = h(
                  G,
                  function (H) {
                    (p.duration = Date.now() - p.timestamp),
                      (p.complete = !0),
                      H instanceof Blob && (H = Vl(H, H.name || Su(G))),
                      k.fire("load", H instanceof Blob ? H : H ? H.body : null);
                  },
                  function (H) {
                    k.fire(
                      "error",
                      typeof H == "string"
                        ? { type: "error", code: 0, body: H }
                        : H
                    );
                  },
                  function (H, se, oe) {
                    if (
                      (oe && (p.size = oe),
                      (p.duration = Date.now() - p.timestamp),
                      !H)
                    ) {
                      p.progress = null;
                      return;
                    }
                    (p.progress = se / oe), k.fire("progress", p.progress);
                  },
                  function () {
                    k.fire("abort");
                  },
                  function (H) {
                    var se = kg(typeof H == "string" ? H : H.headers);
                    k.fire("meta", {
                      size: p.size || se.size,
                      filename: se.name,
                      source: se.source,
                    });
                  }
                ));
            },
            k = Object.assign({}, Xf(), {
              setSource: function (G) {
                return (p.source = G);
              },
              getProgress: v,
              abort: T,
              load: C,
            });
          return k;
        },
        wT = function (h) {
          return /GET|HEAD/.test(h);
        },
        Ro = function (h, p, v) {
          var T = {
              onheaders: function () {},
              onprogress: function () {},
              onload: function () {},
              ontimeout: function () {},
              onerror: function () {},
              onabort: function () {},
              abort: function () {
                (C = !0), k.abort();
              },
            },
            C = !1,
            N = !1;
          (v = Object.assign(
            { method: "POST", headers: {}, withCredentials: !1 },
            v
          )),
            (p = encodeURI(p)),
            wT(v.method) &&
              h &&
              (p =
                "" +
                p +
                encodeURIComponent(
                  typeof h == "string" ? h : JSON.stringify(h)
                ));
          var k = new XMLHttpRequest(),
            z = wT(v.method) ? k : k.upload;
          return (
            (z.onprogress = function (G) {
              C || T.onprogress(G.lengthComputable, G.loaded, G.total);
            }),
            (k.onreadystatechange = function () {
              k.readyState < 2 ||
                (k.readyState === 4 && k.status === 0) ||
                N ||
                ((N = !0), T.onheaders(k));
            }),
            (k.onload = function () {
              k.status >= 200 && k.status < 300 ? T.onload(k) : T.onerror(k);
            }),
            (k.onerror = function () {
              return T.onerror(k);
            }),
            (k.onabort = function () {
              (C = !0), T.onabort();
            }),
            (k.ontimeout = function () {
              return T.ontimeout(k);
            }),
            k.open(v.method, p, !0),
            B(v.timeout) && (k.timeout = v.timeout),
            Object.keys(v.headers).forEach(function (G) {
              var H = unescape(encodeURIComponent(v.headers[G]));
              k.setRequestHeader(G, H);
            }),
            v.responseType && (k.responseType = v.responseType),
            v.withCredentials && (k.withCredentials = !0),
            k.send(h),
            T
          );
        },
        $i = function (h, p, v, T) {
          return { type: h, code: p, body: v, headers: T };
        },
        Oo = function (h) {
          return function (p) {
            h($i("error", 0, "Timeout", p.getAllResponseHeaders()));
          };
        },
        MT = function (h) {
          return /\?/.test(h);
        },
        Mu = function () {
          for (
            var h = "", p = arguments.length, v = new Array(p), T = 0;
            T < p;
            T++
          )
            v[T] = arguments[T];
          return (
            v.forEach(function (C) {
              h += MT(h) && MT(C) ? C.replace(/\?/, "&") : C;
            }),
            h
          );
        },
        Fg = function () {
          var h =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : "",
            p = arguments.length > 1 ? arguments[1] : void 0;
          if (typeof p == "function") return p;
          if (!p || !Ie(p.url)) return null;
          var v =
              p.onload ||
              function (C) {
                return C;
              },
            T =
              p.onerror ||
              function (C) {
                return null;
              };
          return function (C, N, k, z, G, H) {
            var se = Ro(
              C,
              Mu(h, p.url),
              Object.assign({}, p, { responseType: "blob" })
            );
            return (
              (se.onload = function (oe) {
                var ke = oe.getAllResponseHeaders(),
                  $e = kg(ke).name || Su(C);
                N(
                  $i(
                    "load",
                    oe.status,
                    p.method === "HEAD" ? null : Vl(v(oe.response), $e),
                    ke
                  )
                );
              }),
              (se.onerror = function (oe) {
                k(
                  $i(
                    "error",
                    oe.status,
                    T(oe.response) || oe.statusText,
                    oe.getAllResponseHeaders()
                  )
                );
              }),
              (se.onheaders = function (oe) {
                H($i("headers", oe.status, null, oe.getAllResponseHeaders()));
              }),
              (se.ontimeout = Oo(k)),
              (se.onprogress = z),
              (se.onabort = G),
              se
            );
          };
        },
        Nr = { QUEUED: 0, COMPLETE: 1, PROCESSING: 2, ERROR: 3, WAITING: 4 },
        jN = function (h, p, v, T, C, N, k, z, G, H, se) {
          for (
            var oe = [],
              ke = se.chunkTransferId,
              $e = se.chunkServer,
              je = se.chunkSize,
              Ce = se.chunkRetryDelays,
              Xe = { serverId: ke, aborted: !1 },
              at =
                p.ondata ||
                function (Ge) {
                  return Ge;
                },
              ht =
                p.onload ||
                function (Ge, xe) {
                  return xe === "HEAD"
                    ? Ge.getResponseHeader("Upload-Offset")
                    : Ge.response;
                },
              Ke =
                p.onerror ||
                function (Ge) {
                  return null;
                },
              Nt = function (xe) {
                var ct = new FormData();
                V(C) && ct.append(v, JSON.stringify(C));
                var Lt =
                    typeof p.headers == "function"
                      ? p.headers(T, C)
                      : Object.assign({}, p.headers, {
                          "Upload-Length": T.size,
                        }),
                  Ft = Object.assign({}, p, { headers: Lt }),
                  ni = Ro(at(ct), Mu(h, p.url), Ft);
                (ni.onload = function (Zt) {
                  return xe(ht(Zt, Ft.method));
                }),
                  (ni.onerror = function (Zt) {
                    return k(
                      $i(
                        "error",
                        Zt.status,
                        Ke(Zt.response) || Zt.statusText,
                        Zt.getAllResponseHeaders()
                      )
                    );
                  }),
                  (ni.ontimeout = Oo(k));
              },
              et = function (xe) {
                var ct = Mu(h, $e.url, Xe.serverId),
                  Lt =
                    typeof p.headers == "function"
                      ? p.headers(Xe.serverId)
                      : Object.assign({}, p.headers),
                  Ft = { headers: Lt, method: "HEAD" },
                  ni = Ro(null, ct, Ft);
                (ni.onload = function (Zt) {
                  return xe(ht(Zt, Ft.method));
                }),
                  (ni.onerror = function (Zt) {
                    return k(
                      $i(
                        "error",
                        Zt.status,
                        Ke(Zt.response) || Zt.statusText,
                        Zt.getAllResponseHeaders()
                      )
                    );
                  }),
                  (ni.ontimeout = Oo(k));
              },
              yi = Math.floor(T.size / je),
              vi = 0;
            vi <= yi;
            vi++
          ) {
            var rt = vi * je,
              mt = T.slice(rt, rt + je, "application/offset+octet-stream");
            oe[vi] = {
              index: vi,
              size: mt.size,
              offset: rt,
              data: mt,
              file: T,
              progress: 0,
              retries: jf(Ce),
              status: Nr.QUEUED,
              error: null,
              request: null,
              timeout: null,
            };
          }
          var bt = function () {
              return N(Xe.serverId);
            },
            it = function (xe) {
              return xe.status === Nr.QUEUED || xe.status === Nr.ERROR;
            },
            lt = function (xe) {
              if (!Xe.aborted) {
                if (((xe = xe || oe.find(it)), !xe)) {
                  oe.every(function (ui) {
                    return ui.status === Nr.COMPLETE;
                  }) && bt();
                  return;
                }
                (xe.status = Nr.PROCESSING), (xe.progress = null);
                var ct =
                    $e.ondata ||
                    function (ui) {
                      return ui;
                    },
                  Lt =
                    $e.onerror ||
                    function (ui) {
                      return null;
                    },
                  Ft = Mu(h, $e.url, Xe.serverId),
                  ni =
                    typeof $e.headers == "function"
                      ? $e.headers(xe)
                      : Object.assign({}, $e.headers, {
                          "Content-Type": "application/offset+octet-stream",
                          "Upload-Offset": xe.offset,
                          "Upload-Length": T.size,
                          "Upload-Name": T.name,
                        }),
                  Zt = (xe.request = Ro(
                    ct(xe.data),
                    Ft,
                    Object.assign({}, $e, { headers: ni })
                  ));
                (Zt.onload = function () {
                  (xe.status = Nr.COMPLETE), (xe.request = null), mi();
                }),
                  (Zt.onprogress = function (ui, Wl, Pu) {
                    (xe.progress = ui ? Wl : null), xi();
                  }),
                  (Zt.onerror = function (ui) {
                    (xe.status = Nr.ERROR),
                      (xe.request = null),
                      (xe.error = Lt(ui.response) || ui.statusText),
                      Tt(xe) ||
                        k(
                          $i(
                            "error",
                            ui.status,
                            Lt(ui.response) || ui.statusText,
                            ui.getAllResponseHeaders()
                          )
                        );
                  }),
                  (Zt.ontimeout = function (ui) {
                    (xe.status = Nr.ERROR),
                      (xe.request = null),
                      Tt(xe) || Oo(k)(ui);
                  }),
                  (Zt.onabort = function () {
                    (xe.status = Nr.QUEUED), (xe.request = null), G();
                  });
              }
            },
            Tt = function (xe) {
              return xe.retries.length === 0
                ? !1
                : ((xe.status = Nr.WAITING),
                  clearTimeout(xe.timeout),
                  (xe.timeout = setTimeout(function () {
                    lt(xe);
                  }, xe.retries.shift())),
                  !0);
            },
            xi = function () {
              var xe = oe.reduce(function (Lt, Ft) {
                return Lt === null || Ft.progress === null
                  ? null
                  : Lt + Ft.progress;
              }, 0);
              if (xe === null) return z(!1, 0, 0);
              var ct = oe.reduce(function (Lt, Ft) {
                return Lt + Ft.size;
              }, 0);
              z(!0, xe, ct);
            },
            mi = function () {
              var xe = oe.filter(function (ct) {
                return ct.status === Nr.PROCESSING;
              }).length;
              xe >= 1 || lt();
            },
            wt = function () {
              oe.forEach(function (xe) {
                clearTimeout(xe.timeout), xe.request && xe.request.abort();
              });
            };
          return (
            Xe.serverId
              ? et(function (Ge) {
                  Xe.aborted ||
                    (oe
                      .filter(function (xe) {
                        return xe.offset < Ge;
                      })
                      .forEach(function (xe) {
                        (xe.status = Nr.COMPLETE), (xe.progress = xe.size);
                      }),
                    mi());
                })
              : Nt(function (Ge) {
                  Xe.aborted || (H(Ge), (Xe.serverId = Ge), mi());
                }),
            {
              abort: function () {
                (Xe.aborted = !0), wt();
              },
            }
          );
        },
        XN = function (h, p, v, T) {
          return function (C, N, k, z, G, H, se) {
            if (!!C) {
              var oe = T.chunkUploads,
                ke = oe && C.size > T.chunkSize,
                $e = oe && (ke || T.chunkForce);
              if (C instanceof Blob && $e)
                return jN(h, p, v, C, N, k, z, G, H, se, T);
              var je =
                  p.ondata ||
                  function (et) {
                    return et;
                  },
                Ce =
                  p.onload ||
                  function (et) {
                    return et;
                  },
                Xe =
                  p.onerror ||
                  function (et) {
                    return null;
                  },
                at =
                  typeof p.headers == "function"
                    ? p.headers(C, N) || {}
                    : Object.assign({}, p.headers),
                ht = Object.assign({}, p, { headers: at }),
                Ke = new FormData();
              V(N) && Ke.append(v, JSON.stringify(N)),
                (C instanceof Blob ? [{ name: null, file: C }] : C).forEach(
                  function (et) {
                    Ke.append(
                      v,
                      et.file,
                      et.name === null
                        ? et.file.name
                        : "" + et.name + et.file.name
                    );
                  }
                );
              var Nt = Ro(je(Ke), Mu(h, p.url), ht);
              return (
                (Nt.onload = function (et) {
                  k(
                    $i(
                      "load",
                      et.status,
                      Ce(et.response),
                      et.getAllResponseHeaders()
                    )
                  );
                }),
                (Nt.onerror = function (et) {
                  z(
                    $i(
                      "error",
                      et.status,
                      Xe(et.response) || et.statusText,
                      et.getAllResponseHeaders()
                    )
                  );
                }),
                (Nt.ontimeout = Oo(z)),
                (Nt.onprogress = G),
                (Nt.onabort = H),
                Nt
              );
            }
          };
        },
        YN = function () {
          var h =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : "",
            p = arguments.length > 1 ? arguments[1] : void 0,
            v = arguments.length > 2 ? arguments[2] : void 0,
            T = arguments.length > 3 ? arguments[3] : void 0;
          return typeof p == "function"
            ? function () {
                for (
                  var C = arguments.length, N = new Array(C), k = 0;
                  k < C;
                  k++
                )
                  N[k] = arguments[k];
                return p.apply(void 0, [v].concat(N, [T]));
              }
            : !p || !Ie(p.url)
            ? null
            : XN(h, p, v, T);
        },
        Au = function () {
          var h =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : "",
            p = arguments.length > 1 ? arguments[1] : void 0;
          if (typeof p == "function") return p;
          if (!p || !Ie(p.url))
            return function (C, N) {
              return N();
            };
          var v =
              p.onload ||
              function (C) {
                return C;
              },
            T =
              p.onerror ||
              function (C) {
                return null;
              };
          return function (C, N, k) {
            var z = Ro(C, h + p.url, p);
            return (
              (z.onload = function (G) {
                N(
                  $i("load", G.status, v(G.response), G.getAllResponseHeaders())
                );
              }),
              (z.onerror = function (G) {
                k(
                  $i(
                    "error",
                    G.status,
                    T(G.response) || G.statusText,
                    G.getAllResponseHeaders()
                  )
                );
              }),
              (z.ontimeout = Oo(k)),
              z
            );
          };
        },
        AT = function () {
          var h =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : 0,
            p =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : 1;
          return h + Math.random() * (p - h);
        },
        KN = function (h) {
          var p =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : 1e3,
            v =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : 0,
            T =
              arguments.length > 3 && arguments[3] !== void 0
                ? arguments[3]
                : 25,
            C =
              arguments.length > 4 && arguments[4] !== void 0
                ? arguments[4]
                : 250,
            N = null,
            k = Date.now(),
            z = function G() {
              var H = Date.now() - k,
                se = AT(T, C);
              H + se > p && (se = H + se - p);
              var oe = H / p;
              if (oe >= 1 || document.hidden) {
                h(1);
                return;
              }
              h(oe), (N = setTimeout(G, se));
            };
          return (
            p > 0 && z(),
            {
              clear: function () {
                clearTimeout(N);
              },
            }
          );
        },
        JN = function (h, p) {
          var v = {
              complete: !1,
              perceivedProgress: 0,
              perceivedPerformanceUpdater: null,
              progress: null,
              timestamp: null,
              perceivedDuration: 0,
              duration: 0,
              request: null,
              response: null,
            },
            T = p.allowMinimumUploadDuration,
            C = function (oe, ke) {
              var $e = function () {
                  v.duration === 0 ||
                    v.progress === null ||
                    H.fire("progress", H.getProgress());
                },
                je = function () {
                  (v.complete = !0), H.fire("load-perceived", v.response.body);
                };
              H.fire("start"),
                (v.timestamp = Date.now()),
                (v.perceivedPerformanceUpdater = KN(
                  function (Ce) {
                    (v.perceivedProgress = Ce),
                      (v.perceivedDuration = Date.now() - v.timestamp),
                      $e(),
                      v.response &&
                        v.perceivedProgress === 1 &&
                        !v.complete &&
                        je();
                  },
                  T ? AT(750, 1500) : 0
                )),
                (v.request = h(
                  oe,
                  ke,
                  function (Ce) {
                    (v.response = V(Ce)
                      ? Ce
                      : {
                          type: "load",
                          code: 200,
                          body: "" + Ce,
                          headers: {},
                        }),
                      (v.duration = Date.now() - v.timestamp),
                      (v.progress = 1),
                      H.fire("load", v.response.body),
                      (!T || (T && v.perceivedProgress === 1)) && je();
                  },
                  function (Ce) {
                    v.perceivedPerformanceUpdater.clear(),
                      H.fire(
                        "error",
                        V(Ce) ? Ce : { type: "error", code: 0, body: "" + Ce }
                      );
                  },
                  function (Ce, Xe, at) {
                    (v.duration = Date.now() - v.timestamp),
                      (v.progress = Ce ? Xe / at : null),
                      $e();
                  },
                  function () {
                    v.perceivedPerformanceUpdater.clear(),
                      H.fire("abort", v.response ? v.response.body : null);
                  },
                  function (Ce) {
                    H.fire("transfer", Ce);
                  }
                ));
            },
            N = function () {
              !v.request ||
                (v.perceivedPerformanceUpdater.clear(),
                v.request.abort && v.request.abort(),
                (v.complete = !0));
            },
            k = function () {
              N(),
                (v.complete = !1),
                (v.perceivedProgress = 0),
                (v.progress = 0),
                (v.timestamp = null),
                (v.perceivedDuration = 0),
                (v.duration = 0),
                (v.request = null),
                (v.response = null);
            },
            z = T
              ? function () {
                  return v.progress
                    ? Math.min(v.progress, v.perceivedProgress)
                    : null;
                }
              : function () {
                  return v.progress || null;
                },
            G = T
              ? function () {
                  return Math.min(v.duration, v.perceivedDuration);
                }
              : function () {
                  return v.duration;
                },
            H = Object.assign({}, Xf(), {
              process: C,
              abort: N,
              getProgress: z,
              getDuration: G,
              reset: k,
            });
          return H;
        },
        CT = function (h) {
          return h.substring(0, h.lastIndexOf(".")) || h;
        },
        ZN = function (h) {
          var p = [h.name, h.size, h.type];
          return (
            h instanceof Blob || Ng(h)
              ? (p[0] = h.name || ET())
              : Ng(h)
              ? ((p[1] = h.length), (p[2] = ST(h)))
              : Ie(h) &&
                ((p[0] = Su(h)),
                (p[1] = 0),
                (p[2] = "application/octet-stream")),
            { name: p[0], size: p[1], type: p[2] }
          );
        },
        Gl = function (h) {
          return !!(h instanceof File || (h instanceof Blob && h.name));
        },
        QN = function S(h) {
          if (!V(h)) return h;
          var p = kt(h) ? [] : {};
          for (var v in h)
            if (!!h.hasOwnProperty(v)) {
              var T = h[v];
              p[v] = T && V(T) ? S(T) : T;
            }
          return p;
        },
        e3 = function () {
          var h =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : null,
            p =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : null,
            v =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : null,
            T = gi(),
            C = {
              archived: !1,
              frozen: !1,
              released: !1,
              source: null,
              file: v,
              serverFileReference: p,
              transferId: null,
              processingAborted: !1,
              status: p ? Ot.PROCESSING_COMPLETE : Ot.INIT,
              activeLoader: null,
              activeProcessor: null,
            },
            N = null,
            k = {},
            z = function (mt) {
              return (C.status = mt);
            },
            G = function (mt) {
              if (!(C.released || C.frozen)) {
                for (
                  var bt = arguments.length,
                    it = new Array(bt > 1 ? bt - 1 : 0),
                    lt = 1;
                  lt < bt;
                  lt++
                )
                  it[lt - 1] = arguments[lt];
                yi.fire.apply(yi, [mt].concat(it));
              }
            },
            H = function () {
              return Jf(C.file.name);
            },
            se = function () {
              return C.file.type;
            },
            oe = function () {
              return C.file.size;
            },
            ke = function () {
              return C.file;
            },
            $e = function (mt, bt, it) {
              if (((C.source = mt), yi.fireSync("init"), C.file)) {
                yi.fireSync("load-skip");
                return;
              }
              (C.file = ZN(mt)),
                bt.on("init", function () {
                  G("load-init");
                }),
                bt.on("meta", function (lt) {
                  (C.file.size = lt.size),
                    (C.file.filename = lt.filename),
                    lt.source &&
                      ((h = on.LIMBO),
                      (C.serverFileReference = lt.source),
                      (C.status = Ot.PROCESSING_COMPLETE)),
                    G("load-meta");
                }),
                bt.on("progress", function (lt) {
                  z(Ot.LOADING), G("load-progress", lt);
                }),
                bt.on("error", function (lt) {
                  z(Ot.LOAD_ERROR), G("load-request-error", lt);
                }),
                bt.on("abort", function () {
                  z(Ot.INIT), G("load-abort");
                }),
                bt.on("load", function (lt) {
                  C.activeLoader = null;
                  var Tt = function (wt) {
                      (C.file = Gl(wt) ? wt : C.file),
                        h === on.LIMBO && C.serverFileReference
                          ? z(Ot.PROCESSING_COMPLETE)
                          : z(Ot.IDLE),
                        G("load");
                    },
                    xi = function (wt) {
                      (C.file = lt),
                        G("load-meta"),
                        z(Ot.LOAD_ERROR),
                        G("load-file-error", wt);
                    };
                  if (C.serverFileReference) {
                    Tt(lt);
                    return;
                  }
                  it(lt, Tt, xi);
                }),
                bt.setSource(mt),
                (C.activeLoader = bt),
                bt.load();
            },
            je = function () {
              !C.activeLoader || C.activeLoader.load();
            },
            Ce = function () {
              if (C.activeLoader) {
                C.activeLoader.abort();
                return;
              }
              z(Ot.INIT), G("load-abort");
            },
            Xe = function rt(mt, bt) {
              if (C.processingAborted) {
                C.processingAborted = !1;
                return;
              }
              if ((z(Ot.PROCESSING), (N = null), !(C.file instanceof Blob))) {
                yi.on("load", function () {
                  rt(mt, bt);
                });
                return;
              }
              mt.on("load", function (Tt) {
                (C.transferId = null), (C.serverFileReference = Tt);
              }),
                mt.on("transfer", function (Tt) {
                  C.transferId = Tt;
                }),
                mt.on("load-perceived", function (Tt) {
                  (C.activeProcessor = null),
                    (C.transferId = null),
                    (C.serverFileReference = Tt),
                    z(Ot.PROCESSING_COMPLETE),
                    G("process-complete", Tt);
                }),
                mt.on("start", function () {
                  G("process-start");
                }),
                mt.on("error", function (Tt) {
                  (C.activeProcessor = null),
                    z(Ot.PROCESSING_ERROR),
                    G("process-error", Tt);
                }),
                mt.on("abort", function (Tt) {
                  (C.activeProcessor = null),
                    (C.serverFileReference = Tt),
                    z(Ot.IDLE),
                    G("process-abort"),
                    N && N();
                }),
                mt.on("progress", function (Tt) {
                  G("process-progress", Tt);
                });
              var it = function (xi) {
                  C.archived || mt.process(xi, Object.assign({}, k));
                },
                lt = console.error;
              bt(C.file, it, lt), (C.activeProcessor = mt);
            },
            at = function () {
              (C.processingAborted = !1), z(Ot.PROCESSING_QUEUED);
            },
            ht = function () {
              return new Promise(function (mt) {
                if (!C.activeProcessor) {
                  (C.processingAborted = !0),
                    z(Ot.IDLE),
                    G("process-abort"),
                    mt();
                  return;
                }
                (N = function () {
                  mt();
                }),
                  C.activeProcessor.abort();
              });
            },
            Ke = function (mt, bt) {
              return new Promise(function (it, lt) {
                var Tt =
                  C.serverFileReference !== null
                    ? C.serverFileReference
                    : C.transferId;
                if (Tt === null) {
                  it();
                  return;
                }
                mt(
                  Tt,
                  function () {
                    (C.serverFileReference = null), (C.transferId = null), it();
                  },
                  function (xi) {
                    if (!bt) {
                      it();
                      return;
                    }
                    z(Ot.PROCESSING_REVERT_ERROR),
                      G("process-revert-error"),
                      lt(xi);
                  }
                ),
                  z(Ot.IDLE),
                  G("process-revert");
              });
            },
            Nt = function (mt, bt, it) {
              var lt = mt.split("."),
                Tt = lt[0],
                xi = lt.pop(),
                mi = k;
              lt.forEach(function (wt) {
                return (mi = mi[wt]);
              }),
                JSON.stringify(mi[xi]) !== JSON.stringify(bt) &&
                  ((mi[xi] = bt),
                  G("metadata-update", { key: Tt, value: k[Tt], silent: it }));
            },
            et = function (mt) {
              return QN(mt ? k[mt] : k);
            },
            yi = Object.assign(
              {
                id: {
                  get: function () {
                    return T;
                  },
                },
                origin: {
                  get: function () {
                    return h;
                  },
                  set: function (mt) {
                    return (h = mt);
                  },
                },
                serverId: {
                  get: function () {
                    return C.serverFileReference;
                  },
                },
                transferId: {
                  get: function () {
                    return C.transferId;
                  },
                },
                status: {
                  get: function () {
                    return C.status;
                  },
                },
                filename: {
                  get: function () {
                    return C.file.name;
                  },
                },
                filenameWithoutExtension: {
                  get: function () {
                    return CT(C.file.name);
                  },
                },
                fileExtension: { get: H },
                fileType: { get: se },
                fileSize: { get: oe },
                file: { get: ke },
                relativePath: {
                  get: function () {
                    return C.file._relativePath;
                  },
                },
                source: {
                  get: function () {
                    return C.source;
                  },
                },
                getMetadata: et,
                setMetadata: function (mt, bt, it) {
                  if (V(mt)) {
                    var lt = mt;
                    return (
                      Object.keys(lt).forEach(function (Tt) {
                        Nt(Tt, lt[Tt], bt);
                      }),
                      mt
                    );
                  }
                  return Nt(mt, bt, it), bt;
                },
                extend: function (mt, bt) {
                  return (vi[mt] = bt);
                },
                abortLoad: Ce,
                retryLoad: je,
                requestProcessing: at,
                abortProcessing: ht,
                load: $e,
                process: Xe,
                revert: Ke,
              },
              Xf(),
              {
                freeze: function () {
                  return (C.frozen = !0);
                },
                release: function () {
                  return (C.released = !0);
                },
                released: {
                  get: function () {
                    return C.released;
                  },
                },
                archive: function () {
                  return (C.archived = !0);
                },
                archived: {
                  get: function () {
                    return C.archived;
                  },
                },
              }
            ),
            vi = s(yi);
          return vi;
        },
        t3 = function (h, p) {
          return Et(p)
            ? 0
            : Ie(p)
            ? h.findIndex(function (v) {
                return v.id === p;
              })
            : -1;
        },
        PT = function (h, p) {
          var v = t3(h, p);
          if (!(v < 0)) return h[v] || null;
        },
        DT = function (h, p, v, T, C, N) {
          var k = Ro(null, h, { method: "GET", responseType: "blob" });
          return (
            (k.onload = function (z) {
              var G = z.getAllResponseHeaders(),
                H = kg(G).name || Su(h);
              p($i("load", z.status, Vl(z.response, H), G));
            }),
            (k.onerror = function (z) {
              v($i("error", z.status, z.statusText, z.getAllResponseHeaders()));
            }),
            (k.onheaders = function (z) {
              N($i("headers", z.status, null, z.getAllResponseHeaders()));
            }),
            (k.ontimeout = Oo(v)),
            (k.onprogress = T),
            (k.onabort = C),
            k
          );
        },
        IT = function (h) {
          return (
            h.indexOf("//") === 0 && (h = location.protocol + h),
            h
              .toLowerCase()
              .replace("blob:", "")
              .replace(/([a-z])?:\/\//, "$1")
              .split("/")[0]
          );
        },
        i3 = function (h) {
          return (
            (h.indexOf(":") > -1 || h.indexOf("//") > -1) &&
            IT(location.href) !== IT(h)
          );
        },
        Zf = function (h) {
          return function () {
            return re(h) ? h.apply(void 0, arguments) : h;
          };
        },
        n3 = function (h) {
          return !Gl(h.file);
        },
        Bg = function (h, p) {
          clearTimeout(p.listUpdateTimeout),
            (p.listUpdateTimeout = setTimeout(function () {
              h("DID_UPDATE_ITEMS", { items: ss(p.items) });
            }, 0));
        },
        LT = function (h) {
          for (
            var p = arguments.length, v = new Array(p > 1 ? p - 1 : 0), T = 1;
            T < p;
            T++
          )
            v[T - 1] = arguments[T];
          return new Promise(function (C) {
            if (!h) return C(!0);
            var N = h.apply(void 0, v);
            if (N == null) return C(!0);
            if (typeof N == "boolean") return C(N);
            typeof N.then == "function" && N.then(C);
          });
        },
        zg = function (h, p) {
          h.items.sort(function (v, T) {
            return p(Jn(v), Jn(T));
          });
        },
        kr = function (h, p) {
          return function () {
            var v =
                arguments.length > 0 && arguments[0] !== void 0
                  ? arguments[0]
                  : {},
              T = v.query,
              C = v.success,
              N = C === void 0 ? function () {} : C,
              k = v.failure,
              z = k === void 0 ? function () {} : k,
              G = Bn(v, ["query", "success", "failure"]),
              H = Lo(h.items, T);
            if (!H) {
              z({ error: $i("error", 0, "Item not found"), file: null });
              return;
            }
            p(H, N, z, G || {});
          };
        },
        r3 = function (h, p, v) {
          return {
            ABORT_ALL: function () {
              ss(v.items).forEach(function (C) {
                C.freeze(), C.abortLoad(), C.abortProcessing();
              });
            },
            DID_SET_FILES: function (C) {
              var N = C.value,
                k = N === void 0 ? [] : N,
                z = k.map(function (H) {
                  return {
                    source: H.source ? H.source : H,
                    options: H.options,
                  };
                }),
                G = ss(v.items);
              G.forEach(function (H) {
                z.find(function (se) {
                  return se.source === H.source || se.source === H.file;
                }) || h("REMOVE_ITEM", { query: H, remove: !1 });
              }),
                (G = ss(v.items)),
                z.forEach(function (H, se) {
                  G.find(function (oe) {
                    return oe.source === H.source || oe.file === H.source;
                  }) ||
                    h(
                      "ADD_ITEM",
                      Object.assign({}, H, {
                        interactionMethod: zt.NONE,
                        index: se,
                      })
                    );
                });
            },
            DID_UPDATE_ITEM_METADATA: function (C) {
              var N = C.id,
                k = C.action,
                z = C.change;
              z.silent ||
                (clearTimeout(v.itemUpdateTimeout),
                (v.itemUpdateTimeout = setTimeout(function () {
                  var G = PT(v.items, N);
                  if (!p("IS_ASYNC")) {
                    rs("SHOULD_PREPARE_OUTPUT", !1, {
                      item: G,
                      query: p,
                      action: k,
                      change: z,
                    }).then(function (ke) {
                      var $e = p("GET_BEFORE_PREPARE_FILE");
                      $e && (ke = $e(G, ke)),
                        ke &&
                          h(
                            "REQUEST_PREPARE_OUTPUT",
                            {
                              query: N,
                              item: G,
                              success: function (Ce) {
                                h("DID_PREPARE_OUTPUT", { id: N, file: Ce });
                              },
                            },
                            !0
                          );
                    });
                    return;
                  }
                  G.origin === on.LOCAL &&
                    h("DID_LOAD_ITEM", {
                      id: G.id,
                      error: null,
                      serverFileReference: G.source,
                    });
                  var H = function () {
                      setTimeout(function () {
                        h("REQUEST_ITEM_PROCESSING", { query: N });
                      }, 32);
                    },
                    se = function ($e) {
                      G.revert(
                        Au(v.options.server.url, v.options.server.revert),
                        p("GET_FORCE_REVERT")
                      )
                        .then($e ? H : function () {})
                        .catch(function () {});
                    },
                    oe = function ($e) {
                      G.abortProcessing().then($e ? H : function () {});
                    };
                  if (G.status === Ot.PROCESSING_COMPLETE)
                    return se(v.options.instantUpload);
                  if (G.status === Ot.PROCESSING)
                    return oe(v.options.instantUpload);
                  v.options.instantUpload && H();
                }, 0)));
            },
            MOVE_ITEM: function (C) {
              var N = C.query,
                k = C.index,
                z = Lo(v.items, N);
              if (!!z) {
                var G = v.items.indexOf(z);
                (k = _T(k, 0, v.items.length - 1)),
                  G !== k && v.items.splice(k, 0, v.items.splice(G, 1)[0]);
              }
            },
            SORT: function (C) {
              var N = C.compare;
              zg(v, N), h("DID_SORT_ITEMS", { items: p("GET_ACTIVE_ITEMS") });
            },
            ADD_ITEMS: function (C) {
              var N = C.items,
                k = C.index,
                z = C.interactionMethod,
                G = C.success,
                H = G === void 0 ? function () {} : G,
                se = C.failure,
                oe = se === void 0 ? function () {} : se,
                ke = k;
              if (k === -1 || typeof k == "undefined") {
                var $e = p("GET_ITEM_INSERT_LOCATION"),
                  je = p("GET_TOTAL_ITEMS");
                ke = $e === "before" ? 0 : je;
              }
              var Ce = p("GET_IGNORED_FILES"),
                Xe = function (Nt) {
                  return Gl(Nt) ? !Ce.includes(Nt.name.toLowerCase()) : !Et(Nt);
                },
                at = N.filter(Xe),
                ht = at.map(function (Ke) {
                  return new Promise(function (Nt, et) {
                    h("ADD_ITEM", {
                      interactionMethod: z,
                      source: Ke.source || Ke,
                      success: Nt,
                      failure: et,
                      index: ke++,
                      options: Ke.options || {},
                    });
                  });
                });
              Promise.all(ht).then(H).catch(oe);
            },
            ADD_ITEM: function (C) {
              var N = C.source,
                k = C.index,
                z = k === void 0 ? -1 : k,
                G = C.interactionMethod,
                H = C.success,
                se = H === void 0 ? function () {} : H,
                oe = C.failure,
                ke = oe === void 0 ? function () {} : oe,
                $e = C.options,
                je = $e === void 0 ? {} : $e;
              if (Et(N)) {
                ke({ error: $i("error", 0, "No source"), file: null });
                return;
              }
              if (
                !(
                  Gl(N) && v.options.ignoredFiles.includes(N.name.toLowerCase())
                )
              ) {
                if (!RN(v)) {
                  if (
                    v.options.allowMultiple ||
                    (!v.options.allowMultiple && !v.options.allowReplace)
                  ) {
                    var Ce = $i("warning", 0, "Max files");
                    h("DID_THROW_MAX_FILES", { source: N, error: Ce }),
                      ke({ error: Ce, file: null });
                    return;
                  }
                  var Xe = ss(v.items)[0];
                  if (
                    Xe.status === Ot.PROCESSING_COMPLETE ||
                    Xe.status === Ot.PROCESSING_REVERT_ERROR
                  ) {
                    var at = p("GET_FORCE_REVERT");
                    if (
                      (Xe.revert(
                        Au(v.options.server.url, v.options.server.revert),
                        at
                      )
                        .then(function () {
                          !at ||
                            h("ADD_ITEM", {
                              source: N,
                              index: z,
                              interactionMethod: G,
                              success: se,
                              failure: ke,
                              options: je,
                            });
                        })
                        .catch(function () {}),
                      at)
                    )
                      return;
                  }
                  h("REMOVE_ITEM", { query: Xe.id });
                }
                var ht =
                    je.type === "local"
                      ? on.LOCAL
                      : je.type === "limbo"
                      ? on.LIMBO
                      : on.INPUT,
                  Ke = e3(ht, ht === on.INPUT ? null : N, je.file);
                Object.keys(je.metadata || {}).forEach(function (it) {
                  Ke.setMetadata(it, je.metadata[it]);
                }),
                  Io("DID_CREATE_ITEM", Ke, { query: p, dispatch: h });
                var Nt = p("GET_ITEM_INSERT_LOCATION");
                v.options.itemInsertLocationFreedom ||
                  (z = Nt === "before" ? -1 : v.items.length),
                  NN(v.items, Ke, z),
                  re(Nt) && N && zg(v, Nt);
                var et = Ke.id;
                Ke.on("init", function () {
                  h("DID_INIT_ITEM", { id: et });
                }),
                  Ke.on("load-init", function () {
                    h("DID_START_ITEM_LOAD", { id: et });
                  }),
                  Ke.on("load-meta", function () {
                    h("DID_UPDATE_ITEM_META", { id: et });
                  }),
                  Ke.on("load-progress", function (it) {
                    h("DID_UPDATE_ITEM_LOAD_PROGRESS", {
                      id: et,
                      progress: it,
                    });
                  }),
                  Ke.on("load-request-error", function (it) {
                    var lt = Zf(v.options.labelFileLoadError)(it);
                    if (it.code >= 400 && it.code < 500) {
                      h("DID_THROW_ITEM_INVALID", {
                        id: et,
                        error: it,
                        status: {
                          main: lt,
                          sub: it.code + " (" + it.body + ")",
                        },
                      }),
                        ke({ error: it, file: Jn(Ke) });
                      return;
                    }
                    h("DID_THROW_ITEM_LOAD_ERROR", {
                      id: et,
                      error: it,
                      status: { main: lt, sub: v.options.labelTapToRetry },
                    });
                  }),
                  Ke.on("load-file-error", function (it) {
                    h("DID_THROW_ITEM_INVALID", {
                      id: et,
                      error: it.status,
                      status: it.status,
                    }),
                      ke({ error: it.status, file: Jn(Ke) });
                  }),
                  Ke.on("load-abort", function () {
                    h("REMOVE_ITEM", { query: et });
                  }),
                  Ke.on("load-skip", function () {
                    h("COMPLETE_LOAD_ITEM", {
                      query: et,
                      item: Ke,
                      data: { source: N, success: se },
                    });
                  }),
                  Ke.on("load", function () {
                    var it = function (Tt) {
                      if (!Tt) {
                        h("REMOVE_ITEM", { query: et });
                        return;
                      }
                      Ke.on("metadata-update", function (xi) {
                        h("DID_UPDATE_ITEM_METADATA", { id: et, change: xi });
                      }),
                        rs("SHOULD_PREPARE_OUTPUT", !1, {
                          item: Ke,
                          query: p,
                        }).then(function (xi) {
                          var mi = p("GET_BEFORE_PREPARE_FILE");
                          mi && (xi = mi(Ke, xi));
                          var wt = function () {
                            h("COMPLETE_LOAD_ITEM", {
                              query: et,
                              item: Ke,
                              data: { source: N, success: se },
                            }),
                              Bg(h, v);
                          };
                          if (xi) {
                            h(
                              "REQUEST_PREPARE_OUTPUT",
                              {
                                query: et,
                                item: Ke,
                                success: function (xe) {
                                  h("DID_PREPARE_OUTPUT", { id: et, file: xe }),
                                    wt();
                                },
                              },
                              !0
                            );
                            return;
                          }
                          wt();
                        });
                    };
                    rs("DID_LOAD_ITEM", Ke, { query: p, dispatch: h })
                      .then(function () {
                        LT(p("GET_BEFORE_ADD_FILE"), Jn(Ke)).then(it);
                      })
                      .catch(function (lt) {
                        if (!lt || !lt.error || !lt.status) return it(!1);
                        h("DID_THROW_ITEM_INVALID", {
                          id: et,
                          error: lt.error,
                          status: lt.status,
                        });
                      });
                  }),
                  Ke.on("process-start", function () {
                    h("DID_START_ITEM_PROCESSING", { id: et });
                  }),
                  Ke.on("process-progress", function (it) {
                    h("DID_UPDATE_ITEM_PROCESS_PROGRESS", {
                      id: et,
                      progress: it,
                    });
                  }),
                  Ke.on("process-error", function (it) {
                    h("DID_THROW_ITEM_PROCESSING_ERROR", {
                      id: et,
                      error: it,
                      status: {
                        main: Zf(v.options.labelFileProcessingError)(it),
                        sub: v.options.labelTapToRetry,
                      },
                    });
                  }),
                  Ke.on("process-revert-error", function (it) {
                    h("DID_THROW_ITEM_PROCESSING_REVERT_ERROR", {
                      id: et,
                      error: it,
                      status: {
                        main: Zf(v.options.labelFileProcessingRevertError)(it),
                        sub: v.options.labelTapToRetry,
                      },
                    });
                  }),
                  Ke.on("process-complete", function (it) {
                    h("DID_COMPLETE_ITEM_PROCESSING", {
                      id: et,
                      error: null,
                      serverFileReference: it,
                    }),
                      h("DID_DEFINE_VALUE", { id: et, value: it });
                  }),
                  Ke.on("process-abort", function () {
                    h("DID_ABORT_ITEM_PROCESSING", { id: et });
                  }),
                  Ke.on("process-revert", function () {
                    h("DID_REVERT_ITEM_PROCESSING", { id: et }),
                      h("DID_DEFINE_VALUE", { id: et, value: null });
                  }),
                  h("DID_ADD_ITEM", { id: et, index: z, interactionMethod: G }),
                  Bg(h, v);
                var yi = v.options.server || {},
                  vi = yi.url,
                  rt = yi.load,
                  mt = yi.restore,
                  bt = yi.fetch;
                Ke.load(
                  N,
                  qN(
                    ht === on.INPUT
                      ? Ie(N) && i3(N) && bt
                        ? Fg(vi, bt)
                        : DT
                      : ht === on.LIMBO
                      ? Fg(vi, mt)
                      : Fg(vi, rt)
                  ),
                  function (it, lt, Tt) {
                    rs("LOAD_FILE", it, { query: p }).then(lt).catch(Tt);
                  }
                );
              }
            },
            REQUEST_PREPARE_OUTPUT: function (C) {
              var N = C.item,
                k = C.success,
                z = C.failure,
                G = z === void 0 ? function () {} : z,
                H = { error: $i("error", 0, "Item not found"), file: null };
              if (N.archived) return G(H);
              rs("PREPARE_OUTPUT", N.file, { query: p, item: N }).then(
                function (se) {
                  rs("COMPLETE_PREPARE_OUTPUT", se, { query: p, item: N }).then(
                    function (oe) {
                      if (N.archived) return G(H);
                      k(oe);
                    }
                  );
                }
              );
            },
            COMPLETE_LOAD_ITEM: function (C) {
              var N = C.item,
                k = C.data,
                z = k.success,
                G = k.source,
                H = p("GET_ITEM_INSERT_LOCATION");
              if (
                (re(H) && G && zg(v, H),
                h("DID_LOAD_ITEM", {
                  id: N.id,
                  error: null,
                  serverFileReference: N.origin === on.INPUT ? null : G,
                }),
                z(Jn(N)),
                N.origin === on.LOCAL)
              ) {
                h("DID_LOAD_LOCAL_ITEM", { id: N.id });
                return;
              }
              if (N.origin === on.LIMBO) {
                h("DID_COMPLETE_ITEM_PROCESSING", {
                  id: N.id,
                  error: null,
                  serverFileReference: G,
                }),
                  h("DID_DEFINE_VALUE", { id: N.id, value: N.serverId || G });
                return;
              }
              p("IS_ASYNC") &&
                v.options.instantUpload &&
                h("REQUEST_ITEM_PROCESSING", { query: N.id });
            },
            RETRY_ITEM_LOAD: kr(v, function (T) {
              T.retryLoad();
            }),
            REQUEST_ITEM_PREPARE: kr(v, function (T, C, N) {
              h(
                "REQUEST_PREPARE_OUTPUT",
                {
                  query: T.id,
                  item: T,
                  success: function (z) {
                    h("DID_PREPARE_OUTPUT", { id: T.id, file: z }),
                      C({ file: T, output: z });
                  },
                  failure: N,
                },
                !0
              );
            }),
            REQUEST_ITEM_PROCESSING: kr(v, function (T, C, N) {
              var k = T.status === Ot.IDLE || T.status === Ot.PROCESSING_ERROR;
              if (!k) {
                var z = function () {
                    return h("REQUEST_ITEM_PROCESSING", {
                      query: T,
                      success: C,
                      failure: N,
                    });
                  },
                  G = function () {
                    return document.hidden ? z() : setTimeout(z, 32);
                  };
                T.status === Ot.PROCESSING_COMPLETE ||
                T.status === Ot.PROCESSING_REVERT_ERROR
                  ? T.revert(
                      Au(v.options.server.url, v.options.server.revert),
                      p("GET_FORCE_REVERT")
                    )
                      .then(G)
                      .catch(function () {})
                  : T.status === Ot.PROCESSING && T.abortProcessing().then(G);
                return;
              }
              T.status !== Ot.PROCESSING_QUEUED &&
                (T.requestProcessing(),
                h("DID_REQUEST_ITEM_PROCESSING", { id: T.id }),
                h("PROCESS_ITEM", { query: T, success: C, failure: N }, !0));
            }),
            PROCESS_ITEM: kr(v, function (T, C, N) {
              var k = p("GET_MAX_PARALLEL_UPLOADS"),
                z = p("GET_ITEMS_BY_STATUS", Ot.PROCESSING).length;
              if (z === k) {
                v.processingQueue.push({ id: T.id, success: C, failure: N });
                return;
              }
              if (T.status !== Ot.PROCESSING) {
                var G = function se() {
                  var oe = v.processingQueue.shift();
                  if (!!oe) {
                    var ke = oe.id,
                      $e = oe.success,
                      je = oe.failure,
                      Ce = Lo(v.items, ke);
                    if (!Ce || Ce.archived) {
                      se();
                      return;
                    }
                    h(
                      "PROCESS_ITEM",
                      { query: ke, success: $e, failure: je },
                      !0
                    );
                  }
                };
                T.onOnce("process-complete", function () {
                  C(Jn(T)), G();
                  var se = v.options.server,
                    oe = v.options.instantUpload;
                  if (oe && T.origin === on.LOCAL && re(se.remove)) {
                    var ke = function () {};
                    (T.origin = on.LIMBO),
                      v.options.server.remove(T.source, ke, ke);
                  }
                  var $e =
                    p("GET_ITEMS_BY_STATUS", Ot.PROCESSING_COMPLETE).length ===
                    v.items.length;
                  $e && h("DID_COMPLETE_ITEM_PROCESSING_ALL");
                }),
                  T.onOnce("process-error", function (se) {
                    N({ error: se, file: Jn(T) }), G();
                  });
                var H = v.options;
                T.process(
                  JN(
                    YN(H.server.url, H.server.process, H.name, {
                      chunkTransferId: T.transferId,
                      chunkServer: H.server.patch,
                      chunkUploads: H.chunkUploads,
                      chunkForce: H.chunkForce,
                      chunkSize: H.chunkSize,
                      chunkRetryDelays: H.chunkRetryDelays,
                    }),
                    {
                      allowMinimumUploadDuration: p(
                        "GET_ALLOW_MINIMUM_UPLOAD_DURATION"
                      ),
                    }
                  ),
                  function (se, oe, ke) {
                    rs("PREPARE_OUTPUT", se, { query: p, item: T })
                      .then(function ($e) {
                        h("DID_PREPARE_OUTPUT", { id: T.id, file: $e }), oe($e);
                      })
                      .catch(ke);
                  }
                );
              }
            }),
            RETRY_ITEM_PROCESSING: kr(v, function (T) {
              h("REQUEST_ITEM_PROCESSING", { query: T });
            }),
            REQUEST_REMOVE_ITEM: kr(v, function (T) {
              LT(p("GET_BEFORE_REMOVE_FILE"), Jn(T)).then(function (C) {
                !C || h("REMOVE_ITEM", { query: T });
              });
            }),
            RELEASE_ITEM: kr(v, function (T) {
              T.release();
            }),
            REMOVE_ITEM: kr(v, function (T, C, N, k) {
              var z = function () {
                  var se = T.id;
                  PT(v.items, se).archive(),
                    h("DID_REMOVE_ITEM", { error: null, id: se, item: T }),
                    Bg(h, v),
                    C(Jn(T));
                },
                G = v.options.server;
              T.origin === on.LOCAL && G && re(G.remove) && k.remove !== !1
                ? (h("DID_START_ITEM_REMOVE", { id: T.id }),
                  G.remove(
                    T.source,
                    function () {
                      return z();
                    },
                    function (H) {
                      h("DID_THROW_ITEM_REMOVE_ERROR", {
                        id: T.id,
                        error: $i("error", 0, H, null),
                        status: {
                          main: Zf(v.options.labelFileRemoveError)(H),
                          sub: v.options.labelTapToRetry,
                        },
                      });
                    }
                  ))
                : (((k.revert &&
                    T.origin !== on.LOCAL &&
                    T.serverId !== null) ||
                    (v.options.chunkUploads &&
                      T.file.size > v.options.chunkSize) ||
                    (v.options.chunkUploads && v.options.chunkForce)) &&
                    T.revert(
                      Au(v.options.server.url, v.options.server.revert),
                      p("GET_FORCE_REVERT")
                    ),
                  z());
            }),
            ABORT_ITEM_LOAD: kr(v, function (T) {
              T.abortLoad();
            }),
            ABORT_ITEM_PROCESSING: kr(v, function (T) {
              if (T.serverId) {
                h("REVERT_ITEM_PROCESSING", { id: T.id });
                return;
              }
              T.abortProcessing().then(function () {
                var C = v.options.instantUpload;
                C && h("REMOVE_ITEM", { query: T.id });
              });
            }),
            REQUEST_REVERT_ITEM_PROCESSING: kr(v, function (T) {
              if (!v.options.instantUpload) {
                h("REVERT_ITEM_PROCESSING", { query: T });
                return;
              }
              var C = function (G) {
                  !G || h("REVERT_ITEM_PROCESSING", { query: T });
                },
                N = p("GET_BEFORE_REMOVE_FILE");
              if (!N) return C(!0);
              var k = N(Jn(T));
              if (k == null) return C(!0);
              if (typeof k == "boolean") return C(k);
              typeof k.then == "function" && k.then(C);
            }),
            REVERT_ITEM_PROCESSING: kr(v, function (T) {
              T.revert(
                Au(v.options.server.url, v.options.server.revert),
                p("GET_FORCE_REVERT")
              )
                .then(function () {
                  var C = v.options.instantUpload || n3(T);
                  C && h("REMOVE_ITEM", { query: T.id });
                })
                .catch(function () {});
            }),
            SET_OPTIONS: function (C) {
              var N = C.options,
                k = Object.keys(N),
                z = s3.filter(function (H) {
                  return k.includes(H);
                }),
                G = [].concat(
                  jf(z),
                  jf(
                    Object.keys(N).filter(function (H) {
                      return !z.includes(H);
                    })
                  )
                );
              G.forEach(function (H) {
                h("SET_" + Le(H, "_").toUpperCase(), { value: N[H] });
              });
            },
          };
        },
        s3 = ["server"],
        Ug = function (h) {
          return h;
        },
        Bs = function (h) {
          return document.createElement(h);
        },
        Wi = function (h, p) {
          var v = h.childNodes[0];
          v
            ? p !== v.nodeValue && (v.nodeValue = p)
            : ((v = document.createTextNode(p)), h.appendChild(v));
        },
        RT = function (h, p, v, T) {
          var C = (((T % 360) - 90) * Math.PI) / 180;
          return { x: h + v * Math.cos(C), y: p + v * Math.sin(C) };
        },
        a3 = function (h, p, v, T, C, N) {
          var k = RT(h, p, v, C),
            z = RT(h, p, v, T);
          return ["M", k.x, k.y, "A", v, v, 0, N, 0, z.x, z.y].join(" ");
        },
        o3 = function (h, p, v, T, C) {
          var N = 1;
          return (
            C > T && C - T <= 0.5 && (N = 0),
            T > C && T - C >= 0.5 && (N = 0),
            a3(h, p, v, Math.min(0.9999, T) * 360, Math.min(0.9999, C) * 360, N)
          );
        },
        l3 = function (h) {
          var p = h.root,
            v = h.props;
          (v.spin = !1), (v.progress = 0), (v.opacity = 0);
          var T = u("svg");
          (p.ref.path = u("path", {
            "stroke-width": 2,
            "stroke-linecap": "round",
          })),
            T.appendChild(p.ref.path),
            (p.ref.svg = T),
            p.appendChild(T);
        },
        c3 = function (h) {
          var p = h.root,
            v = h.props;
          if (v.opacity !== 0) {
            v.align && (p.element.dataset.align = v.align);
            var T = parseInt(a(p.ref.path, "stroke-width"), 10),
              C = p.rect.element.width * 0.5,
              N = 0,
              k = 0;
            v.spin ? ((N = 0), (k = 0.5)) : ((N = 0), (k = v.progress));
            var z = o3(C, C, C - T, N, k);
            a(p.ref.path, "d", z),
              a(p.ref.path, "stroke-opacity", v.spin || v.progress > 0 ? 1 : 0);
          }
        },
        OT = be({
          tag: "div",
          name: "progress-indicator",
          ignoreRectUpdate: !0,
          ignoreRect: !0,
          create: l3,
          write: c3,
          mixins: {
            apis: ["progress", "spin", "align"],
            styles: ["opacity"],
            animations: {
              opacity: { type: "tween", duration: 500 },
              progress: {
                type: "spring",
                stiffness: 0.95,
                damping: 0.65,
                mass: 10,
              },
            },
          },
        }),
        u3 = function (h) {
          var p = h.root,
            v = h.props;
          (p.element.innerHTML =
            (v.icon || "") + ("<span>" + v.label + "</span>")),
            (v.isDisabled = !1);
        },
        h3 = function (h) {
          var p = h.root,
            v = h.props,
            T = v.isDisabled,
            C = p.query("GET_DISABLED") || v.opacity === 0;
          C && !T
            ? ((v.isDisabled = !0), a(p.element, "disabled", "disabled"))
            : !C &&
              T &&
              ((v.isDisabled = !1), p.element.removeAttribute("disabled"));
        },
        NT = be({
          tag: "button",
          attributes: { type: "button" },
          ignoreRect: !0,
          ignoreRectUpdate: !0,
          name: "file-action-button",
          mixins: {
            apis: ["label"],
            styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity"],
            animations: {
              scaleX: "spring",
              scaleY: "spring",
              translateX: "spring",
              translateY: "spring",
              opacity: { type: "tween", duration: 250 },
            },
            listeners: !0,
          },
          create: u3,
          write: h3,
        }),
        kT = function (h) {
          var p =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : ".",
            v =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : 1e3,
            T =
              arguments.length > 3 && arguments[3] !== void 0
                ? arguments[3]
                : {},
            C = T.labelBytes,
            N = C === void 0 ? "bytes" : C,
            k = T.labelKilobytes,
            z = k === void 0 ? "KB" : k,
            G = T.labelMegabytes,
            H = G === void 0 ? "MB" : G,
            se = T.labelGigabytes,
            oe = se === void 0 ? "GB" : se;
          h = Math.round(Math.abs(h));
          var ke = v,
            $e = v * v,
            je = v * v * v;
          return h < ke
            ? h + " " + N
            : h < $e
            ? Math.floor(h / ke) + " " + z
            : h < je
            ? FT(h / $e, 1, p) + " " + H
            : FT(h / je, 2, p) + " " + oe;
        },
        FT = function (h, p, v) {
          return h
            .toFixed(p)
            .split(".")
            .filter(function (T) {
              return T !== "0";
            })
            .join(v);
        },
        f3 = function (h) {
          var p = h.root,
            v = h.props,
            T = Bs("span");
          (T.className = "filepond--file-info-main"),
            a(T, "aria-hidden", "true"),
            p.appendChild(T),
            (p.ref.fileName = T);
          var C = Bs("span");
          (C.className = "filepond--file-info-sub"),
            p.appendChild(C),
            (p.ref.fileSize = C),
            Wi(C, p.query("GET_LABEL_FILE_WAITING_FOR_SIZE")),
            Wi(T, Ug(p.query("GET_ITEM_NAME", v.id)));
        },
        Vg = function (h) {
          var p = h.root,
            v = h.props;
          Wi(
            p.ref.fileSize,
            kT(
              p.query("GET_ITEM_SIZE", v.id),
              ".",
              p.query("GET_FILE_SIZE_BASE"),
              p.query("GET_FILE_SIZE_LABELS", p.query)
            )
          ),
            Wi(p.ref.fileName, Ug(p.query("GET_ITEM_NAME", v.id)));
        },
        BT = function (h) {
          var p = h.root,
            v = h.props;
          if (B(p.query("GET_ITEM_SIZE", v.id))) {
            Vg({ root: p, props: v });
            return;
          }
          Wi(p.ref.fileSize, p.query("GET_LABEL_FILE_SIZE_NOT_AVAILABLE"));
        },
        d3 = be({
          name: "file-info",
          ignoreRect: !0,
          ignoreRectUpdate: !0,
          write: Ye({
            DID_LOAD_ITEM: Vg,
            DID_UPDATE_ITEM_META: Vg,
            DID_THROW_ITEM_LOAD_ERROR: BT,
            DID_THROW_ITEM_INVALID: BT,
          }),
          didCreateView: function (h) {
            Io("CREATE_VIEW", Object.assign({}, h, { view: h }));
          },
          create: f3,
          mixins: {
            styles: ["translateX", "translateY"],
            animations: { translateX: "spring", translateY: "spring" },
          },
        }),
        zT = function (h) {
          return Math.round(h * 100);
        },
        p3 = function (h) {
          var p = h.root,
            v = Bs("span");
          (v.className = "filepond--file-status-main"),
            p.appendChild(v),
            (p.ref.main = v);
          var T = Bs("span");
          (T.className = "filepond--file-status-sub"),
            p.appendChild(T),
            (p.ref.sub = T),
            UT({ root: p, action: { progress: null } });
        },
        UT = function (h) {
          var p = h.root,
            v = h.action,
            T =
              v.progress === null
                ? p.query("GET_LABEL_FILE_LOADING")
                : p.query("GET_LABEL_FILE_LOADING") +
                  " " +
                  zT(v.progress) +
                  "%";
          Wi(p.ref.main, T), Wi(p.ref.sub, p.query("GET_LABEL_TAP_TO_CANCEL"));
        },
        m3 = function (h) {
          var p = h.root,
            v = h.action,
            T =
              v.progress === null
                ? p.query("GET_LABEL_FILE_PROCESSING")
                : p.query("GET_LABEL_FILE_PROCESSING") +
                  " " +
                  zT(v.progress) +
                  "%";
          Wi(p.ref.main, T), Wi(p.ref.sub, p.query("GET_LABEL_TAP_TO_CANCEL"));
        },
        g3 = function (h) {
          var p = h.root;
          Wi(p.ref.main, p.query("GET_LABEL_FILE_PROCESSING")),
            Wi(p.ref.sub, p.query("GET_LABEL_TAP_TO_CANCEL"));
        },
        y3 = function (h) {
          var p = h.root;
          Wi(p.ref.main, p.query("GET_LABEL_FILE_PROCESSING_ABORTED")),
            Wi(p.ref.sub, p.query("GET_LABEL_TAP_TO_RETRY"));
        },
        v3 = function (h) {
          var p = h.root;
          Wi(p.ref.main, p.query("GET_LABEL_FILE_PROCESSING_COMPLETE")),
            Wi(p.ref.sub, p.query("GET_LABEL_TAP_TO_UNDO"));
        },
        VT = function (h) {
          var p = h.root;
          Wi(p.ref.main, ""), Wi(p.ref.sub, "");
        },
        Cu = function (h) {
          var p = h.root,
            v = h.action;
          Wi(p.ref.main, v.status.main), Wi(p.ref.sub, v.status.sub);
        },
        x3 = be({
          name: "file-status",
          ignoreRect: !0,
          ignoreRectUpdate: !0,
          write: Ye({
            DID_LOAD_ITEM: VT,
            DID_REVERT_ITEM_PROCESSING: VT,
            DID_REQUEST_ITEM_PROCESSING: g3,
            DID_ABORT_ITEM_PROCESSING: y3,
            DID_COMPLETE_ITEM_PROCESSING: v3,
            DID_UPDATE_ITEM_PROCESS_PROGRESS: m3,
            DID_UPDATE_ITEM_LOAD_PROGRESS: UT,
            DID_THROW_ITEM_LOAD_ERROR: Cu,
            DID_THROW_ITEM_INVALID: Cu,
            DID_THROW_ITEM_PROCESSING_ERROR: Cu,
            DID_THROW_ITEM_PROCESSING_REVERT_ERROR: Cu,
            DID_THROW_ITEM_REMOVE_ERROR: Cu,
          }),
          didCreateView: function (h) {
            Io("CREATE_VIEW", Object.assign({}, h, { view: h }));
          },
          create: p3,
          mixins: {
            styles: ["translateX", "translateY", "opacity"],
            animations: {
              opacity: { type: "tween", duration: 250 },
              translateX: "spring",
              translateY: "spring",
            },
          },
        }),
        Gg = {
          AbortItemLoad: {
            label: "GET_LABEL_BUTTON_ABORT_ITEM_LOAD",
            action: "ABORT_ITEM_LOAD",
            className: "filepond--action-abort-item-load",
            align: "LOAD_INDICATOR_POSITION",
          },
          RetryItemLoad: {
            label: "GET_LABEL_BUTTON_RETRY_ITEM_LOAD",
            action: "RETRY_ITEM_LOAD",
            icon: "GET_ICON_RETRY",
            className: "filepond--action-retry-item-load",
            align: "BUTTON_PROCESS_ITEM_POSITION",
          },
          RemoveItem: {
            label: "GET_LABEL_BUTTON_REMOVE_ITEM",
            action: "REQUEST_REMOVE_ITEM",
            icon: "GET_ICON_REMOVE",
            className: "filepond--action-remove-item",
            align: "BUTTON_REMOVE_ITEM_POSITION",
          },
          ProcessItem: {
            label: "GET_LABEL_BUTTON_PROCESS_ITEM",
            action: "REQUEST_ITEM_PROCESSING",
            icon: "GET_ICON_PROCESS",
            className: "filepond--action-process-item",
            align: "BUTTON_PROCESS_ITEM_POSITION",
          },
          AbortItemProcessing: {
            label: "GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING",
            action: "ABORT_ITEM_PROCESSING",
            className: "filepond--action-abort-item-processing",
            align: "BUTTON_PROCESS_ITEM_POSITION",
          },
          RetryItemProcessing: {
            label: "GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING",
            action: "RETRY_ITEM_PROCESSING",
            icon: "GET_ICON_RETRY",
            className: "filepond--action-retry-item-processing",
            align: "BUTTON_PROCESS_ITEM_POSITION",
          },
          RevertItemProcessing: {
            label: "GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING",
            action: "REQUEST_REVERT_ITEM_PROCESSING",
            icon: "GET_ICON_UNDO",
            className: "filepond--action-revert-item-processing",
            align: "BUTTON_PROCESS_ITEM_POSITION",
          },
        },
        Hg = [];
      r(Gg, function (S) {
        Hg.push(S);
      });
      var dr = function (h) {
          if ($g(h) === "right") return 0;
          var p = h.ref.buttonRemoveItem.rect.element;
          return p.hidden ? null : p.width + p.left;
        },
        b3 = function (h) {
          var p = h.ref.buttonAbortItemLoad.rect.element;
          return p.width;
        },
        Qf = function (h) {
          return Math.floor(h.ref.buttonRemoveItem.rect.element.height / 4);
        },
        _3 = function (h) {
          return Math.floor(h.ref.buttonRemoveItem.rect.element.left / 2);
        },
        E3 = function (h) {
          return h.query("GET_STYLE_LOAD_INDICATOR_POSITION");
        },
        T3 = function (h) {
          return h.query("GET_STYLE_PROGRESS_INDICATOR_POSITION");
        },
        $g = function (h) {
          return h.query("GET_STYLE_BUTTON_REMOVE_ITEM_POSITION");
        },
        S3 = {
          buttonAbortItemLoad: { opacity: 0 },
          buttonRetryItemLoad: { opacity: 0 },
          buttonRemoveItem: { opacity: 0 },
          buttonProcessItem: { opacity: 0 },
          buttonAbortItemProcessing: { opacity: 0 },
          buttonRetryItemProcessing: { opacity: 0 },
          buttonRevertItemProcessing: { opacity: 0 },
          loadProgressIndicator: { opacity: 0, align: E3 },
          processProgressIndicator: { opacity: 0, align: T3 },
          processingCompleteIndicator: {
            opacity: 0,
            scaleX: 0.75,
            scaleY: 0.75,
          },
          info: { translateX: 0, translateY: 0, opacity: 0 },
          status: { translateX: 0, translateY: 0, opacity: 0 },
        },
        GT = {
          buttonRemoveItem: { opacity: 1 },
          buttonProcessItem: { opacity: 1 },
          info: { translateX: dr },
          status: { translateX: dr },
        },
        Wg = {
          buttonAbortItemProcessing: { opacity: 1 },
          processProgressIndicator: { opacity: 1 },
          status: { opacity: 1 },
        },
        Hl = {
          DID_THROW_ITEM_INVALID: {
            buttonRemoveItem: { opacity: 1 },
            info: { translateX: dr },
            status: { translateX: dr, opacity: 1 },
          },
          DID_START_ITEM_LOAD: {
            buttonAbortItemLoad: { opacity: 1 },
            loadProgressIndicator: { opacity: 1 },
            status: { opacity: 1 },
          },
          DID_THROW_ITEM_LOAD_ERROR: {
            buttonRetryItemLoad: { opacity: 1 },
            buttonRemoveItem: { opacity: 1 },
            info: { translateX: dr },
            status: { opacity: 1 },
          },
          DID_START_ITEM_REMOVE: {
            processProgressIndicator: { opacity: 1, align: $g },
            info: { translateX: dr },
            status: { opacity: 0 },
          },
          DID_THROW_ITEM_REMOVE_ERROR: {
            processProgressIndicator: { opacity: 0, align: $g },
            buttonRemoveItem: { opacity: 1 },
            info: { translateX: dr },
            status: { opacity: 1, translateX: dr },
          },
          DID_LOAD_ITEM: GT,
          DID_LOAD_LOCAL_ITEM: {
            buttonRemoveItem: { opacity: 1 },
            info: { translateX: dr },
            status: { translateX: dr },
          },
          DID_START_ITEM_PROCESSING: Wg,
          DID_REQUEST_ITEM_PROCESSING: Wg,
          DID_UPDATE_ITEM_PROCESS_PROGRESS: Wg,
          DID_COMPLETE_ITEM_PROCESSING: {
            buttonRevertItemProcessing: { opacity: 1 },
            info: { opacity: 1 },
            status: { opacity: 1 },
          },
          DID_THROW_ITEM_PROCESSING_ERROR: {
            buttonRemoveItem: { opacity: 1 },
            buttonRetryItemProcessing: { opacity: 1 },
            status: { opacity: 1 },
            info: { translateX: dr },
          },
          DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {
            buttonRevertItemProcessing: { opacity: 1 },
            status: { opacity: 1 },
            info: { opacity: 1 },
          },
          DID_ABORT_ITEM_PROCESSING: {
            buttonRemoveItem: { opacity: 1 },
            buttonProcessItem: { opacity: 1 },
            info: { translateX: dr },
            status: { opacity: 1 },
          },
          DID_REVERT_ITEM_PROCESSING: GT,
        },
        w3 = be({
          create: function (h) {
            var p = h.root;
            p.element.innerHTML = p.query("GET_ICON_DONE");
          },
          name: "processing-complete-indicator",
          ignoreRect: !0,
          mixins: {
            styles: ["scaleX", "scaleY", "opacity"],
            animations: {
              scaleX: "spring",
              scaleY: "spring",
              opacity: { type: "tween", duration: 250 },
            },
          },
        }),
        M3 = function (h) {
          var p = h.root,
            v = h.props,
            T = Object.keys(Gg).reduce(function (at, ht) {
              return (at[ht] = Object.assign({}, Gg[ht])), at;
            }, {}),
            C = v.id,
            N = p.query("GET_ALLOW_REVERT"),
            k = p.query("GET_ALLOW_REMOVE"),
            z = p.query("GET_ALLOW_PROCESS"),
            G = p.query("GET_INSTANT_UPLOAD"),
            H = p.query("IS_ASYNC"),
            se = p.query("GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN"),
            oe;
          H
            ? z && !N
              ? (oe = function (ht) {
                  return !/RevertItemProcessing/.test(ht);
                })
              : !z && N
              ? (oe = function (ht) {
                  return !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(
                    ht
                  );
                })
              : !z &&
                !N &&
                (oe = function (ht) {
                  return !/Process/.test(ht);
                })
            : (oe = function (ht) {
                return !/Process/.test(ht);
              });
          var ke = oe ? Hg.filter(oe) : Hg.concat();
          if (
            (G &&
              N &&
              ((T.RevertItemProcessing.label = "GET_LABEL_BUTTON_REMOVE_ITEM"),
              (T.RevertItemProcessing.icon = "GET_ICON_REMOVE")),
            H && !N)
          ) {
            var $e = Hl.DID_COMPLETE_ITEM_PROCESSING;
            ($e.info.translateX = _3),
              ($e.info.translateY = Qf),
              ($e.status.translateY = Qf),
              ($e.processingCompleteIndicator = {
                opacity: 1,
                scaleX: 1,
                scaleY: 1,
              });
          }
          if (
            (H &&
              !z &&
              ([
                "DID_START_ITEM_PROCESSING",
                "DID_REQUEST_ITEM_PROCESSING",
                "DID_UPDATE_ITEM_PROCESS_PROGRESS",
                "DID_THROW_ITEM_PROCESSING_ERROR",
              ].forEach(function (at) {
                Hl[at].status.translateY = Qf;
              }),
              (Hl.DID_THROW_ITEM_PROCESSING_ERROR.status.translateX = b3)),
            se && N)
          ) {
            T.RevertItemProcessing.align = "BUTTON_REMOVE_ITEM_POSITION";
            var je = Hl.DID_COMPLETE_ITEM_PROCESSING;
            (je.info.translateX = dr),
              (je.status.translateY = Qf),
              (je.processingCompleteIndicator = {
                opacity: 1,
                scaleX: 1,
                scaleY: 1,
              });
          }
          k || (T.RemoveItem.disabled = !0),
            r(T, function (at, ht) {
              var Ke = p.createChildView(NT, {
                label: p.query(ht.label),
                icon: p.query(ht.icon),
                opacity: 0,
              });
              ke.includes(at) && p.appendChildView(Ke),
                ht.disabled &&
                  (Ke.element.setAttribute("disabled", "disabled"),
                  Ke.element.setAttribute("hidden", "hidden")),
                (Ke.element.dataset.align = p.query("GET_STYLE_" + ht.align)),
                Ke.element.classList.add(ht.className),
                Ke.on("click", function (Nt) {
                  Nt.stopPropagation(),
                    !ht.disabled && p.dispatch(ht.action, { query: C });
                }),
                (p.ref["button" + at] = Ke);
            }),
            (p.ref.processingCompleteIndicator = p.appendChildView(
              p.createChildView(w3)
            )),
            (p.ref.processingCompleteIndicator.element.dataset.align = p.query(
              "GET_STYLE_BUTTON_PROCESS_ITEM_POSITION"
            )),
            (p.ref.info = p.appendChildView(p.createChildView(d3, { id: C }))),
            (p.ref.status = p.appendChildView(
              p.createChildView(x3, { id: C })
            ));
          var Ce = p.appendChildView(
            p.createChildView(OT, {
              opacity: 0,
              align: p.query("GET_STYLE_LOAD_INDICATOR_POSITION"),
            })
          );
          Ce.element.classList.add("filepond--load-indicator"),
            (p.ref.loadProgressIndicator = Ce);
          var Xe = p.appendChildView(
            p.createChildView(OT, {
              opacity: 0,
              align: p.query("GET_STYLE_PROGRESS_INDICATOR_POSITION"),
            })
          );
          Xe.element.classList.add("filepond--process-indicator"),
            (p.ref.processProgressIndicator = Xe),
            (p.ref.activeStyles = []);
        },
        A3 = function (h) {
          var p = h.root,
            v = h.actions,
            T = h.props;
          C3({ root: p, actions: v, props: T });
          var C = v
            .concat()
            .filter(function (k) {
              return /^DID_/.test(k.type);
            })
            .reverse()
            .find(function (k) {
              return Hl[k.type];
            });
          if (C) {
            p.ref.activeStyles = [];
            var N = Hl[C.type];
            r(S3, function (k, z) {
              var G = p.ref[k];
              r(z, function (H, se) {
                var oe = N[k] && typeof N[k][H] != "undefined" ? N[k][H] : se;
                p.ref.activeStyles.push({ control: G, key: H, value: oe });
              });
            });
          }
          p.ref.activeStyles.forEach(function (k) {
            var z = k.control,
              G = k.key,
              H = k.value;
            z[G] = typeof H == "function" ? H(p) : H;
          });
        },
        C3 = Ye({
          DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: function (h) {
            var p = h.root,
              v = h.action;
            p.ref.buttonAbortItemProcessing.label = v.value;
          },
          DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: function (h) {
            var p = h.root,
              v = h.action;
            p.ref.buttonAbortItemLoad.label = v.value;
          },
          DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: function (h) {
            var p = h.root,
              v = h.action;
            p.ref.buttonAbortItemRemoval.label = v.value;
          },
          DID_REQUEST_ITEM_PROCESSING: function (h) {
            var p = h.root;
            (p.ref.processProgressIndicator.spin = !0),
              (p.ref.processProgressIndicator.progress = 0);
          },
          DID_START_ITEM_LOAD: function (h) {
            var p = h.root;
            (p.ref.loadProgressIndicator.spin = !0),
              (p.ref.loadProgressIndicator.progress = 0);
          },
          DID_START_ITEM_REMOVE: function (h) {
            var p = h.root;
            (p.ref.processProgressIndicator.spin = !0),
              (p.ref.processProgressIndicator.progress = 0);
          },
          DID_UPDATE_ITEM_LOAD_PROGRESS: function (h) {
            var p = h.root,
              v = h.action;
            (p.ref.loadProgressIndicator.spin = !1),
              (p.ref.loadProgressIndicator.progress = v.progress);
          },
          DID_UPDATE_ITEM_PROCESS_PROGRESS: function (h) {
            var p = h.root,
              v = h.action;
            (p.ref.processProgressIndicator.spin = !1),
              (p.ref.processProgressIndicator.progress = v.progress);
          },
        }),
        P3 = be({
          create: M3,
          write: A3,
          didCreateView: function (h) {
            Io("CREATE_VIEW", Object.assign({}, h, { view: h }));
          },
          name: "file",
        }),
        D3 = function (h) {
          var p = h.root,
            v = h.props;
          (p.ref.fileName = Bs("legend")),
            p.appendChild(p.ref.fileName),
            (p.ref.file = p.appendChildView(
              p.createChildView(P3, { id: v.id })
            )),
            (p.ref.data = !1);
        },
        I3 = function (h) {
          var p = h.root,
            v = h.props;
          Wi(p.ref.fileName, Ug(p.query("GET_ITEM_NAME", v.id)));
        },
        L3 = be({
          create: D3,
          ignoreRect: !0,
          write: Ye({ DID_LOAD_ITEM: I3 }),
          didCreateView: function (h) {
            Io("CREATE_VIEW", Object.assign({}, h, { view: h }));
          },
          tag: "fieldset",
          name: "file-wrapper",
        }),
        HT = { type: "spring", damping: 0.6, mass: 7 },
        R3 = function (h) {
          var p = h.root,
            v = h.props;
          [
            { name: "top" },
            {
              name: "center",
              props: { translateY: null, scaleY: null },
              mixins: {
                animations: { scaleY: HT },
                styles: ["translateY", "scaleY"],
              },
            },
            {
              name: "bottom",
              props: { translateY: null },
              mixins: {
                animations: { translateY: HT },
                styles: ["translateY"],
              },
            },
          ].forEach(function (T) {
            O3(p, T, v.name);
          }),
            p.element.classList.add("filepond--" + v.name),
            (p.ref.scalable = null);
        },
        O3 = function (h, p, v) {
          var T = be({
              name: "panel-" + p.name + " filepond--" + v,
              mixins: p.mixins,
              ignoreRectUpdate: !0,
            }),
            C = h.createChildView(T, p.props);
          h.ref[p.name] = h.appendChildView(C);
        },
        N3 = function (h) {
          var p = h.root,
            v = h.props;
          if (
            ((p.ref.scalable === null || v.scalable !== p.ref.scalable) &&
              ((p.ref.scalable = Pe(v.scalable) ? v.scalable : !0),
              (p.element.dataset.scalable = p.ref.scalable)),
            !!v.height)
          ) {
            var T = p.ref.top.rect.element,
              C = p.ref.bottom.rect.element,
              N = Math.max(T.height + C.height, v.height);
            (p.ref.center.translateY = T.height),
              (p.ref.center.scaleY = (N - T.height - C.height) / 100),
              (p.ref.bottom.translateY = N - C.height);
          }
        },
        $T = be({
          name: "panel",
          read: function (h) {
            var p = h.root,
              v = h.props;
            return (v.heightCurrent = p.ref.bottom.translateY);
          },
          write: N3,
          create: R3,
          ignoreRect: !0,
          mixins: { apis: ["height", "heightCurrent", "scalable"] },
        }),
        k3 = function (h) {
          var p = h.map(function (T) {
              return T.id;
            }),
            v = void 0;
          return {
            setIndex: function (C) {
              v = C;
            },
            getIndex: function () {
              return v;
            },
            getItemIndex: function (C) {
              return p.indexOf(C.id);
            },
          };
        },
        WT = { type: "spring", stiffness: 0.75, damping: 0.45, mass: 10 },
        qT = "spring",
        jT = {
          DID_START_ITEM_LOAD: "busy",
          DID_UPDATE_ITEM_LOAD_PROGRESS: "loading",
          DID_THROW_ITEM_INVALID: "load-invalid",
          DID_THROW_ITEM_LOAD_ERROR: "load-error",
          DID_LOAD_ITEM: "idle",
          DID_THROW_ITEM_REMOVE_ERROR: "remove-error",
          DID_START_ITEM_REMOVE: "busy",
          DID_START_ITEM_PROCESSING: "busy processing",
          DID_REQUEST_ITEM_PROCESSING: "busy processing",
          DID_UPDATE_ITEM_PROCESS_PROGRESS: "processing",
          DID_COMPLETE_ITEM_PROCESSING: "processing-complete",
          DID_THROW_ITEM_PROCESSING_ERROR: "processing-error",
          DID_THROW_ITEM_PROCESSING_REVERT_ERROR: "processing-revert-error",
          DID_ABORT_ITEM_PROCESSING: "cancelled",
          DID_REVERT_ITEM_PROCESSING: "idle",
        },
        F3 = function (h) {
          var p = h.root,
            v = h.props;
          if (
            ((p.ref.handleClick = function (C) {
              return p.dispatch("DID_ACTIVATE_ITEM", { id: v.id });
            }),
            (p.element.id = "filepond--item-" + v.id),
            p.element.addEventListener("click", p.ref.handleClick),
            (p.ref.container = p.appendChildView(
              p.createChildView(L3, { id: v.id })
            )),
            (p.ref.panel = p.appendChildView(
              p.createChildView($T, { name: "item-panel" })
            )),
            (p.ref.panel.height = null),
            (v.markedForRemoval = !1),
            !!p.query("GET_ALLOW_REORDER"))
          ) {
            p.element.dataset.dragState = "idle";
            var T = function (N) {
              if (!!N.isPrimary) {
                var k = !1,
                  z = { x: N.pageX, y: N.pageY };
                (v.dragOrigin = { x: p.translateX, y: p.translateY }),
                  (v.dragCenter = { x: N.offsetX, y: N.offsetY });
                var G = k3(p.query("GET_ACTIVE_ITEMS"));
                p.dispatch("DID_GRAB_ITEM", { id: v.id, dragState: G });
                var H = function (ke) {
                    if (!!ke.isPrimary) {
                      ke.stopPropagation(),
                        ke.preventDefault(),
                        (v.dragOffset = {
                          x: ke.pageX - z.x,
                          y: ke.pageY - z.y,
                        });
                      var $e =
                        v.dragOffset.x * v.dragOffset.x +
                        v.dragOffset.y * v.dragOffset.y;
                      $e > 16 &&
                        !k &&
                        ((k = !0),
                        p.element.removeEventListener(
                          "click",
                          p.ref.handleClick
                        )),
                        p.dispatch("DID_DRAG_ITEM", { id: v.id, dragState: G });
                    }
                  },
                  se = function oe(ke) {
                    !ke.isPrimary ||
                      (document.removeEventListener("pointermove", H),
                      document.removeEventListener("pointerup", oe),
                      (v.dragOffset = { x: ke.pageX - z.x, y: ke.pageY - z.y }),
                      p.dispatch("DID_DROP_ITEM", { id: v.id, dragState: G }),
                      k &&
                        setTimeout(function () {
                          return p.element.addEventListener(
                            "click",
                            p.ref.handleClick
                          );
                        }, 0));
                  };
                document.addEventListener("pointermove", H),
                  document.addEventListener("pointerup", se);
              }
            };
            p.element.addEventListener("pointerdown", T);
          }
        },
        B3 = Ye({
          DID_UPDATE_PANEL_HEIGHT: function (h) {
            var p = h.root,
              v = h.action;
            p.height = v.height;
          },
        }),
        z3 = Ye(
          {
            DID_GRAB_ITEM: function (h) {
              var p = h.root,
                v = h.props;
              v.dragOrigin = { x: p.translateX, y: p.translateY };
            },
            DID_DRAG_ITEM: function (h) {
              var p = h.root;
              p.element.dataset.dragState = "drag";
            },
            DID_DROP_ITEM: function (h) {
              var p = h.root,
                v = h.props;
              (v.dragOffset = null),
                (v.dragOrigin = null),
                (p.element.dataset.dragState = "drop");
            },
          },
          function (S) {
            var h = S.root,
              p = S.actions,
              v = S.props,
              T = S.shouldOptimize;
            h.element.dataset.dragState === "drop" &&
              h.scaleX <= 1 &&
              (h.element.dataset.dragState = "idle");
            var C = p
              .concat()
              .filter(function (k) {
                return /^DID_/.test(k.type);
              })
              .reverse()
              .find(function (k) {
                return jT[k.type];
              });
            C &&
              C.type !== v.currentState &&
              ((v.currentState = C.type),
              (h.element.dataset.filepondItemState = jT[v.currentState] || ""));
            var N =
              h.query("GET_ITEM_PANEL_ASPECT_RATIO") ||
              h.query("GET_PANEL_ASPECT_RATIO");
            N
              ? T || (h.height = h.rect.element.width * N)
              : (B3({ root: h, actions: p, props: v }),
                !h.height &&
                  h.ref.container.rect.element.height > 0 &&
                  (h.height = h.ref.container.rect.element.height)),
              T && (h.ref.panel.height = null),
              (h.ref.panel.height = h.height);
          }
        ),
        U3 = be({
          create: F3,
          write: z3,
          destroy: function (h) {
            var p = h.root,
              v = h.props;
            p.element.removeEventListener("click", p.ref.handleClick),
              p.dispatch("RELEASE_ITEM", { query: v.id });
          },
          tag: "li",
          name: "item",
          mixins: {
            apis: [
              "id",
              "interactionMethod",
              "markedForRemoval",
              "spawnDate",
              "dragCenter",
              "dragOrigin",
              "dragOffset",
            ],
            styles: [
              "translateX",
              "translateY",
              "scaleX",
              "scaleY",
              "opacity",
              "height",
            ],
            animations: {
              scaleX: qT,
              scaleY: qT,
              translateX: WT,
              translateY: WT,
              opacity: { type: "tween", duration: 150 },
            },
          },
        }),
        qg = function (S, h) {
          return Math.max(1, Math.floor((S + 1) / h));
        },
        jg = function (h, p, v) {
          if (!!v) {
            var T = h.rect.element.width,
              C = p.length,
              N = null;
            if (C === 0 || v.top < p[0].rect.element.top) return -1;
            var k = p[0],
              z = k.rect.element,
              G = z.marginLeft + z.marginRight,
              H = z.width + G,
              se = qg(T, H);
            if (se === 1) {
              for (var oe = 0; oe < C; oe++) {
                var ke = p[oe],
                  $e = ke.rect.outer.top + ke.rect.element.height * 0.5;
                if (v.top < $e) return oe;
              }
              return C;
            }
            for (
              var je = z.marginTop + z.marginBottom, Ce = z.height + je, Xe = 0;
              Xe < C;
              Xe++
            ) {
              var at = Xe % se,
                ht = Math.floor(Xe / se),
                Ke = at * H,
                Nt = ht * Ce,
                et = Nt - z.marginTop,
                yi = Ke + H,
                vi = Nt + Ce + z.marginBottom;
              if (v.top < vi && v.top > et) {
                if (v.left < yi) return Xe;
                Xe !== C - 1 ? (N = Xe) : (N = null);
              }
            }
            return N !== null ? N : C;
          }
        },
        ed = {
          height: 0,
          width: 0,
          get getHeight() {
            return this.height;
          },
          set setHeight(S) {
            (this.height === 0 || S === 0) && (this.height = S);
          },
          get getWidth() {
            return this.width;
          },
          set setWidth(S) {
            (this.width === 0 || S === 0) && (this.width = S);
          },
          setDimensions: function (h, p) {
            (this.height === 0 || h === 0) && (this.height = h),
              (this.width === 0 || p === 0) && (this.width = p);
          },
        },
        V3 = function (h) {
          var p = h.root;
          a(p.element, "role", "list"), (p.ref.lastItemSpanwDate = Date.now());
        },
        G3 = function (h) {
          var p = h.root,
            v = h.action,
            T = v.id,
            C = v.index,
            N = v.interactionMethod;
          p.ref.addIndex = C;
          var k = Date.now(),
            z = k,
            G = 1;
          if (N !== zt.NONE) {
            G = 0;
            var H = p.query("GET_ITEM_INSERT_INTERVAL"),
              se = k - p.ref.lastItemSpanwDate;
            z = se < H ? k + (H - se) : k;
          }
          (p.ref.lastItemSpanwDate = z),
            p.appendChildView(
              p.createChildView(U3, {
                spawnDate: z,
                id: T,
                opacity: G,
                interactionMethod: N,
              }),
              C
            );
        },
        XT = function (h, p, v) {
          var T =
              arguments.length > 3 && arguments[3] !== void 0
                ? arguments[3]
                : 0,
            C =
              arguments.length > 4 && arguments[4] !== void 0
                ? arguments[4]
                : 1;
          h.dragOffset
            ? ((h.translateX = null),
              (h.translateY = null),
              (h.translateX = h.dragOrigin.x + h.dragOffset.x),
              (h.translateY = h.dragOrigin.y + h.dragOffset.y),
              (h.scaleX = 1.025),
              (h.scaleY = 1.025))
            : ((h.translateX = p),
              (h.translateY = v),
              Date.now() > h.spawnDate &&
                (h.opacity === 0 && H3(h, p, v, T, C),
                (h.scaleX = 1),
                (h.scaleY = 1),
                (h.opacity = 1)));
        },
        H3 = function (h, p, v, T, C) {
          h.interactionMethod === zt.NONE
            ? ((h.translateX = null),
              (h.translateX = p),
              (h.translateY = null),
              (h.translateY = v))
            : h.interactionMethod === zt.DROP
            ? ((h.translateX = null),
              (h.translateX = p - T * 20),
              (h.translateY = null),
              (h.translateY = v - C * 10),
              (h.scaleX = 0.8),
              (h.scaleY = 0.8))
            : h.interactionMethod === zt.BROWSE
            ? ((h.translateY = null), (h.translateY = v - 30))
            : h.interactionMethod === zt.API &&
              ((h.translateX = null),
              (h.translateX = p - 30),
              (h.translateY = null));
        },
        $3 = function (h) {
          var p = h.root,
            v = h.action,
            T = v.id,
            C = p.childViews.find(function (N) {
              return N.id === T;
            });
          !C ||
            ((C.scaleX = 0.9),
            (C.scaleY = 0.9),
            (C.opacity = 0),
            (C.markedForRemoval = !0));
        },
        Xg = function (h) {
          return (
            h.rect.element.height +
            h.rect.element.marginBottom * 0.5 +
            h.rect.element.marginTop * 0.5
          );
        },
        W3 = function (h) {
          return (
            h.rect.element.width +
            h.rect.element.marginLeft * 0.5 +
            h.rect.element.marginRight * 0.5
          );
        },
        q3 = function (h) {
          var p = h.root,
            v = h.action,
            T = v.id,
            C = v.dragState,
            N = p.query("GET_ITEM", { id: T }),
            k = p.childViews.find(function (at) {
              return at.id === T;
            }),
            z = p.childViews.length,
            G = C.getItemIndex(N);
          if (!!k) {
            var H = {
                x: k.dragOrigin.x + k.dragOffset.x + k.dragCenter.x,
                y: k.dragOrigin.y + k.dragOffset.y + k.dragCenter.y,
              },
              se = Xg(k),
              oe = W3(k),
              ke = Math.floor(p.rect.outer.width / oe);
            ke > z && (ke = z);
            var $e = Math.floor(z / ke + 1);
            (ed.setHeight = se * $e), (ed.setWidth = oe * ke);
            var je = {
                y: Math.floor(H.y / se),
                x: Math.floor(H.x / oe),
                getGridIndex: function () {
                  return H.y > ed.getHeight ||
                    H.y < 0 ||
                    H.x > ed.getWidth ||
                    H.x < 0
                    ? G
                    : this.y * ke + this.x;
                },
                getColIndex: function () {
                  for (
                    var ht = p.query("GET_ACTIVE_ITEMS"),
                      Ke = p.childViews.filter(function (Tt) {
                        return Tt.rect.element.height;
                      }),
                      Nt = ht.map(function (Tt) {
                        return Ke.find(function (xi) {
                          return xi.id === Tt.id;
                        });
                      }),
                      et = Nt.findIndex(function (Tt) {
                        return Tt === k;
                      }),
                      yi = Xg(k),
                      vi = Nt.length,
                      rt = vi,
                      mt = 0,
                      bt = 0,
                      it = 0,
                      lt = 0;
                    lt < vi;
                    lt++
                  )
                    if (
                      ((mt = Xg(Nt[lt])), (it = bt), (bt = it + mt), H.y < bt)
                    ) {
                      if (et > lt) {
                        if (H.y < it + yi) {
                          rt = lt;
                          break;
                        }
                        continue;
                      }
                      rt = lt;
                      break;
                    }
                  return rt;
                },
              },
              Ce = ke > 1 ? je.getGridIndex() : je.getColIndex();
            p.dispatch("MOVE_ITEM", { query: k, index: Ce });
            var Xe = C.getIndex();
            if (Xe === void 0 || Xe !== Ce) {
              if ((C.setIndex(Ce), Xe === void 0)) return;
              p.dispatch("DID_REORDER_ITEMS", {
                items: p.query("GET_ACTIVE_ITEMS"),
                origin: G,
                target: Ce,
              });
            }
          }
        },
        j3 = Ye({ DID_ADD_ITEM: G3, DID_REMOVE_ITEM: $3, DID_DRAG_ITEM: q3 }),
        X3 = function (h) {
          var p = h.root,
            v = h.props,
            T = h.actions,
            C = h.shouldOptimize;
          j3({ root: p, props: v, actions: T });
          var N = v.dragCoordinates,
            k = p.rect.element.width,
            z = p.childViews.filter(function (rt) {
              return rt.rect.element.height;
            }),
            G = p
              .query("GET_ACTIVE_ITEMS")
              .map(function (rt) {
                return z.find(function (mt) {
                  return mt.id === rt.id;
                });
              })
              .filter(function (rt) {
                return rt;
              }),
            H = N ? jg(p, G, N) : null,
            se = p.ref.addIndex || null;
          p.ref.addIndex = null;
          var oe = 0,
            ke = 0,
            $e = 0;
          if (G.length !== 0) {
            var je = G[0].rect.element,
              Ce = je.marginTop + je.marginBottom,
              Xe = je.marginLeft + je.marginRight,
              at = je.width + Xe,
              ht = je.height + Ce,
              Ke = qg(k, at);
            if (Ke === 1) {
              var Nt = 0,
                et = 0;
              G.forEach(function (rt, mt) {
                if (H) {
                  var bt = mt - H;
                  bt === -2
                    ? (et = -Ce * 0.25)
                    : bt === -1
                    ? (et = -Ce * 0.75)
                    : bt === 0
                    ? (et = Ce * 0.75)
                    : bt === 1
                    ? (et = Ce * 0.25)
                    : (et = 0);
                }
                C && ((rt.translateX = null), (rt.translateY = null)),
                  rt.markedForRemoval || XT(rt, 0, Nt + et);
                var it = rt.rect.element.height + Ce,
                  lt = it * (rt.markedForRemoval ? rt.opacity : 1);
                Nt += lt;
              });
            } else {
              var yi = 0,
                vi = 0;
              G.forEach(function (rt, mt) {
                mt === H && (oe = 1),
                  mt === se && ($e += 1),
                  rt.markedForRemoval && rt.opacity < 0.5 && (ke -= 1);
                var bt = mt + $e + oe + ke,
                  it = bt % Ke,
                  lt = Math.floor(bt / Ke),
                  Tt = it * at,
                  xi = lt * ht,
                  mi = Math.sign(Tt - yi),
                  wt = Math.sign(xi - vi);
                (yi = Tt),
                  (vi = xi),
                  !rt.markedForRemoval &&
                    (C && ((rt.translateX = null), (rt.translateY = null)),
                    XT(rt, Tt, xi, mi, wt));
              });
            }
          }
        },
        Y3 = function (h, p) {
          return p.filter(function (v) {
            return v.data && v.data.id ? h.id === v.data.id : !0;
          });
        },
        K3 = be({
          create: V3,
          write: X3,
          tag: "ul",
          name: "list",
          didWriteView: function (h) {
            var p = h.root;
            p.childViews
              .filter(function (v) {
                return v.markedForRemoval && v.opacity === 0 && v.resting;
              })
              .forEach(function (v) {
                v._destroy(), p.removeChildView(v);
              });
          },
          filterFrameActionsForChild: Y3,
          mixins: { apis: ["dragCoordinates"] },
        }),
        J3 = function (h) {
          var p = h.root,
            v = h.props;
          (p.ref.list = p.appendChildView(p.createChildView(K3))),
            (v.dragCoordinates = null),
            (v.overflowing = !1);
        },
        Z3 = function (h) {
          var p = h.root,
            v = h.props,
            T = h.action;
          !p.query("GET_ITEM_INSERT_LOCATION_FREEDOM") ||
            (v.dragCoordinates = {
              left: T.position.scopeLeft - p.ref.list.rect.element.left,
              top:
                T.position.scopeTop -
                (p.rect.outer.top +
                  p.rect.element.marginTop +
                  p.rect.element.scrollTop),
            });
        },
        Q3 = function (h) {
          var p = h.props;
          p.dragCoordinates = null;
        },
        ek = Ye({ DID_DRAG: Z3, DID_END_DRAG: Q3 }),
        tk = function (h) {
          var p = h.root,
            v = h.props,
            T = h.actions;
          if (
            (ek({ root: p, props: v, actions: T }),
            (p.ref.list.dragCoordinates = v.dragCoordinates),
            v.overflowing &&
              !v.overflow &&
              ((v.overflowing = !1),
              (p.element.dataset.state = ""),
              (p.height = null)),
            v.overflow)
          ) {
            var C = Math.round(v.overflow);
            C !== p.height &&
              ((v.overflowing = !0),
              (p.element.dataset.state = "overflow"),
              (p.height = C));
          }
        },
        ik = be({
          create: J3,
          write: tk,
          name: "list-scroller",
          mixins: {
            apis: ["overflow", "dragCoordinates"],
            styles: ["height", "translateY"],
            animations: { translateY: "spring" },
          },
        }),
        as = function (h, p, v) {
          var T =
            arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
          v ? a(h, p, T) : h.removeAttribute(p);
        },
        nk = function (h) {
          if (!(!h || h.value === "")) {
            try {
              h.value = "";
            } catch (C) {}
            if (h.value) {
              var p = Bs("form"),
                v = h.parentNode,
                T = h.nextSibling;
              p.appendChild(h),
                p.reset(),
                T ? v.insertBefore(h, T) : v.appendChild(h);
            }
          }
        },
        rk = function (h) {
          var p = h.root,
            v = h.props;
          (p.element.id = "filepond--browser-" + v.id),
            a(p.element, "name", p.query("GET_NAME")),
            a(p.element, "aria-controls", "filepond--assistant-" + v.id),
            a(p.element, "aria-labelledby", "filepond--drop-label-" + v.id),
            YT({
              root: p,
              action: { value: p.query("GET_ACCEPTED_FILE_TYPES") },
            }),
            KT({ root: p, action: { value: p.query("GET_ALLOW_MULTIPLE") } }),
            JT({
              root: p,
              action: { value: p.query("GET_ALLOW_DIRECTORIES_ONLY") },
            }),
            Yg({ root: p }),
            ZT({ root: p, action: { value: p.query("GET_REQUIRED") } }),
            QT({ root: p, action: { value: p.query("GET_CAPTURE_METHOD") } }),
            (p.ref.handleChange = function (T) {
              if (!!p.element.value) {
                var C = Array.from(p.element.files).map(function (N) {
                  return (N._relativePath = N.webkitRelativePath), N;
                });
                setTimeout(function () {
                  v.onload(C), nk(p.element);
                }, 250);
              }
            }),
            p.element.addEventListener("change", p.ref.handleChange);
        },
        YT = function (h) {
          var p = h.root,
            v = h.action;
          !p.query("GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE") ||
            as(
              p.element,
              "accept",
              !!v.value,
              v.value ? v.value.join(",") : ""
            );
        },
        KT = function (h) {
          var p = h.root,
            v = h.action;
          as(p.element, "multiple", v.value);
        },
        JT = function (h) {
          var p = h.root,
            v = h.action;
          as(p.element, "webkitdirectory", v.value);
        },
        Yg = function (h) {
          var p = h.root,
            v = p.query("GET_DISABLED"),
            T = p.query("GET_ALLOW_BROWSE"),
            C = v || !T;
          as(p.element, "disabled", C);
        },
        ZT = function (h) {
          var p = h.root,
            v = h.action;
          v.value
            ? p.query("GET_TOTAL_ITEMS") === 0 && as(p.element, "required", !0)
            : as(p.element, "required", !1);
        },
        QT = function (h) {
          var p = h.root,
            v = h.action;
          as(p.element, "capture", !!v.value, v.value === !0 ? "" : v.value);
        },
        eS = function (h) {
          var p = h.root,
            v = p.element;
          if (p.query("GET_TOTAL_ITEMS") > 0)
            as(v, "required", !1), as(v, "name", !1);
          else {
            as(v, "name", !0, p.query("GET_NAME"));
            var T = p.query("GET_CHECK_VALIDITY");
            T && v.setCustomValidity(""),
              p.query("GET_REQUIRED") && as(v, "required", !0);
          }
        },
        sk = function (h) {
          var p = h.root,
            v = p.query("GET_CHECK_VALIDITY");
          !v || p.element.setCustomValidity(p.query("GET_LABEL_INVALID_FIELD"));
        },
        ak = be({
          tag: "input",
          name: "browser",
          ignoreRect: !0,
          ignoreRectUpdate: !0,
          attributes: { type: "file" },
          create: rk,
          destroy: function (h) {
            var p = h.root;
            p.element.removeEventListener("change", p.ref.handleChange);
          },
          write: Ye({
            DID_LOAD_ITEM: eS,
            DID_REMOVE_ITEM: eS,
            DID_THROW_ITEM_INVALID: sk,
            DID_SET_DISABLED: Yg,
            DID_SET_ALLOW_BROWSE: Yg,
            DID_SET_ALLOW_DIRECTORIES_ONLY: JT,
            DID_SET_ALLOW_MULTIPLE: KT,
            DID_SET_ACCEPTED_FILE_TYPES: YT,
            DID_SET_CAPTURE_METHOD: QT,
            DID_SET_REQUIRED: ZT,
          }),
        }),
        tS = { ENTER: 13, SPACE: 32 },
        ok = function (h) {
          var p = h.root,
            v = h.props,
            T = Bs("label");
          a(T, "for", "filepond--browser-" + v.id),
            a(T, "id", "filepond--drop-label-" + v.id),
            a(T, "aria-hidden", "true"),
            (p.ref.handleKeyDown = function (C) {
              var N = C.keyCode === tS.ENTER || C.keyCode === tS.SPACE;
              !N || (C.preventDefault(), p.ref.label.click());
            }),
            (p.ref.handleClick = function (C) {
              var N = C.target === T || T.contains(C.target);
              N || p.ref.label.click();
            }),
            T.addEventListener("keydown", p.ref.handleKeyDown),
            p.element.addEventListener("click", p.ref.handleClick),
            iS(T, v.caption),
            p.appendChild(T),
            (p.ref.label = T);
        },
        iS = function (h, p) {
          h.innerHTML = p;
          var v = h.querySelector(".filepond--label-action");
          return v && a(v, "tabindex", "0"), p;
        },
        lk = be({
          name: "drop-label",
          ignoreRect: !0,
          create: ok,
          destroy: function (h) {
            var p = h.root;
            p.ref.label.addEventListener("keydown", p.ref.handleKeyDown),
              p.element.removeEventListener("click", p.ref.handleClick);
          },
          write: Ye({
            DID_SET_LABEL_IDLE: function (h) {
              var p = h.root,
                v = h.action;
              iS(p.ref.label, v.value);
            },
          }),
          mixins: {
            styles: ["opacity", "translateX", "translateY"],
            animations: {
              opacity: { type: "tween", duration: 150 },
              translateX: "spring",
              translateY: "spring",
            },
          },
        }),
        ck = be({
          name: "drip-blob",
          ignoreRect: !0,
          mixins: {
            styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity"],
            animations: {
              scaleX: "spring",
              scaleY: "spring",
              translateX: "spring",
              translateY: "spring",
              opacity: { type: "tween", duration: 250 },
            },
          },
        }),
        uk = function (h) {
          var p = h.root,
            v = p.rect.element.width * 0.5,
            T = p.rect.element.height * 0.5;
          p.ref.blob = p.appendChildView(
            p.createChildView(ck, {
              opacity: 0,
              scaleX: 2.5,
              scaleY: 2.5,
              translateX: v,
              translateY: T,
            })
          );
        },
        hk = function (h) {
          var p = h.root,
            v = h.action;
          if (!p.ref.blob) {
            uk({ root: p });
            return;
          }
          (p.ref.blob.translateX = v.position.scopeLeft),
            (p.ref.blob.translateY = v.position.scopeTop),
            (p.ref.blob.scaleX = 1),
            (p.ref.blob.scaleY = 1),
            (p.ref.blob.opacity = 1);
        },
        fk = function (h) {
          var p = h.root;
          !p.ref.blob || (p.ref.blob.opacity = 0);
        },
        dk = function (h) {
          var p = h.root;
          !p.ref.blob ||
            ((p.ref.blob.scaleX = 2.5),
            (p.ref.blob.scaleY = 2.5),
            (p.ref.blob.opacity = 0));
        },
        pk = function (h) {
          var p = h.root,
            v = h.props,
            T = h.actions;
          mk({ root: p, props: v, actions: T });
          var C = p.ref.blob;
          T.length === 0 &&
            C &&
            C.opacity === 0 &&
            (p.removeChildView(C), (p.ref.blob = null));
        },
        mk = Ye({ DID_DRAG: hk, DID_DROP: dk, DID_END_DRAG: fk }),
        gk = be({
          ignoreRect: !0,
          ignoreRectUpdate: !0,
          name: "drip",
          write: pk,
        }),
        nS = function (h, p) {
          try {
            var v = new DataTransfer();
            p.forEach(function (T) {
              T instanceof File
                ? v.items.add(T)
                : v.items.add(new File([T], T.name, { type: T.type }));
            }),
              (h.files = v.files);
          } catch (T) {
            return !1;
          }
          return !0;
        },
        yk = function (h) {
          var p = h.root;
          return (p.ref.fields = {});
        },
        td = function (h, p) {
          return h.ref.fields[p];
        },
        Kg = function (h) {
          h.query("GET_ACTIVE_ITEMS").forEach(function (p) {
            !h.ref.fields[p.id] || h.element.appendChild(h.ref.fields[p.id]);
          });
        },
        rS = function (h) {
          var p = h.root;
          return Kg(p);
        },
        vk = function (h) {
          var p = h.root,
            v = h.action,
            T = p.query("GET_ITEM", v.id),
            C = T.origin === on.LOCAL,
            N = !C && p.query("SHOULD_UPDATE_FILE_INPUT"),
            k = Bs("input");
          (k.type = N ? "file" : "hidden"),
            (k.name = p.query("GET_NAME")),
            (k.disabled = p.query("GET_DISABLED")),
            (p.ref.fields[v.id] = k),
            Kg(p);
        },
        xk = function (h) {
          var p = h.root,
            v = h.action,
            T = td(p, v.id);
          if (
            !!T &&
            (v.serverFileReference !== null &&
              (T.value = v.serverFileReference),
            !!p.query("SHOULD_UPDATE_FILE_INPUT"))
          ) {
            var C = p.query("GET_ITEM", v.id);
            nS(T, [C.file]);
          }
        },
        bk = function (h) {
          var p = h.root,
            v = h.action;
          !p.query("SHOULD_UPDATE_FILE_INPUT") ||
            setTimeout(function () {
              var T = td(p, v.id);
              !T || nS(T, [v.file]);
            }, 0);
        },
        _k = function (h) {
          var p = h.root;
          p.element.disabled = p.query("GET_DISABLED");
        },
        Ek = function (h) {
          var p = h.root,
            v = h.action,
            T = td(p, v.id);
          !T ||
            (T.parentNode && T.parentNode.removeChild(T),
            delete p.ref.fields[v.id]);
        },
        Tk = function (h) {
          var p = h.root,
            v = h.action,
            T = td(p, v.id);
          !T ||
            (v.value === null
              ? T.removeAttribute("value")
              : (T.value = v.value),
            Kg(p));
        },
        Sk = Ye({
          DID_SET_DISABLED: _k,
          DID_ADD_ITEM: vk,
          DID_LOAD_ITEM: xk,
          DID_REMOVE_ITEM: Ek,
          DID_DEFINE_VALUE: Tk,
          DID_PREPARE_OUTPUT: bk,
          DID_REORDER_ITEMS: rS,
          DID_SORT_ITEMS: rS,
        }),
        wk = be({
          tag: "fieldset",
          name: "data",
          create: yk,
          write: Sk,
          ignoreRect: !0,
        }),
        Mk = function (h) {
          return "getRootNode" in h ? h.getRootNode() : document;
        },
        Ak = ["jpg", "jpeg", "png", "gif", "bmp", "webp", "svg", "tiff"],
        Ck = ["css", "csv", "html", "txt"],
        Pk = { zip: "zip|compressed", epub: "application/epub+zip" },
        sS = function () {
          var h =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return (
            (h = h.toLowerCase()),
            Ak.includes(h)
              ? "image/" + (h === "jpg" ? "jpeg" : h === "svg" ? "svg+xml" : h)
              : Ck.includes(h)
              ? "text/" + h
              : Pk[h] || ""
          );
        },
        Jg = function (h) {
          return new Promise(function (p, v) {
            var T = Fk(h);
            if (T.length && !Dk(h)) return p(T);
            Ik(h).then(p);
          });
        },
        Dk = function (h) {
          return h.files ? h.files.length > 0 : !1;
        },
        Ik = function (h) {
          return new Promise(function (p, v) {
            var T = (h.items ? Array.from(h.items) : [])
              .filter(function (C) {
                return Lk(C);
              })
              .map(function (C) {
                return Rk(C);
              });
            if (!T.length) {
              p(h.files ? Array.from(h.files) : []);
              return;
            }
            Promise.all(T)
              .then(function (C) {
                var N = [];
                C.forEach(function (k) {
                  N.push.apply(N, k);
                }),
                  p(
                    N.filter(function (k) {
                      return k;
                    }).map(function (k) {
                      return (
                        k._relativePath ||
                          (k._relativePath = k.webkitRelativePath),
                        k
                      );
                    })
                  );
              })
              .catch(console.error);
          });
        },
        Lk = function (h) {
          if (aS(h)) {
            var p = Zg(h);
            if (p) return p.isFile || p.isDirectory;
          }
          return h.kind === "file";
        },
        Rk = function (h) {
          return new Promise(function (p, v) {
            if (kk(h)) {
              Ok(Zg(h)).then(p).catch(v);
              return;
            }
            p([h.getAsFile()]);
          });
        },
        Ok = function (h) {
          return new Promise(function (p, v) {
            var T = [],
              C = 0,
              N = 0,
              k = function () {
                N === 0 && C === 0 && p(T);
              },
              z = function G(H) {
                C++;
                var se = H.createReader(),
                  oe = function ke() {
                    se.readEntries(function ($e) {
                      if ($e.length === 0) {
                        C--, k();
                        return;
                      }
                      $e.forEach(function (je) {
                        je.isDirectory
                          ? G(je)
                          : (N++,
                            je.file(function (Ce) {
                              var Xe = Nk(Ce);
                              je.fullPath && (Xe._relativePath = je.fullPath),
                                T.push(Xe),
                                N--,
                                k();
                            }));
                      }),
                        ke();
                    }, v);
                  };
                oe();
              };
            z(h);
          });
        },
        Nk = function (h) {
          if (h.type.length) return h;
          var p = h.lastModifiedDate,
            v = h.name,
            T = sS(Jf(h.name));
          return (
            T.length &&
              ((h = h.slice(0, h.size, T)),
              (h.name = v),
              (h.lastModifiedDate = p)),
            h
          );
        },
        kk = function (h) {
          return aS(h) && (Zg(h) || {}).isDirectory;
        },
        aS = function (h) {
          return "webkitGetAsEntry" in h;
        },
        Zg = function (h) {
          return h.webkitGetAsEntry();
        },
        Fk = function (h) {
          var p = [];
          try {
            if (((p = zk(h)), p.length)) return p;
            p = Bk(h);
          } catch (v) {}
          return p;
        },
        Bk = function (h) {
          var p = h.getData("url");
          return typeof p == "string" && p.length ? [p] : [];
        },
        zk = function (h) {
          var p = h.getData("text/html");
          if (typeof p == "string" && p.length) {
            var v = p.match(/src\s*=\s*"(.+?)"/);
            if (v) return [v[1]];
          }
          return [];
        },
        id = [],
        No = function (h) {
          return {
            pageLeft: h.pageX,
            pageTop: h.pageY,
            scopeLeft: h.offsetX || h.layerX,
            scopeTop: h.offsetY || h.layerY,
          };
        },
        Uk = function (h, p, v) {
          var T = Vk(p),
            C = {
              element: h,
              filterElement: v,
              state: null,
              ondrop: function () {},
              onenter: function () {},
              ondrag: function () {},
              onexit: function () {},
              onload: function () {},
              allowdrop: function () {},
            };
          return (C.destroy = T.addListener(C)), C;
        },
        Vk = function (h) {
          var p = id.find(function (T) {
            return T.element === h;
          });
          if (p) return p;
          var v = Gk(h);
          return id.push(v), v;
        },
        Gk = function (h) {
          var p = [],
            v = { dragenter: $k, dragover: Wk, dragleave: jk, drop: qk },
            T = {};
          r(v, function (N, k) {
            (T[N] = k(h, p)), h.addEventListener(N, T[N], !1);
          });
          var C = {
            element: h,
            addListener: function (k) {
              return (
                p.push(k),
                function () {
                  p.splice(p.indexOf(k), 1),
                    p.length === 0 &&
                      (id.splice(id.indexOf(C), 1),
                      r(v, function (z) {
                        h.removeEventListener(z, T[z], !1);
                      }));
                }
              );
            },
          };
          return C;
        },
        Hk = function (h, p) {
          return (
            "elementFromPoint" in h || (h = document),
            h.elementFromPoint(p.x, p.y)
          );
        },
        Qg = function (h, p) {
          var v = Mk(p),
            T = Hk(v, {
              x: h.pageX - window.pageXOffset,
              y: h.pageY - window.pageYOffset,
            });
          return T === p || p.contains(T);
        },
        oS = null,
        nd = function (h, p) {
          try {
            h.dropEffect = p;
          } catch (v) {}
        },
        $k = function (h, p) {
          return function (v) {
            v.preventDefault(),
              (oS = v.target),
              p.forEach(function (T) {
                var C = T.element,
                  N = T.onenter;
                Qg(v, C) && ((T.state = "enter"), N(No(v)));
              });
          };
        },
        Wk = function (h, p) {
          return function (v) {
            v.preventDefault();
            var T = v.dataTransfer;
            Jg(T).then(function (C) {
              var N = !1;
              p.some(function (k) {
                var z = k.filterElement,
                  G = k.element,
                  H = k.onenter,
                  se = k.onexit,
                  oe = k.ondrag,
                  ke = k.allowdrop;
                nd(T, "copy");
                var $e = ke(C);
                if (!$e) {
                  nd(T, "none");
                  return;
                }
                if (Qg(v, G)) {
                  if (((N = !0), k.state === null)) {
                    (k.state = "enter"), H(No(v));
                    return;
                  }
                  if (((k.state = "over"), z && !$e)) {
                    nd(T, "none");
                    return;
                  }
                  oe(No(v));
                } else z && !N && nd(T, "none"), k.state && ((k.state = null), se(No(v)));
              });
            });
          };
        },
        qk = function (h, p) {
          return function (v) {
            v.preventDefault();
            var T = v.dataTransfer;
            Jg(T).then(function (C) {
              p.forEach(function (N) {
                var k = N.filterElement,
                  z = N.element,
                  G = N.ondrop,
                  H = N.onexit,
                  se = N.allowdrop;
                if (((N.state = null), !(k && !Qg(v, z)))) {
                  if (!se(C)) return H(No(v));
                  G(No(v), C);
                }
              });
            });
          };
        },
        jk = function (h, p) {
          return function (v) {
            oS === v.target &&
              p.forEach(function (T) {
                var C = T.onexit;
                (T.state = null), C(No(v));
              });
          };
        },
        Xk = function (h, p, v) {
          h.classList.add("filepond--hopper");
          var T = v.catchesDropsOnPage,
            C = v.requiresDropOnElement,
            N = v.filterItems,
            k =
              N === void 0
                ? function (oe) {
                    return oe;
                  }
                : N,
            z = Uk(h, T ? document.documentElement : h, C),
            G = "",
            H = "";
          (z.allowdrop = function (oe) {
            return p(k(oe));
          }),
            (z.ondrop = function (oe, ke) {
              var $e = k(ke);
              if (!p($e)) {
                se.ondragend(oe);
                return;
              }
              (H = "drag-drop"), se.onload($e, oe);
            }),
            (z.ondrag = function (oe) {
              se.ondrag(oe);
            }),
            (z.onenter = function (oe) {
              (H = "drag-over"), se.ondragstart(oe);
            }),
            (z.onexit = function (oe) {
              (H = "drag-exit"), se.ondragend(oe);
            });
          var se = {
            updateHopperState: function () {
              G !== H && ((h.dataset.hopperState = H), (G = H));
            },
            onload: function () {},
            ondragstart: function () {},
            ondrag: function () {},
            ondragend: function () {},
            destroy: function () {
              z.destroy();
            },
          };
          return se;
        },
        e0 = !1,
        $l = [],
        lS = function (h) {
          var p = document.activeElement;
          if (p && /textarea|input/i.test(p.nodeName)) {
            for (var v = !1, T = p; T !== document.body; ) {
              if (T.classList.contains("filepond--root")) {
                v = !0;
                break;
              }
              T = T.parentNode;
            }
            if (!v) return;
          }
          Jg(h.clipboardData).then(function (C) {
            !C.length ||
              $l.forEach(function (N) {
                return N(C);
              });
          });
        },
        Yk = function (h) {
          $l.includes(h) ||
            ($l.push(h),
            !e0 && ((e0 = !0), document.addEventListener("paste", lS)));
        },
        Kk = function (h) {
          Rg($l, $l.indexOf(h)),
            $l.length === 0 &&
              (document.removeEventListener("paste", lS), (e0 = !1));
        },
        Jk = function () {
          var h = function (T) {
              p.onload(T);
            },
            p = {
              destroy: function () {
                Kk(h);
              },
              onload: function () {},
            };
          return Yk(h), p;
        },
        Zk = function (h) {
          var p = h.root,
            v = h.props;
          (p.element.id = "filepond--assistant-" + v.id),
            a(p.element, "role", "status"),
            a(p.element, "aria-live", "polite"),
            a(p.element, "aria-relevant", "additions");
        },
        cS = null,
        uS = null,
        t0 = [],
        rd = function (h, p) {
          h.element.textContent = p;
        },
        Qk = function (h) {
          h.element.textContent = "";
        },
        hS = function (h, p, v) {
          var T = h.query("GET_TOTAL_ITEMS");
          rd(
            h,
            v +
              " " +
              p +
              ", " +
              T +
              " " +
              (T === 1
                ? h.query("GET_LABEL_FILE_COUNT_SINGULAR")
                : h.query("GET_LABEL_FILE_COUNT_PLURAL"))
          ),
            clearTimeout(uS),
            (uS = setTimeout(function () {
              Qk(h);
            }, 1500));
        },
        fS = function (h) {
          return h.element.parentNode.contains(document.activeElement);
        },
        eF = function (h) {
          var p = h.root,
            v = h.action;
          if (!!fS(p)) {
            p.element.textContent = "";
            var T = p.query("GET_ITEM", v.id);
            t0.push(T.filename),
              clearTimeout(cS),
              (cS = setTimeout(function () {
                hS(p, t0.join(", "), p.query("GET_LABEL_FILE_ADDED")),
                  (t0.length = 0);
              }, 750));
          }
        },
        tF = function (h) {
          var p = h.root,
            v = h.action;
          if (!!fS(p)) {
            var T = v.item;
            hS(p, T.filename, p.query("GET_LABEL_FILE_REMOVED"));
          }
        },
        iF = function (h) {
          var p = h.root,
            v = h.action,
            T = p.query("GET_ITEM", v.id),
            C = T.filename,
            N = p.query("GET_LABEL_FILE_PROCESSING_COMPLETE");
          rd(p, C + " " + N);
        },
        dS = function (h) {
          var p = h.root,
            v = h.action,
            T = p.query("GET_ITEM", v.id),
            C = T.filename,
            N = p.query("GET_LABEL_FILE_PROCESSING_ABORTED");
          rd(p, C + " " + N);
        },
        sd = function (h) {
          var p = h.root,
            v = h.action,
            T = p.query("GET_ITEM", v.id),
            C = T.filename;
          rd(p, v.status.main + " " + C + " " + v.status.sub);
        },
        nF = be({
          create: Zk,
          ignoreRect: !0,
          ignoreRectUpdate: !0,
          write: Ye({
            DID_LOAD_ITEM: eF,
            DID_REMOVE_ITEM: tF,
            DID_COMPLETE_ITEM_PROCESSING: iF,
            DID_ABORT_ITEM_PROCESSING: dS,
            DID_REVERT_ITEM_PROCESSING: dS,
            DID_THROW_ITEM_REMOVE_ERROR: sd,
            DID_THROW_ITEM_LOAD_ERROR: sd,
            DID_THROW_ITEM_INVALID: sd,
            DID_THROW_ITEM_PROCESSING_ERROR: sd,
          }),
          tag: "span",
          name: "assistant",
        }),
        pS = function (h) {
          var p =
            arguments.length > 1 && arguments[1] !== void 0
              ? arguments[1]
              : "-";
          return h.replace(new RegExp(p + ".", "g"), function (v) {
            return v.charAt(1).toUpperCase();
          });
        },
        mS = function (h) {
          var p =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : 16,
            v =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : !0,
            T = Date.now(),
            C = null;
          return function () {
            for (var N = arguments.length, k = new Array(N), z = 0; z < N; z++)
              k[z] = arguments[z];
            clearTimeout(C);
            var G = Date.now() - T,
              H = function () {
                (T = Date.now()), h.apply(void 0, k);
              };
            G < p ? v || (C = setTimeout(H, p - G)) : H();
          };
        },
        rF = 1e6,
        ad = function (h) {
          return h.preventDefault();
        },
        sF = function (h) {
          var p = h.root,
            v = h.props,
            T = p.query("GET_ID");
          T && (p.element.id = T);
          var C = p.query("GET_CLASS_NAME");
          C &&
            C.split(" ")
              .filter(function (se) {
                return se.length;
              })
              .forEach(function (se) {
                p.element.classList.add(se);
              }),
            (p.ref.label = p.appendChildView(
              p.createChildView(
                lk,
                Object.assign({}, v, {
                  translateY: null,
                  caption: p.query("GET_LABEL_IDLE"),
                })
              )
            )),
            (p.ref.list = p.appendChildView(
              p.createChildView(ik, { translateY: null })
            )),
            (p.ref.panel = p.appendChildView(
              p.createChildView($T, { name: "panel-root" })
            )),
            (p.ref.assistant = p.appendChildView(
              p.createChildView(nF, Object.assign({}, v))
            )),
            (p.ref.data = p.appendChildView(
              p.createChildView(wk, Object.assign({}, v))
            )),
            (p.ref.measure = Bs("div")),
            (p.ref.measure.style.height = "100%"),
            p.element.appendChild(p.ref.measure),
            (p.ref.bounds = null),
            p
              .query("GET_STYLES")
              .filter(function (se) {
                return !Et(se.value);
              })
              .map(function (se) {
                var oe = se.name,
                  ke = se.value;
                p.element.dataset[oe] = ke;
              }),
            (p.ref.widthPrevious = null),
            (p.ref.widthUpdated = mS(function () {
              (p.ref.updateHistory = []), p.dispatch("DID_RESIZE_ROOT");
            }, 250)),
            (p.ref.previousAspectRatio = null),
            (p.ref.updateHistory = []);
          var N = window.matchMedia(
              "(pointer: fine) and (hover: hover)"
            ).matches,
            k = "PointerEvent" in window;
          p.query("GET_ALLOW_REORDER") &&
            k &&
            !N &&
            (p.element.addEventListener("touchmove", ad, { passive: !1 }),
            p.element.addEventListener("gesturestart", ad));
          var z = p.query("GET_CREDITS"),
            G = z.length === 2;
          if (G) {
            var H = document.createElement("a");
            (H.className = "filepond--credits"),
              H.setAttribute("aria-hidden", "true"),
              (H.href = z[0]),
              (H.tabindex = -1),
              (H.target = "_blank"),
              (H.rel = "noopener noreferrer"),
              (H.textContent = z[1]),
              p.element.appendChild(H),
              (p.ref.credits = H);
          }
        },
        aF = function (h) {
          var p = h.root,
            v = h.props,
            T = h.actions;
          if (
            (hF({ root: p, props: v, actions: T }),
            T.filter(function (Zt) {
              return /^DID_SET_STYLE_/.test(Zt.type);
            })
              .filter(function (Zt) {
                return !Et(Zt.data.value);
              })
              .map(function (Zt) {
                var ui = Zt.type,
                  Wl = Zt.data,
                  Pu = pS(ui.substring(8).toLowerCase(), "_");
                (p.element.dataset[Pu] = Wl.value), p.invalidateLayout();
              }),
            !p.rect.element.hidden)
          ) {
            p.rect.element.width !== p.ref.widthPrevious &&
              ((p.ref.widthPrevious = p.rect.element.width),
              p.ref.widthUpdated());
            var C = p.ref.bounds;
            C ||
              ((C = p.ref.bounds = cF(p)),
              p.element.removeChild(p.ref.measure),
              (p.ref.measure = null));
            var N = p.ref,
              k = N.hopper,
              z = N.label,
              G = N.list,
              H = N.panel;
            k && k.updateHopperState();
            var se = p.query("GET_PANEL_ASPECT_RATIO"),
              oe = p.query("GET_ALLOW_MULTIPLE"),
              ke = p.query("GET_TOTAL_ITEMS"),
              $e = oe ? p.query("GET_MAX_FILES") || rF : 1,
              je = ke === $e,
              Ce = T.find(function (Zt) {
                return Zt.type === "DID_ADD_ITEM";
              });
            if (je && Ce) {
              var Xe = Ce.data.interactionMethod;
              (z.opacity = 0),
                oe
                  ? (z.translateY = -40)
                  : Xe === zt.API
                  ? (z.translateX = 40)
                  : Xe === zt.BROWSE
                  ? (z.translateY = 40)
                  : (z.translateY = 30);
            } else
              je || ((z.opacity = 1), (z.translateX = 0), (z.translateY = 0));
            var at = oF(p),
              ht = lF(p),
              Ke = z.rect.element.height,
              Nt = !oe || je ? 0 : Ke,
              et = je ? G.rect.element.marginTop : 0,
              yi = ke === 0 ? 0 : G.rect.element.marginBottom,
              vi = Nt + et + ht.visual + yi,
              rt = Nt + et + ht.bounds + yi;
            if (
              ((G.translateY =
                Math.max(0, Nt - G.rect.element.marginTop) - at.top),
              se)
            ) {
              var mt = p.rect.element.width,
                bt = mt * se;
              se !== p.ref.previousAspectRatio &&
                ((p.ref.previousAspectRatio = se), (p.ref.updateHistory = []));
              var it = p.ref.updateHistory;
              it.push(mt);
              var lt = 2;
              if (it.length > lt * 2) {
                for (
                  var Tt = it.length, xi = Tt - 10, mi = 0, wt = Tt;
                  wt >= xi;
                  wt--
                )
                  if ((it[wt] === it[wt - 2] && mi++, mi >= lt)) return;
              }
              (H.scalable = !1), (H.height = bt);
              var Ge = bt - Nt - (yi - at.bottom) - (je ? et : 0);
              ht.visual > Ge ? (G.overflow = Ge) : (G.overflow = null),
                (p.height = bt);
            } else if (C.fixedHeight) {
              H.scalable = !1;
              var xe = C.fixedHeight - Nt - (yi - at.bottom) - (je ? et : 0);
              ht.visual > xe ? (G.overflow = xe) : (G.overflow = null);
            } else if (C.cappedHeight) {
              var ct = vi >= C.cappedHeight,
                Lt = Math.min(C.cappedHeight, vi);
              (H.scalable = !0), (H.height = ct ? Lt : Lt - at.top - at.bottom);
              var Ft = Lt - Nt - (yi - at.bottom) - (je ? et : 0);
              vi > C.cappedHeight && ht.visual > Ft
                ? (G.overflow = Ft)
                : (G.overflow = null),
                (p.height = Math.min(C.cappedHeight, rt - at.top - at.bottom));
            } else {
              var ni = ke > 0 ? at.top + at.bottom : 0;
              (H.scalable = !0),
                (H.height = Math.max(Ke, vi - ni)),
                (p.height = Math.max(Ke, rt - ni));
            }
            p.ref.credits &&
              H.heightCurrent &&
              (p.ref.credits.style.transform =
                "translateY(" + H.heightCurrent + "px)");
          }
        },
        oF = function (h) {
          var p = h.ref.list.childViews[0].childViews[0];
          return p
            ? {
                top: p.rect.element.marginTop,
                bottom: p.rect.element.marginBottom,
              }
            : { top: 0, bottom: 0 };
        },
        lF = function (h) {
          var p = 0,
            v = 0,
            T = h.ref.list,
            C = T.childViews[0],
            N = C.childViews.filter(function (ht) {
              return ht.rect.element.height;
            }),
            k = h
              .query("GET_ACTIVE_ITEMS")
              .map(function (ht) {
                return N.find(function (Ke) {
                  return Ke.id === ht.id;
                });
              })
              .filter(function (ht) {
                return ht;
              });
          if (k.length === 0) return { visual: p, bounds: v };
          var z = C.rect.element.width,
            G = jg(C, k, T.dragCoordinates),
            H = k[0].rect.element,
            se = H.marginTop + H.marginBottom,
            oe = H.marginLeft + H.marginRight,
            ke = H.width + oe,
            $e = H.height + se,
            je = typeof G != "undefined" && G >= 0 ? 1 : 0,
            Ce = k.find(function (ht) {
              return ht.markedForRemoval && ht.opacity < 0.45;
            })
              ? -1
              : 0,
            Xe = k.length + je + Ce,
            at = qg(z, ke);
          return (
            at === 1
              ? k.forEach(function (ht) {
                  var Ke = ht.rect.element.height + se;
                  (v += Ke), (p += Ke * ht.opacity);
                })
              : ((v = Math.ceil(Xe / at) * $e), (p = v)),
            { visual: p, bounds: v }
          );
        },
        cF = function (h) {
          var p = h.ref.measureHeight || null,
            v = parseInt(h.style.maxHeight, 10) || null,
            T = p === 0 ? null : p;
          return { cappedHeight: v, fixedHeight: T };
        },
        i0 = function (h, p) {
          var v = h.query("GET_ALLOW_REPLACE"),
            T = h.query("GET_ALLOW_MULTIPLE"),
            C = h.query("GET_TOTAL_ITEMS"),
            N = h.query("GET_MAX_FILES"),
            k = p.length;
          if (!T && k > 1)
            return (
              h.dispatch("DID_THROW_MAX_FILES", {
                source: p,
                error: $i("warning", 0, "Max files"),
              }),
              !0
            );
          if (((N = T ? N : 1), !T && v)) return !1;
          var z = B(N);
          return z && C + k > N
            ? (h.dispatch("DID_THROW_MAX_FILES", {
                source: p,
                error: $i("warning", 0, "Max files"),
              }),
              !0)
            : !1;
        },
        uF = function (h, p, v) {
          var T = h.childViews[0];
          return jg(T, p, {
            left: v.scopeLeft - T.rect.element.left,
            top:
              v.scopeTop -
              (h.rect.outer.top +
                h.rect.element.marginTop +
                h.rect.element.scrollTop),
          });
        },
        gS = function (h) {
          var p = h.query("GET_ALLOW_DROP"),
            v = h.query("GET_DISABLED"),
            T = p && !v;
          if (T && !h.ref.hopper) {
            var C = Xk(
              h.element,
              function (N) {
                var k =
                    h.query("GET_BEFORE_DROP_FILE") ||
                    function () {
                      return !0;
                    },
                  z = h.query("GET_DROP_VALIDATION");
                return z
                  ? N.every(function (G) {
                      return (
                        Io("ALLOW_HOPPER_ITEM", G, { query: h.query }).every(
                          function (H) {
                            return H === !0;
                          }
                        ) && k(G)
                      );
                    })
                  : !0;
              },
              {
                filterItems: function (k) {
                  var z = h.query("GET_IGNORED_FILES");
                  return k.filter(function (G) {
                    return Gl(G) ? !z.includes(G.name.toLowerCase()) : !0;
                  });
                },
                catchesDropsOnPage: h.query("GET_DROP_ON_PAGE"),
                requiresDropOnElement: h.query("GET_DROP_ON_ELEMENT"),
              }
            );
            (C.onload = function (N, k) {
              var z = h.ref.list.childViews[0],
                G = z.childViews.filter(function (se) {
                  return se.rect.element.height;
                }),
                H = h
                  .query("GET_ACTIVE_ITEMS")
                  .map(function (se) {
                    return G.find(function (oe) {
                      return oe.id === se.id;
                    });
                  })
                  .filter(function (se) {
                    return se;
                  });
              rs("ADD_ITEMS", N, { dispatch: h.dispatch }).then(function (se) {
                if (i0(h, se)) return !1;
                h.dispatch("ADD_ITEMS", {
                  items: se,
                  index: uF(h.ref.list, H, k),
                  interactionMethod: zt.DROP,
                });
              }),
                h.dispatch("DID_DROP", { position: k }),
                h.dispatch("DID_END_DRAG", { position: k });
            }),
              (C.ondragstart = function (N) {
                h.dispatch("DID_START_DRAG", { position: N });
              }),
              (C.ondrag = mS(function (N) {
                h.dispatch("DID_DRAG", { position: N });
              })),
              (C.ondragend = function (N) {
                h.dispatch("DID_END_DRAG", { position: N });
              }),
              (h.ref.hopper = C),
              (h.ref.drip = h.appendChildView(h.createChildView(gk)));
          } else
            !T &&
              h.ref.hopper &&
              (h.ref.hopper.destroy(),
              (h.ref.hopper = null),
              h.removeChildView(h.ref.drip));
        },
        yS = function (h, p) {
          var v = h.query("GET_ALLOW_BROWSE"),
            T = h.query("GET_DISABLED"),
            C = v && !T;
          C && !h.ref.browser
            ? (h.ref.browser = h.appendChildView(
                h.createChildView(
                  ak,
                  Object.assign({}, p, {
                    onload: function (k) {
                      rs("ADD_ITEMS", k, { dispatch: h.dispatch }).then(
                        function (z) {
                          if (i0(h, z)) return !1;
                          h.dispatch("ADD_ITEMS", {
                            items: z,
                            index: -1,
                            interactionMethod: zt.BROWSE,
                          });
                        }
                      );
                    },
                  })
                ),
                0
              ))
            : !C &&
              h.ref.browser &&
              (h.removeChildView(h.ref.browser), (h.ref.browser = null));
        },
        vS = function (h) {
          var p = h.query("GET_ALLOW_PASTE"),
            v = h.query("GET_DISABLED"),
            T = p && !v;
          T && !h.ref.paster
            ? ((h.ref.paster = Jk()),
              (h.ref.paster.onload = function (C) {
                rs("ADD_ITEMS", C, { dispatch: h.dispatch }).then(function (N) {
                  if (i0(h, N)) return !1;
                  h.dispatch("ADD_ITEMS", {
                    items: N,
                    index: -1,
                    interactionMethod: zt.PASTE,
                  });
                });
              }))
            : !T &&
              h.ref.paster &&
              (h.ref.paster.destroy(), (h.ref.paster = null));
        },
        hF = Ye({
          DID_SET_ALLOW_BROWSE: function (h) {
            var p = h.root,
              v = h.props;
            yS(p, v);
          },
          DID_SET_ALLOW_DROP: function (h) {
            var p = h.root;
            gS(p);
          },
          DID_SET_ALLOW_PASTE: function (h) {
            var p = h.root;
            vS(p);
          },
          DID_SET_DISABLED: function (h) {
            var p = h.root,
              v = h.props;
            gS(p), vS(p), yS(p, v);
            var T = p.query("GET_DISABLED");
            T
              ? (p.element.dataset.disabled = "disabled")
              : p.element.removeAttribute("data-disabled");
          },
        }),
        fF = be({
          name: "root",
          read: function (h) {
            var p = h.root;
            p.ref.measure && (p.ref.measureHeight = p.ref.measure.offsetHeight);
          },
          create: sF,
          write: aF,
          destroy: function (h) {
            var p = h.root;
            p.ref.paster && p.ref.paster.destroy(),
              p.ref.hopper && p.ref.hopper.destroy(),
              p.element.removeEventListener("touchmove", ad),
              p.element.removeEventListener("gesturestart", ad);
          },
          mixins: { styles: ["height"] },
        }),
        dF = function () {
          var h =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : {},
            p = null,
            v = Yf(),
            T = t(fe(v), [LN, Ct(v)], [r3, ot(v)]);
          T.dispatch("SET_OPTIONS", { options: h });
          var C = function () {
            document.hidden || T.dispatch("KICK");
          };
          document.addEventListener("visibilitychange", C);
          var N = null,
            k = !1,
            z = !1,
            G = null,
            H = null,
            se = function () {
              k || (k = !0),
                clearTimeout(N),
                (N = setTimeout(function () {
                  (k = !1),
                    (G = null),
                    (H = null),
                    z && ((z = !1), T.dispatch("DID_STOP_RESIZE"));
                }, 500));
            };
          window.addEventListener("resize", se);
          var oe = fF(T, { id: gi() }),
            ke = !1,
            $e = !1,
            je = {
              _read: function () {
                k &&
                  ((H = window.innerWidth),
                  G || (G = H),
                  !z && H !== G && (T.dispatch("DID_START_RESIZE"), (z = !0))),
                  $e && ke && (ke = oe.element.offsetParent === null),
                  !ke && (oe._read(), ($e = oe.rect.element.hidden));
              },
              _write: function (Ge) {
                var xe = T.processActionQueue().filter(function (ct) {
                  return !/^SET_/.test(ct.type);
                });
                (ke && !xe.length) ||
                  (ht(xe),
                  (ke = oe._write(Ge, xe, z)),
                  bN(T.query("GET_ITEMS")),
                  ke && T.processDispatchQueue());
              },
            },
            Ce = function (Ge) {
              return function (xe) {
                var ct = { type: Ge };
                if (!xe) return ct;
                if (
                  (xe.hasOwnProperty("error") &&
                    (ct.error = xe.error ? Object.assign({}, xe.error) : null),
                  xe.status && (ct.status = Object.assign({}, xe.status)),
                  xe.file && (ct.output = xe.file),
                  xe.source)
                )
                  ct.file = xe.source;
                else if (xe.item || xe.id) {
                  var Lt = xe.item ? xe.item : T.query("GET_ITEM", xe.id);
                  ct.file = Lt ? Jn(Lt) : null;
                }
                return (
                  xe.items && (ct.items = xe.items.map(Jn)),
                  /progress/.test(Ge) && (ct.progress = xe.progress),
                  xe.hasOwnProperty("origin") &&
                    xe.hasOwnProperty("target") &&
                    ((ct.origin = xe.origin), (ct.target = xe.target)),
                  ct
                );
              };
            },
            Xe = {
              DID_DESTROY: Ce("destroy"),
              DID_INIT: Ce("init"),
              DID_THROW_MAX_FILES: Ce("warning"),
              DID_INIT_ITEM: Ce("initfile"),
              DID_START_ITEM_LOAD: Ce("addfilestart"),
              DID_UPDATE_ITEM_LOAD_PROGRESS: Ce("addfileprogress"),
              DID_LOAD_ITEM: Ce("addfile"),
              DID_THROW_ITEM_INVALID: [Ce("error"), Ce("addfile")],
              DID_THROW_ITEM_LOAD_ERROR: [Ce("error"), Ce("addfile")],
              DID_THROW_ITEM_REMOVE_ERROR: [Ce("error"), Ce("removefile")],
              DID_PREPARE_OUTPUT: Ce("preparefile"),
              DID_START_ITEM_PROCESSING: Ce("processfilestart"),
              DID_UPDATE_ITEM_PROCESS_PROGRESS: Ce("processfileprogress"),
              DID_ABORT_ITEM_PROCESSING: Ce("processfileabort"),
              DID_COMPLETE_ITEM_PROCESSING: Ce("processfile"),
              DID_COMPLETE_ITEM_PROCESSING_ALL: Ce("processfiles"),
              DID_REVERT_ITEM_PROCESSING: Ce("processfilerevert"),
              DID_THROW_ITEM_PROCESSING_ERROR: [Ce("error"), Ce("processfile")],
              DID_REMOVE_ITEM: Ce("removefile"),
              DID_UPDATE_ITEMS: Ce("updatefiles"),
              DID_ACTIVATE_ITEM: Ce("activatefile"),
              DID_REORDER_ITEMS: Ce("reorderfiles"),
            },
            at = function (Ge) {
              var xe = Object.assign({ pond: mi }, Ge);
              delete xe.type,
                oe.element.dispatchEvent(
                  new CustomEvent("FilePond:" + Ge.type, {
                    detail: xe,
                    bubbles: !0,
                    cancelable: !0,
                    composed: !0,
                  })
                );
              var ct = [];
              Ge.hasOwnProperty("error") && ct.push(Ge.error),
                Ge.hasOwnProperty("file") && ct.push(Ge.file);
              var Lt = ["type", "error", "file"];
              Object.keys(Ge)
                .filter(function (ni) {
                  return !Lt.includes(ni);
                })
                .forEach(function (ni) {
                  return ct.push(Ge[ni]);
                }),
                mi.fire.apply(mi, [Ge.type].concat(ct));
              var Ft = T.query("GET_ON" + Ge.type.toUpperCase());
              Ft && Ft.apply(void 0, ct);
            },
            ht = function (Ge) {
              !Ge.length ||
                Ge.filter(function (xe) {
                  return Xe[xe.type];
                }).forEach(function (xe) {
                  var ct = Xe[xe.type];
                  (Array.isArray(ct) ? ct : [ct]).forEach(function (Lt) {
                    xe.type === "DID_INIT_ITEM"
                      ? at(Lt(xe.data))
                      : setTimeout(function () {
                          at(Lt(xe.data));
                        }, 0);
                  });
                });
            },
            Ke = function (Ge) {
              return T.dispatch("SET_OPTIONS", { options: Ge });
            },
            Nt = function (Ge) {
              return T.query("GET_ACTIVE_ITEM", Ge);
            },
            et = function (Ge) {
              return new Promise(function (xe, ct) {
                T.dispatch("REQUEST_ITEM_PREPARE", {
                  query: Ge,
                  success: function (Ft) {
                    xe(Ft);
                  },
                  failure: function (Ft) {
                    ct(Ft);
                  },
                });
              });
            },
            yi = function (Ge) {
              var xe =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {};
              return new Promise(function (ct, Lt) {
                mt([{ source: Ge, options: xe }], { index: xe.index })
                  .then(function (Ft) {
                    return ct(Ft && Ft[0]);
                  })
                  .catch(Lt);
              });
            },
            vi = function (Ge) {
              return Ge.file && Ge.id;
            },
            rt = function (Ge, xe) {
              return (
                typeof Ge == "object" &&
                  !vi(Ge) &&
                  !xe &&
                  ((xe = Ge), (Ge = void 0)),
                T.dispatch("REMOVE_ITEM", Object.assign({}, xe, { query: Ge })),
                T.query("GET_ACTIVE_ITEM", Ge) === null
              );
            },
            mt = function () {
              for (
                var Ge = arguments.length, xe = new Array(Ge), ct = 0;
                ct < Ge;
                ct++
              )
                xe[ct] = arguments[ct];
              return new Promise(function (Lt, Ft) {
                var ni = [],
                  Zt = {};
                if (kt(xe[0]))
                  ni.push.apply(ni, xe[0]), Object.assign(Zt, xe[1] || {});
                else {
                  var ui = xe[xe.length - 1];
                  typeof ui == "object" &&
                    !(ui instanceof Blob) &&
                    Object.assign(Zt, xe.pop()),
                    ni.push.apply(ni, xe);
                }
                T.dispatch("ADD_ITEMS", {
                  items: ni,
                  index: Zt.index,
                  interactionMethod: zt.API,
                  success: Lt,
                  failure: Ft,
                });
              });
            },
            bt = function () {
              return T.query("GET_ACTIVE_ITEMS");
            },
            it = function (Ge) {
              return new Promise(function (xe, ct) {
                T.dispatch("REQUEST_ITEM_PROCESSING", {
                  query: Ge,
                  success: function (Ft) {
                    xe(Ft);
                  },
                  failure: function (Ft) {
                    ct(Ft);
                  },
                });
              });
            },
            lt = function () {
              for (
                var Ge = arguments.length, xe = new Array(Ge), ct = 0;
                ct < Ge;
                ct++
              )
                xe[ct] = arguments[ct];
              var Lt = Array.isArray(xe[0]) ? xe[0] : xe,
                Ft = Lt.length ? Lt : bt();
              return Promise.all(Ft.map(et));
            },
            Tt = function () {
              for (
                var Ge = arguments.length, xe = new Array(Ge), ct = 0;
                ct < Ge;
                ct++
              )
                xe[ct] = arguments[ct];
              var Lt = Array.isArray(xe[0]) ? xe[0] : xe;
              if (!Lt.length) {
                var Ft = bt().filter(function (ni) {
                  return (
                    !(ni.status === Ot.IDLE && ni.origin === on.LOCAL) &&
                    ni.status !== Ot.PROCESSING &&
                    ni.status !== Ot.PROCESSING_COMPLETE &&
                    ni.status !== Ot.PROCESSING_REVERT_ERROR
                  );
                });
                return Promise.all(Ft.map(it));
              }
              return Promise.all(Lt.map(it));
            },
            xi = function () {
              for (
                var Ge = arguments.length, xe = new Array(Ge), ct = 0;
                ct < Ge;
                ct++
              )
                xe[ct] = arguments[ct];
              var Lt = Array.isArray(xe[0]) ? xe[0] : xe,
                Ft;
              typeof Lt[Lt.length - 1] == "object"
                ? (Ft = Lt.pop())
                : Array.isArray(xe[0]) && (Ft = xe[1]);
              var ni = bt();
              if (!Lt.length)
                return Promise.all(
                  ni.map(function (ui) {
                    return rt(ui, Ft);
                  })
                );
              var Zt = Lt.map(function (ui) {
                return P(ui) ? (ni[ui] ? ni[ui].id : null) : ui;
              }).filter(function (ui) {
                return ui;
              });
              return Zt.map(function (ui) {
                return rt(ui, Ft);
              });
            },
            mi = Object.assign({}, Xf(), {}, je, {}, qe(T, v), {
              setOptions: Ke,
              addFile: yi,
              addFiles: mt,
              getFile: Nt,
              processFile: it,
              prepareFile: et,
              removeFile: rt,
              moveFile: function (Ge, xe) {
                return T.dispatch("MOVE_ITEM", { query: Ge, index: xe });
              },
              getFiles: bt,
              processFiles: Tt,
              removeFiles: xi,
              prepareFiles: lt,
              sort: function (Ge) {
                return T.dispatch("SORT", { compare: Ge });
              },
              browse: function () {
                var Ge = oe.element.querySelector("input[type=file]");
                Ge && Ge.click();
              },
              destroy: function () {
                mi.fire("destroy", oe.element),
                  T.dispatch("ABORT_ALL"),
                  oe._destroy(),
                  window.removeEventListener("resize", se),
                  document.removeEventListener("visibilitychange", C),
                  T.dispatch("DID_DESTROY");
              },
              insertBefore: function (Ge) {
                return _t(oe.element, Ge);
              },
              insertAfter: function (Ge) {
                return Ze(oe.element, Ge);
              },
              appendTo: function (Ge) {
                return Ge.appendChild(oe.element);
              },
              replaceElement: function (Ge) {
                _t(oe.element, Ge), Ge.parentNode.removeChild(Ge), (p = Ge);
              },
              restoreElement: function () {
                !p ||
                  (Ze(p, oe.element),
                  oe.element.parentNode.removeChild(oe.element),
                  (p = null));
              },
              isAttachedTo: function (Ge) {
                return oe.element === Ge || p === Ge;
              },
              element: {
                get: function () {
                  return oe.element;
                },
              },
              status: {
                get: function () {
                  return T.query("GET_STATUS");
                },
              },
            });
          return T.dispatch("DID_INIT"), s(mi);
        },
        xS = function () {
          var h =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : {},
            p = {};
          r(Yf(), function (T, C) {
            p[T] = C[0];
          });
          var v = dF(Object.assign({}, p, {}, h));
          return v;
        },
        pF = function (h) {
          return h.charAt(0).toLowerCase() + h.slice(1);
        },
        mF = function (h) {
          return pS(h.replace(/^data-/, ""));
        },
        gF = function S(h, p) {
          r(p, function (v, T) {
            r(h, function (C, N) {
              var k = new RegExp(v),
                z = k.test(C);
              if (!!z && (delete h[C], T !== !1)) {
                if (Ie(T)) {
                  h[T] = N;
                  return;
                }
                var G = T.group;
                V(T) && !h[G] && (h[G] = {}), (h[G][pF(C.replace(k, ""))] = N);
              }
            }),
              T.mapping && S(h[T.group], T.mapping);
          });
        },
        yF = function (h) {
          var p =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : {},
            v = [];
          r(h.attributes, function (C) {
            v.push(h.attributes[C]);
          });
          var T = v
            .filter(function (C) {
              return C.name;
            })
            .reduce(function (C, N) {
              var k = a(h, N.name);
              return (C[mF(N.name)] = k === N.name ? !0 : k), C;
            }, {});
          return gF(T, p), T;
        },
        vF = function (h) {
          var p =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : {},
            v = {
              "^class$": "className",
              "^multiple$": "allowMultiple",
              "^capture$": "captureMethod",
              "^webkitdirectory$": "allowDirectoriesOnly",
              "^server": {
                group: "server",
                mapping: {
                  "^process": { group: "process" },
                  "^revert": { group: "revert" },
                  "^fetch": { group: "fetch" },
                  "^restore": { group: "restore" },
                  "^load": { group: "load" },
                },
              },
              "^type$": !1,
              "^files$": !1,
            };
          Io("SET_ATTRIBUTE_TO_OPTION_MAP", v);
          var T = Object.assign({}, p),
            C = yF(
              h.nodeName === "FIELDSET"
                ? h.querySelector("input[type=file]")
                : h,
              v
            );
          Object.keys(C).forEach(function (k) {
            V(C[k])
              ? (V(T[k]) || (T[k] = {}), Object.assign(T[k], C[k]))
              : (T[k] = C[k]);
          }),
            (T.files = (p.files || []).concat(
              Array.from(h.querySelectorAll("input:not([type=file])")).map(
                function (k) {
                  return { source: k.value, options: { type: k.dataset.type } };
                }
              )
            ));
          var N = xS(T);
          return (
            h.files &&
              Array.from(h.files).forEach(function (k) {
                N.addFile(k);
              }),
            N.replaceElement(h),
            N
          );
        },
        xF = function () {
          return e(arguments.length <= 0 ? void 0 : arguments[0])
            ? vF.apply(void 0, arguments)
            : xS.apply(void 0, arguments);
        },
        bF = ["fire", "_read", "_write"],
        bS = function (h) {
          var p = {};
          return gT(h, p, bF), p;
        },
        _F = function (h, p) {
          return h.replace(/(?:{([a-zA-Z]+)})/g, function (v, T) {
            return p[T];
          });
        },
        EF = function (h) {
          var p = new Blob(["(", h.toString(), ")()"], {
              type: "application/javascript",
            }),
            v = URL.createObjectURL(p),
            T = new Worker(v);
          return {
            transfer: function (N, k) {},
            post: function (N, k, z) {
              var G = gi();
              (T.onmessage = function (H) {
                H.data.id === G && k(H.data.message);
              }),
                T.postMessage({ id: G, message: N }, z);
            },
            terminate: function () {
              T.terminate(), URL.revokeObjectURL(v);
            },
          };
        },
        TF = function (h) {
          return new Promise(function (p, v) {
            var T = new Image();
            (T.onload = function () {
              p(T);
            }),
              (T.onerror = function (C) {
                v(C);
              }),
              (T.src = h);
          });
        },
        _S = function (h, p) {
          var v = h.slice(0, h.size, h.type);
          return (v.lastModifiedDate = h.lastModifiedDate), (v.name = p), v;
        },
        SF = function (h) {
          return _S(h, h.name);
        },
        ES = [],
        wF = function (h) {
          if (!ES.includes(h)) {
            ES.push(h);
            var p = h({
              addFilter: EN,
              utils: {
                Type: ze,
                forin: r,
                isString: Ie,
                isFile: Gl,
                toNaturalFileSize: kT,
                replaceInString: _F,
                getExtensionFromFilename: Jf,
                getFilenameWithoutExtension: CT,
                guesstimateMimeType: sS,
                getFileFromBlob: Vl,
                getFilenameFromURL: Su,
                createRoute: Ye,
                createWorker: EF,
                createView: be,
                createItemAPI: Jn,
                loadImage: TF,
                copyFile: SF,
                renameFile: _S,
                createBlob: TT,
                applyFilterChain: rs,
                text: Wi,
                getNumericAspectRatioFromString: xT,
              },
              views: { fileActionButton: NT },
            });
            TN(p.options);
          }
        },
        MF = function () {
          return (
            Object.prototype.toString.call(window.operamini) ===
            "[object OperaMini]"
          );
        },
        AF = function () {
          return "Promise" in window;
        },
        CF = function () {
          return "slice" in Blob.prototype;
        },
        PF = function () {
          return "URL" in window && "createObjectURL" in window.URL;
        },
        DF = function () {
          return "visibilityState" in document;
        },
        IF = function () {
          return "performance" in window;
        },
        LF = function () {
          return "supports" in (window.CSS || {});
        },
        RF = function () {
          return /MSIE|Trident/.test(window.navigator.userAgent);
        },
        n0 = (function () {
          var S =
            y() &&
            !MF() &&
            DF() &&
            AF() &&
            CF() &&
            PF() &&
            IF() &&
            (LF() || RF());
          return function () {
            return S;
          };
        })(),
        Na = { apps: [] },
        OF = "filepond",
        ko = function () {};
      if (
        ((n.Status = {}),
        (n.FileStatus = {}),
        (n.FileOrigin = {}),
        (n.OptionTypes = {}),
        (n.create = ko),
        (n.destroy = ko),
        (n.parse = ko),
        (n.find = ko),
        (n.registerPlugin = ko),
        (n.getOptions = ko),
        (n.setOptions = ko),
        n0())
      ) {
        ut(
          function () {
            Na.apps.forEach(function (S) {
              return S._read();
            });
          },
          function (S) {
            Na.apps.forEach(function (h) {
              return h._write(S);
            });
          }
        );
        var TS = function S() {
          document.dispatchEvent(
            new CustomEvent("FilePond:loaded", {
              detail: {
                supported: n0,
                create: n.create,
                destroy: n.destroy,
                parse: n.parse,
                find: n.find,
                registerPlugin: n.registerPlugin,
                setOptions: n.setOptions,
              },
            })
          ),
            document.removeEventListener("DOMContentLoaded", S);
        };
        document.readyState !== "loading"
          ? setTimeout(function () {
              return TS();
            }, 0)
          : document.addEventListener("DOMContentLoaded", TS);
        var SS = function () {
          return r(Yf(), function (h, p) {
            n.OptionTypes[h] = p[1];
          });
        };
        (n.Status = Object.assign({}, Ul)),
          (n.FileOrigin = Object.assign({}, on)),
          (n.FileStatus = Object.assign({}, Ot)),
          (n.OptionTypes = {}),
          SS(),
          (n.create = function () {
            var h = xF.apply(void 0, arguments);
            return h.on("destroy", n.destroy), Na.apps.push(h), bS(h);
          }),
          (n.destroy = function (h) {
            var p = Na.apps.findIndex(function (T) {
              return T.isAttachedTo(h);
            });
            if (p >= 0) {
              var v = Na.apps.splice(p, 1)[0];
              return v.restoreElement(), !0;
            }
            return !1;
          }),
          (n.parse = function (h) {
            var p = Array.from(h.querySelectorAll("." + OF)),
              v = p.filter(function (T) {
                return !Na.apps.find(function (C) {
                  return C.isAttachedTo(T);
                });
              });
            return v.map(function (T) {
              return n.create(T);
            });
          }),
          (n.find = function (h) {
            var p = Na.apps.find(function (v) {
              return v.isAttachedTo(h);
            });
            return p ? bS(p) : null;
          }),
          (n.registerPlugin = function () {
            for (var h = arguments.length, p = new Array(h), v = 0; v < h; v++)
              p[v] = arguments[v];
            p.forEach(wF), SS();
          }),
          (n.getOptions = function () {
            var h = {};
            return (
              r(Yf(), function (p, v) {
                h[p] = v[0];
              }),
              h
            );
          }),
          (n.setOptions = function (h) {
            return (
              V(h) &&
                (Na.apps.forEach(function (p) {
                  p.setOptions(h);
                }),
                SN(h)),
              n.getOptions()
            );
          });
      }
      (n.supported = n0), Object.defineProperty(n, "__esModule", { value: !0 });
    });
  });
  var bO = jt((bg) => {
    (function (n, e) {
      if (typeof define == "function" && define.amd)
        define("vueFilePond", ["exports", "vue", "filepond"], e);
      else if (typeof bg != "undefined") e(bg, yO(), xO());
      else {
        var t = { exports: {} };
        e(t.exports, n.Vue, n.FilePond), (n.vueFilePond = t.exports);
      }
    })(
      typeof globalThis != "undefined"
        ? globalThis
        : typeof self != "undefined"
        ? self
        : bg,
      function (n, e, t) {
        "use strict";
        Object.defineProperty(n, "__esModule", { value: !0 }),
          (n.default = n.setOptions = void 0);
        function i(g, b) {
          return a(g) || s(g, b) || r();
        }
        function r() {
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance"
          );
        }
        function s(g, b) {
          if (
            Symbol.iterator in Object(g) ||
            Object.prototype.toString.call(g) === "[object Arguments]"
          ) {
            var _ = [],
              E = !0,
              w = !1,
              P = void 0;
            try {
              for (
                var L = g[Symbol.iterator](), I;
                !(E = (I = L.next()).done) &&
                (_.push(I.value), !(b && _.length === b));
                E = !0
              );
            } catch (M) {
              (w = !0), (P = M);
            } finally {
              try {
                !E && L.return != null && L.return();
              } finally {
                if (w) throw P;
              }
            }
            return _;
          }
        }
        function a(g) {
          if (Array.isArray(g)) return g;
        }
        var o = [
            "setOptions",
            "on",
            "off",
            "onOnce",
            "appendTo",
            "insertAfter",
            "insertBefore",
            "isAttachedTo",
            "replaceElement",
            "restoreElement",
            "destroy",
          ],
          l = (0, t.supported)(),
          c = function (b) {
            return {
              string: String,
              boolean: Boolean,
              array: Array,
              function: Function,
              int: Number,
              serverapi: Object,
              object: Object,
            }[b];
          },
          u = {},
          f = [],
          d = [],
          m = {},
          x = function (b) {
            (m = Object.assign(m, b)),
              d.forEach(function (_) {
                _.setOptions(m);
              });
          };
        n.setOptions = x;
        var y = function () {
          t.registerPlugin.apply(void 0, arguments), (f.length = 0);
          for (var b in t.OptionTypes) {
            if (/^on/.test(b)) {
              f.push(b);
              continue;
            }
            var _ = [String, c(t.OptionTypes[b])];
            b == "labelFileProcessingError" && _.push(Function),
              (u[b] = { type: _, default: void 0 });
          }
          return {
            name: "FilePond",
            props: u,
            render: function () {
              var w = Object.entries({
                id: this.id,
                name: this.name,
                type: "file",
                class: this.className,
                required: this.required,
                multiple: this.allowMultiple,
                accept: this.acceptedFileTypes,
                capture: this.captureMethod,
              }).reduce(function (P, L) {
                var I = i(L, 2),
                  M = I[0],
                  R = I[1];
                return R !== void 0 && (P[M] = R), P;
              }, {});
              return (0, e.h)("div", { class: { "filepond--wrapper": !0 } }, [
                (0, e.h)("input", w),
              ]);
            },
            created: function () {
              var w = this;
              this.watchers = Object.keys(u).map(function (P) {
                return w.$watch(P, function (L) {
                  w._pond[P] = L;
                });
              });
            },
            mounted: function () {
              var w = this;
              if (!!l) {
                this._element = this.$el.querySelector("input");
                var P = f.reduce(function (I, M) {
                    return (
                      (I[M] = function () {
                        w.$emit("input", w._pond ? w._pond.getFiles() : []);
                        for (
                          var R = arguments.length, O = new Array(R), U = 0;
                          U < R;
                          U++
                        )
                          O[U] = arguments[U];
                        w.$emit.apply(w, [M.substr(2)].concat(O));
                      }),
                      I
                    );
                  }, {}),
                  L = {};
                Object.keys(u).forEach(function (I) {
                  w[I] !== void 0 && (L[I] = w[I]);
                }),
                  (this._pond = (0, t.create)(
                    this._element,
                    Object.assign({}, m, P, L)
                  )),
                  Object.keys(this._pond)
                    .filter(function (I) {
                      return !o.includes(I);
                    })
                    .forEach(function (I) {
                      w[I] = w._pond[I];
                    }),
                  d.push(this._pond);
              }
            },
            beforeUnmount: function () {
              var w = this,
                P = this.$options.detached;
              if (!this.$el.offsetParent) {
                P.call(this);
                return;
              }
              var L = function (R, O) {
                  var U = (R[0] || {}).removedNodes || [],
                    X = U[0];
                  !X || !X.contains(w.$el) || (O.disconnect(), P.call(w));
                },
                I = new MutationObserver(L);
              I.observe(document.documentElement, {
                childList: !0,
                subtree: !0,
              });
            },
            detached: function () {
              if (
                (this.watchers.forEach(function (P) {
                  return P();
                }),
                !!this._pond)
              ) {
                this._pond.destroy();
                var w = d.indexOf(this._pond);
                w >= 0 && d.splice(w, 1), (this._pond = null);
              }
            },
          };
        };
        n.default = y;
      }
    );
  });
  var _O = jt((PE, DE) => {
    (function (n, e) {
      typeof PE == "object" && typeof DE != "undefined"
        ? (DE.exports = e())
        : typeof define == "function" && define.amd
        ? define(e)
        : ((n = n || self), (n.FilePondPluginFileValidateType = e()));
    })(PE, function () {
      "use strict";
      var n = function (i) {
          var r = i.addFilter,
            s = i.utils,
            a = s.Type,
            o = s.isString,
            l = s.replaceInString,
            c = s.guesstimateMimeType,
            u = s.getExtensionFromFilename,
            f = s.getFilenameFromURL,
            d = function (_, E) {
              var w = (/^[^/]+/.exec(_) || []).pop(),
                P = E.slice(0, -2);
              return w === P;
            },
            m = function (_, E) {
              return _.some(function (w) {
                return /\*$/.test(w) ? d(E, w) : w === E;
              });
            },
            x = function (_) {
              var E = "";
              if (o(_)) {
                var w = f(_),
                  P = u(w);
                P && (E = c(P));
              } else E = _.type;
              return E;
            },
            y = function (_, E, w) {
              if (E.length === 0) return !0;
              var P = x(_);
              return w
                ? new Promise(function (L, I) {
                    w(_, P)
                      .then(function (M) {
                        m(E, M) ? L() : I();
                      })
                      .catch(I);
                  })
                : m(E, P);
            },
            g = function (_) {
              return function (E) {
                return _[E] === null ? !1 : _[E] || E;
              };
            };
          return (
            r("SET_ATTRIBUTE_TO_OPTION_MAP", function (b) {
              return Object.assign(b, { accept: "acceptedFileTypes" });
            }),
            r("ALLOW_HOPPER_ITEM", function (b, _) {
              var E = _.query;
              return E("GET_ALLOW_FILE_TYPE_VALIDATION")
                ? y(b, E("GET_ACCEPTED_FILE_TYPES"))
                : !0;
            }),
            r("LOAD_FILE", function (b, _) {
              var E = _.query;
              return new Promise(function (w, P) {
                if (!E("GET_ALLOW_FILE_TYPE_VALIDATION")) {
                  w(b);
                  return;
                }
                var L = E("GET_ACCEPTED_FILE_TYPES"),
                  I = E("GET_FILE_VALIDATE_TYPE_DETECT_TYPE"),
                  M = y(b, L, I),
                  R = function () {
                    var U = L.map(
                        g(E("GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP"))
                      ).filter(function ($) {
                        return $ !== !1;
                      }),
                      X = U.filter(function ($, W) {
                        return U.indexOf($) === W;
                      });
                    P({
                      status: {
                        main: E("GET_LABEL_FILE_TYPE_NOT_ALLOWED"),
                        sub: l(
                          E("GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES"),
                          {
                            allTypes: X.join(", "),
                            allButLastType: X.slice(0, -1).join(", "),
                            lastType: X[U.length - 1],
                          }
                        ),
                      },
                    });
                  };
                if (typeof M == "boolean") return M ? w(b) : R();
                M.then(function () {
                  w(b);
                }).catch(R);
              });
            }),
            {
              options: {
                allowFileTypeValidation: [!0, a.BOOLEAN],
                acceptedFileTypes: [[], a.ARRAY],
                labelFileTypeNotAllowed: ["File is of invalid type", a.STRING],
                fileValidateTypeLabelExpectedTypes: [
                  "Expects {allButLastType} or {lastType}",
                  a.STRING,
                ],
                fileValidateTypeLabelExpectedTypesMap: [{}, a.OBJECT],
                fileValidateTypeDetectType: [null, a.FUNCTION],
              },
            }
          );
        },
        e =
          typeof window != "undefined" && typeof window.document != "undefined";
      return (
        e &&
          document.dispatchEvent(
            new CustomEvent("FilePond:pluginloaded", { detail: n })
          ),
        n
      );
    });
  });
  var EO = jt((IE, LE) => {
    (function (n, e) {
      typeof IE == "object" && typeof LE != "undefined"
        ? (LE.exports = e())
        : typeof define == "function" && define.amd
        ? define(e)
        : ((n = n || self), (n.FilePondPluginFileValidateSize = e()));
    })(IE, function () {
      "use strict";
      var n = function (i) {
          var r = i.addFilter,
            s = i.utils,
            a = s.Type,
            o = s.replaceInString,
            l = s.toNaturalFileSize;
          return (
            r("ALLOW_HOPPER_ITEM", function (c, u) {
              var f = u.query;
              if (!f("GET_ALLOW_FILE_SIZE_VALIDATION")) return !0;
              var d = f("GET_MAX_FILE_SIZE");
              if (d !== null && c.size > d) return !1;
              var m = f("GET_MIN_FILE_SIZE");
              return !(m !== null && c.size < m);
            }),
            r("LOAD_FILE", function (c, u) {
              var f = u.query;
              return new Promise(function (d, m) {
                if (!f("GET_ALLOW_FILE_SIZE_VALIDATION")) return d(c);
                var x = f("GET_FILE_VALIDATE_SIZE_FILTER");
                if (x && !x(c)) return d(c);
                var y = f("GET_MAX_FILE_SIZE");
                if (y !== null && c.size > y) {
                  m({
                    status: {
                      main: f("GET_LABEL_MAX_FILE_SIZE_EXCEEDED"),
                      sub: o(f("GET_LABEL_MAX_FILE_SIZE"), {
                        filesize: l(
                          y,
                          ".",
                          f("GET_FILE_SIZE_BASE"),
                          f("GET_FILE_SIZE_LABELS", f)
                        ),
                      }),
                    },
                  });
                  return;
                }
                var g = f("GET_MIN_FILE_SIZE");
                if (g !== null && c.size < g) {
                  m({
                    status: {
                      main: f("GET_LABEL_MIN_FILE_SIZE_EXCEEDED"),
                      sub: o(f("GET_LABEL_MIN_FILE_SIZE"), {
                        filesize: l(
                          g,
                          ".",
                          f("GET_FILE_SIZE_BASE"),
                          f("GET_FILE_SIZE_LABELS", f)
                        ),
                      }),
                    },
                  });
                  return;
                }
                var b = f("GET_MAX_TOTAL_FILE_SIZE");
                if (b !== null) {
                  var _ = f("GET_ACTIVE_ITEMS").reduce(function (E, w) {
                    return E + w.fileSize;
                  }, 0);
                  if (_ > b) {
                    m({
                      status: {
                        main: f("GET_LABEL_MAX_TOTAL_FILE_SIZE_EXCEEDED"),
                        sub: o(f("GET_LABEL_MAX_TOTAL_FILE_SIZE"), {
                          filesize: l(
                            b,
                            ".",
                            f("GET_FILE_SIZE_BASE"),
                            f("GET_FILE_SIZE_LABELS", f)
                          ),
                        }),
                      },
                    });
                    return;
                  }
                }
                d(c);
              });
            }),
            {
              options: {
                allowFileSizeValidation: [!0, a.BOOLEAN],
                maxFileSize: [null, a.INT],
                minFileSize: [null, a.INT],
                maxTotalFileSize: [null, a.INT],
                fileValidateSizeFilter: [null, a.FUNCTION],
                labelMinFileSizeExceeded: ["File is too small", a.STRING],
                labelMinFileSize: ["Minimum file size is {filesize}", a.STRING],
                labelMaxFileSizeExceeded: ["File is too large", a.STRING],
                labelMaxFileSize: ["Maximum file size is {filesize}", a.STRING],
                labelMaxTotalFileSizeExceeded: [
                  "Maximum total size exceeded",
                  a.STRING,
                ],
                labelMaxTotalFileSize: [
                  "Maximum total file size is {filesize}",
                  a.STRING,
                ],
              },
            }
          );
        },
        e =
          typeof window != "undefined" && typeof window.document != "undefined";
      return (
        e &&
          document.dispatchEvent(
            new CustomEvent("FilePond:pluginloaded", { detail: n })
          ),
        n
      );
    });
  });
  var LO = jt((tae, IO) => {
    IO.exports = {
      jet: [
        { index: 0, rgb: [0, 0, 131] },
        { index: 0.125, rgb: [0, 60, 170] },
        { index: 0.375, rgb: [5, 255, 255] },
        { index: 0.625, rgb: [255, 255, 0] },
        { index: 0.875, rgb: [250, 0, 0] },
        { index: 1, rgb: [128, 0, 0] },
      ],
      hsv: [
        { index: 0, rgb: [255, 0, 0] },
        { index: 0.169, rgb: [253, 255, 2] },
        { index: 0.173, rgb: [247, 255, 2] },
        { index: 0.337, rgb: [0, 252, 4] },
        { index: 0.341, rgb: [0, 252, 10] },
        { index: 0.506, rgb: [1, 249, 255] },
        { index: 0.671, rgb: [2, 0, 253] },
        { index: 0.675, rgb: [8, 0, 253] },
        { index: 0.839, rgb: [255, 0, 251] },
        { index: 0.843, rgb: [255, 0, 245] },
        { index: 1, rgb: [255, 0, 6] },
      ],
      hot: [
        { index: 0, rgb: [0, 0, 0] },
        { index: 0.3, rgb: [230, 0, 0] },
        { index: 0.6, rgb: [255, 210, 0] },
        { index: 1, rgb: [255, 255, 255] },
      ],
      spring: [
        { index: 0, rgb: [255, 0, 255] },
        { index: 1, rgb: [255, 255, 0] },
      ],
      summer: [
        { index: 0, rgb: [0, 128, 102] },
        { index: 1, rgb: [255, 255, 102] },
      ],
      autumn: [
        { index: 0, rgb: [255, 0, 0] },
        { index: 1, rgb: [255, 255, 0] },
      ],
      winter: [
        { index: 0, rgb: [0, 0, 255] },
        { index: 1, rgb: [0, 255, 128] },
      ],
      bone: [
        { index: 0, rgb: [0, 0, 0] },
        { index: 0.376, rgb: [84, 84, 116] },
        { index: 0.753, rgb: [169, 200, 200] },
        { index: 1, rgb: [255, 255, 255] },
      ],
      copper: [
        { index: 0, rgb: [0, 0, 0] },
        { index: 0.804, rgb: [255, 160, 102] },
        { index: 1, rgb: [255, 199, 127] },
      ],
      greys: [
        { index: 0, rgb: [0, 0, 0] },
        { index: 1, rgb: [255, 255, 255] },
      ],
      yignbu: [
        { index: 0, rgb: [8, 29, 88] },
        { index: 0.125, rgb: [37, 52, 148] },
        { index: 0.25, rgb: [34, 94, 168] },
        { index: 0.375, rgb: [29, 145, 192] },
        { index: 0.5, rgb: [65, 182, 196] },
        { index: 0.625, rgb: [127, 205, 187] },
        { index: 0.75, rgb: [199, 233, 180] },
        { index: 0.875, rgb: [237, 248, 217] },
        { index: 1, rgb: [255, 255, 217] },
      ],
      greens: [
        { index: 0, rgb: [0, 68, 27] },
        { index: 0.125, rgb: [0, 109, 44] },
        { index: 0.25, rgb: [35, 139, 69] },
        { index: 0.375, rgb: [65, 171, 93] },
        { index: 0.5, rgb: [116, 196, 118] },
        { index: 0.625, rgb: [161, 217, 155] },
        { index: 0.75, rgb: [199, 233, 192] },
        { index: 0.875, rgb: [229, 245, 224] },
        { index: 1, rgb: [247, 252, 245] },
      ],
      yiorrd: [
        { index: 0, rgb: [128, 0, 38] },
        { index: 0.125, rgb: [189, 0, 38] },
        { index: 0.25, rgb: [227, 26, 28] },
        { index: 0.375, rgb: [252, 78, 42] },
        { index: 0.5, rgb: [253, 141, 60] },
        { index: 0.625, rgb: [254, 178, 76] },
        { index: 0.75, rgb: [254, 217, 118] },
        { index: 0.875, rgb: [255, 237, 160] },
        { index: 1, rgb: [255, 255, 204] },
      ],
      bluered: [
        { index: 0, rgb: [0, 0, 255] },
        { index: 1, rgb: [255, 0, 0] },
      ],
      rdbu: [
        { index: 0, rgb: [5, 10, 172] },
        { index: 0.35, rgb: [106, 137, 247] },
        { index: 0.5, rgb: [190, 190, 190] },
        { index: 0.6, rgb: [220, 170, 132] },
        { index: 0.7, rgb: [230, 145, 90] },
        { index: 1, rgb: [178, 10, 28] },
      ],
      picnic: [
        { index: 0, rgb: [0, 0, 255] },
        { index: 0.1, rgb: [51, 153, 255] },
        { index: 0.2, rgb: [102, 204, 255] },
        { index: 0.3, rgb: [153, 204, 255] },
        { index: 0.4, rgb: [204, 204, 255] },
        { index: 0.5, rgb: [255, 255, 255] },
        { index: 0.6, rgb: [255, 204, 255] },
        { index: 0.7, rgb: [255, 153, 255] },
        { index: 0.8, rgb: [255, 102, 204] },
        { index: 0.9, rgb: [255, 102, 102] },
        { index: 1, rgb: [255, 0, 0] },
      ],
      rainbow: [
        { index: 0, rgb: [150, 0, 90] },
        { index: 0.125, rgb: [0, 0, 200] },
        { index: 0.25, rgb: [0, 25, 255] },
        { index: 0.375, rgb: [0, 152, 255] },
        { index: 0.5, rgb: [44, 255, 150] },
        { index: 0.625, rgb: [151, 255, 0] },
        { index: 0.75, rgb: [255, 234, 0] },
        { index: 0.875, rgb: [255, 111, 0] },
        { index: 1, rgb: [255, 0, 0] },
      ],
      portland: [
        { index: 0, rgb: [12, 51, 131] },
        { index: 0.25, rgb: [10, 136, 186] },
        { index: 0.5, rgb: [242, 211, 56] },
        { index: 0.75, rgb: [242, 143, 56] },
        { index: 1, rgb: [217, 30, 30] },
      ],
      blackbody: [
        { index: 0, rgb: [0, 0, 0] },
        { index: 0.2, rgb: [230, 0, 0] },
        { index: 0.4, rgb: [230, 210, 0] },
        { index: 0.7, rgb: [255, 255, 255] },
        { index: 1, rgb: [160, 200, 255] },
      ],
      earth: [
        { index: 0, rgb: [0, 0, 130] },
        { index: 0.1, rgb: [0, 180, 180] },
        { index: 0.2, rgb: [40, 210, 40] },
        { index: 0.4, rgb: [230, 230, 50] },
        { index: 0.6, rgb: [120, 70, 20] },
        { index: 1, rgb: [255, 255, 255] },
      ],
      electric: [
        { index: 0, rgb: [0, 0, 0] },
        { index: 0.15, rgb: [30, 0, 100] },
        { index: 0.4, rgb: [120, 0, 100] },
        { index: 0.6, rgb: [160, 90, 0] },
        { index: 0.8, rgb: [230, 200, 0] },
        { index: 1, rgb: [255, 250, 220] },
      ],
      alpha: [
        { index: 0, rgb: [255, 255, 255, 0] },
        { index: 1, rgb: [255, 255, 255, 1] },
      ],
      viridis: [
        { index: 0, rgb: [68, 1, 84] },
        { index: 0.13, rgb: [71, 44, 122] },
        { index: 0.25, rgb: [59, 81, 139] },
        { index: 0.38, rgb: [44, 113, 142] },
        { index: 0.5, rgb: [33, 144, 141] },
        { index: 0.63, rgb: [39, 173, 129] },
        { index: 0.75, rgb: [92, 200, 99] },
        { index: 0.88, rgb: [170, 220, 50] },
        { index: 1, rgb: [253, 231, 37] },
      ],
      inferno: [
        { index: 0, rgb: [0, 0, 4] },
        { index: 0.13, rgb: [31, 12, 72] },
        { index: 0.25, rgb: [85, 15, 109] },
        { index: 0.38, rgb: [136, 34, 106] },
        { index: 0.5, rgb: [186, 54, 85] },
        { index: 0.63, rgb: [227, 89, 51] },
        { index: 0.75, rgb: [249, 140, 10] },
        { index: 0.88, rgb: [249, 201, 50] },
        { index: 1, rgb: [252, 255, 164] },
      ],
      magma: [
        { index: 0, rgb: [0, 0, 4] },
        { index: 0.13, rgb: [28, 16, 68] },
        { index: 0.25, rgb: [79, 18, 123] },
        { index: 0.38, rgb: [129, 37, 129] },
        { index: 0.5, rgb: [181, 54, 122] },
        { index: 0.63, rgb: [229, 80, 100] },
        { index: 0.75, rgb: [251, 135, 97] },
        { index: 0.88, rgb: [254, 194, 135] },
        { index: 1, rgb: [252, 253, 191] },
      ],
      plasma: [
        { index: 0, rgb: [13, 8, 135] },
        { index: 0.13, rgb: [75, 3, 161] },
        { index: 0.25, rgb: [125, 3, 168] },
        { index: 0.38, rgb: [168, 34, 150] },
        { index: 0.5, rgb: [203, 70, 121] },
        { index: 0.63, rgb: [229, 107, 93] },
        { index: 0.75, rgb: [248, 148, 65] },
        { index: 0.88, rgb: [253, 195, 40] },
        { index: 1, rgb: [240, 249, 33] },
      ],
      warm: [
        { index: 0, rgb: [125, 0, 179] },
        { index: 0.13, rgb: [172, 0, 187] },
        { index: 0.25, rgb: [219, 0, 170] },
        { index: 0.38, rgb: [255, 0, 130] },
        { index: 0.5, rgb: [255, 63, 74] },
        { index: 0.63, rgb: [255, 123, 0] },
        { index: 0.75, rgb: [234, 176, 0] },
        { index: 0.88, rgb: [190, 228, 0] },
        { index: 1, rgb: [147, 255, 0] },
      ],
      cool: [
        { index: 0, rgb: [125, 0, 179] },
        { index: 0.13, rgb: [116, 0, 218] },
        { index: 0.25, rgb: [98, 74, 237] },
        { index: 0.38, rgb: [68, 146, 231] },
        { index: 0.5, rgb: [0, 204, 197] },
        { index: 0.63, rgb: [0, 247, 146] },
        { index: 0.75, rgb: [0, 255, 88] },
        { index: 0.88, rgb: [40, 255, 8] },
        { index: 1, rgb: [147, 255, 0] },
      ],
      "rainbow-soft": [
        { index: 0, rgb: [125, 0, 179] },
        { index: 0.1, rgb: [199, 0, 180] },
        { index: 0.2, rgb: [255, 0, 121] },
        { index: 0.3, rgb: [255, 108, 0] },
        { index: 0.4, rgb: [222, 194, 0] },
        { index: 0.5, rgb: [150, 255, 0] },
        { index: 0.6, rgb: [0, 255, 55] },
        { index: 0.7, rgb: [0, 246, 150] },
        { index: 0.8, rgb: [50, 167, 222] },
        { index: 0.9, rgb: [103, 51, 235] },
        { index: 1, rgb: [124, 0, 186] },
      ],
      bathymetry: [
        { index: 0, rgb: [40, 26, 44] },
        { index: 0.13, rgb: [59, 49, 90] },
        { index: 0.25, rgb: [64, 76, 139] },
        { index: 0.38, rgb: [63, 110, 151] },
        { index: 0.5, rgb: [72, 142, 158] },
        { index: 0.63, rgb: [85, 174, 163] },
        { index: 0.75, rgb: [120, 206, 163] },
        { index: 0.88, rgb: [187, 230, 172] },
        { index: 1, rgb: [253, 254, 204] },
      ],
      cdom: [
        { index: 0, rgb: [47, 15, 62] },
        { index: 0.13, rgb: [87, 23, 86] },
        { index: 0.25, rgb: [130, 28, 99] },
        { index: 0.38, rgb: [171, 41, 96] },
        { index: 0.5, rgb: [206, 67, 86] },
        { index: 0.63, rgb: [230, 106, 84] },
        { index: 0.75, rgb: [242, 149, 103] },
        { index: 0.88, rgb: [249, 193, 135] },
        { index: 1, rgb: [254, 237, 176] },
      ],
      chlorophyll: [
        { index: 0, rgb: [18, 36, 20] },
        { index: 0.13, rgb: [25, 63, 41] },
        { index: 0.25, rgb: [24, 91, 59] },
        { index: 0.38, rgb: [13, 119, 72] },
        { index: 0.5, rgb: [18, 148, 80] },
        { index: 0.63, rgb: [80, 173, 89] },
        { index: 0.75, rgb: [132, 196, 122] },
        { index: 0.88, rgb: [175, 221, 162] },
        { index: 1, rgb: [215, 249, 208] },
      ],
      density: [
        { index: 0, rgb: [54, 14, 36] },
        { index: 0.13, rgb: [89, 23, 80] },
        { index: 0.25, rgb: [110, 45, 132] },
        { index: 0.38, rgb: [120, 77, 178] },
        { index: 0.5, rgb: [120, 113, 213] },
        { index: 0.63, rgb: [115, 151, 228] },
        { index: 0.75, rgb: [134, 185, 227] },
        { index: 0.88, rgb: [177, 214, 227] },
        { index: 1, rgb: [230, 241, 241] },
      ],
      "freesurface-blue": [
        { index: 0, rgb: [30, 4, 110] },
        { index: 0.13, rgb: [47, 14, 176] },
        { index: 0.25, rgb: [41, 45, 236] },
        { index: 0.38, rgb: [25, 99, 212] },
        { index: 0.5, rgb: [68, 131, 200] },
        { index: 0.63, rgb: [114, 156, 197] },
        { index: 0.75, rgb: [157, 181, 203] },
        { index: 0.88, rgb: [200, 208, 216] },
        { index: 1, rgb: [241, 237, 236] },
      ],
      "freesurface-red": [
        { index: 0, rgb: [60, 9, 18] },
        { index: 0.13, rgb: [100, 17, 27] },
        { index: 0.25, rgb: [142, 20, 29] },
        { index: 0.38, rgb: [177, 43, 27] },
        { index: 0.5, rgb: [192, 87, 63] },
        { index: 0.63, rgb: [205, 125, 105] },
        { index: 0.75, rgb: [216, 162, 148] },
        { index: 0.88, rgb: [227, 199, 193] },
        { index: 1, rgb: [241, 237, 236] },
      ],
      oxygen: [
        { index: 0, rgb: [64, 5, 5] },
        { index: 0.13, rgb: [106, 6, 15] },
        { index: 0.25, rgb: [144, 26, 7] },
        { index: 0.38, rgb: [168, 64, 3] },
        { index: 0.5, rgb: [188, 100, 4] },
        { index: 0.63, rgb: [206, 136, 11] },
        { index: 0.75, rgb: [220, 174, 25] },
        { index: 0.88, rgb: [231, 215, 44] },
        { index: 1, rgb: [248, 254, 105] },
      ],
      par: [
        { index: 0, rgb: [51, 20, 24] },
        { index: 0.13, rgb: [90, 32, 35] },
        { index: 0.25, rgb: [129, 44, 34] },
        { index: 0.38, rgb: [159, 68, 25] },
        { index: 0.5, rgb: [182, 99, 19] },
        { index: 0.63, rgb: [199, 134, 22] },
        { index: 0.75, rgb: [212, 171, 35] },
        { index: 0.88, rgb: [221, 210, 54] },
        { index: 1, rgb: [225, 253, 75] },
      ],
      phase: [
        { index: 0, rgb: [145, 105, 18] },
        { index: 0.13, rgb: [184, 71, 38] },
        { index: 0.25, rgb: [186, 58, 115] },
        { index: 0.38, rgb: [160, 71, 185] },
        { index: 0.5, rgb: [110, 97, 218] },
        { index: 0.63, rgb: [50, 123, 164] },
        { index: 0.75, rgb: [31, 131, 110] },
        { index: 0.88, rgb: [77, 129, 34] },
        { index: 1, rgb: [145, 105, 18] },
      ],
      salinity: [
        { index: 0, rgb: [42, 24, 108] },
        { index: 0.13, rgb: [33, 50, 162] },
        { index: 0.25, rgb: [15, 90, 145] },
        { index: 0.38, rgb: [40, 118, 137] },
        { index: 0.5, rgb: [59, 146, 135] },
        { index: 0.63, rgb: [79, 175, 126] },
        { index: 0.75, rgb: [120, 203, 104] },
        { index: 0.88, rgb: [193, 221, 100] },
        { index: 1, rgb: [253, 239, 154] },
      ],
      temperature: [
        { index: 0, rgb: [4, 35, 51] },
        { index: 0.13, rgb: [23, 51, 122] },
        { index: 0.25, rgb: [85, 59, 157] },
        { index: 0.38, rgb: [129, 79, 143] },
        { index: 0.5, rgb: [175, 95, 130] },
        { index: 0.63, rgb: [222, 112, 101] },
        { index: 0.75, rgb: [249, 146, 66] },
        { index: 0.88, rgb: [249, 196, 65] },
        { index: 1, rgb: [232, 250, 91] },
      ],
      turbidity: [
        { index: 0, rgb: [34, 31, 27] },
        { index: 0.13, rgb: [65, 50, 41] },
        { index: 0.25, rgb: [98, 69, 52] },
        { index: 0.38, rgb: [131, 89, 57] },
        { index: 0.5, rgb: [161, 112, 59] },
        { index: 0.63, rgb: [185, 140, 66] },
        { index: 0.75, rgb: [202, 174, 88] },
        { index: 0.88, rgb: [216, 209, 126] },
        { index: 1, rgb: [233, 246, 171] },
      ],
      "velocity-blue": [
        { index: 0, rgb: [17, 32, 64] },
        { index: 0.13, rgb: [35, 52, 116] },
        { index: 0.25, rgb: [29, 81, 156] },
        { index: 0.38, rgb: [31, 113, 162] },
        { index: 0.5, rgb: [50, 144, 169] },
        { index: 0.63, rgb: [87, 173, 176] },
        { index: 0.75, rgb: [149, 196, 189] },
        { index: 0.88, rgb: [203, 221, 211] },
        { index: 1, rgb: [254, 251, 230] },
      ],
      "velocity-green": [
        { index: 0, rgb: [23, 35, 19] },
        { index: 0.13, rgb: [24, 64, 38] },
        { index: 0.25, rgb: [11, 95, 45] },
        { index: 0.38, rgb: [39, 123, 35] },
        { index: 0.5, rgb: [95, 146, 12] },
        { index: 0.63, rgb: [152, 165, 18] },
        { index: 0.75, rgb: [201, 186, 69] },
        { index: 0.88, rgb: [233, 216, 137] },
        { index: 1, rgb: [255, 253, 205] },
      ],
      cubehelix: [
        { index: 0, rgb: [0, 0, 0] },
        { index: 0.07, rgb: [22, 5, 59] },
        { index: 0.13, rgb: [60, 4, 105] },
        { index: 0.2, rgb: [109, 1, 135] },
        { index: 0.27, rgb: [161, 0, 147] },
        { index: 0.33, rgb: [210, 2, 142] },
        { index: 0.4, rgb: [251, 11, 123] },
        { index: 0.47, rgb: [255, 29, 97] },
        { index: 0.53, rgb: [255, 54, 69] },
        { index: 0.6, rgb: [255, 85, 46] },
        { index: 0.67, rgb: [255, 120, 34] },
        { index: 0.73, rgb: [255, 157, 37] },
        { index: 0.8, rgb: [241, 191, 57] },
        { index: 0.87, rgb: [224, 220, 93] },
        { index: 0.93, rgb: [218, 241, 142] },
        { index: 1, rgb: [227, 253, 198] },
      ],
    };
  });
  var OO = jt((iae, RO) => {
    function FY(n, e, t) {
      return n * (1 - t) + e * t;
    }
    RO.exports = FY;
  });
  var FO = jt((nae, kO) => {
    "use strict";
    var NO = LO(),
      _g = OO();
    kO.exports = BY;
    function BY(n) {
      var e, t, i, r, s, a, o, l, d, c, u;
      if (
        (n || (n = {}),
        (l = (n.nshades || 72) - 1),
        (o = n.format || "hex"),
        (a = n.colormap),
        a || (a = "jet"),
        typeof a == "string")
      ) {
        if (((a = a.toLowerCase()), !NO[a]))
          throw Error(a + " not a supported colorscale");
        s = NO[a];
      } else if (Array.isArray(a)) s = a.slice();
      else throw Error("unsupported colormap option", a);
      if (s.length > l + 1)
        throw new Error(
          a + " map requires nshades to be at least size " + s.length
        );
      Array.isArray(n.alpha)
        ? n.alpha.length !== 2
          ? (c = [1, 1])
          : (c = n.alpha.slice())
        : typeof n.alpha == "number"
        ? (c = [n.alpha, n.alpha])
        : (c = [1, 1]),
        (e = s.map(function (y) {
          return Math.round(y.index * l);
        })),
        (c[0] = Math.min(Math.max(c[0], 0), 1)),
        (c[1] = Math.min(Math.max(c[1], 0), 1));
      var f = s.map(function (y, g) {
          var b = s[g].index,
            _ = s[g].rgb.slice();
          return (
            (_.length === 4 && _[3] >= 0 && _[3] <= 1) ||
              (_[3] = c[0] + (c[1] - c[0]) * b),
            _
          );
        }),
        d = [];
      for (u = 0; u < e.length - 1; ++u) {
        (r = e[u + 1] - e[u]), (t = f[u]), (i = f[u + 1]);
        for (var m = 0; m < r; m++) {
          var x = m / r;
          d.push([
            Math.round(_g(t[0], i[0], x)),
            Math.round(_g(t[1], i[1], x)),
            Math.round(_g(t[2], i[2], x)),
            _g(t[3], i[3], x),
          ]);
        }
      }
      return (
        d.push(s[s.length - 1].rgb.concat(c[1])),
        o === "hex"
          ? (d = d.map(UY))
          : o === "rgbaString"
          ? (d = d.map(VY))
          : o === "float" && (d = d.map(zY)),
        d
      );
    }
    function zY(n) {
      return [n[0] / 255, n[1] / 255, n[2] / 255, n[3]];
    }
    function UY(n) {
      for (var e, t = "#", i = 0; i < 3; ++i)
        (e = n[i]), (e = e.toString(16)), (t += ("00" + e).substr(e.length));
      return t;
    }
    function VY(n) {
      return "rgba(" + n.join(",") + ")";
    }
  });
  var VO = jt((Iae, zE) => {
    function BE() {}
    BE.prototype = {
      on: function (n, e, t) {
        var i = this.e || (this.e = {});
        return (i[n] || (i[n] = [])).push({ fn: e, ctx: t }), this;
      },
      once: function (n, e, t) {
        var i = this;
        function r() {
          i.off(n, r), e.apply(t, arguments);
        }
        return (r._ = e), this.on(n, r, t);
      },
      emit: function (n) {
        var e = [].slice.call(arguments, 1),
          t = ((this.e || (this.e = {}))[n] || []).slice(),
          i = 0,
          r = t.length;
        for (i; i < r; i++) t[i].fn.apply(t[i].ctx, e);
        return this;
      },
      off: function (n, e) {
        var t = this.e || (this.e = {}),
          i = t[n],
          r = [];
        if (i && e)
          for (var s = 0, a = i.length; s < a; s++)
            i[s].fn !== e && i[s].fn._ !== e && r.push(i[s]);
        return r.length ? (t[n] = r) : delete t[n], this;
      },
    };
    zE.exports = BE;
    zE.exports.TinyEmitter = BE;
  });
  var GO = jt((UE, VE) => {
    (function (n, e) {
      typeof UE == "object" && typeof VE != "undefined"
        ? (VE.exports = e())
        : typeof define == "function" && define.amd
        ? define(e)
        : ((n || self).virtualScroll = e());
    })(UE, function () {
      var n = 0;
      function e(m) {
        return "__private_" + n++ + "_" + m;
      }
      function t(m, x) {
        if (!Object.prototype.hasOwnProperty.call(m, x))
          throw new TypeError("attempted to use private field on non-instance");
        return m;
      }
      function i() {}
      i.prototype = {
        on: function (m, x, y) {
          var g = this.e || (this.e = {});
          return (g[m] || (g[m] = [])).push({ fn: x, ctx: y }), this;
        },
        once: function (m, x, y) {
          var g = this;
          function b() {
            g.off(m, b), x.apply(y, arguments);
          }
          return (b._ = x), this.on(m, b, y);
        },
        emit: function (m) {
          for (
            var x = [].slice.call(arguments, 1),
              y = ((this.e || (this.e = {}))[m] || []).slice(),
              g = 0,
              b = y.length;
            g < b;
            g++
          )
            y[g].fn.apply(y[g].ctx, x);
          return this;
        },
        off: function (m, x) {
          var y = this.e || (this.e = {}),
            g = y[m],
            b = [];
          if (g && x)
            for (var _ = 0, E = g.length; _ < E; _++)
              g[_].fn !== x && g[_].fn._ !== x && b.push(g[_]);
          return b.length ? (y[m] = b) : delete y[m], this;
        },
      };
      var r = i;
      r.TinyEmitter = i;
      var s,
        a = "virtualscroll",
        o = e("options"),
        l = e("el"),
        c = e("emitter"),
        u = e("event"),
        f = e("touchStart"),
        d = e("bodyTouchAction");
      return (function () {
        function m(y) {
          var g = this;
          Object.defineProperty(this, o, { writable: !0, value: void 0 }),
            Object.defineProperty(this, l, { writable: !0, value: void 0 }),
            Object.defineProperty(this, c, { writable: !0, value: void 0 }),
            Object.defineProperty(this, u, { writable: !0, value: void 0 }),
            Object.defineProperty(this, f, { writable: !0, value: void 0 }),
            Object.defineProperty(this, d, { writable: !0, value: void 0 }),
            (this._onWheel = function (b) {
              var _ = t(g, o)[o],
                E = t(g, u)[u];
              (E.deltaX = b.wheelDeltaX || -1 * b.deltaX),
                (E.deltaY = b.wheelDeltaY || -1 * b.deltaY),
                s.isFirefox &&
                  b.deltaMode === 1 &&
                  ((E.deltaX *= _.firefoxMultiplier),
                  (E.deltaY *= _.firefoxMultiplier)),
                (E.deltaX *= _.mouseMultiplier),
                (E.deltaY *= _.mouseMultiplier),
                g._notify(b);
            }),
            (this._onMouseWheel = function (b) {
              var _ = t(g, u)[u];
              (_.deltaX = b.wheelDeltaX ? b.wheelDeltaX : 0),
                (_.deltaY = b.wheelDeltaY ? b.wheelDeltaY : b.wheelDelta),
                g._notify(b);
            }),
            (this._onTouchStart = function (b) {
              var _ = b.targetTouches ? b.targetTouches[0] : b;
              (t(g, f)[f].x = _.pageX), (t(g, f)[f].y = _.pageY);
            }),
            (this._onTouchMove = function (b) {
              var _ = t(g, o)[o];
              _.preventTouch &&
                !b.target.classList.contains(_.unpreventTouchClass) &&
                b.preventDefault();
              var E = t(g, u)[u],
                w = b.targetTouches ? b.targetTouches[0] : b;
              (E.deltaX = (w.pageX - t(g, f)[f].x) * _.touchMultiplier),
                (E.deltaY = (w.pageY - t(g, f)[f].y) * _.touchMultiplier),
                (t(g, f)[f].x = w.pageX),
                (t(g, f)[f].y = w.pageY),
                g._notify(b);
            }),
            (this._onKeyDown = function (b) {
              var _ = t(g, u)[u];
              _.deltaX = _.deltaY = 0;
              var E = window.innerHeight - 40;
              switch (b.keyCode) {
                case 37:
                case 38:
                  _.deltaY = t(g, o)[o].keyStep;
                  break;
                case 39:
                case 40:
                  _.deltaY = -t(g, o)[o].keyStep;
                  break;
                case 32:
                  _.deltaY = E * (b.shiftKey ? 1 : -1);
                  break;
                default:
                  return;
              }
              g._notify(b);
            }),
            (t(this, l)[l] = window),
            y && y.el && ((t(this, l)[l] = y.el), delete y.el),
            s ||
              (s = {
                hasWheelEvent: "onwheel" in document,
                hasMouseWheelEvent: "onmousewheel" in document,
                hasTouch: "ontouchstart" in document,
                hasTouchWin:
                  navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
                hasPointer: !!window.navigator.msPointerEnabled,
                hasKeyDown: "onkeydown" in document,
                isFirefox: navigator.userAgent.indexOf("Firefox") > -1,
              }),
            (t(this, o)[o] = Object.assign(
              {
                mouseMultiplier: 1,
                touchMultiplier: 2,
                firefoxMultiplier: 15,
                keyStep: 120,
                preventTouch: !1,
                unpreventTouchClass: "vs-touchmove-allowed",
                useKeyboard: !0,
                useTouch: !0,
              },
              y
            )),
            (t(this, c)[c] = new r()),
            (t(this, u)[u] = { y: 0, x: 0, deltaX: 0, deltaY: 0 }),
            (t(this, f)[f] = { x: null, y: null }),
            (t(this, d)[d] = null),
            t(this, o)[o].passive !== void 0 &&
              (this.listenerOptions = { passive: t(this, o)[o].passive });
        }
        var x = m.prototype;
        return (
          (x._notify = function (y) {
            var g = t(this, u)[u];
            (g.x += g.deltaX),
              (g.y += g.deltaY),
              t(this, c)[c].emit(a, {
                x: g.x,
                y: g.y,
                deltaX: g.deltaX,
                deltaY: g.deltaY,
                originalEvent: y,
              });
          }),
          (x._bind = function () {
            s.hasWheelEvent &&
              t(this, l)[l].addEventListener(
                "wheel",
                this._onWheel,
                this.listenerOptions
              ),
              s.hasMouseWheelEvent &&
                t(this, l)[l].addEventListener(
                  "mousewheel",
                  this._onMouseWheel,
                  this.listenerOptions
                ),
              s.hasTouch &&
                t(this, o)[o].useTouch &&
                (t(this, l)[l].addEventListener(
                  "touchstart",
                  this._onTouchStart,
                  this.listenerOptions
                ),
                t(this, l)[l].addEventListener(
                  "touchmove",
                  this._onTouchMove,
                  this.listenerOptions
                )),
              s.hasPointer &&
                s.hasTouchWin &&
                ((t(this, d)[d] = document.body.style.msTouchAction),
                (document.body.style.msTouchAction = "none"),
                t(this, l)[l].addEventListener(
                  "MSPointerDown",
                  this._onTouchStart,
                  !0
                ),
                t(this, l)[l].addEventListener(
                  "MSPointerMove",
                  this._onTouchMove,
                  !0
                )),
              s.hasKeyDown &&
                t(this, o)[o].useKeyboard &&
                document.addEventListener("keydown", this._onKeyDown);
          }),
          (x._unbind = function () {
            s.hasWheelEvent &&
              t(this, l)[l].removeEventListener("wheel", this._onWheel),
              s.hasMouseWheelEvent &&
                t(this, l)[l].removeEventListener(
                  "mousewheel",
                  this._onMouseWheel
                ),
              s.hasTouch &&
                (t(this, l)[l].removeEventListener(
                  "touchstart",
                  this._onTouchStart
                ),
                t(this, l)[l].removeEventListener(
                  "touchmove",
                  this._onTouchMove
                )),
              s.hasPointer &&
                s.hasTouchWin &&
                ((document.body.style.msTouchAction = t(this, d)[d]),
                t(this, l)[l].removeEventListener(
                  "MSPointerDown",
                  this._onTouchStart,
                  !0
                ),
                t(this, l)[l].removeEventListener(
                  "MSPointerMove",
                  this._onTouchMove,
                  !0
                )),
              s.hasKeyDown &&
                t(this, o)[o].useKeyboard &&
                document.removeEventListener("keydown", this._onKeyDown);
          }),
          (x.on = function (y, g) {
            t(this, c)[c].on(a, y, g);
            var b = t(this, c)[c].e;
            b && b[a] && b[a].length === 1 && this._bind();
          }),
          (x.off = function (y, g) {
            t(this, c)[c].off(a, y, g);
            var b = t(this, c)[c].e;
            (!b[a] || b[a].length <= 0) && this._unbind();
          }),
          (x.destroy = function () {
            t(this, c)[c].off(), this._unbind();
          }),
          m
        );
      })();
    });
  });
  var tN = jt((eN, Cg) => {
    (function (n, e) {
      typeof define == "function" && define.amd
        ? define([], function () {
            return (n.svg4everybody = e());
          })
        : typeof Cg == "object" && Cg.exports
        ? (Cg.exports = e())
        : (n.svg4everybody = e());
    })(eN, function () {
      function n(r, s, a) {
        if (a) {
          var o = document.createDocumentFragment(),
            l = !s.hasAttribute("viewBox") && a.getAttribute("viewBox");
          l && s.setAttribute("viewBox", l);
          for (var c = a.cloneNode(!0); c.childNodes.length; )
            o.appendChild(c.firstChild);
          r.appendChild(o);
        }
      }
      function e(r) {
        (r.onreadystatechange = function () {
          if (r.readyState === 4) {
            var s = r._cachedDocument;
            s ||
              ((s = r._cachedDocument =
                document.implementation.createHTMLDocument("")),
              (s.body.innerHTML = r.responseText),
              (r._cachedTarget = {})),
              r._embeds.splice(0).map(function (a) {
                var o = r._cachedTarget[a.id];
                o || (o = r._cachedTarget[a.id] = s.getElementById(a.id)),
                  n(a.parent, a.svg, o);
              });
          }
        }),
          r.onreadystatechange();
      }
      function t(r) {
        function s() {
          for (var b = 0; b < y.length; ) {
            var _ = y[b],
              E = _.parentNode,
              w = i(E),
              P = _.getAttribute("xlink:href") || _.getAttribute("href");
            if (
              (!P && o.attributeName && (P = _.getAttribute(o.attributeName)),
              w && P)
            ) {
              if (a)
                if (!o.validate || o.validate(P, w, _)) {
                  E.removeChild(_);
                  var L = P.split("#"),
                    I = L.shift(),
                    M = L.join("#");
                  if (I.length) {
                    var R = m[I];
                    R ||
                      ((R = m[I] = new XMLHttpRequest()),
                      R.open("GET", I),
                      R.send(),
                      (R._embeds = [])),
                      R._embeds.push({ parent: E, svg: w, id: M }),
                      e(R);
                  } else n(E, w, document.getElementById(M));
                } else ++b, ++g;
            } else ++b;
          }
          (!y.length || y.length - g > 0) && x(s, 67);
        }
        var a,
          o = Object(r),
          l = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/,
          c = /\bAppleWebKit\/(\d+)\b/,
          u = /\bEdge\/12\.(\d+)\b/,
          f = /\bEdge\/.(\d+)\b/,
          d = window.top !== window.self;
        a =
          "polyfill" in o
            ? o.polyfill
            : l.test(navigator.userAgent) ||
              (navigator.userAgent.match(u) || [])[1] < 10547 ||
              (navigator.userAgent.match(c) || [])[1] < 537 ||
              (f.test(navigator.userAgent) && d);
        var m = {},
          x = window.requestAnimationFrame || setTimeout,
          y = document.getElementsByTagName("use"),
          g = 0;
        a && s();
      }
      function i(r) {
        for (
          var s = r;
          s.nodeName.toLowerCase() !== "svg" && (s = s.parentNode);

        );
        return s;
      }
      return t;
    });
  });
  function ud(n) {
    return (
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? (ud = function (e) {
            return typeof e;
          })
        : (ud = function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
      ud(n)
    );
  }
  function OS(n, e) {
    if (!(n instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function LS(n, e) {
    for (var t = 0; t < e.length; t++) {
      var i = e[t];
      (i.enumerable = i.enumerable || !1),
        (i.configurable = !0),
        "value" in i && (i.writable = !0),
        Object.defineProperty(n, i.key, i);
    }
  }
  function NS(n, e, t) {
    return e && LS(n.prototype, e), t && LS(n, t), n;
  }
  function RS(n, e, t) {
    return (
      e in n
        ? Object.defineProperty(n, e, {
            value: t,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (n[e] = t),
      n
    );
  }
  function cd(n, e) {
    return ZF(n) || eB(n, e) || kS(n, e) || iB();
  }
  function KF(n) {
    return JF(n) || QF(n) || kS(n) || tB();
  }
  function JF(n) {
    if (Array.isArray(n)) return a0(n);
  }
  function ZF(n) {
    if (Array.isArray(n)) return n;
  }
  function QF(n) {
    if (typeof Symbol != "undefined" && Symbol.iterator in Object(n))
      return Array.from(n);
  }
  function eB(n, e) {
    if (!(typeof Symbol == "undefined" || !(Symbol.iterator in Object(n)))) {
      var t = [],
        i = !0,
        r = !1,
        s = void 0;
      try {
        for (
          var a = n[Symbol.iterator](), o;
          !(i = (o = a.next()).done) &&
          (t.push(o.value), !(e && t.length === e));
          i = !0
        );
      } catch (l) {
        (r = !0), (s = l);
      } finally {
        try {
          !i && a.return != null && a.return();
        } finally {
          if (r) throw s;
        }
      }
      return t;
    }
  }
  function kS(n, e) {
    if (!!n) {
      if (typeof n == "string") return a0(n, e);
      var t = Object.prototype.toString.call(n).slice(8, -1);
      if (
        (t === "Object" && n.constructor && (t = n.constructor.name),
        t === "Map" || t === "Set")
      )
        return Array.from(n);
      if (
        t === "Arguments" ||
        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)
      )
        return a0(n, e);
    }
  }
  function a0(n, e) {
    (e == null || e > n.length) && (e = n.length);
    for (var t = 0, i = new Array(e); t < e; t++) i[t] = n[t];
    return i;
  }
  function tB() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function iB() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var St = (function () {
      function n(e) {
        OS(this, n),
          (this.mAttr = "data-" + e.dataName),
          (this.mCaptureEvents = ["mouseenter", "mouseleave"]),
          (this.el = e.el);
      }
      return (
        NS(n, [
          {
            key: "mInit",
            value: function (t) {
              var i = this;
              (this.modules = t),
                (this.mCheckEventTarget = this.mCheckEventTarget.bind(this)),
                this.events &&
                  Object.keys(this.events).forEach(function (r) {
                    return i.mAddEvent(r);
                  });
            },
          },
          {
            key: "mUpdate",
            value: function (t) {
              this.modules = t;
            },
          },
          {
            key: "mDestroy",
            value: function () {
              var t = this;
              this.events &&
                Object.keys(this.events).forEach(function (i) {
                  return t.mRemoveEvent(i);
                });
            },
          },
          {
            key: "mAddEvent",
            value: function (t) {
              var i = !!this.mCaptureEvents.includes(t);
              this.el.addEventListener(t, this.mCheckEventTarget, i);
            },
          },
          {
            key: "mRemoveEvent",
            value: function (t) {
              var i = !!this.mCaptureEvents.includes(t);
              this.el.removeEventListener(t, this.mCheckEventTarget, i);
            },
          },
          {
            key: "mCheckEventTarget",
            value: function (t) {
              var i = this.events[t.type];
              if (typeof i == "string") this[i](t);
              else {
                var r = "[" + this.mAttr + "]",
                  s = t.target;
                if (this.mCaptureEvents.includes(t.type))
                  s.matches(r) && this.mCallEventMethod(t, i, s);
                else
                  for (
                    ;
                    s &&
                    s !== document &&
                    !(
                      s.matches(r) &&
                      this.mCallEventMethod(t, i, s) != "undefined"
                    );

                  )
                    s = s.parentNode;
              }
            },
          },
          {
            key: "mCallEventMethod",
            value: function (t, i, r) {
              var s = r.getAttribute(this.mAttr);
              if (i.hasOwnProperty(s)) {
                var a = i[s];
                t.hasOwnProperty("currentTarget") ||
                  Object.defineProperty(t, "currentTarget", { value: r }),
                  t.hasOwnProperty("curTarget") ||
                    Object.defineProperty(t, "curTarget", { value: r }),
                  this[a](t);
              }
            },
          },
          {
            key: "$",
            value: function (t, i) {
              var r = t.indexOf("."),
                s = t.indexOf("#"),
                a = t.indexOf("["),
                o = [r, s, a].filter(function (d) {
                  return d != -1;
                }),
                l = !1,
                c = t,
                u = "",
                f = this.el;
              return (
                o.length &&
                  ((l = Math.min.apply(Math, KF(o))),
                  (c = t.slice(0, l)),
                  (u = t.slice(l))),
                ud(i) == "object" && (f = i),
                f.querySelectorAll("[" + this.mAttr + "=" + c + "]" + u)
              );
            },
          },
          {
            key: "parent",
            value: function (t, i) {
              for (
                var r = "[" + this.mAttr + "=" + t + "]", s = i.parentNode;
                s && s !== document;

              ) {
                if (s.matches(r)) return s;
                s = s.parentNode;
              }
            },
          },
          {
            key: "getData",
            value: function (t, i) {
              var r = i || this.el;
              return r.getAttribute(this.mAttr + "-" + t);
            },
          },
          {
            key: "setData",
            value: function (t, i, r) {
              var s = r || this.el;
              return s.setAttribute(this.mAttr + "-" + t, i);
            },
          },
          {
            key: "call",
            value: function (t, i, r, s) {
              var a = this;
              i && !r && ((r = i), (i = !1)),
                this.modules[r] &&
                  (s
                    ? this.modules[r][s] && this.modules[r][s][t](i)
                    : Object.keys(this.modules[r]).forEach(function (o) {
                        a.modules[r][o][t](i);
                      }));
            },
          },
          {
            key: "on",
            value: function (t, i, r, s) {
              var a = this;
              this.modules[i] &&
                (s
                  ? this.modules[i][s].el.addEventListener(t, function (o) {
                      return r(o);
                    })
                  : Object.keys(this.modules[i]).forEach(function (o) {
                      a.modules[i][o].el.addEventListener(t, function (l) {
                        return r(l);
                      });
                    }));
            },
          },
          { key: "init", value: function () {} },
          { key: "destroy", value: function () {} },
        ]),
        n
      );
    })(),
    nB = (function () {
      function n(e) {
        OS(this, n),
          this.app,
          (this.modules = e.modules),
          (this.currentModules = {}),
          (this.activeModules = {}),
          (this.newModules = {}),
          (this.moduleId = 0);
      }
      return (
        NS(n, [
          {
            key: "init",
            value: function (t, i) {
              var r = this,
                s = i || document,
                a = s.querySelectorAll("*");
              t && !this.app && (this.app = t),
                (this.activeModules.app = { app: this.app }),
                a.forEach(function (o) {
                  Array.from(o.attributes).forEach(function (l) {
                    if (l.name.startsWith("data-module")) {
                      var c = !1,
                        u = l.name.split("-").splice(2),
                        f = r.toCamel(u);
                      if (
                        (r.modules[f]
                          ? (c = !0)
                          : r.modules[r.toUpper(f)] &&
                            ((f = r.toUpper(f)), (c = !0)),
                        c)
                      ) {
                        var d = { el: o, name: f, dataName: u.join("-") },
                          m = new r.modules[f](d),
                          x = l.value;
                        x ||
                          (r.moduleId++,
                          (x = "m" + r.moduleId),
                          o.setAttribute(l.name, x)),
                          r.addActiveModule(f, x, m);
                        var y = f + "-" + x;
                        i ? (r.newModules[y] = m) : (r.currentModules[y] = m);
                      }
                    }
                  });
                }),
                Object.entries(this.currentModules).forEach(function (o) {
                  var l = cd(o, 2),
                    c = l[0],
                    u = l[1];
                  if (i) {
                    var f = c.split("-"),
                      d = f.shift(),
                      m = f.pop();
                    r.addActiveModule(d, m, u);
                  } else r.initModule(u);
                });
            },
          },
          {
            key: "initModule",
            value: function (t) {
              t.mInit(this.activeModules), t.init();
            },
          },
          {
            key: "addActiveModule",
            value: function (t, i, r) {
              this.activeModules[t]
                ? Object.assign(this.activeModules[t], RS({}, i, r))
                : (this.activeModules[t] = RS({}, i, r));
            },
          },
          {
            key: "update",
            value: function (t) {
              var i = this;
              this.init(this.app, t),
                Object.entries(this.currentModules).forEach(function (r) {
                  var s = cd(r, 2),
                    a = s[0],
                    o = s[1];
                  o.mUpdate(i.activeModules);
                }),
                Object.entries(this.newModules).forEach(function (r) {
                  var s = cd(r, 2),
                    a = s[0],
                    o = s[1];
                  i.initModule(o);
                }),
                Object.assign(this.currentModules, this.newModules);
            },
          },
          {
            key: "destroy",
            value: function (t) {
              t ? this.destroyScope(t) : this.destroyModules();
            },
          },
          {
            key: "destroyScope",
            value: function (t) {
              var i = this,
                r = t.querySelectorAll("*");
              r.forEach(function (s) {
                Array.from(s.attributes).forEach(function (a) {
                  if (a.name.startsWith("data-module")) {
                    var o = a.value,
                      l = a.name.split("-").splice(2),
                      c = i.toCamel(l) + "-" + o,
                      u = !1;
                    i.currentModules[c]
                      ? (u = !0)
                      : i.currentModules[i.toUpper(c)] &&
                        ((c = i.toUpper(c)), (u = !0)),
                      u &&
                        (i.destroyModule(i.currentModules[c]),
                        delete i.currentModules[c]);
                  }
                });
              }),
                (this.activeModules = {}),
                (this.newModules = {});
            },
          },
          {
            key: "destroyModules",
            value: function () {
              var t = this;
              Object.entries(this.currentModules).forEach(function (i) {
                var r = cd(i, 2),
                  s = r[0],
                  a = r[1];
                t.destroyModule(a);
              }),
                (this.currentModules = []);
            },
          },
          {
            key: "destroyModule",
            value: function (t) {
              t.mDestroy(), t.destroy();
            },
          },
          {
            key: "toCamel",
            value: function (t) {
              var i = this;
              return t.reduce(function (r, s) {
                return r + i.toUpper(s);
              });
            },
          },
          {
            key: "toUpper",
            value: function (t) {
              return t.charAt(0).toUpperCase() + t.slice(1);
            },
          },
        ]),
        n
      );
    })(),
    FS = nB;
  var aT = {};
  ld(aT, {
    CopyToClipboard: () => o0,
    FancyGallery: () => ny,
    FancyTexts: () => ly,
    FeaturedLinks: () => cy,
    Gallery: () => cv,
    GridHelper: () => Js,
    Header: () => hv,
    HomeHero: () => fv,
    Hovers: () => dv,
    ImagesSequence: () => pv,
    Lisa: () => OE,
    Load: () => yv,
    LostScene: () => Wx,
    ModelViewer: () => La,
    NewsletterModal: () => NE,
    NewsletterToggler: () => kE,
    Rail: () => FE,
    Scroll: () => $E,
    TeamCanvas: () => WE,
    TeamList: () => qE,
    TeamListCanvas: () => jE,
    TeamModal: () => KE,
    TeamModalCanvas: () => JE,
    VideoInview: () => ZE,
    VideoModal: () => QE,
    VideoModalToggler: () => eT,
    WorkFilters: () => tT,
    WorkGallery: () => iT,
    WorkListItem: () => nT,
    WorkNext: () => rT,
    WorkSingleHero: () => sT,
  });
  var rB = /\p{Extended_Pictographic}|\r|\n|./gu;
  function Fa(n, e) {
    if ((!n.children.length || n.dataset.allowShuffle != null) && n.innerText) {
      n.querySelectorAll(".u-screen-reader-text").forEach((i) => i.remove());
      let t = n.innerText
        .replace(
          `
`,
          ` 
 `
        )
        .split(" ");
      for (let i = 0; i < t.length; i++) {
        let r = [...t[i].matchAll(rB)].map((s) => s[0]);
        t[i] = e(r);
      }
      n.innerText = t.join(" ");
    }
  }
  function BS(n, e) {
    n.querySelectorAll("*").forEach((t) => {
      Fa(t, e);
    });
  }
  function hd(n) {
    window.copyToClipboard(n.dataset.toCopy), alert(n.dataset.confirmation);
  }
  var o0 = class extends St {
    constructor(n) {
      super(n);
      this.events = { click: "onClick" };
    }
    onClick(n) {
      n.preventDefault(), n.stopPropagation(), hd(n.target);
    }
  };
  function Gs(n) {
    if (n === void 0)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return n;
  }
  function qS(n, e) {
    (n.prototype = Object.create(e.prototype)),
      (n.prototype.constructor = n),
      (n.__proto__ = e);
  }
  var nr = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: { lineHeight: "" },
    },
    Xl = { duration: 0.5, overwrite: !1, delay: 0 },
    M0,
    tr,
    Zi,
    Ur = 1e8,
    Ei = 1 / Ur,
    m0 = Math.PI * 2,
    sB = m0 / 4,
    aB = 0,
    jS = Math.sqrt,
    oB = Math.cos,
    lB = Math.sin,
    ln = function (e) {
      return typeof e == "string";
    },
    Ui = function (e) {
      return typeof e == "function";
    },
    $s = function (e) {
      return typeof e == "number";
    },
    Ed = function (e) {
      return typeof e == "undefined";
    },
    bs = function (e) {
      return typeof e == "object";
    },
    ir = function (e) {
      return e !== !1;
    },
    XS = function () {
      return typeof window != "undefined";
    },
    fd = function (e) {
      return Ui(e) || ln(e);
    },
    YS =
      (typeof ArrayBuffer == "function" && ArrayBuffer.isView) ||
      function () {},
    An = Array.isArray,
    g0 = /(?:-?\.?\d|\.)+/gi,
    A0 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    Vo = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    l0 = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    C0 = /[+-]=-?[.\d]+/,
    KS = /[^,'"\[\]\s]+/gi,
    cB = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    ki,
    zr,
    y0,
    P0,
    pr = {},
    gd = {},
    JS,
    ZS = function (e) {
      return (gd = Uo(e, pr)) && zn;
    },
    Td = function (e, t) {
      return console.warn(
        "Invalid property",
        e,
        "set to",
        t,
        "Missing plugin? gsap.registerPlugin()"
      );
    },
    yd = function (e, t) {
      return !t && console.warn(e);
    },
    QS = function (e, t) {
      return (e && (pr[e] = t) && gd && (gd[e] = t)) || pr;
    },
    Nu = function () {
      return 0;
    },
    uB = { suppressEvents: !0, isStart: !0, kill: !1 },
    dd = { suppressEvents: !0, kill: !1 },
    hB = { suppressEvents: !0 },
    D0 = {},
    za = [],
    v0 = {},
    e1,
    Qn = {},
    c0 = {},
    zS = 30,
    pd = [],
    I0 = "",
    L0 = function (e) {
      var t = e[0],
        i,
        r;
      if ((bs(t) || Ui(t) || (e = [e]), !(i = (t._gsap || {}).harness))) {
        for (r = pd.length; r-- && !pd[r].targetTest(t); );
        i = pd[r];
      }
      for (r = e.length; r--; )
        (e[r] && (e[r]._gsap || (e[r]._gsap = new N0(e[r], i)))) ||
          e.splice(r, 1);
      return e;
    },
    Ua = function (e) {
      return e._gsap || L0(Vr(e))[0]._gsap;
    },
    R0 = function (e, t, i) {
      return (i = e[t]) && Ui(i)
        ? e[t]()
        : (Ed(i) && e.getAttribute && e.getAttribute(t)) || i;
    },
    Un = function (e, t) {
      return (e = e.split(",")).forEach(t) || e;
    },
    Vi = function (e) {
      return Math.round(e * 1e5) / 1e5 || 0;
    },
    _n = function (e) {
      return Math.round(e * 1e7) / 1e7 || 0;
    },
    Go = function (e, t) {
      var i = t.charAt(0),
        r = parseFloat(t.substr(2));
      return (
        (e = parseFloat(e)),
        i === "+" ? e + r : i === "-" ? e - r : i === "*" ? e * r : e / r
      );
    },
    fB = function (e, t) {
      for (var i = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < i; );
      return r < i;
    },
    vd = function () {
      var e = za.length,
        t = za.slice(0),
        i,
        r;
      for (v0 = {}, za.length = 0, i = 0; i < e; i++)
        (r = t[i]),
          r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0);
    },
    t1 = function (e, t, i, r) {
      za.length && vd(),
        e.render(t, i, r || (tr && t < 0 && (e._initted || e._startAt))),
        za.length && vd();
    },
    i1 = function (e) {
      var t = parseFloat(e);
      return (t || t === 0) && (e + "").match(KS).length < 2
        ? t
        : ln(e)
        ? e.trim()
        : e;
    },
    n1 = function (e) {
      return e;
    },
    Hr = function (e, t) {
      for (var i in t) i in e || (e[i] = t[i]);
      return e;
    },
    dB = function (e) {
      return function (t, i) {
        for (var r in i)
          r in t || (r === "duration" && e) || r === "ease" || (t[r] = i[r]);
      };
    },
    Uo = function (e, t) {
      for (var i in t) e[i] = t[i];
      return e;
    },
    US = function n(e, t) {
      for (var i in t)
        i !== "__proto__" &&
          i !== "constructor" &&
          i !== "prototype" &&
          (e[i] = bs(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]);
      return e;
    },
    xd = function (e, t) {
      var i = {},
        r;
      for (r in e) r in t || (i[r] = e[r]);
      return i;
    },
    Lu = function (e) {
      var t = e.parent || ki,
        i = e.keyframes ? dB(An(e.keyframes)) : Hr;
      if (ir(e.inherit))
        for (; t; ) i(e, t.vars.defaults), (t = t.parent || t._dp);
      return e;
    },
    pB = function (e, t) {
      for (var i = e.length, r = i === t.length; r && i-- && e[i] === t[i]; );
      return i < 0;
    },
    r1 = function (e, t, i, r, s) {
      i === void 0 && (i = "_first"), r === void 0 && (r = "_last");
      var a = e[r],
        o;
      if (s) for (o = t[s]; a && a[s] > o; ) a = a._prev;
      return (
        a
          ? ((t._next = a._next), (a._next = t))
          : ((t._next = e[i]), (e[i] = t)),
        t._next ? (t._next._prev = t) : (e[r] = t),
        (t._prev = a),
        (t.parent = t._dp = e),
        t
      );
    },
    Sd = function (e, t, i, r) {
      i === void 0 && (i = "_first"), r === void 0 && (r = "_last");
      var s = t._prev,
        a = t._next;
      s ? (s._next = a) : e[i] === t && (e[i] = a),
        a ? (a._prev = s) : e[r] === t && (e[r] = s),
        (t._next = t._prev = t.parent = null);
    },
    Va = function (e, t) {
      e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove(e),
        (e._act = 0);
    },
    Bo = function (e, t) {
      if (e && (!t || t._end > e._dur || t._start < 0))
        for (var i = e; i; ) (i._dirty = 1), (i = i.parent);
      return e;
    },
    mB = function (e) {
      for (var t = e.parent; t && t.parent; )
        (t._dirty = 1), t.totalDuration(), (t = t.parent);
      return e;
    },
    x0 = function (e, t, i, r) {
      return (
        e._startAt &&
        (tr
          ? e._startAt.revert(dd)
          : (e.vars.immediateRender && !e.vars.autoRevert) ||
            e._startAt.render(t, !0, r))
      );
    },
    gB = function n(e) {
      return !e || (e._ts && n(e.parent));
    },
    VS = function (e) {
      return e._repeat ? Yl(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
    },
    Yl = function (e, t) {
      var i = Math.floor((e /= t));
      return e && i === e ? i - 1 : i;
    },
    bd = function (e, t) {
      return (
        (e - t._start) * t._ts +
        (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
      );
    },
    wd = function (e) {
      return (e._end = _n(
        e._start + (e._tDur / Math.abs(e._ts || e._rts || Ei) || 0)
      ));
    },
    Md = function (e, t) {
      var i = e._dp;
      return (
        i &&
          i.smoothChildTiming &&
          e._ts &&
          ((e._start = _n(
            i._time -
              (e._ts > 0
                ? t / e._ts
                : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
          )),
          wd(e),
          i._dirty || Bo(i, e)),
        e
      );
    },
    s1 = function (e, t) {
      var i;
      if (
        ((t._time || (t._initted && !t._dur)) &&
          ((i = bd(e.rawTime(), t)),
          (!t._dur || Fu(0, t.totalDuration(), i) - t._tTime > Ei) &&
            t.render(i, !0)),
        Bo(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
      ) {
        if (e._dur < e.duration())
          for (i = e; i._dp; )
            i.rawTime() >= 0 && i.totalTime(i._tTime), (i = i._dp);
        e._zTime = -Ei;
      }
    },
    xs = function (e, t, i, r) {
      return (
        t.parent && Va(t),
        (t._start = _n(
          ($s(i) ? i : i || e !== ki ? Br(e, i, t) : e._time) + t._delay
        )),
        (t._end = _n(
          t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
        )),
        r1(e, t, "_first", "_last", e._sort ? "_start" : 0),
        b0(t) || (e._recent = t),
        r || s1(e, t),
        e._ts < 0 && Md(e, e._tTime),
        e
      );
    },
    a1 = function (e, t) {
      return (
        (pr.ScrollTrigger || Td("scrollTrigger", t)) &&
        pr.ScrollTrigger.create(t, e)
      );
    },
    o1 = function (e, t, i, r, s) {
      if ((B0(e, t, s), !e._initted)) return 1;
      if (
        !i &&
        e._pt &&
        !tr &&
        ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
        e1 !== er.frame
      )
        return za.push(e), (e._lazy = [s, r]), 1;
    },
    yB = function n(e) {
      var t = e.parent;
      return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t));
    },
    b0 = function (e) {
      var t = e.data;
      return t === "isFromStart" || t === "isStart";
    },
    vB = function (e, t, i, r) {
      var s = e.ratio,
        a =
          t < 0 ||
          (!t &&
            ((!e._start && yB(e) && !(!e._initted && b0(e))) ||
              ((e._ts < 0 || e._dp._ts < 0) && !b0(e))))
            ? 0
            : 1,
        o = e._rDelay,
        l = 0,
        c,
        u,
        f;
      if (
        (o &&
          e._repeat &&
          ((l = Fu(0, e._tDur, t)),
          (u = Yl(l, o)),
          e._yoyo && u & 1 && (a = 1 - a),
          u !== Yl(e._tTime, o) &&
            ((s = 1 - a),
            e.vars.repeatRefresh && e._initted && e.invalidate())),
        a !== s || tr || r || e._zTime === Ei || (!t && e._zTime))
      ) {
        if (!e._initted && o1(e, t, r, i, l)) return;
        for (
          f = e._zTime,
            e._zTime = t || (i ? Ei : 0),
            i || (i = t && !f),
            e.ratio = a,
            e._from && (a = 1 - a),
            e._time = 0,
            e._tTime = l,
            c = e._pt;
          c;

        )
          c.r(a, c.d), (c = c._next);
        t < 0 && x0(e, t, i, !0),
          e._onUpdate && !i && Gr(e, "onUpdate"),
          l && e._repeat && !i && e.parent && Gr(e, "onRepeat"),
          (t >= e._tDur || t < 0) &&
            e.ratio === a &&
            (a && Va(e, 1),
            !i &&
              !tr &&
              (Gr(e, a ? "onComplete" : "onReverseComplete", !0),
              e._prom && e._prom()));
      } else e._zTime || (e._zTime = t);
    },
    xB = function (e, t, i) {
      var r;
      if (i > t)
        for (r = e._first; r && r._start <= i; ) {
          if (r.data === "isPause" && r._start > t) return r;
          r = r._next;
        }
      else
        for (r = e._last; r && r._start >= i; ) {
          if (r.data === "isPause" && r._start < t) return r;
          r = r._prev;
        }
    },
    Kl = function (e, t, i, r) {
      var s = e._repeat,
        a = _n(t) || 0,
        o = e._tTime / e._tDur;
      return (
        o && !r && (e._time *= a / e._dur),
        (e._dur = a),
        (e._tDur = s ? (s < 0 ? 1e10 : _n(a * (s + 1) + e._rDelay * s)) : a),
        o > 0 && !r && Md(e, (e._tTime = e._tDur * o)),
        e.parent && wd(e),
        i || Bo(e.parent, e),
        e
      );
    },
    GS = function (e) {
      return e instanceof Mn ? Bo(e) : Kl(e, e._dur);
    },
    bB = { _start: 0, endTime: Nu, totalDuration: Nu },
    Br = function n(e, t, i) {
      var r = e.labels,
        s = e._recent || bB,
        a = e.duration() >= Ur ? s.endTime(!1) : e._dur,
        o,
        l,
        c;
      return ln(t) && (isNaN(t) || t in r)
        ? ((l = t.charAt(0)),
          (c = t.substr(-1) === "%"),
          (o = t.indexOf("=")),
          l === "<" || l === ">"
            ? (o >= 0 && (t = t.replace(/=/, "")),
              (l === "<" ? s._start : s.endTime(s._repeat >= 0)) +
                (parseFloat(t.substr(1)) || 0) *
                  (c ? (o < 0 ? s : i).totalDuration() / 100 : 1))
            : o < 0
            ? (t in r || (r[t] = a), r[t])
            : ((l = parseFloat(t.charAt(o - 1) + t.substr(o + 1))),
              c && i && (l = (l / 100) * (An(i) ? i[0] : i).totalDuration()),
              o > 1 ? n(e, t.substr(0, o - 1), i) + l : a + l))
        : t == null
        ? a
        : +t;
    },
    Ru = function (e, t, i) {
      var r = $s(t[1]),
        s = (r ? 2 : 1) + (e < 2 ? 0 : 1),
        a = t[s],
        o,
        l;
      if ((r && (a.duration = t[1]), (a.parent = i), e)) {
        for (o = a, l = i; l && !("immediateRender" in o); )
          (o = l.vars.defaults || {}), (l = ir(l.vars.inherit) && l.parent);
        (a.immediateRender = ir(o.immediateRender)),
          e < 2 ? (a.runBackwards = 1) : (a.startAt = t[s - 1]);
      }
      return new Ji(t[0], a, t[s + 1]);
    },
    Ga = function (e, t) {
      return e || e === 0 ? t(e) : t;
    },
    Fu = function (e, t, i) {
      return i < e ? e : i > t ? t : i;
    },
    En = function (e, t) {
      return !ln(e) || !(t = cB.exec(e)) ? "" : t[1];
    },
    _B = function (e, t, i) {
      return Ga(i, function (r) {
        return Fu(e, t, r);
      });
    },
    _0 = [].slice,
    l1 = function (e, t) {
      return (
        e &&
        bs(e) &&
        "length" in e &&
        ((!t && !e.length) || (e.length - 1 in e && bs(e[0]))) &&
        !e.nodeType &&
        e !== zr
      );
    },
    EB = function (e, t, i) {
      return (
        i === void 0 && (i = []),
        e.forEach(function (r) {
          var s;
          return (ln(r) && !t) || l1(r, 1)
            ? (s = i).push.apply(s, Vr(r))
            : i.push(r);
        }) || i
      );
    },
    Vr = function (e, t, i) {
      return Zi && !t && Zi.selector
        ? Zi.selector(e)
        : ln(e) && !i && (y0 || !Jl())
        ? _0.call((t || P0).querySelectorAll(e), 0)
        : An(e)
        ? EB(e, i)
        : l1(e)
        ? _0.call(e, 0)
        : e
        ? [e]
        : [];
    },
    E0 = function (e) {
      return (
        (e = Vr(e)[0] || yd("Invalid scope") || {}),
        function (t) {
          var i = e.current || e.nativeElement || e;
          return Vr(
            t,
            i.querySelectorAll
              ? i
              : i === e
              ? yd("Invalid scope") || P0.createElement("div")
              : e
          );
        }
      );
    },
    c1 = function (e) {
      return e.sort(function () {
        return 0.5 - Math.random();
      });
    },
    u1 = function (e) {
      if (Ui(e)) return e;
      var t = bs(e) ? e : { each: e },
        i = zo(t.ease),
        r = t.from || 0,
        s = parseFloat(t.base) || 0,
        a = {},
        o = r > 0 && r < 1,
        l = isNaN(r) || o,
        c = t.axis,
        u = r,
        f = r;
      return (
        ln(r)
          ? (u = f = { center: 0.5, edges: 0.5, end: 1 }[r] || 0)
          : !o && l && ((u = r[0]), (f = r[1])),
        function (d, m, x) {
          var y = (x || t).length,
            g = a[y],
            b,
            _,
            E,
            w,
            P,
            L,
            I,
            M,
            R;
          if (!g) {
            if (((R = t.grid === "auto" ? 0 : (t.grid || [1, Ur])[1]), !R)) {
              for (
                I = -Ur;
                I < (I = x[R++].getBoundingClientRect().left) && R < y;

              );
              R--;
            }
            for (
              g = a[y] = [],
                b = l ? Math.min(R, y) * u - 0.5 : r % R,
                _ = R === Ur ? 0 : l ? (y * f) / R - 0.5 : (r / R) | 0,
                I = 0,
                M = Ur,
                L = 0;
              L < y;
              L++
            )
              (E = (L % R) - b),
                (w = _ - ((L / R) | 0)),
                (g[L] = P =
                  c ? Math.abs(c === "y" ? w : E) : jS(E * E + w * w)),
                P > I && (I = P),
                P < M && (M = P);
            r === "random" && c1(g),
              (g.max = I - M),
              (g.min = M),
              (g.v = y =
                (parseFloat(t.amount) ||
                  parseFloat(t.each) *
                    (R > y
                      ? y - 1
                      : c
                      ? c === "y"
                        ? y / R
                        : R
                      : Math.max(R, y / R)) ||
                  0) * (r === "edges" ? -1 : 1)),
              (g.b = y < 0 ? s - y : s),
              (g.u = En(t.amount || t.each) || 0),
              (i = i && y < 0 ? y1(i) : i);
          }
          return (
            (y = (g[d] - g.min) / g.max || 0),
            _n(g.b + (i ? i(y) : y) * g.v) + g.u
          );
        }
      );
    },
    T0 = function (e) {
      var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
      return function (i) {
        var r = _n(Math.round(parseFloat(i) / e) * e * t);
        return (r - (r % 1)) / t + ($s(i) ? 0 : En(i));
      };
    },
    h1 = function (e, t) {
      var i = An(e),
        r,
        s;
      return (
        !i &&
          bs(e) &&
          ((r = i = e.radius || Ur),
          e.values
            ? ((e = Vr(e.values)), (s = !$s(e[0])) && (r *= r))
            : (e = T0(e.increment))),
        Ga(
          t,
          i
            ? Ui(e)
              ? function (a) {
                  return (s = e(a)), Math.abs(s - a) <= r ? s : a;
                }
              : function (a) {
                  for (
                    var o = parseFloat(s ? a.x : a),
                      l = parseFloat(s ? a.y : 0),
                      c = Ur,
                      u = 0,
                      f = e.length,
                      d,
                      m;
                    f--;

                  )
                    s
                      ? ((d = e[f].x - o),
                        (m = e[f].y - l),
                        (d = d * d + m * m))
                      : (d = Math.abs(e[f] - o)),
                      d < c && ((c = d), (u = f));
                  return (
                    (u = !r || c <= r ? e[u] : a),
                    s || u === a || $s(a) ? u : u + En(a)
                  );
                }
            : T0(e)
        )
      );
    },
    f1 = function (e, t, i, r) {
      return Ga(An(e) ? !t : i === !0 ? !!(i = 0) : !r, function () {
        return An(e)
          ? e[~~(Math.random() * e.length)]
          : (i = i || 1e-5) &&
              (r = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) &&
              Math.floor(
                Math.round(
                  (e - i / 2 + Math.random() * (t - e + i * 0.99)) / i
                ) *
                  i *
                  r
              ) / r;
      });
    },
    TB = function () {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      return function (r) {
        return t.reduce(function (s, a) {
          return a(s);
        }, r);
      };
    },
    SB = function (e, t) {
      return function (i) {
        return e(parseFloat(i)) + (t || En(i));
      };
    },
    wB = function (e, t, i) {
      return p1(e, t, 0, 1, i);
    },
    d1 = function (e, t, i) {
      return Ga(i, function (r) {
        return e[~~t(r)];
      });
    },
    MB = function n(e, t, i) {
      var r = t - e;
      return An(e)
        ? d1(e, n(0, e.length), t)
        : Ga(i, function (s) {
            return ((r + ((s - e) % r)) % r) + e;
          });
    },
    AB = function n(e, t, i) {
      var r = t - e,
        s = r * 2;
      return An(e)
        ? d1(e, n(0, e.length - 1), t)
        : Ga(i, function (a) {
            return (a = (s + ((a - e) % s)) % s || 0), e + (a > r ? s - a : a);
          });
    },
    ec = function (e) {
      for (var t = 0, i = "", r, s, a, o; ~(r = e.indexOf("random(", t)); )
        (a = e.indexOf(")", r)),
          (o = e.charAt(r + 7) === "["),
          (s = e.substr(r + 7, a - r - 7).match(o ? KS : g0)),
          (i +=
            e.substr(t, r - t) +
            f1(o ? s : +s[0], o ? 0 : +s[1], +s[2] || 1e-5)),
          (t = a + 1);
      return i + e.substr(t, e.length - t);
    },
    p1 = function (e, t, i, r, s) {
      var a = t - e,
        o = r - i;
      return Ga(s, function (l) {
        return i + (((l - e) / a) * o || 0);
      });
    },
    CB = function n(e, t, i, r) {
      var s = isNaN(e + t)
        ? 0
        : function (m) {
            return (1 - m) * e + m * t;
          };
      if (!s) {
        var a = ln(e),
          o = {},
          l,
          c,
          u,
          f,
          d;
        if ((i === !0 && (r = 1) && (i = null), a))
          (e = { p: e }), (t = { p: t });
        else if (An(e) && !An(t)) {
          for (u = [], f = e.length, d = f - 2, c = 1; c < f; c++)
            u.push(n(e[c - 1], e[c]));
          f--,
            (s = function (x) {
              x *= f;
              var y = Math.min(d, ~~x);
              return u[y](x - y);
            }),
            (i = t);
        } else r || (e = Uo(An(e) ? [] : {}, e));
        if (!u) {
          for (l in t) k0.call(o, e, l, "get", t[l]);
          s = function (x) {
            return V0(x, o) || (a ? e.p : e);
          };
        }
      }
      return Ga(i, s);
    },
    HS = function (e, t, i) {
      var r = e.labels,
        s = Ur,
        a,
        o,
        l;
      for (a in r)
        (o = r[a] - t),
          o < 0 == !!i && o && s > (o = Math.abs(o)) && ((l = a), (s = o));
      return l;
    },
    Gr = function (e, t, i) {
      var r = e.vars,
        s = r[t],
        a = Zi,
        o = e._ctx,
        l,
        c,
        u;
      if (!!s)
        return (
          (l = r[t + "Params"]),
          (c = r.callbackScope || e),
          i && za.length && vd(),
          o && (Zi = o),
          (u = l ? s.apply(c, l) : s.call(c)),
          (Zi = a),
          u
        );
    },
    Du = function (e) {
      return (
        Va(e),
        e.scrollTrigger && e.scrollTrigger.kill(!!tr),
        e.progress() < 1 && Gr(e, "onInterrupt"),
        e
      );
    },
    jl,
    PB = function (e) {
      e = (!e.name && e.default) || e;
      var t = e.name,
        i = Ui(e),
        r =
          t && !i && e.init
            ? function () {
                this._props = [];
              }
            : e,
        s = {
          init: Nu,
          render: V0,
          add: k0,
          kill: WB,
          modifier: $B,
          rawVars: 0,
        },
        a = { targetTest: 0, get: 0, getSetter: Ad, aliases: {}, register: 0 };
      if ((Jl(), e !== r)) {
        if (Qn[t]) return;
        Hr(r, Hr(xd(e, s), a)),
          Uo(r.prototype, Uo(s, xd(e, a))),
          (Qn[(r.prop = t)] = r),
          e.targetTest && (pd.push(r), (D0[t] = 1)),
          (t =
            (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) +
            "Plugin");
      }
      QS(t, r), e.register && e.register(zn, r, Vn);
    },
    wi = 255,
    Iu = {
      aqua: [0, wi, wi],
      lime: [0, wi, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, wi],
      navy: [0, 0, 128],
      white: [wi, wi, wi],
      olive: [128, 128, 0],
      yellow: [wi, wi, 0],
      orange: [wi, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [wi, 0, 0],
      pink: [wi, 192, 203],
      cyan: [0, wi, wi],
      transparent: [wi, wi, wi, 0],
    },
    u0 = function (e, t, i) {
      return (
        (e += e < 0 ? 1 : e > 1 ? -1 : 0),
        ((e * 6 < 1
          ? t + (i - t) * e * 6
          : e < 0.5
          ? i
          : e * 3 < 2
          ? t + (i - t) * (2 / 3 - e) * 6
          : t) *
          wi +
          0.5) |
          0
      );
    },
    m1 = function (e, t, i) {
      var r = e ? ($s(e) ? [e >> 16, (e >> 8) & wi, e & wi] : 0) : Iu.black,
        s,
        a,
        o,
        l,
        c,
        u,
        f,
        d,
        m,
        x;
      if (!r) {
        if ((e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Iu[e]))
          r = Iu[e];
        else if (e.charAt(0) === "#") {
          if (
            (e.length < 6 &&
              ((s = e.charAt(1)),
              (a = e.charAt(2)),
              (o = e.charAt(3)),
              (e =
                "#" +
                s +
                s +
                a +
                a +
                o +
                o +
                (e.length === 5 ? e.charAt(4) + e.charAt(4) : ""))),
            e.length === 9)
          )
            return (
              (r = parseInt(e.substr(1, 6), 16)),
              [r >> 16, (r >> 8) & wi, r & wi, parseInt(e.substr(7), 16) / 255]
            );
          (e = parseInt(e.substr(1), 16)),
            (r = [e >> 16, (e >> 8) & wi, e & wi]);
        } else if (e.substr(0, 3) === "hsl") {
          if (((r = x = e.match(g0)), !t))
            (l = (+r[0] % 360) / 360),
              (c = +r[1] / 100),
              (u = +r[2] / 100),
              (a = u <= 0.5 ? u * (c + 1) : u + c - u * c),
              (s = u * 2 - a),
              r.length > 3 && (r[3] *= 1),
              (r[0] = u0(l + 1 / 3, s, a)),
              (r[1] = u0(l, s, a)),
              (r[2] = u0(l - 1 / 3, s, a));
          else if (~e.indexOf("="))
            return (r = e.match(A0)), i && r.length < 4 && (r[3] = 1), r;
        } else r = e.match(g0) || Iu.transparent;
        r = r.map(Number);
      }
      return (
        t &&
          !x &&
          ((s = r[0] / wi),
          (a = r[1] / wi),
          (o = r[2] / wi),
          (f = Math.max(s, a, o)),
          (d = Math.min(s, a, o)),
          (u = (f + d) / 2),
          f === d
            ? (l = c = 0)
            : ((m = f - d),
              (c = u > 0.5 ? m / (2 - f - d) : m / (f + d)),
              (l =
                f === s
                  ? (a - o) / m + (a < o ? 6 : 0)
                  : f === a
                  ? (o - s) / m + 2
                  : (s - a) / m + 4),
              (l *= 60)),
          (r[0] = ~~(l + 0.5)),
          (r[1] = ~~(c * 100 + 0.5)),
          (r[2] = ~~(u * 100 + 0.5))),
        i && r.length < 4 && (r[3] = 1),
        r
      );
    },
    g1 = function (e) {
      var t = [],
        i = [],
        r = -1;
      return (
        e.split(Hs).forEach(function (s) {
          var a = s.match(Vo) || [];
          t.push.apply(t, a), i.push((r += a.length + 1));
        }),
        (t.c = i),
        t
      );
    },
    $S = function (e, t, i) {
      var r = "",
        s = (e + r).match(Hs),
        a = t ? "hsla(" : "rgba(",
        o = 0,
        l,
        c,
        u,
        f;
      if (!s) return e;
      if (
        ((s = s.map(function (d) {
          return (
            (d = m1(d, t, 1)) &&
            a +
              (t
                ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3]
                : d.join(",")) +
              ")"
          );
        })),
        i && ((u = g1(e)), (l = i.c), l.join(r) !== u.c.join(r)))
      )
        for (c = e.replace(Hs, "1").split(Vo), f = c.length - 1; o < f; o++)
          r +=
            c[o] +
            (~l.indexOf(o)
              ? s.shift() || a + "0,0,0,0)"
              : (u.length ? u : s.length ? s : i).shift());
      if (!c)
        for (c = e.split(Hs), f = c.length - 1; o < f; o++) r += c[o] + s[o];
      return r + c[f];
    },
    Hs = (function () {
      var n =
          "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
        e;
      for (e in Iu) n += "|" + e + "\\b";
      return new RegExp(n + ")", "gi");
    })(),
    DB = /hsl[a]?\(/,
    O0 = function (e) {
      var t = e.join(" "),
        i;
      if (((Hs.lastIndex = 0), Hs.test(t)))
        return (
          (i = DB.test(t)),
          (e[1] = $S(e[1], i)),
          (e[0] = $S(e[0], i, g1(e[1]))),
          !0
        );
    },
    ku,
    er = (function () {
      var n = Date.now,
        e = 500,
        t = 33,
        i = n(),
        r = i,
        s = 1e3 / 240,
        a = s,
        o = [],
        l,
        c,
        u,
        f,
        d,
        m,
        x = function y(g) {
          var b = n() - r,
            _ = g === !0,
            E,
            w,
            P,
            L;
          if (
            (b > e && (i += b - t),
            (r += b),
            (P = r - i),
            (E = P - a),
            (E > 0 || _) &&
              ((L = ++f.frame),
              (d = P - f.time * 1e3),
              (f.time = P = P / 1e3),
              (a += E + (E >= s ? 4 : s - E)),
              (w = 1)),
            _ || (l = c(y)),
            w)
          )
            for (m = 0; m < o.length; m++) o[m](P, d, L, g);
        };
      return (
        (f = {
          time: 0,
          frame: 0,
          tick: function () {
            x(!0);
          },
          deltaRatio: function (g) {
            return d / (1e3 / (g || 60));
          },
          wake: function () {
            JS &&
              (!y0 &&
                XS() &&
                ((zr = y0 = window),
                (P0 = zr.document || {}),
                (pr.gsap = zn),
                (zr.gsapVersions || (zr.gsapVersions = [])).push(zn.version),
                ZS(gd || zr.GreenSockGlobals || (!zr.gsap && zr) || {}),
                (u = zr.requestAnimationFrame)),
              l && f.sleep(),
              (c =
                u ||
                function (g) {
                  return setTimeout(g, (a - f.time * 1e3 + 1) | 0);
                }),
              (ku = 1),
              x(2));
          },
          sleep: function () {
            (u ? zr.cancelAnimationFrame : clearTimeout)(l), (ku = 0), (c = Nu);
          },
          lagSmoothing: function (g, b) {
            (e = g || 1 / Ei), (t = Math.min(b, e, 0));
          },
          fps: function (g) {
            (s = 1e3 / (g || 240)), (a = f.time * 1e3 + s);
          },
          add: function (g, b, _) {
            var E = b
              ? function (w, P, L, I) {
                  g(w, P, L, I), f.remove(E);
                }
              : g;
            return f.remove(g), o[_ ? "unshift" : "push"](E), Jl(), E;
          },
          remove: function (g, b) {
            ~(b = o.indexOf(g)) && o.splice(b, 1) && m >= b && m--;
          },
          _listeners: o,
        }),
        f
      );
    })(),
    Jl = function () {
      return !ku && er.wake();
    },
    si = {},
    IB = /^[\d.\-M][\d.\-,\s]/,
    LB = /["']/g,
    RB = function (e) {
      for (
        var t = {},
          i = e.substr(1, e.length - 3).split(":"),
          r = i[0],
          s = 1,
          a = i.length,
          o,
          l,
          c;
        s < a;
        s++
      )
        (l = i[s]),
          (o = s !== a - 1 ? l.lastIndexOf(",") : l.length),
          (c = l.substr(0, o)),
          (t[r] = isNaN(c) ? c.replace(LB, "").trim() : +c),
          (r = l.substr(o + 1).trim());
      return t;
    },
    OB = function (e) {
      var t = e.indexOf("(") + 1,
        i = e.indexOf(")"),
        r = e.indexOf("(", t);
      return e.substring(t, ~r && r < i ? e.indexOf(")", i + 1) : i);
    },
    NB = function (e) {
      var t = (e + "").split("("),
        i = si[t[0]];
      return i && t.length > 1 && i.config
        ? i.config.apply(
            null,
            ~e.indexOf("{") ? [RB(t[1])] : OB(e).split(",").map(i1)
          )
        : si._CE && IB.test(e)
        ? si._CE("", e)
        : i;
    },
    y1 = function (e) {
      return function (t) {
        return 1 - e(1 - t);
      };
    },
    v1 = function n(e, t) {
      for (var i = e._first, r; i; )
        i instanceof Mn
          ? n(i, t)
          : i.vars.yoyoEase &&
            (!i._yoyo || !i._repeat) &&
            i._yoyo !== t &&
            (i.timeline
              ? n(i.timeline, t)
              : ((r = i._ease),
                (i._ease = i._yEase),
                (i._yEase = r),
                (i._yoyo = t))),
          (i = i._next);
    },
    zo = function (e, t) {
      return (e && (Ui(e) ? e : si[e] || NB(e))) || t;
    },
    Ho = function (e, t, i, r) {
      i === void 0 &&
        (i = function (l) {
          return 1 - t(1 - l);
        }),
        r === void 0 &&
          (r = function (l) {
            return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
          });
      var s = { easeIn: t, easeOut: i, easeInOut: r },
        a;
      return (
        Un(e, function (o) {
          (si[o] = pr[o] = s), (si[(a = o.toLowerCase())] = i);
          for (var l in s)
            si[
              a + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")
            ] = si[o + "." + l] = s[l];
        }),
        s
      );
    },
    x1 = function (e) {
      return function (t) {
        return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
      };
    },
    h0 = function n(e, t, i) {
      var r = t >= 1 ? t : 1,
        s = (i || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
        a = (s / m0) * (Math.asin(1 / r) || 0),
        o = function (u) {
          return u === 1 ? 1 : r * Math.pow(2, -10 * u) * lB((u - a) * s) + 1;
        },
        l =
          e === "out"
            ? o
            : e === "in"
            ? function (c) {
                return 1 - o(1 - c);
              }
            : x1(o);
      return (
        (s = m0 / s),
        (l.config = function (c, u) {
          return n(e, c, u);
        }),
        l
      );
    },
    f0 = function n(e, t) {
      t === void 0 && (t = 1.70158);
      var i = function (a) {
          return a ? --a * a * ((t + 1) * a + t) + 1 : 0;
        },
        r =
          e === "out"
            ? i
            : e === "in"
            ? function (s) {
                return 1 - i(1 - s);
              }
            : x1(i);
      return (
        (r.config = function (s) {
          return n(e, s);
        }),
        r
      );
    };
  Un("Linear,Quad,Cubic,Quart,Quint,Strong", function (n, e) {
    var t = e < 5 ? e + 1 : e;
    Ho(
      n + ",Power" + (t - 1),
      e
        ? function (i) {
            return Math.pow(i, t);
          }
        : function (i) {
            return i;
          },
      function (i) {
        return 1 - Math.pow(1 - i, t);
      },
      function (i) {
        return i < 0.5
          ? Math.pow(i * 2, t) / 2
          : 1 - Math.pow((1 - i) * 2, t) / 2;
      }
    );
  });
  si.Linear.easeNone = si.none = si.Linear.easeIn;
  Ho("Elastic", h0("in"), h0("out"), h0());
  (function (n, e) {
    var t = 1 / e,
      i = 2 * t,
      r = 2.5 * t,
      s = function (o) {
        return o < t
          ? n * o * o
          : o < i
          ? n * Math.pow(o - 1.5 / e, 2) + 0.75
          : o < r
          ? n * (o -= 2.25 / e) * o + 0.9375
          : n * Math.pow(o - 2.625 / e, 2) + 0.984375;
      };
    Ho(
      "Bounce",
      function (a) {
        return 1 - s(1 - a);
      },
      s
    );
  })(7.5625, 2.75);
  Ho("Expo", function (n) {
    return n ? Math.pow(2, 10 * (n - 1)) : 0;
  });
  Ho("Circ", function (n) {
    return -(jS(1 - n * n) - 1);
  });
  Ho("Sine", function (n) {
    return n === 1 ? 1 : -oB(n * sB) + 1;
  });
  Ho("Back", f0("in"), f0("out"), f0());
  si.SteppedEase =
    si.steps =
    pr.SteppedEase =
      {
        config: function (e, t) {
          e === void 0 && (e = 1);
          var i = 1 / e,
            r = e + (t ? 0 : 1),
            s = t ? 1 : 0,
            a = 1 - Ei;
          return function (o) {
            return (((r * Fu(0, a, o)) | 0) + s) * i;
          };
        },
      };
  Xl.ease = si["quad.out"];
  Un(
    "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
    function (n) {
      return (I0 += n + "," + n + "Params,");
    }
  );
  var N0 = function (e, t) {
      (this.id = aB++),
        (e._gsap = this),
        (this.target = e),
        (this.harness = t),
        (this.get = t ? t.get : R0),
        (this.set = t ? t.getSetter : Ad);
    },
    Zl = (function () {
      function n(t) {
        (this.vars = t),
          (this._delay = +t.delay || 0),
          (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
            ((this._rDelay = t.repeatDelay || 0),
            (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
          (this._ts = 1),
          Kl(this, +t.duration, 1, 1),
          (this.data = t.data),
          Zi && ((this._ctx = Zi), Zi.data.push(this)),
          ku || er.wake();
      }
      var e = n.prototype;
      return (
        (e.delay = function (i) {
          return i || i === 0
            ? (this.parent &&
                this.parent.smoothChildTiming &&
                this.startTime(this._start + i - this._delay),
              (this._delay = i),
              this)
            : this._delay;
        }),
        (e.duration = function (i) {
          return arguments.length
            ? this.totalDuration(
                this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i
              )
            : this.totalDuration() && this._dur;
        }),
        (e.totalDuration = function (i) {
          return arguments.length
            ? ((this._dirty = 0),
              Kl(
                this,
                this._repeat < 0
                  ? i
                  : (i - this._repeat * this._rDelay) / (this._repeat + 1)
              ))
            : this._tDur;
        }),
        (e.totalTime = function (i, r) {
          if ((Jl(), !arguments.length)) return this._tTime;
          var s = this._dp;
          if (s && s.smoothChildTiming && this._ts) {
            for (
              Md(this, i), !s._dp || s.parent || s1(s, this);
              s && s.parent;

            )
              s.parent._time !==
                s._start +
                  (s._ts >= 0
                    ? s._tTime / s._ts
                    : (s.totalDuration() - s._tTime) / -s._ts) &&
                s.totalTime(s._tTime, !0),
                (s = s.parent);
            !this.parent &&
              this._dp.autoRemoveChildren &&
              ((this._ts > 0 && i < this._tDur) ||
                (this._ts < 0 && i > 0) ||
                (!this._tDur && !i)) &&
              xs(this._dp, this, this._start - this._delay);
          }
          return (
            (this._tTime !== i ||
              (!this._dur && !r) ||
              (this._initted && Math.abs(this._zTime) === Ei) ||
              (!i && !this._initted && (this.add || this._ptLookup))) &&
              (this._ts || (this._pTime = i), t1(this, i, r)),
            this
          );
        }),
        (e.time = function (i, r) {
          return arguments.length
            ? this.totalTime(
                Math.min(this.totalDuration(), i + VS(this)) %
                  (this._dur + this._rDelay) || (i ? this._dur : 0),
                r
              )
            : this._time;
        }),
        (e.totalProgress = function (i, r) {
          return arguments.length
            ? this.totalTime(this.totalDuration() * i, r)
            : this.totalDuration()
            ? Math.min(1, this._tTime / this._tDur)
            : this.ratio;
        }),
        (e.progress = function (i, r) {
          return arguments.length
            ? this.totalTime(
                this.duration() *
                  (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) +
                  VS(this),
                r
              )
            : this.duration()
            ? Math.min(1, this._time / this._dur)
            : this.ratio;
        }),
        (e.iteration = function (i, r) {
          var s = this.duration() + this._rDelay;
          return arguments.length
            ? this.totalTime(this._time + (i - 1) * s, r)
            : this._repeat
            ? Yl(this._tTime, s) + 1
            : 1;
        }),
        (e.timeScale = function (i) {
          if (!arguments.length) return this._rts === -Ei ? 0 : this._rts;
          if (this._rts === i) return this;
          var r =
            this.parent && this._ts ? bd(this.parent._time, this) : this._tTime;
          return (
            (this._rts = +i || 0),
            (this._ts = this._ps || i === -Ei ? 0 : this._rts),
            this.totalTime(Fu(-this._delay, this._tDur, r), !0),
            wd(this),
            mB(this)
          );
        }),
        (e.paused = function (i) {
          return arguments.length
            ? (this._ps !== i &&
                ((this._ps = i),
                i
                  ? ((this._pTime =
                      this._tTime || Math.max(-this._delay, this.rawTime())),
                    (this._ts = this._act = 0))
                  : (Jl(),
                    (this._ts = this._rts),
                    this.totalTime(
                      this.parent && !this.parent.smoothChildTiming
                        ? this.rawTime()
                        : this._tTime || this._pTime,
                      this.progress() === 1 &&
                        Math.abs(this._zTime) !== Ei &&
                        (this._tTime -= Ei)
                    ))),
              this)
            : this._ps;
        }),
        (e.startTime = function (i) {
          if (arguments.length) {
            this._start = i;
            var r = this.parent || this._dp;
            return (
              r && (r._sort || !this.parent) && xs(r, this, i - this._delay),
              this
            );
          }
          return this._start;
        }),
        (e.endTime = function (i) {
          return (
            this._start +
            (ir(i) ? this.totalDuration() : this.duration()) /
              Math.abs(this._ts || 1)
          );
        }),
        (e.rawTime = function (i) {
          var r = this.parent || this._dp;
          return r
            ? i &&
              (!this._ts ||
                (this._repeat && this._time && this.totalProgress() < 1))
              ? this._tTime % (this._dur + this._rDelay)
              : this._ts
              ? bd(r.rawTime(i), this)
              : this._tTime
            : this._tTime;
        }),
        (e.revert = function (i) {
          i === void 0 && (i = hB);
          var r = tr;
          return (
            (tr = i),
            (this._initted || this._startAt) &&
              (this.timeline && this.timeline.revert(i),
              this.totalTime(-0.01, i.suppressEvents)),
            this.data !== "nested" && i.kill !== !1 && this.kill(),
            (tr = r),
            this
          );
        }),
        (e.globalTime = function (i) {
          for (var r = this, s = arguments.length ? i : r.rawTime(); r; )
            (s = r._start + s / (r._ts || 1)), (r = r._dp);
          return !this.parent && this.vars.immediateRender ? -1 : s;
        }),
        (e.repeat = function (i) {
          return arguments.length
            ? ((this._repeat = i === 1 / 0 ? -2 : i), GS(this))
            : this._repeat === -2
            ? 1 / 0
            : this._repeat;
        }),
        (e.repeatDelay = function (i) {
          if (arguments.length) {
            var r = this._time;
            return (this._rDelay = i), GS(this), r ? this.time(r) : this;
          }
          return this._rDelay;
        }),
        (e.yoyo = function (i) {
          return arguments.length ? ((this._yoyo = i), this) : this._yoyo;
        }),
        (e.seek = function (i, r) {
          return this.totalTime(Br(this, i), ir(r));
        }),
        (e.restart = function (i, r) {
          return this.play().totalTime(i ? -this._delay : 0, ir(r));
        }),
        (e.play = function (i, r) {
          return i != null && this.seek(i, r), this.reversed(!1).paused(!1);
        }),
        (e.reverse = function (i, r) {
          return (
            i != null && this.seek(i || this.totalDuration(), r),
            this.reversed(!0).paused(!1)
          );
        }),
        (e.pause = function (i, r) {
          return i != null && this.seek(i, r), this.paused(!0);
        }),
        (e.resume = function () {
          return this.paused(!1);
        }),
        (e.reversed = function (i) {
          return arguments.length
            ? (!!i !== this.reversed() &&
                this.timeScale(-this._rts || (i ? -Ei : 0)),
              this)
            : this._rts < 0;
        }),
        (e.invalidate = function () {
          return (this._initted = this._act = 0), (this._zTime = -Ei), this;
        }),
        (e.isActive = function () {
          var i = this.parent || this._dp,
            r = this._start,
            s;
          return !!(
            !i ||
            (this._ts &&
              this._initted &&
              i.isActive() &&
              (s = i.rawTime(!0)) >= r &&
              s < this.endTime(!0) - Ei)
          );
        }),
        (e.eventCallback = function (i, r, s) {
          var a = this.vars;
          return arguments.length > 1
            ? (r
                ? ((a[i] = r),
                  s && (a[i + "Params"] = s),
                  i === "onUpdate" && (this._onUpdate = r))
                : delete a[i],
              this)
            : a[i];
        }),
        (e.then = function (i) {
          var r = this;
          return new Promise(function (s) {
            var a = Ui(i) ? i : n1,
              o = function () {
                var c = r.then;
                (r.then = null),
                  Ui(a) && (a = a(r)) && (a.then || a === r) && (r.then = c),
                  s(a),
                  (r.then = c);
              };
            (r._initted && r.totalProgress() === 1 && r._ts >= 0) ||
            (!r._tTime && r._ts < 0)
              ? o()
              : (r._prom = o);
          });
        }),
        (e.kill = function () {
          Du(this);
        }),
        n
      );
    })();
  Hr(Zl.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -Ei,
    _prom: 0,
    _ps: !1,
    _rts: 1,
  });
  var Mn = (function (n) {
    qS(e, n);
    function e(i, r) {
      var s;
      return (
        i === void 0 && (i = {}),
        (s = n.call(this, i) || this),
        (s.labels = {}),
        (s.smoothChildTiming = !!i.smoothChildTiming),
        (s.autoRemoveChildren = !!i.autoRemoveChildren),
        (s._sort = ir(i.sortChildren)),
        ki && xs(i.parent || ki, Gs(s), r),
        i.reversed && s.reverse(),
        i.paused && s.paused(!0),
        i.scrollTrigger && a1(Gs(s), i.scrollTrigger),
        s
      );
    }
    var t = e.prototype;
    return (
      (t.to = function (r, s, a) {
        return Ru(0, arguments, this), this;
      }),
      (t.from = function (r, s, a) {
        return Ru(1, arguments, this), this;
      }),
      (t.fromTo = function (r, s, a, o) {
        return Ru(2, arguments, this), this;
      }),
      (t.set = function (r, s, a) {
        return (
          (s.duration = 0),
          (s.parent = this),
          Lu(s).repeatDelay || (s.repeat = 0),
          (s.immediateRender = !!s.immediateRender),
          new Ji(r, s, Br(this, a), 1),
          this
        );
      }),
      (t.call = function (r, s, a) {
        return xs(this, Ji.delayedCall(0, r, s), a);
      }),
      (t.staggerTo = function (r, s, a, o, l, c, u) {
        return (
          (a.duration = s),
          (a.stagger = a.stagger || o),
          (a.onComplete = c),
          (a.onCompleteParams = u),
          (a.parent = this),
          new Ji(r, a, Br(this, l)),
          this
        );
      }),
      (t.staggerFrom = function (r, s, a, o, l, c, u) {
        return (
          (a.runBackwards = 1),
          (Lu(a).immediateRender = ir(a.immediateRender)),
          this.staggerTo(r, s, a, o, l, c, u)
        );
      }),
      (t.staggerFromTo = function (r, s, a, o, l, c, u, f) {
        return (
          (o.startAt = a),
          (Lu(o).immediateRender = ir(o.immediateRender)),
          this.staggerTo(r, s, o, l, c, u, f)
        );
      }),
      (t.render = function (r, s, a) {
        var o = this._time,
          l = this._dirty ? this.totalDuration() : this._tDur,
          c = this._dur,
          u = r <= 0 ? 0 : _n(r),
          f = this._zTime < 0 != r < 0 && (this._initted || !c),
          d,
          m,
          x,
          y,
          g,
          b,
          _,
          E,
          w,
          P,
          L,
          I;
        if (
          (this !== ki && u > l && r >= 0 && (u = l),
          u !== this._tTime || a || f)
        ) {
          if (
            (o !== this._time &&
              c &&
              ((u += this._time - o), (r += this._time - o)),
            (d = u),
            (w = this._start),
            (E = this._ts),
            (b = !E),
            f && (c || (o = this._zTime), (r || !s) && (this._zTime = r)),
            this._repeat)
          ) {
            if (
              ((L = this._yoyo),
              (g = c + this._rDelay),
              this._repeat < -1 && r < 0)
            )
              return this.totalTime(g * 100 + r, s, a);
            if (
              ((d = _n(u % g)),
              u === l
                ? ((y = this._repeat), (d = c))
                : ((y = ~~(u / g)),
                  y && y === u / g && ((d = c), y--),
                  d > c && (d = c)),
              (P = Yl(this._tTime, g)),
              !o && this._tTime && P !== y && (P = y),
              L && y & 1 && ((d = c - d), (I = 1)),
              y !== P && !this._lock)
            ) {
              var M = L && P & 1,
                R = M === (L && y & 1);
              if (
                (y < P && (M = !M),
                (o = M ? 0 : c),
                (this._lock = 1),
                (this.render(o || (I ? 0 : _n(y * g)), s, !c)._lock = 0),
                (this._tTime = u),
                !s && this.parent && Gr(this, "onRepeat"),
                this.vars.repeatRefresh && !I && (this.invalidate()._lock = 1),
                (o && o !== this._time) ||
                  b !== !this._ts ||
                  (this.vars.onRepeat && !this.parent && !this._act))
              )
                return this;
              if (
                ((c = this._dur),
                (l = this._tDur),
                R &&
                  ((this._lock = 2),
                  (o = M ? c : -1e-4),
                  this.render(o, !0),
                  this.vars.repeatRefresh && !I && this.invalidate()),
                (this._lock = 0),
                !this._ts && !b)
              )
                return this;
              v1(this, I);
            }
          }
          if (
            (this._hasPause &&
              !this._forcing &&
              this._lock < 2 &&
              ((_ = xB(this, _n(o), _n(d))), _ && (u -= d - (d = _._start))),
            (this._tTime = u),
            (this._time = d),
            (this._act = !E),
            this._initted ||
              ((this._onUpdate = this.vars.onUpdate),
              (this._initted = 1),
              (this._zTime = r),
              (o = 0)),
            !o && d && !s && (Gr(this, "onStart"), this._tTime !== u))
          )
            return this;
          if (d >= o && r >= 0)
            for (m = this._first; m; ) {
              if (
                ((x = m._next), (m._act || d >= m._start) && m._ts && _ !== m)
              ) {
                if (m.parent !== this) return this.render(r, s, a);
                if (
                  (m.render(
                    m._ts > 0
                      ? (d - m._start) * m._ts
                      : (m._dirty ? m.totalDuration() : m._tDur) +
                          (d - m._start) * m._ts,
                    s,
                    a
                  ),
                  d !== this._time || (!this._ts && !b))
                ) {
                  (_ = 0), x && (u += this._zTime = -Ei);
                  break;
                }
              }
              m = x;
            }
          else {
            m = this._last;
            for (var O = r < 0 ? r : d; m; ) {
              if (
                ((x = m._prev), (m._act || O <= m._end) && m._ts && _ !== m)
              ) {
                if (m.parent !== this) return this.render(r, s, a);
                if (
                  (m.render(
                    m._ts > 0
                      ? (O - m._start) * m._ts
                      : (m._dirty ? m.totalDuration() : m._tDur) +
                          (O - m._start) * m._ts,
                    s,
                    a || (tr && (m._initted || m._startAt))
                  ),
                  d !== this._time || (!this._ts && !b))
                ) {
                  (_ = 0), x && (u += this._zTime = O ? -Ei : Ei);
                  break;
                }
              }
              m = x;
            }
          }
          if (
            _ &&
            !s &&
            (this.pause(),
            (_.render(d >= o ? 0 : -Ei)._zTime = d >= o ? 1 : -1),
            this._ts)
          )
            return (this._start = w), wd(this), this.render(r, s, a);
          this._onUpdate && !s && Gr(this, "onUpdate", !0),
            ((u === l && this._tTime >= this.totalDuration()) || (!u && o)) &&
              (w === this._start || Math.abs(E) !== Math.abs(this._ts)) &&
              (this._lock ||
                ((r || !c) &&
                  ((u === l && this._ts > 0) || (!u && this._ts < 0)) &&
                  Va(this, 1),
                !s &&
                  !(r < 0 && !o) &&
                  (u || o || !l) &&
                  (Gr(
                    this,
                    u === l && r >= 0 ? "onComplete" : "onReverseComplete",
                    !0
                  ),
                  this._prom &&
                    !(u < l && this.timeScale() > 0) &&
                    this._prom())));
        }
        return this;
      }),
      (t.add = function (r, s) {
        var a = this;
        if (($s(s) || (s = Br(this, s, r)), !(r instanceof Zl))) {
          if (An(r))
            return (
              r.forEach(function (o) {
                return a.add(o, s);
              }),
              this
            );
          if (ln(r)) return this.addLabel(r, s);
          if (Ui(r)) r = Ji.delayedCall(0, r);
          else return this;
        }
        return this !== r ? xs(this, r, s) : this;
      }),
      (t.getChildren = function (r, s, a, o) {
        r === void 0 && (r = !0),
          s === void 0 && (s = !0),
          a === void 0 && (a = !0),
          o === void 0 && (o = -Ur);
        for (var l = [], c = this._first; c; )
          c._start >= o &&
            (c instanceof Ji
              ? s && l.push(c)
              : (a && l.push(c),
                r && l.push.apply(l, c.getChildren(!0, s, a)))),
            (c = c._next);
        return l;
      }),
      (t.getById = function (r) {
        for (var s = this.getChildren(1, 1, 1), a = s.length; a--; )
          if (s[a].vars.id === r) return s[a];
      }),
      (t.remove = function (r) {
        return ln(r)
          ? this.removeLabel(r)
          : Ui(r)
          ? this.killTweensOf(r)
          : (Sd(this, r),
            r === this._recent && (this._recent = this._last),
            Bo(this));
      }),
      (t.totalTime = function (r, s) {
        return arguments.length
          ? ((this._forcing = 1),
            !this._dp &&
              this._ts &&
              (this._start = _n(
                er.time -
                  (this._ts > 0
                    ? r / this._ts
                    : (this.totalDuration() - r) / -this._ts)
              )),
            n.prototype.totalTime.call(this, r, s),
            (this._forcing = 0),
            this)
          : this._tTime;
      }),
      (t.addLabel = function (r, s) {
        return (this.labels[r] = Br(this, s)), this;
      }),
      (t.removeLabel = function (r) {
        return delete this.labels[r], this;
      }),
      (t.addPause = function (r, s, a) {
        var o = Ji.delayedCall(0, s || Nu, a);
        return (
          (o.data = "isPause"), (this._hasPause = 1), xs(this, o, Br(this, r))
        );
      }),
      (t.removePause = function (r) {
        var s = this._first;
        for (r = Br(this, r); s; )
          s._start === r && s.data === "isPause" && Va(s), (s = s._next);
      }),
      (t.killTweensOf = function (r, s, a) {
        for (var o = this.getTweensOf(r, a), l = o.length; l--; )
          Ba !== o[l] && o[l].kill(r, s);
        return this;
      }),
      (t.getTweensOf = function (r, s) {
        for (var a = [], o = Vr(r), l = this._first, c = $s(s), u; l; )
          l instanceof Ji
            ? fB(l._targets, o) &&
              (c
                ? (!Ba || (l._initted && l._ts)) &&
                  l.globalTime(0) <= s &&
                  l.globalTime(l.totalDuration()) > s
                : !s || l.isActive()) &&
              a.push(l)
            : (u = l.getTweensOf(o, s)).length && a.push.apply(a, u),
            (l = l._next);
        return a;
      }),
      (t.tweenTo = function (r, s) {
        s = s || {};
        var a = this,
          o = Br(a, r),
          l = s,
          c = l.startAt,
          u = l.onStart,
          f = l.onStartParams,
          d = l.immediateRender,
          m,
          x = Ji.to(
            a,
            Hr(
              {
                ease: s.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: o,
                overwrite: "auto",
                duration:
                  s.duration ||
                  Math.abs(
                    (o - (c && "time" in c ? c.time : a._time)) / a.timeScale()
                  ) ||
                  Ei,
                onStart: function () {
                  if ((a.pause(), !m)) {
                    var g =
                      s.duration ||
                      Math.abs(
                        (o - (c && "time" in c ? c.time : a._time)) /
                          a.timeScale()
                      );
                    x._dur !== g && Kl(x, g, 0, 1).render(x._time, !0, !0),
                      (m = 1);
                  }
                  u && u.apply(x, f || []);
                },
              },
              s
            )
          );
        return d ? x.render(0) : x;
      }),
      (t.tweenFromTo = function (r, s, a) {
        return this.tweenTo(s, Hr({ startAt: { time: Br(this, r) } }, a));
      }),
      (t.recent = function () {
        return this._recent;
      }),
      (t.nextLabel = function (r) {
        return r === void 0 && (r = this._time), HS(this, Br(this, r));
      }),
      (t.previousLabel = function (r) {
        return r === void 0 && (r = this._time), HS(this, Br(this, r), 1);
      }),
      (t.currentLabel = function (r) {
        return arguments.length
          ? this.seek(r, !0)
          : this.previousLabel(this._time + Ei);
      }),
      (t.shiftChildren = function (r, s, a) {
        a === void 0 && (a = 0);
        for (var o = this._first, l = this.labels, c; o; )
          o._start >= a && ((o._start += r), (o._end += r)), (o = o._next);
        if (s) for (c in l) l[c] >= a && (l[c] += r);
        return Bo(this);
      }),
      (t.invalidate = function (r) {
        var s = this._first;
        for (this._lock = 0; s; ) s.invalidate(r), (s = s._next);
        return n.prototype.invalidate.call(this, r);
      }),
      (t.clear = function (r) {
        r === void 0 && (r = !0);
        for (var s = this._first, a; s; )
          (a = s._next), this.remove(s), (s = a);
        return (
          this._dp && (this._time = this._tTime = this._pTime = 0),
          r && (this.labels = {}),
          Bo(this)
        );
      }),
      (t.totalDuration = function (r) {
        var s = 0,
          a = this,
          o = a._last,
          l = Ur,
          c,
          u,
          f;
        if (arguments.length)
          return a.timeScale(
            (a._repeat < 0 ? a.duration() : a.totalDuration()) /
              (a.reversed() ? -r : r)
          );
        if (a._dirty) {
          for (f = a.parent; o; )
            (c = o._prev),
              o._dirty && o.totalDuration(),
              (u = o._start),
              u > l && a._sort && o._ts && !a._lock
                ? ((a._lock = 1), (xs(a, o, u - o._delay, 1)._lock = 0))
                : (l = u),
              u < 0 &&
                o._ts &&
                ((s -= u),
                ((!f && !a._dp) || (f && f.smoothChildTiming)) &&
                  ((a._start += u / a._ts), (a._time -= u), (a._tTime -= u)),
                a.shiftChildren(-u, !1, -1 / 0),
                (l = 0)),
              o._end > s && o._ts && (s = o._end),
              (o = c);
          Kl(a, a === ki && a._time > s ? a._time : s, 1, 1), (a._dirty = 0);
        }
        return a._tDur;
      }),
      (e.updateRoot = function (r) {
        if ((ki._ts && (t1(ki, bd(r, ki)), (e1 = er.frame)), er.frame >= zS)) {
          zS += nr.autoSleep || 120;
          var s = ki._first;
          if ((!s || !s._ts) && nr.autoSleep && er._listeners.length < 2) {
            for (; s && !s._ts; ) s = s._next;
            s || er.sleep();
          }
        }
      }),
      e
    );
  })(Zl);
  Hr(Mn.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
  var kB = function (e, t, i, r, s, a, o) {
      var l = new Vn(this._pt, e, t, 0, 1, U0, null, s),
        c = 0,
        u = 0,
        f,
        d,
        m,
        x,
        y,
        g,
        b,
        _;
      for (
        l.b = i,
          l.e = r,
          i += "",
          r += "",
          (b = ~r.indexOf("random(")) && (r = ec(r)),
          a && ((_ = [i, r]), a(_, e, t), (i = _[0]), (r = _[1])),
          d = i.match(l0) || [];
        (f = l0.exec(r));

      )
        (x = f[0]),
          (y = r.substring(c, f.index)),
          m ? (m = (m + 1) % 5) : y.substr(-5) === "rgba(" && (m = 1),
          x !== d[u++] &&
            ((g = parseFloat(d[u - 1]) || 0),
            (l._pt = {
              _next: l._pt,
              p: y || u === 1 ? y : ",",
              s: g,
              c: x.charAt(1) === "=" ? Go(g, x) - g : parseFloat(x) - g,
              m: m && m < 4 ? Math.round : 0,
            }),
            (c = l0.lastIndex));
      return (
        (l.c = c < r.length ? r.substring(c, r.length) : ""),
        (l.fp = o),
        (C0.test(r) || b) && (l.e = 0),
        (this._pt = l),
        l
      );
    },
    k0 = function (e, t, i, r, s, a, o, l, c, u) {
      Ui(r) && (r = r(s || 0, e, a));
      var f = e[t],
        d =
          i !== "get"
            ? i
            : Ui(f)
            ? c
              ? e[
                  t.indexOf("set") || !Ui(e["get" + t.substr(3)])
                    ? t
                    : "get" + t.substr(3)
                ](c)
              : e[t]()
            : f,
        m = Ui(f) ? (c ? VB : E1) : z0,
        x;
      if (
        (ln(r) &&
          (~r.indexOf("random(") && (r = ec(r)),
          r.charAt(1) === "=" &&
            ((x = Go(d, r) + (En(d) || 0)), (x || x === 0) && (r = x))),
        !u || d !== r || S0)
      )
        return !isNaN(d * r) && r !== ""
          ? ((x = new Vn(
              this._pt,
              e,
              t,
              +d || 0,
              r - (d || 0),
              typeof f == "boolean" ? HB : T1,
              0,
              m
            )),
            c && (x.fp = c),
            o && x.modifier(o, this, e),
            (this._pt = x))
          : (!f && !(t in e) && Td(t, r),
            kB.call(this, e, t, d, r, m, l || nr.stringFilter, c));
    },
    FB = function (e, t, i, r, s) {
      if (
        (Ui(e) && (e = Ou(e, s, t, i, r)),
        !bs(e) || (e.style && e.nodeType) || An(e) || YS(e))
      )
        return ln(e) ? Ou(e, s, t, i, r) : e;
      var a = {},
        o;
      for (o in e) a[o] = Ou(e[o], s, t, i, r);
      return a;
    },
    F0 = function (e, t, i, r, s, a) {
      var o, l, c, u;
      if (
        Qn[e] &&
        (o = new Qn[e]()).init(
          s,
          o.rawVars ? t[e] : FB(t[e], r, s, a, i),
          i,
          r,
          a
        ) !== !1 &&
        ((i._pt = l = new Vn(i._pt, s, e, 0, 1, o.render, o, 0, o.priority)),
        i !== jl)
      )
        for (c = i._ptLookup[i._targets.indexOf(s)], u = o._props.length; u--; )
          c[o._props[u]] = l;
      return o;
    },
    Ba,
    S0,
    B0 = function n(e, t, i) {
      var r = e.vars,
        s = r.ease,
        a = r.startAt,
        o = r.immediateRender,
        l = r.lazy,
        c = r.onUpdate,
        u = r.onUpdateParams,
        f = r.callbackScope,
        d = r.runBackwards,
        m = r.yoyoEase,
        x = r.keyframes,
        y = r.autoRevert,
        g = e._dur,
        b = e._startAt,
        _ = e._targets,
        E = e.parent,
        w = E && E.data === "nested" ? E.vars.targets : _,
        P = e._overwrite === "auto" && !M0,
        L = e.timeline,
        I,
        M,
        R,
        O,
        U,
        X,
        $,
        W,
        ue,
        ae,
        he,
        ce,
        te;
      if (
        (L && (!x || !s) && (s = "none"),
        (e._ease = zo(s, Xl.ease)),
        (e._yEase = m ? y1(zo(m === !0 ? s : m, Xl.ease)) : 0),
        m &&
          e._yoyo &&
          !e._repeat &&
          ((m = e._yEase), (e._yEase = e._ease), (e._ease = m)),
        (e._from = !L && !!r.runBackwards),
        !L || (x && !r.stagger))
      ) {
        if (
          ((W = _[0] ? Ua(_[0]).harness : 0),
          (ce = W && r[W.prop]),
          (I = xd(r, D0)),
          b &&
            (b._zTime < 0 && b.progress(1),
            t < 0 && d && o && !y
              ? b.render(-1, !0)
              : b.revert(d && g ? dd : uB),
            (b._lazy = 0)),
          a)
        ) {
          if (
            (Va(
              (e._startAt = Ji.set(
                _,
                Hr(
                  {
                    data: "isStart",
                    overwrite: !1,
                    parent: E,
                    immediateRender: !0,
                    lazy: ir(l),
                    startAt: null,
                    delay: 0,
                    onUpdate: c,
                    onUpdateParams: u,
                    callbackScope: f,
                    stagger: 0,
                  },
                  a
                )
              ))
            ),
            (e._startAt._dp = 0),
            t < 0 && (tr || (!o && !y)) && e._startAt.revert(dd),
            o && g && t <= 0 && i <= 0)
          ) {
            t && (e._zTime = t);
            return;
          }
        } else if (d && g && !b) {
          if (
            (t && (o = !1),
            (R = Hr(
              {
                overwrite: !1,
                data: "isFromStart",
                lazy: o && ir(l),
                immediateRender: o,
                stagger: 0,
                parent: E,
              },
              I
            )),
            ce && (R[W.prop] = ce),
            Va((e._startAt = Ji.set(_, R))),
            (e._startAt._dp = 0),
            t < 0 && (tr ? e._startAt.revert(dd) : e._startAt.render(-1, !0)),
            (e._zTime = t),
            !o)
          )
            n(e._startAt, Ei, Ei);
          else if (!t) return;
        }
        for (
          e._pt = e._ptCache = 0, l = (g && ir(l)) || (l && !g), M = 0;
          M < _.length;
          M++
        ) {
          if (
            ((U = _[M]),
            ($ = U._gsap || L0(_)[M]._gsap),
            (e._ptLookup[M] = ae = {}),
            v0[$.id] && za.length && vd(),
            (he = w === _ ? M : w.indexOf(U)),
            W &&
              (ue = new W()).init(U, ce || I, e, he, w) !== !1 &&
              ((e._pt = O =
                new Vn(e._pt, U, ue.name, 0, 1, ue.render, ue, 0, ue.priority)),
              ue._props.forEach(function (Me) {
                ae[Me] = O;
              }),
              ue.priority && (X = 1)),
            !W || ce)
          )
            for (R in I)
              Qn[R] && (ue = F0(R, I, e, he, U, w))
                ? ue.priority && (X = 1)
                : (ae[R] = O =
                    k0.call(e, U, R, "get", I[R], he, w, 0, r.stringFilter));
          e._op && e._op[M] && e.kill(U, e._op[M]),
            P &&
              e._pt &&
              ((Ba = e),
              ki.killTweensOf(U, ae, e.globalTime(t)),
              (te = !e.parent),
              (Ba = 0)),
            e._pt && l && (v0[$.id] = 1);
        }
        X && G0(e), e._onInit && e._onInit(e);
      }
      (e._onUpdate = c),
        (e._initted = (!e._op || e._pt) && !te),
        x && t <= 0 && L.render(Ur, !0, !0);
    },
    BB = function (e, t, i, r, s, a, o) {
      var l = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
        c,
        u,
        f,
        d;
      if (!l)
        for (
          l = e._ptCache[t] = [], f = e._ptLookup, d = e._targets.length;
          d--;

        ) {
          if (((c = f[d][t]), c && c.d && c.d._pt))
            for (c = c.d._pt; c && c.p !== t && c.fp !== t; ) c = c._next;
          if (!c) return (S0 = 1), (e.vars[t] = "+=0"), B0(e, o), (S0 = 0), 1;
          l.push(c);
        }
      for (d = l.length; d--; )
        (u = l[d]),
          (c = u._pt || u),
          (c.s = (r || r === 0) && !s ? r : c.s + (r || 0) + a * c.c),
          (c.c = i - c.s),
          u.e && (u.e = Vi(i) + En(u.e)),
          u.b && (u.b = c.s + En(u.b));
    },
    zB = function (e, t) {
      var i = e[0] ? Ua(e[0]).harness : 0,
        r = i && i.aliases,
        s,
        a,
        o,
        l;
      if (!r) return t;
      s = Uo({}, t);
      for (a in r)
        if (a in s)
          for (l = r[a].split(","), o = l.length; o--; ) s[l[o]] = s[a];
      return s;
    },
    UB = function (e, t, i, r) {
      var s = t.ease || r || "power1.inOut",
        a,
        o;
      if (An(t))
        (o = i[e] || (i[e] = [])),
          t.forEach(function (l, c) {
            return o.push({ t: (c / (t.length - 1)) * 100, v: l, e: s });
          });
      else
        for (a in t)
          (o = i[a] || (i[a] = [])),
            a === "ease" || o.push({ t: parseFloat(e), v: t[a], e: s });
    },
    Ou = function (e, t, i, r, s) {
      return Ui(e)
        ? e.call(t, i, r, s)
        : ln(e) && ~e.indexOf("random(")
        ? ec(e)
        : e;
    },
    b1 = I0 + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    _1 = {};
  Un(b1 + ",id,stagger,delay,duration,paused,scrollTrigger", function (n) {
    return (_1[n] = 1);
  });
  var Ji = (function (n) {
    qS(e, n);
    function e(i, r, s, a) {
      var o;
      typeof r == "number" && ((s.duration = r), (r = s), (s = null)),
        (o = n.call(this, a ? r : Lu(r)) || this);
      var l = o.vars,
        c = l.duration,
        u = l.delay,
        f = l.immediateRender,
        d = l.stagger,
        m = l.overwrite,
        x = l.keyframes,
        y = l.defaults,
        g = l.scrollTrigger,
        b = l.yoyoEase,
        _ = r.parent || ki,
        E = (An(i) || YS(i) ? $s(i[0]) : "length" in r) ? [i] : Vr(i),
        w,
        P,
        L,
        I,
        M,
        R,
        O,
        U;
      if (
        ((o._targets = E.length
          ? L0(E)
          : yd(
              "GSAP target " + i + " not found. https://greensock.com",
              !nr.nullTargetWarn
            ) || []),
        (o._ptLookup = []),
        (o._overwrite = m),
        x || d || fd(c) || fd(u))
      ) {
        if (
          ((r = o.vars),
          (w = o.timeline =
            new Mn({
              data: "nested",
              defaults: y || {},
              targets: _ && _.data === "nested" ? _.vars.targets : E,
            })),
          w.kill(),
          (w.parent = w._dp = Gs(o)),
          (w._start = 0),
          d || fd(c) || fd(u))
        ) {
          if (((I = E.length), (O = d && u1(d)), bs(d)))
            for (M in d) ~b1.indexOf(M) && (U || (U = {}), (U[M] = d[M]));
          for (P = 0; P < I; P++)
            (L = xd(r, _1)),
              (L.stagger = 0),
              b && (L.yoyoEase = b),
              U && Uo(L, U),
              (R = E[P]),
              (L.duration = +Ou(c, Gs(o), P, R, E)),
              (L.delay = (+Ou(u, Gs(o), P, R, E) || 0) - o._delay),
              !d &&
                I === 1 &&
                L.delay &&
                ((o._delay = u = L.delay), (o._start += u), (L.delay = 0)),
              w.to(R, L, O ? O(P, R, E) : 0),
              (w._ease = si.none);
          w.duration() ? (c = u = 0) : (o.timeline = 0);
        } else if (x) {
          Lu(Hr(w.vars.defaults, { ease: "none" })),
            (w._ease = zo(x.ease || r.ease || "none"));
          var X = 0,
            $,
            W,
            ue;
          if (An(x))
            x.forEach(function (ae) {
              return w.to(E, ae, ">");
            }),
              w.duration();
          else {
            L = {};
            for (M in x)
              M === "ease" || M === "easeEach" || UB(M, x[M], L, x.easeEach);
            for (M in L)
              for (
                $ = L[M].sort(function (ae, he) {
                  return ae.t - he.t;
                }),
                  X = 0,
                  P = 0;
                P < $.length;
                P++
              )
                (W = $[P]),
                  (ue = {
                    ease: W.e,
                    duration: ((W.t - (P ? $[P - 1].t : 0)) / 100) * c,
                  }),
                  (ue[M] = W.v),
                  w.to(E, ue, X),
                  (X += ue.duration);
            w.duration() < c && w.to({}, { duration: c - w.duration() });
          }
        }
        c || o.duration((c = w.duration()));
      } else o.timeline = 0;
      return (
        m === !0 && !M0 && ((Ba = Gs(o)), ki.killTweensOf(E), (Ba = 0)),
        xs(_, Gs(o), s),
        r.reversed && o.reverse(),
        r.paused && o.paused(!0),
        (f ||
          (!c &&
            !x &&
            o._start === _n(_._time) &&
            ir(f) &&
            gB(Gs(o)) &&
            _.data !== "nested")) &&
          ((o._tTime = -Ei), o.render(Math.max(0, -u) || 0)),
        g && a1(Gs(o), g),
        o
      );
    }
    var t = e.prototype;
    return (
      (t.render = function (r, s, a) {
        var o = this._time,
          l = this._tDur,
          c = this._dur,
          u = r < 0,
          f = r > l - Ei && !u ? l : r < Ei ? 0 : r,
          d,
          m,
          x,
          y,
          g,
          b,
          _,
          E,
          w;
        if (!c) vB(this, r, s, a);
        else if (
          f !== this._tTime ||
          !r ||
          a ||
          (!this._initted && this._tTime) ||
          (this._startAt && this._zTime < 0 !== u)
        ) {
          if (((d = f), (E = this.timeline), this._repeat)) {
            if (((y = c + this._rDelay), this._repeat < -1 && u))
              return this.totalTime(y * 100 + r, s, a);
            if (
              ((d = _n(f % y)),
              f === l
                ? ((x = this._repeat), (d = c))
                : ((x = ~~(f / y)),
                  x && x === f / y && ((d = c), x--),
                  d > c && (d = c)),
              (b = this._yoyo && x & 1),
              b && ((w = this._yEase), (d = c - d)),
              (g = Yl(this._tTime, y)),
              d === o && !a && this._initted)
            )
              return (this._tTime = f), this;
            x !== g &&
              (E && this._yEase && v1(E, b),
              this.vars.repeatRefresh &&
                !b &&
                !this._lock &&
                ((this._lock = a = 1),
                (this.render(_n(y * x), !0).invalidate()._lock = 0)));
          }
          if (!this._initted) {
            if (o1(this, u ? r : d, a, s, f)) return (this._tTime = 0), this;
            if (o !== this._time) return this;
            if (c !== this._dur) return this.render(r, s, a);
          }
          if (
            ((this._tTime = f),
            (this._time = d),
            !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
            (this.ratio = _ = (w || this._ease)(d / c)),
            this._from && (this.ratio = _ = 1 - _),
            d && !o && !s && (Gr(this, "onStart"), this._tTime !== f))
          )
            return this;
          for (m = this._pt; m; ) m.r(_, m.d), (m = m._next);
          (E &&
            E.render(
              r < 0 ? r : !d && b ? -Ei : E._dur * E._ease(d / this._dur),
              s,
              a
            )) ||
            (this._startAt && (this._zTime = r)),
            this._onUpdate &&
              !s &&
              (u && x0(this, r, s, a), Gr(this, "onUpdate")),
            this._repeat &&
              x !== g &&
              this.vars.onRepeat &&
              !s &&
              this.parent &&
              Gr(this, "onRepeat"),
            (f === this._tDur || !f) &&
              this._tTime === f &&
              (u && !this._onUpdate && x0(this, r, !0, !0),
              (r || !c) &&
                ((f === this._tDur && this._ts > 0) || (!f && this._ts < 0)) &&
                Va(this, 1),
              !s &&
                !(u && !o) &&
                (f || o || b) &&
                (Gr(this, f === l ? "onComplete" : "onReverseComplete", !0),
                this._prom &&
                  !(f < l && this.timeScale() > 0) &&
                  this._prom()));
        }
        return this;
      }),
      (t.targets = function () {
        return this._targets;
      }),
      (t.invalidate = function (r) {
        return (
          (!r || !this.vars.runBackwards) && (this._startAt = 0),
          (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
          (this._ptLookup = []),
          this.timeline && this.timeline.invalidate(r),
          n.prototype.invalidate.call(this, r)
        );
      }),
      (t.resetTo = function (r, s, a, o) {
        ku || er.wake(), this._ts || this.play();
        var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
          c;
        return (
          this._initted || B0(this, l),
          (c = this._ease(l / this._dur)),
          BB(this, r, s, a, o, c, l)
            ? this.resetTo(r, s, a, o)
            : (Md(this, 0),
              this.parent ||
                r1(
                  this._dp,
                  this,
                  "_first",
                  "_last",
                  this._dp._sort ? "_start" : 0
                ),
              this.render(0))
        );
      }),
      (t.kill = function (r, s) {
        if ((s === void 0 && (s = "all"), !r && (!s || s === "all")))
          return (this._lazy = this._pt = 0), this.parent ? Du(this) : this;
        if (this.timeline) {
          var a = this.timeline.totalDuration();
          return (
            this.timeline.killTweensOf(r, s, Ba && Ba.vars.overwrite !== !0)
              ._first || Du(this),
            this.parent &&
              a !== this.timeline.totalDuration() &&
              Kl(this, (this._dur * this.timeline._tDur) / a, 0, 1),
            this
          );
        }
        var o = this._targets,
          l = r ? Vr(r) : o,
          c = this._ptLookup,
          u = this._pt,
          f,
          d,
          m,
          x,
          y,
          g,
          b;
        if ((!s || s === "all") && pB(o, l))
          return s === "all" && (this._pt = 0), Du(this);
        for (
          f = this._op = this._op || [],
            s !== "all" &&
              (ln(s) &&
                ((y = {}),
                Un(s, function (_) {
                  return (y[_] = 1);
                }),
                (s = y)),
              (s = zB(o, s))),
            b = o.length;
          b--;

        )
          if (~l.indexOf(o[b])) {
            (d = c[b]),
              s === "all"
                ? ((f[b] = s), (x = d), (m = {}))
                : ((m = f[b] = f[b] || {}), (x = s));
            for (y in x)
              (g = d && d[y]),
                g &&
                  ((!("kill" in g.d) || g.d.kill(y) === !0) &&
                    Sd(this, g, "_pt"),
                  delete d[y]),
                m !== "all" && (m[y] = 1);
          }
        return this._initted && !this._pt && u && Du(this), this;
      }),
      (e.to = function (r, s) {
        return new e(r, s, arguments[2]);
      }),
      (e.from = function (r, s) {
        return Ru(1, arguments);
      }),
      (e.delayedCall = function (r, s, a, o) {
        return new e(s, 0, {
          immediateRender: !1,
          lazy: !1,
          overwrite: !1,
          delay: r,
          onComplete: s,
          onReverseComplete: s,
          onCompleteParams: a,
          onReverseCompleteParams: a,
          callbackScope: o,
        });
      }),
      (e.fromTo = function (r, s, a) {
        return Ru(2, arguments);
      }),
      (e.set = function (r, s) {
        return (s.duration = 0), s.repeatDelay || (s.repeat = 0), new e(r, s);
      }),
      (e.killTweensOf = function (r, s, a) {
        return ki.killTweensOf(r, s, a);
      }),
      e
    );
  })(Zl);
  Hr(Ji.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
  Un("staggerTo,staggerFrom,staggerFromTo", function (n) {
    Ji[n] = function () {
      var e = new Mn(),
        t = _0.call(arguments, 0);
      return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t);
    };
  });
  var z0 = function (e, t, i) {
      return (e[t] = i);
    },
    E1 = function (e, t, i) {
      return e[t](i);
    },
    VB = function (e, t, i, r) {
      return e[t](r.fp, i);
    },
    GB = function (e, t, i) {
      return e.setAttribute(t, i);
    },
    Ad = function (e, t) {
      return Ui(e[t]) ? E1 : Ed(e[t]) && e.setAttribute ? GB : z0;
    },
    T1 = function (e, t) {
      return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
    },
    HB = function (e, t) {
      return t.set(t.t, t.p, !!(t.s + t.c * e), t);
    },
    U0 = function (e, t) {
      var i = t._pt,
        r = "";
      if (!e && t.b) r = t.b;
      else if (e === 1 && t.e) r = t.e;
      else {
        for (; i; )
          (r =
            i.p +
            (i.m
              ? i.m(i.s + i.c * e)
              : Math.round((i.s + i.c * e) * 1e4) / 1e4) +
            r),
            (i = i._next);
        r += t.c;
      }
      t.set(t.t, t.p, r, t);
    },
    V0 = function (e, t) {
      for (var i = t._pt; i; ) i.r(e, i.d), (i = i._next);
    },
    $B = function (e, t, i, r) {
      for (var s = this._pt, a; s; )
        (a = s._next), s.p === r && s.modifier(e, t, i), (s = a);
    },
    WB = function (e) {
      for (var t = this._pt, i, r; t; )
        (r = t._next),
          (t.p === e && !t.op) || t.op === e
            ? Sd(this, t, "_pt")
            : t.dep || (i = 1),
          (t = r);
      return !i;
    },
    qB = function (e, t, i, r) {
      r.mSet(e, t, r.m.call(r.tween, i, r.mt), r);
    },
    G0 = function (e) {
      for (var t = e._pt, i, r, s, a; t; ) {
        for (i = t._next, r = s; r && r.pr > t.pr; ) r = r._next;
        (t._prev = r ? r._prev : a) ? (t._prev._next = t) : (s = t),
          (t._next = r) ? (r._prev = t) : (a = t),
          (t = i);
      }
      e._pt = s;
    },
    Vn = (function () {
      function n(t, i, r, s, a, o, l, c, u) {
        (this.t = i),
          (this.s = s),
          (this.c = a),
          (this.p = r),
          (this.r = o || T1),
          (this.d = l || this),
          (this.set = c || z0),
          (this.pr = u || 0),
          (this._next = t),
          t && (t._prev = this);
      }
      var e = n.prototype;
      return (
        (e.modifier = function (i, r, s) {
          (this.mSet = this.mSet || this.set),
            (this.set = qB),
            (this.m = i),
            (this.mt = s),
            (this.tween = r);
        }),
        n
      );
    })();
  Un(
    I0 +
      "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
    function (n) {
      return (D0[n] = 1);
    }
  );
  pr.TweenMax = pr.TweenLite = Ji;
  pr.TimelineLite = pr.TimelineMax = Mn;
  ki = new Mn({
    sortChildren: !1,
    defaults: Xl,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0,
  });
  nr.stringFilter = O0;
  var Ql = [],
    md = {},
    jB = [],
    WS = 0,
    d0 = function (e) {
      return (md[e] || jB).map(function (t) {
        return t();
      });
    },
    w0 = function () {
      var e = Date.now(),
        t = [];
      e - WS > 2 &&
        (d0("matchMediaInit"),
        Ql.forEach(function (i) {
          var r = i.queries,
            s = i.conditions,
            a,
            o,
            l,
            c;
          for (o in r)
            (a = zr.matchMedia(r[o]).matches),
              a && (l = 1),
              a !== s[o] && ((s[o] = a), (c = 1));
          c && (i.revert(), l && t.push(i));
        }),
        d0("matchMediaRevert"),
        t.forEach(function (i) {
          return i.onMatch(i);
        }),
        (WS = e),
        d0("matchMedia"));
    },
    S1 = (function () {
      function n(t, i) {
        (this.selector = i && E0(i)),
          (this.data = []),
          (this._r = []),
          (this.isReverted = !1),
          t && this.add(t);
      }
      var e = n.prototype;
      return (
        (e.add = function (i, r, s) {
          Ui(i) && ((s = r), (r = i), (i = Ui));
          var a = this,
            o = function () {
              var c = Zi,
                u = a.selector,
                f;
              return (
                c && c !== a && c.data.push(a),
                s && (a.selector = E0(s)),
                (Zi = a),
                (f = r.apply(a, arguments)),
                Ui(f) && a._r.push(f),
                (Zi = c),
                (a.selector = u),
                (a.isReverted = !1),
                f
              );
            };
          return (a.last = o), i === Ui ? o(a) : i ? (a[i] = o) : o;
        }),
        (e.ignore = function (i) {
          var r = Zi;
          (Zi = null), i(this), (Zi = r);
        }),
        (e.getTweens = function () {
          var i = [];
          return (
            this.data.forEach(function (r) {
              return r instanceof n
                ? i.push.apply(i, r.getTweens())
                : r instanceof Ji &&
                    !(r.parent && r.parent.data === "nested") &&
                    i.push(r);
            }),
            i
          );
        }),
        (e.clear = function () {
          this._r.length = this.data.length = 0;
        }),
        (e.kill = function (i, r) {
          var s = this;
          if (i) {
            var a = this.getTweens();
            this.data.forEach(function (l) {
              l.data === "isFlip" &&
                (l.revert(),
                l.getChildren(!0, !0, !1).forEach(function (c) {
                  return a.splice(a.indexOf(c), 1);
                }));
            }),
              a
                .map(function (l) {
                  return { g: l.globalTime(0), t: l };
                })
                .sort(function (l, c) {
                  return c.g - l.g || -1;
                })
                .forEach(function (l) {
                  return l.t.revert(i);
                }),
              this.data.forEach(function (l) {
                return !(l instanceof Zl) && l.revert && l.revert(i);
              }),
              this._r.forEach(function (l) {
                return l(i, s);
              }),
              (this.isReverted = !0);
          } else
            this.data.forEach(function (l) {
              return l.kill && l.kill();
            });
          if ((this.clear(), r)) {
            var o = Ql.indexOf(this);
            ~o && Ql.splice(o, 1);
          }
        }),
        (e.revert = function (i) {
          this.kill(i || {});
        }),
        n
      );
    })(),
    XB = (function () {
      function n(t) {
        (this.contexts = []), (this.scope = t);
      }
      var e = n.prototype;
      return (
        (e.add = function (i, r, s) {
          bs(i) || (i = { matches: i });
          var a = new S1(0, s || this.scope),
            o = (a.conditions = {}),
            l,
            c,
            u;
          this.contexts.push(a), (r = a.add("onMatch", r)), (a.queries = i);
          for (c in i)
            c === "all"
              ? (u = 1)
              : ((l = zr.matchMedia(i[c])),
                l &&
                  (Ql.indexOf(a) < 0 && Ql.push(a),
                  (o[c] = l.matches) && (u = 1),
                  l.addListener
                    ? l.addListener(w0)
                    : l.addEventListener("change", w0)));
          return u && r(a), this;
        }),
        (e.revert = function (i) {
          this.kill(i || {});
        }),
        (e.kill = function (i) {
          this.contexts.forEach(function (r) {
            return r.kill(i, !0);
          });
        }),
        n
      );
    })(),
    _d = {
      registerPlugin: function () {
        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
          t[i] = arguments[i];
        t.forEach(function (r) {
          return PB(r);
        });
      },
      timeline: function (e) {
        return new Mn(e);
      },
      getTweensOf: function (e, t) {
        return ki.getTweensOf(e, t);
      },
      getProperty: function (e, t, i, r) {
        ln(e) && (e = Vr(e)[0]);
        var s = Ua(e || {}).get,
          a = i ? n1 : i1;
        return (
          i === "native" && (i = ""),
          e &&
            (t
              ? a(((Qn[t] && Qn[t].get) || s)(e, t, i, r))
              : function (o, l, c) {
                  return a(((Qn[o] && Qn[o].get) || s)(e, o, l, c));
                })
        );
      },
      quickSetter: function (e, t, i) {
        if (((e = Vr(e)), e.length > 1)) {
          var r = e.map(function (u) {
              return zn.quickSetter(u, t, i);
            }),
            s = r.length;
          return function (u) {
            for (var f = s; f--; ) r[f](u);
          };
        }
        e = e[0] || {};
        var a = Qn[t],
          o = Ua(e),
          l = (o.harness && (o.harness.aliases || {})[t]) || t,
          c = a
            ? function (u) {
                var f = new a();
                (jl._pt = 0),
                  f.init(e, i ? u + i : u, jl, 0, [e]),
                  f.render(1, f),
                  jl._pt && V0(1, jl);
              }
            : o.set(e, l);
        return a
          ? c
          : function (u) {
              return c(e, l, i ? u + i : u, o, 1);
            };
      },
      quickTo: function (e, t, i) {
        var r,
          s = zn.to(
            e,
            Uo(((r = {}), (r[t] = "+=0.1"), (r.paused = !0), r), i || {})
          ),
          a = function (l, c, u) {
            return s.resetTo(t, l, c, u);
          };
        return (a.tween = s), a;
      },
      isTweening: function (e) {
        return ki.getTweensOf(e, !0).length > 0;
      },
      defaults: function (e) {
        return e && e.ease && (e.ease = zo(e.ease, Xl.ease)), US(Xl, e || {});
      },
      config: function (e) {
        return US(nr, e || {});
      },
      registerEffect: function (e) {
        var t = e.name,
          i = e.effect,
          r = e.plugins,
          s = e.defaults,
          a = e.extendTimeline;
        (r || "").split(",").forEach(function (o) {
          return (
            o &&
            !Qn[o] &&
            !pr[o] &&
            yd(t + " effect requires " + o + " plugin.")
          );
        }),
          (c0[t] = function (o, l, c) {
            return i(Vr(o), Hr(l || {}, s), c);
          }),
          a &&
            (Mn.prototype[t] = function (o, l, c) {
              return this.add(c0[t](o, bs(l) ? l : (c = l) && {}, this), c);
            });
      },
      registerEase: function (e, t) {
        si[e] = zo(t);
      },
      parseEase: function (e, t) {
        return arguments.length ? zo(e, t) : si;
      },
      getById: function (e) {
        return ki.getById(e);
      },
      exportRoot: function (e, t) {
        e === void 0 && (e = {});
        var i = new Mn(e),
          r,
          s;
        for (
          i.smoothChildTiming = ir(e.smoothChildTiming),
            ki.remove(i),
            i._dp = 0,
            i._time = i._tTime = ki._time,
            r = ki._first;
          r;

        )
          (s = r._next),
            (t ||
              !(
                !r._dur &&
                r instanceof Ji &&
                r.vars.onComplete === r._targets[0]
              )) &&
              xs(i, r, r._start - r._delay),
            (r = s);
        return xs(ki, i, 0), i;
      },
      context: function (e, t) {
        return e ? new S1(e, t) : Zi;
      },
      matchMedia: function (e) {
        return new XB(e);
      },
      matchMediaRefresh: function () {
        return (
          Ql.forEach(function (e) {
            var t = e.conditions,
              i,
              r;
            for (r in t) t[r] && ((t[r] = !1), (i = 1));
            i && e.revert();
          }) || w0()
        );
      },
      addEventListener: function (e, t) {
        var i = md[e] || (md[e] = []);
        ~i.indexOf(t) || i.push(t);
      },
      removeEventListener: function (e, t) {
        var i = md[e],
          r = i && i.indexOf(t);
        r >= 0 && i.splice(r, 1);
      },
      utils: {
        wrap: MB,
        wrapYoyo: AB,
        distribute: u1,
        random: f1,
        snap: h1,
        normalize: wB,
        getUnit: En,
        clamp: _B,
        splitColor: m1,
        toArray: Vr,
        selector: E0,
        mapRange: p1,
        pipe: TB,
        unitize: SB,
        interpolate: CB,
        shuffle: c1,
      },
      install: ZS,
      effects: c0,
      ticker: er,
      updateRoot: Mn.updateRoot,
      plugins: Qn,
      globalTimeline: ki,
      core: {
        PropTween: Vn,
        globals: QS,
        Tween: Ji,
        Timeline: Mn,
        Animation: Zl,
        getCache: Ua,
        _removeLinkedListItem: Sd,
        reverting: function () {
          return tr;
        },
        context: function (e) {
          return e && Zi && (Zi.data.push(e), (e._ctx = Zi)), Zi;
        },
        suppressOverwrites: function (e) {
          return (M0 = e);
        },
      },
    };
  Un("to,from,fromTo,delayedCall,set,killTweensOf", function (n) {
    return (_d[n] = Ji[n]);
  });
  er.add(Mn.updateRoot);
  jl = _d.to({}, { duration: 0 });
  var YB = function (e, t) {
      for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; )
        i = i._next;
      return i;
    },
    KB = function (e, t) {
      var i = e._targets,
        r,
        s,
        a;
      for (r in t)
        for (s = i.length; s--; )
          (a = e._ptLookup[s][r]),
            a &&
              (a = a.d) &&
              (a._pt && (a = YB(a, r)),
              a && a.modifier && a.modifier(t[r], e, i[s], r));
    },
    p0 = function (e, t) {
      return {
        name: e,
        rawVars: 1,
        init: function (r, s, a) {
          a._onInit = function (o) {
            var l, c;
            if (
              (ln(s) &&
                ((l = {}),
                Un(s, function (u) {
                  return (l[u] = 1);
                }),
                (s = l)),
              t)
            ) {
              l = {};
              for (c in s) l[c] = t(s[c]);
              s = l;
            }
            KB(o, s);
          };
        },
      };
    },
    zn =
      _d.registerPlugin(
        {
          name: "attr",
          init: function (e, t, i, r, s) {
            var a, o, l;
            this.tween = i;
            for (a in t)
              (l = e.getAttribute(a) || ""),
                (o = this.add(
                  e,
                  "setAttribute",
                  (l || 0) + "",
                  t[a],
                  r,
                  s,
                  0,
                  0,
                  a
                )),
                (o.op = a),
                (o.b = l),
                this._props.push(a);
          },
          render: function (e, t) {
            for (var i = t._pt; i; )
              tr ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), (i = i._next);
          },
        },
        {
          name: "endArray",
          init: function (e, t) {
            for (var i = t.length; i--; )
              this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1);
          },
        },
        p0("roundProps", T0),
        p0("modifiers"),
        p0("snap", h1)
      ) || _d;
  Ji.version = Mn.version = zn.version = "3.11.3";
  JS = 1;
  XS() && Jl();
  var JB = si.Power0,
    ZB = si.Power1,
    QB = si.Power2,
    e5 = si.Power3,
    t5 = si.Power4,
    i5 = si.Linear,
    n5 = si.Quad,
    r5 = si.Cubic,
    s5 = si.Quart,
    a5 = si.Quint,
    o5 = si.Strong,
    l5 = si.Elastic,
    c5 = si.Back,
    u5 = si.SteppedEase,
    h5 = si.Bounce,
    f5 = si.Sine,
    d5 = si.Expo,
    p5 = si.Circ;
  var w1,
    Ha,
    ic,
    Y0,
    jo,
    m5,
    M1,
    K0,
    g5 = function () {
      return typeof window != "undefined";
    },
    js = {},
    qo = 180 / Math.PI,
    nc = Math.PI / 180,
    tc = Math.atan2,
    A1 = 1e8,
    J0 = /([A-Z])/g,
    y5 = /(left|right|width|margin|padding|x)/i,
    v5 = /[\s,\(]\S/,
    qs = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity",
    },
    W0 = function (e, t) {
      return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
    },
    x5 = function (e, t) {
      return t.set(
        t.t,
        t.p,
        e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
        t
      );
    },
    b5 = function (e, t) {
      return t.set(
        t.t,
        t.p,
        e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b,
        t
      );
    },
    _5 = function (e, t) {
      var i = t.s + t.c * e;
      t.set(t.t, t.p, ~~(i + (i < 0 ? -0.5 : 0.5)) + t.u, t);
    },
    O1 = function (e, t) {
      return t.set(t.t, t.p, e ? t.e : t.b, t);
    },
    N1 = function (e, t) {
      return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
    },
    E5 = function (e, t, i) {
      return (e.style[t] = i);
    },
    T5 = function (e, t, i) {
      return e.style.setProperty(t, i);
    },
    S5 = function (e, t, i) {
      return (e._gsap[t] = i);
    },
    w5 = function (e, t, i) {
      return (e._gsap.scaleX = e._gsap.scaleY = i);
    },
    M5 = function (e, t, i, r, s) {
      var a = e._gsap;
      (a.scaleX = a.scaleY = i), a.renderTransform(s, a);
    },
    A5 = function (e, t, i, r, s) {
      var a = e._gsap;
      (a[t] = i), a.renderTransform(s, a);
    },
    Fi = "transform",
    os = Fi + "Origin",
    C5 = function (e, t) {
      var i = this,
        r = this.target,
        s = r.style;
      if (e in js) {
        if (
          ((this.tfm = this.tfm || {}),
          e !== "transform" &&
            ((e = qs[e] || e),
            ~e.indexOf(",")
              ? e.split(",").forEach(function (a) {
                  return (i.tfm[a] = Ws(r, a));
                })
              : (this.tfm[e] = r._gsap.x ? r._gsap[e] : Ws(r, e))),
          this.props.indexOf(Fi) >= 0)
        )
          return;
        r._gsap.svg &&
          ((this.svgo = r.getAttribute("data-svg-origin")),
          this.props.push(os, t, "")),
          (e = Fi);
      }
      (s || t) && this.props.push(e, t, s[e]);
    },
    k1 = function (e) {
      e.translate &&
        (e.removeProperty("translate"),
        e.removeProperty("scale"),
        e.removeProperty("rotate"));
    },
    P5 = function () {
      var e = this.props,
        t = this.target,
        i = t.style,
        r = t._gsap,
        s,
        a;
      for (s = 0; s < e.length; s += 3)
        e[s + 1]
          ? (t[e[s]] = e[s + 2])
          : e[s + 2]
          ? (i[e[s]] = e[s + 2])
          : i.removeProperty(e[s].replace(J0, "-$1").toLowerCase());
      if (this.tfm) {
        for (a in this.tfm) r[a] = this.tfm[a];
        r.svg &&
          (r.renderTransform(),
          t.setAttribute("data-svg-origin", this.svgo || "")),
          (s = K0()),
          s && !s.isStart && !i[Fi] && (k1(i), (r.uncache = 1));
      }
    },
    F1 = function (e, t) {
      var i = { target: e, props: [], revert: P5, save: C5 };
      return (
        t &&
          t.split(",").forEach(function (r) {
            return i.save(r);
          }),
        i
      );
    },
    B1,
    q0 = function (e, t) {
      var i = Ha.createElementNS
        ? Ha.createElementNS(
            (t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
            e
          )
        : Ha.createElement(e);
      return i.style ? i : Ha.createElement(e);
    },
    _s = function n(e, t, i) {
      var r = getComputedStyle(e);
      return (
        r[t] ||
        r.getPropertyValue(t.replace(J0, "-$1").toLowerCase()) ||
        r.getPropertyValue(t) ||
        (!i && n(e, rc(t) || t, 1)) ||
        ""
      );
    },
    C1 = "O,Moz,ms,Ms,Webkit".split(","),
    rc = function (e, t, i) {
      var r = t || jo,
        s = r.style,
        a = 5;
      if (e in s && !i) return e;
      for (
        e = e.charAt(0).toUpperCase() + e.substr(1);
        a-- && !(C1[a] + e in s);

      );
      return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? C1[a] : "") + e;
    },
    j0 = function () {
      g5() &&
        window.document &&
        ((w1 = window),
        (Ha = w1.document),
        (ic = Ha.documentElement),
        (jo = q0("div") || { style: {} }),
        (m5 = q0("div")),
        (Fi = rc(Fi)),
        (os = Fi + "Origin"),
        (jo.style.cssText =
          "border-width:0;line-height:0;position:absolute;padding:0"),
        (B1 = !!rc("perspective")),
        (K0 = zn.core.reverting),
        (Y0 = 1));
    },
    H0 = function n(e) {
      var t = q0(
          "svg",
          (this.ownerSVGElement &&
            this.ownerSVGElement.getAttribute("xmlns")) ||
            "http://www.w3.org/2000/svg"
        ),
        i = this.parentNode,
        r = this.nextSibling,
        s = this.style.cssText,
        a;
      if (
        (ic.appendChild(t),
        t.appendChild(this),
        (this.style.display = "block"),
        e)
      )
        try {
          (a = this.getBBox()),
            (this._gsapBBox = this.getBBox),
            (this.getBBox = n);
        } catch (o) {}
      else this._gsapBBox && (a = this._gsapBBox());
      return (
        i && (r ? i.insertBefore(this, r) : i.appendChild(this)),
        ic.removeChild(t),
        (this.style.cssText = s),
        a
      );
    },
    P1 = function (e, t) {
      for (var i = t.length; i--; )
        if (e.hasAttribute(t[i])) return e.getAttribute(t[i]);
    },
    z1 = function (e) {
      var t;
      try {
        t = e.getBBox();
      } catch (i) {
        t = H0.call(e, !0);
      }
      return (
        (t && (t.width || t.height)) ||
          e.getBBox === H0 ||
          (t = H0.call(e, !0)),
        t && !t.width && !t.x && !t.y
          ? {
              x: +P1(e, ["x", "cx", "x1"]) || 0,
              y: +P1(e, ["y", "cy", "y1"]) || 0,
              width: 0,
              height: 0,
            }
          : t
      );
    },
    U1 = function (e) {
      return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && z1(e));
    },
    zu = function (e, t) {
      if (t) {
        var i = e.style;
        t in js && t !== os && (t = Fi),
          i.removeProperty
            ? ((t.substr(0, 2) === "ms" || t.substr(0, 6) === "webkit") &&
                (t = "-" + t),
              i.removeProperty(t.replace(J0, "-$1").toLowerCase()))
            : i.removeAttribute(t);
      }
    },
    $a = function (e, t, i, r, s, a) {
      var o = new Vn(e._pt, t, i, 0, 1, a ? N1 : O1);
      return (e._pt = o), (o.b = r), (o.e = s), e._props.push(i), o;
    },
    D1 = { deg: 1, rad: 1, turn: 1 },
    D5 = { grid: 1, flex: 1 },
    Wa = function n(e, t, i, r) {
      var s = parseFloat(i) || 0,
        a = (i + "").trim().substr((s + "").length) || "px",
        o = jo.style,
        l = y5.test(t),
        c = e.tagName.toLowerCase() === "svg",
        u = (c ? "client" : "offset") + (l ? "Width" : "Height"),
        f = 100,
        d = r === "px",
        m = r === "%",
        x,
        y,
        g,
        b;
      return r === a || !s || D1[r] || D1[a]
        ? s
        : (a !== "px" && !d && (s = n(e, t, i, "px")),
          (b = e.getCTM && U1(e)),
          (m || a === "%") && (js[t] || ~t.indexOf("adius"))
            ? ((x = b ? e.getBBox()[l ? "width" : "height"] : e[u]),
              Vi(m ? (s / x) * f : (s / 100) * x))
            : ((o[l ? "width" : "height"] = f + (d ? a : r)),
              (y =
                ~t.indexOf("adius") || (r === "em" && e.appendChild && !c)
                  ? e
                  : e.parentNode),
              b && (y = (e.ownerSVGElement || {}).parentNode),
              (!y || y === Ha || !y.appendChild) && (y = Ha.body),
              (g = y._gsap),
              g && m && g.width && l && g.time === er.time && !g.uncache
                ? Vi((s / g.width) * f)
                : ((m || a === "%") &&
                    !D5[_s(y, "display")] &&
                    (o.position = _s(e, "position")),
                  y === e && (o.position = "static"),
                  y.appendChild(jo),
                  (x = jo[u]),
                  y.removeChild(jo),
                  (o.position = "absolute"),
                  l && m && ((g = Ua(y)), (g.time = er.time), (g.width = y[u])),
                  Vi(d ? (x * s) / f : x && s ? (f / x) * s : 0))));
    },
    Ws = function (e, t, i, r) {
      var s;
      return (
        Y0 || j0(),
        t in qs &&
          t !== "transform" &&
          ((t = qs[t]), ~t.indexOf(",") && (t = t.split(",")[0])),
        js[t] && t !== "transform"
          ? ((s = Vu(e, r)),
            (s =
              t !== "transformOrigin"
                ? s[t]
                : s.svg
                ? s.origin
                : Pd(_s(e, os)) + " " + s.zOrigin + "px"))
          : ((s = e.style[t]),
            (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) &&
              (s =
                (Cd[t] && Cd[t](e, t, i)) ||
                _s(e, t) ||
                R0(e, t) ||
                (t === "opacity" ? 1 : 0))),
        i && !~(s + "").trim().indexOf(" ") ? Wa(e, t, s, i) + i : s
      );
    },
    I5 = function (e, t, i, r) {
      if (!i || i === "none") {
        var s = rc(t, e, 1),
          a = s && _s(e, s, 1);
        a && a !== i
          ? ((t = s), (i = a))
          : t === "borderColor" && (i = _s(e, "borderTopColor"));
      }
      var o = new Vn(this._pt, e.style, t, 0, 1, U0),
        l = 0,
        c = 0,
        u,
        f,
        d,
        m,
        x,
        y,
        g,
        b,
        _,
        E,
        w,
        P;
      if (
        ((o.b = i),
        (o.e = r),
        (i += ""),
        (r += ""),
        r === "auto" &&
          ((e.style[t] = r), (r = _s(e, t) || r), (e.style[t] = i)),
        (u = [i, r]),
        O0(u),
        (i = u[0]),
        (r = u[1]),
        (d = i.match(Vo) || []),
        (P = r.match(Vo) || []),
        P.length)
      ) {
        for (; (f = Vo.exec(r)); )
          (g = f[0]),
            (_ = r.substring(l, f.index)),
            x
              ? (x = (x + 1) % 5)
              : (_.substr(-5) === "rgba(" || _.substr(-5) === "hsla(") &&
                (x = 1),
            g !== (y = d[c++] || "") &&
              ((m = parseFloat(y) || 0),
              (w = y.substr((m + "").length)),
              g.charAt(1) === "=" && (g = Go(m, g) + w),
              (b = parseFloat(g)),
              (E = g.substr((b + "").length)),
              (l = Vo.lastIndex - E.length),
              E ||
                ((E = E || nr.units[t] || w),
                l === r.length && ((r += E), (o.e += E))),
              w !== E && (m = Wa(e, t, y, E) || 0),
              (o._pt = {
                _next: o._pt,
                p: _ || c === 1 ? _ : ",",
                s: m,
                c: b - m,
                m: (x && x < 4) || t === "zIndex" ? Math.round : 0,
              }));
        o.c = l < r.length ? r.substring(l, r.length) : "";
      } else o.r = t === "display" && r === "none" ? N1 : O1;
      return C0.test(r) && (o.e = 0), (this._pt = o), o;
    },
    I1 = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%",
    },
    L5 = function (e) {
      var t = e.split(" "),
        i = t[0],
        r = t[1] || "50%";
      return (
        (i === "top" || i === "bottom" || r === "left" || r === "right") &&
          ((e = i), (i = r), (r = e)),
        (t[0] = I1[i] || i),
        (t[1] = I1[r] || r),
        t.join(" ")
      );
    },
    R5 = function (e, t) {
      if (t.tween && t.tween._time === t.tween._dur) {
        var i = t.t,
          r = i.style,
          s = t.u,
          a = i._gsap,
          o,
          l,
          c;
        if (s === "all" || s === !0) (r.cssText = ""), (l = 1);
        else
          for (s = s.split(","), c = s.length; --c > -1; )
            (o = s[c]),
              js[o] && ((l = 1), (o = o === "transformOrigin" ? os : Fi)),
              zu(i, o);
        l &&
          (zu(i, Fi),
          a &&
            (a.svg && i.removeAttribute("transform"),
            Vu(i, 1),
            (a.uncache = 1),
            k1(r)));
      }
    },
    Cd = {
      clearProps: function (e, t, i, r, s) {
        if (s.data !== "isFromStart") {
          var a = (e._pt = new Vn(e._pt, t, i, 0, 0, R5));
          return (a.u = r), (a.pr = -10), (a.tween = s), e._props.push(i), 1;
        }
      },
    },
    Uu = [1, 0, 0, 1, 0, 0],
    V1 = {},
    G1 = function (e) {
      return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
    },
    L1 = function (e) {
      var t = _s(e, Fi);
      return G1(t) ? Uu : t.substr(7).match(A0).map(Vi);
    },
    Z0 = function (e, t) {
      var i = e._gsap || Ua(e),
        r = e.style,
        s = L1(e),
        a,
        o,
        l,
        c;
      return i.svg && e.getAttribute("transform")
        ? ((l = e.transform.baseVal.consolidate().matrix),
          (s = [l.a, l.b, l.c, l.d, l.e, l.f]),
          s.join(",") === "1,0,0,1,0,0" ? Uu : s)
        : (s === Uu &&
            !e.offsetParent &&
            e !== ic &&
            !i.svg &&
            ((l = r.display),
            (r.display = "block"),
            (a = e.parentNode),
            (!a || !e.offsetParent) &&
              ((c = 1), (o = e.nextElementSibling), ic.appendChild(e)),
            (s = L1(e)),
            l ? (r.display = l) : zu(e, "display"),
            c &&
              (o
                ? a.insertBefore(e, o)
                : a
                ? a.appendChild(e)
                : ic.removeChild(e))),
          t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s);
    },
    X0 = function (e, t, i, r, s, a) {
      var o = e._gsap,
        l = s || Z0(e, !0),
        c = o.xOrigin || 0,
        u = o.yOrigin || 0,
        f = o.xOffset || 0,
        d = o.yOffset || 0,
        m = l[0],
        x = l[1],
        y = l[2],
        g = l[3],
        b = l[4],
        _ = l[5],
        E = t.split(" "),
        w = parseFloat(E[0]) || 0,
        P = parseFloat(E[1]) || 0,
        L,
        I,
        M,
        R;
      i
        ? l !== Uu &&
          (I = m * g - x * y) &&
          ((M = w * (g / I) + P * (-y / I) + (y * _ - g * b) / I),
          (R = w * (-x / I) + P * (m / I) - (m * _ - x * b) / I),
          (w = M),
          (P = R))
        : ((L = z1(e)),
          (w = L.x + (~E[0].indexOf("%") ? (w / 100) * L.width : w)),
          (P =
            L.y + (~(E[1] || E[0]).indexOf("%") ? (P / 100) * L.height : P))),
        r || (r !== !1 && o.smooth)
          ? ((b = w - c),
            (_ = P - u),
            (o.xOffset = f + (b * m + _ * y) - b),
            (o.yOffset = d + (b * x + _ * g) - _))
          : (o.xOffset = o.yOffset = 0),
        (o.xOrigin = w),
        (o.yOrigin = P),
        (o.smooth = !!r),
        (o.origin = t),
        (o.originIsAbsolute = !!i),
        (e.style[os] = "0px 0px"),
        a &&
          ($a(a, o, "xOrigin", c, w),
          $a(a, o, "yOrigin", u, P),
          $a(a, o, "xOffset", f, o.xOffset),
          $a(a, o, "yOffset", d, o.yOffset)),
        e.setAttribute("data-svg-origin", w + " " + P);
    },
    Vu = function (e, t) {
      var i = e._gsap || new N0(e);
      if ("x" in i && !t && !i.uncache) return i;
      var r = e.style,
        s = i.scaleX < 0,
        a = "px",
        o = "deg",
        l = getComputedStyle(e),
        c = _s(e, os) || "0",
        u,
        f,
        d,
        m,
        x,
        y,
        g,
        b,
        _,
        E,
        w,
        P,
        L,
        I,
        M,
        R,
        O,
        U,
        X,
        $,
        W,
        ue,
        ae,
        he,
        ce,
        te,
        Me,
        ge,
        pe,
        We,
        Fe,
        Be;
      return (
        (u = f = d = y = g = b = _ = E = w = 0),
        (m = x = 1),
        (i.svg = !!(e.getCTM && U1(e))),
        l.translate &&
          ((l.translate !== "none" ||
            l.scale !== "none" ||
            l.rotate !== "none") &&
            (r[Fi] =
              (l.translate !== "none"
                ? "translate3d(" +
                  (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                  ") "
                : "") +
              (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") +
              (l.scale !== "none"
                ? "scale(" + l.scale.split(" ").join(",") + ") "
                : "") +
              (l[Fi] !== "none" ? l[Fi] : "")),
          (r.scale = r.rotate = r.translate = "none")),
        (I = Z0(e, i.svg)),
        i.svg &&
          (i.uncache
            ? ((ce = e.getBBox()),
              (c = i.xOrigin - ce.x + "px " + (i.yOrigin - ce.y) + "px"),
              (he = ""))
            : (he = !t && e.getAttribute("data-svg-origin")),
          X0(e, he || c, !!he || i.originIsAbsolute, i.smooth !== !1, I)),
        (P = i.xOrigin || 0),
        (L = i.yOrigin || 0),
        I !== Uu &&
          ((U = I[0]),
          (X = I[1]),
          ($ = I[2]),
          (W = I[3]),
          (u = ue = I[4]),
          (f = ae = I[5]),
          I.length === 6
            ? ((m = Math.sqrt(U * U + X * X)),
              (x = Math.sqrt(W * W + $ * $)),
              (y = U || X ? tc(X, U) * qo : 0),
              (_ = $ || W ? tc($, W) * qo + y : 0),
              _ && (x *= Math.abs(Math.cos(_ * nc))),
              i.svg && ((u -= P - (P * U + L * $)), (f -= L - (P * X + L * W))))
            : ((Be = I[6]),
              (We = I[7]),
              (Me = I[8]),
              (ge = I[9]),
              (pe = I[10]),
              (Fe = I[11]),
              (u = I[12]),
              (f = I[13]),
              (d = I[14]),
              (M = tc(Be, pe)),
              (g = M * qo),
              M &&
                ((R = Math.cos(-M)),
                (O = Math.sin(-M)),
                (he = ue * R + Me * O),
                (ce = ae * R + ge * O),
                (te = Be * R + pe * O),
                (Me = ue * -O + Me * R),
                (ge = ae * -O + ge * R),
                (pe = Be * -O + pe * R),
                (Fe = We * -O + Fe * R),
                (ue = he),
                (ae = ce),
                (Be = te)),
              (M = tc(-$, pe)),
              (b = M * qo),
              M &&
                ((R = Math.cos(-M)),
                (O = Math.sin(-M)),
                (he = U * R - Me * O),
                (ce = X * R - ge * O),
                (te = $ * R - pe * O),
                (Fe = W * O + Fe * R),
                (U = he),
                (X = ce),
                ($ = te)),
              (M = tc(X, U)),
              (y = M * qo),
              M &&
                ((R = Math.cos(M)),
                (O = Math.sin(M)),
                (he = U * R + X * O),
                (ce = ue * R + ae * O),
                (X = X * R - U * O),
                (ae = ae * R - ue * O),
                (U = he),
                (ue = ce)),
              g &&
                Math.abs(g) + Math.abs(y) > 359.9 &&
                ((g = y = 0), (b = 180 - b)),
              (m = Vi(Math.sqrt(U * U + X * X + $ * $))),
              (x = Vi(Math.sqrt(ae * ae + Be * Be))),
              (M = tc(ue, ae)),
              (_ = Math.abs(M) > 2e-4 ? M * qo : 0),
              (w = Fe ? 1 / (Fe < 0 ? -Fe : Fe) : 0)),
          i.svg &&
            ((he = e.getAttribute("transform")),
            (i.forceCSS = e.setAttribute("transform", "") || !G1(_s(e, Fi))),
            he && e.setAttribute("transform", he))),
        Math.abs(_) > 90 &&
          Math.abs(_) < 270 &&
          (s
            ? ((m *= -1),
              (_ += y <= 0 ? 180 : -180),
              (y += y <= 0 ? 180 : -180))
            : ((x *= -1), (_ += _ <= 0 ? 180 : -180))),
        (t = t || i.uncache),
        (i.x =
          u -
          ((i.xPercent =
            u &&
            ((!t && i.xPercent) ||
              (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0)))
            ? (e.offsetWidth * i.xPercent) / 100
            : 0) +
          a),
        (i.y =
          f -
          ((i.yPercent =
            f &&
            ((!t && i.yPercent) ||
              (Math.round(e.offsetHeight / 2) === Math.round(-f) ? -50 : 0)))
            ? (e.offsetHeight * i.yPercent) / 100
            : 0) +
          a),
        (i.z = d + a),
        (i.scaleX = Vi(m)),
        (i.scaleY = Vi(x)),
        (i.rotation = Vi(y) + o),
        (i.rotationX = Vi(g) + o),
        (i.rotationY = Vi(b) + o),
        (i.skewX = _ + o),
        (i.skewY = E + o),
        (i.transformPerspective = w + a),
        (i.zOrigin = parseFloat(c.split(" ")[2]) || 0) && (r[os] = Pd(c)),
        (i.xOffset = i.yOffset = 0),
        (i.force3D = nr.force3D),
        (i.renderTransform = i.svg ? N5 : B1 ? H1 : O5),
        (i.uncache = 0),
        i
      );
    },
    Pd = function (e) {
      return (e = e.split(" "))[0] + " " + e[1];
    },
    $0 = function (e, t, i) {
      var r = En(t);
      return Vi(parseFloat(t) + parseFloat(Wa(e, "x", i + "px", r))) + r;
    },
    O5 = function (e, t) {
      (t.z = "0px"),
        (t.rotationY = t.rotationX = "0deg"),
        (t.force3D = 0),
        H1(e, t);
    },
    $o = "0deg",
    Bu = "0px",
    Wo = ") ",
    H1 = function (e, t) {
      var i = t || this,
        r = i.xPercent,
        s = i.yPercent,
        a = i.x,
        o = i.y,
        l = i.z,
        c = i.rotation,
        u = i.rotationY,
        f = i.rotationX,
        d = i.skewX,
        m = i.skewY,
        x = i.scaleX,
        y = i.scaleY,
        g = i.transformPerspective,
        b = i.force3D,
        _ = i.target,
        E = i.zOrigin,
        w = "",
        P = (b === "auto" && e && e !== 1) || b === !0;
      if (E && (f !== $o || u !== $o)) {
        var L = parseFloat(u) * nc,
          I = Math.sin(L),
          M = Math.cos(L),
          R;
        (L = parseFloat(f) * nc),
          (R = Math.cos(L)),
          (a = $0(_, a, I * R * -E)),
          (o = $0(_, o, -Math.sin(L) * -E)),
          (l = $0(_, l, M * R * -E + E));
      }
      g !== Bu && (w += "perspective(" + g + Wo),
        (r || s) && (w += "translate(" + r + "%, " + s + "%) "),
        (P || a !== Bu || o !== Bu || l !== Bu) &&
          (w +=
            l !== Bu || P
              ? "translate3d(" + a + ", " + o + ", " + l + ") "
              : "translate(" + a + ", " + o + Wo),
        c !== $o && (w += "rotate(" + c + Wo),
        u !== $o && (w += "rotateY(" + u + Wo),
        f !== $o && (w += "rotateX(" + f + Wo),
        (d !== $o || m !== $o) && (w += "skew(" + d + ", " + m + Wo),
        (x !== 1 || y !== 1) && (w += "scale(" + x + ", " + y + Wo),
        (_.style[Fi] = w || "translate(0, 0)");
    },
    N5 = function (e, t) {
      var i = t || this,
        r = i.xPercent,
        s = i.yPercent,
        a = i.x,
        o = i.y,
        l = i.rotation,
        c = i.skewX,
        u = i.skewY,
        f = i.scaleX,
        d = i.scaleY,
        m = i.target,
        x = i.xOrigin,
        y = i.yOrigin,
        g = i.xOffset,
        b = i.yOffset,
        _ = i.forceCSS,
        E = parseFloat(a),
        w = parseFloat(o),
        P,
        L,
        I,
        M,
        R;
      (l = parseFloat(l)),
        (c = parseFloat(c)),
        (u = parseFloat(u)),
        u && ((u = parseFloat(u)), (c += u), (l += u)),
        l || c
          ? ((l *= nc),
            (c *= nc),
            (P = Math.cos(l) * f),
            (L = Math.sin(l) * f),
            (I = Math.sin(l - c) * -d),
            (M = Math.cos(l - c) * d),
            c &&
              ((u *= nc),
              (R = Math.tan(c - u)),
              (R = Math.sqrt(1 + R * R)),
              (I *= R),
              (M *= R),
              u &&
                ((R = Math.tan(u)),
                (R = Math.sqrt(1 + R * R)),
                (P *= R),
                (L *= R))),
            (P = Vi(P)),
            (L = Vi(L)),
            (I = Vi(I)),
            (M = Vi(M)))
          : ((P = f), (M = d), (L = I = 0)),
        ((E && !~(a + "").indexOf("px")) || (w && !~(o + "").indexOf("px"))) &&
          ((E = Wa(m, "x", a, "px")), (w = Wa(m, "y", o, "px"))),
        (x || y || g || b) &&
          ((E = Vi(E + x - (x * P + y * I) + g)),
          (w = Vi(w + y - (x * L + y * M) + b))),
        (r || s) &&
          ((R = m.getBBox()),
          (E = Vi(E + (r / 100) * R.width)),
          (w = Vi(w + (s / 100) * R.height))),
        (R =
          "matrix(" +
          P +
          "," +
          L +
          "," +
          I +
          "," +
          M +
          "," +
          E +
          "," +
          w +
          ")"),
        m.setAttribute("transform", R),
        _ && (m.style[Fi] = R);
    },
    k5 = function (e, t, i, r, s) {
      var a = 360,
        o = ln(s),
        l = parseFloat(s) * (o && ~s.indexOf("rad") ? qo : 1),
        c = l - r,
        u = r + c + "deg",
        f,
        d;
      return (
        o &&
          ((f = s.split("_")[1]),
          f === "short" &&
            ((c %= a), c !== c % (a / 2) && (c += c < 0 ? a : -a)),
          f === "cw" && c < 0
            ? (c = ((c + a * A1) % a) - ~~(c / a) * a)
            : f === "ccw" && c > 0 && (c = ((c - a * A1) % a) - ~~(c / a) * a)),
        (e._pt = d = new Vn(e._pt, t, i, r, c, x5)),
        (d.e = u),
        (d.u = "deg"),
        e._props.push(i),
        d
      );
    },
    R1 = function (e, t) {
      for (var i in t) e[i] = t[i];
      return e;
    },
    F5 = function (e, t, i) {
      var r = R1({}, i._gsap),
        s = "perspective,force3D,transformOrigin,svgOrigin",
        a = i.style,
        o,
        l,
        c,
        u,
        f,
        d,
        m,
        x;
      r.svg
        ? ((c = i.getAttribute("transform")),
          i.setAttribute("transform", ""),
          (a[Fi] = t),
          (o = Vu(i, 1)),
          zu(i, Fi),
          i.setAttribute("transform", c))
        : ((c = getComputedStyle(i)[Fi]),
          (a[Fi] = t),
          (o = Vu(i, 1)),
          (a[Fi] = c));
      for (l in js)
        (c = r[l]),
          (u = o[l]),
          c !== u &&
            s.indexOf(l) < 0 &&
            ((m = En(c)),
            (x = En(u)),
            (f = m !== x ? Wa(i, l, c, x) : parseFloat(c)),
            (d = parseFloat(u)),
            (e._pt = new Vn(e._pt, o, l, f, d - f, W0)),
            (e._pt.u = x || 0),
            e._props.push(l));
      R1(o, r);
    };
  Un("padding,margin,Width,Radius", function (n, e) {
    var t = "Top",
      i = "Right",
      r = "Bottom",
      s = "Left",
      a = (e < 3 ? [t, i, r, s] : [t + s, t + i, r + i, r + s]).map(function (
        o
      ) {
        return e < 2 ? n + o : "border" + o + n;
      });
    Cd[e > 1 ? "border" + n : n] = function (o, l, c, u, f) {
      var d, m;
      if (arguments.length < 4)
        return (
          (d = a.map(function (x) {
            return Ws(o, x, c);
          })),
          (m = d.join(" ")),
          m.split(d[0]).length === 5 ? d[0] : m
        );
      (d = (u + "").split(" ")),
        (m = {}),
        a.forEach(function (x, y) {
          return (m[x] = d[y] = d[y] || d[((y - 1) / 2) | 0]);
        }),
        o.init(l, m, f);
    };
  });
  var Q0 = {
    name: "css",
    register: j0,
    targetTest: function (e) {
      return e.style && e.nodeType;
    },
    init: function (e, t, i, r, s) {
      var a = this._props,
        o = e.style,
        l = i.vars.startAt,
        c,
        u,
        f,
        d,
        m,
        x,
        y,
        g,
        b,
        _,
        E,
        w,
        P,
        L,
        I,
        M;
      Y0 || j0(),
        (this.styles = this.styles || F1(e)),
        (M = this.styles.props),
        (this.tween = i);
      for (y in t)
        if (
          y !== "autoRound" &&
          ((u = t[y]), !(Qn[y] && F0(y, t, i, r, e, s)))
        ) {
          if (
            ((m = typeof u),
            (x = Cd[y]),
            m === "function" && ((u = u.call(i, r, e, s)), (m = typeof u)),
            m === "string" && ~u.indexOf("random(") && (u = ec(u)),
            x)
          )
            x(this, e, y, u, i) && (I = 1);
          else if (y.substr(0, 2) === "--")
            (c = (getComputedStyle(e).getPropertyValue(y) + "").trim()),
              (u += ""),
              (Hs.lastIndex = 0),
              Hs.test(c) || ((g = En(c)), (b = En(u))),
              b ? g !== b && (c = Wa(e, y, c, b) + b) : g && (u += g),
              this.add(o, "setProperty", c, u, r, s, 0, 0, y),
              a.push(y),
              M.push(y, 0, o[y]);
          else if (m !== "undefined") {
            if (
              (l && y in l
                ? ((c =
                    typeof l[y] == "function" ? l[y].call(i, r, e, s) : l[y]),
                  ln(c) && ~c.indexOf("random(") && (c = ec(c)),
                  En(c + "") || (c += nr.units[y] || En(Ws(e, y)) || ""),
                  (c + "").charAt(1) === "=" && (c = Ws(e, y)))
                : (c = Ws(e, y)),
              (d = parseFloat(c)),
              (_ = m === "string" && u.charAt(1) === "=" && u.substr(0, 2)),
              _ && (u = u.substr(2)),
              (f = parseFloat(u)),
              y in qs &&
                (y === "autoAlpha" &&
                  (d === 1 && Ws(e, "visibility") === "hidden" && f && (d = 0),
                  M.push("visibility", 0, o.visibility),
                  $a(
                    this,
                    o,
                    "visibility",
                    d ? "inherit" : "hidden",
                    f ? "inherit" : "hidden",
                    !f
                  )),
                y !== "scale" &&
                  y !== "transform" &&
                  ((y = qs[y]), ~y.indexOf(",") && (y = y.split(",")[0]))),
              (E = y in js),
              E)
            ) {
              if (
                (this.styles.save(y),
                w ||
                  ((P = e._gsap),
                  (P.renderTransform && !t.parseTransform) ||
                    Vu(e, t.parseTransform),
                  (L = t.smoothOrigin !== !1 && P.smooth),
                  (w = this._pt =
                    new Vn(this._pt, o, Fi, 0, 1, P.renderTransform, P, 0, -1)),
                  (w.dep = 1)),
                y === "scale")
              )
                (this._pt = new Vn(
                  this._pt,
                  P,
                  "scaleY",
                  d,
                  (_ ? Go(d, _ + f) : f) - d || 0,
                  W0
                )),
                  (this._pt.u = 0),
                  a.push("scaleY", y),
                  (y += "X");
              else if (y === "transformOrigin") {
                M.push(os, 0, o[os]),
                  (u = L5(u)),
                  P.svg
                    ? X0(e, u, 0, L, 0, this)
                    : ((b = parseFloat(u.split(" ")[2]) || 0),
                      b !== P.zOrigin && $a(this, P, "zOrigin", P.zOrigin, b),
                      $a(this, o, y, Pd(c), Pd(u)));
                continue;
              } else if (y === "svgOrigin") {
                X0(e, u, 1, L, 0, this);
                continue;
              } else if (y in V1) {
                k5(this, P, y, d, _ ? Go(d, _ + u) : u);
                continue;
              } else if (y === "smoothOrigin") {
                $a(this, P, "smooth", P.smooth, u);
                continue;
              } else if (y === "force3D") {
                P[y] = u;
                continue;
              } else if (y === "transform") {
                F5(this, u, e);
                continue;
              }
            } else y in o || (y = rc(y) || y);
            if (
              E ||
              ((f || f === 0) && (d || d === 0) && !v5.test(u) && y in o)
            )
              (g = (c + "").substr((d + "").length)),
                f || (f = 0),
                (b = En(u) || (y in nr.units ? nr.units[y] : g)),
                g !== b && (d = Wa(e, y, c, b)),
                (this._pt = new Vn(
                  this._pt,
                  E ? P : o,
                  y,
                  d,
                  (_ ? Go(d, _ + f) : f) - d,
                  !E && (b === "px" || y === "zIndex") && t.autoRound !== !1
                    ? _5
                    : W0
                )),
                (this._pt.u = b || 0),
                g !== b && b !== "%" && ((this._pt.b = c), (this._pt.r = b5));
            else if (y in o) I5.call(this, e, y, c, _ ? _ + u : u);
            else if (y in e) this.add(e, y, c || e[y], _ ? _ + u : u, r, s);
            else {
              Td(y, u);
              continue;
            }
            E || (y in o ? M.push(y, 0, o[y]) : M.push(y, 1, c || e[y])),
              a.push(y);
          }
        }
      I && G0(this);
    },
    render: function (e, t) {
      if (t.tween._time || !K0())
        for (var i = t._pt; i; ) i.r(e, i.d), (i = i._next);
      else t.styles.revert();
    },
    get: Ws,
    aliases: qs,
    getSetter: function (e, t, i) {
      var r = qs[t];
      return (
        r && r.indexOf(",") < 0 && (t = r),
        t in js && t !== os && (e._gsap.x || Ws(e, "x"))
          ? i && M1 === i
            ? t === "scale"
              ? w5
              : S5
            : (M1 = i || {}) && (t === "scale" ? M5 : A5)
          : e.style && !Ed(e.style[t])
          ? E5
          : ~t.indexOf("-")
          ? T5
          : Ad(e, t)
      );
    },
    core: { _removeProperty: zu, _getMatrix: Z0 },
  };
  zn.utils.checkPrefix = rc;
  zn.core.getStyleSaver = F1;
  (function (n, e, t, i) {
    var r = Un(n + "," + e + "," + t, function (s) {
      js[s] = 1;
    });
    Un(e, function (s) {
      (nr.units[s] = "deg"), (V1[s] = 1);
    }),
      (qs[r[13]] = n + "," + e),
      Un(i, function (s) {
        var a = s.split(":");
        qs[a[1]] = r[a[0]];
      });
  })(
    "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
    "rotation,rotationX,rotationY,skewX,skewY",
    "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
    "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
  );
  Un(
    "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
    function (n) {
      nr.units[n] = "px";
    }
  );
  zn.registerPlugin(Q0);
  var yt = zn.registerPlugin(Q0) || zn,
    KK = yt.core.Tween;
  function ey(n, e, t) {
    return (1 - t) * n + t * e;
  }
  function ty(n, e, t, i, r) {
    return i + ((n - e) / (t - e)) * (r - i);
  }
  function mr(n) {
    for (let e = n.length - 1; e > 0; e--) {
      let t = Math.floor(Math.random() * (e + 1));
      [n[e], n[t]] = [n[t], n[e]];
    }
    return n;
  }
  var $1 = [],
    W1 = [];
  function iy(n, e = {}) {
    return new Promise((t, i) => {
      let r = W1.find((s) => s.url === n);
      if (r) t(Ki(Ki({}, r), e));
      else {
        let s = new Image();
        e.crossOrigin && (s.crossOrigin = e.crossOrigin);
        let a = () => {
          let o = Ki(Ki({ element: s }, B5(s)), e);
          W1.push(o), t(o);
        };
        s.decode
          ? ((s.src = n),
            s
              .decode()
              .then(a)
              .catch((o) => {
                i(o);
              }))
          : ((s.onload = a),
            (s.onerror = (o) => {
              i(o);
            }),
            (s.src = n));
      }
    });
  }
  function B5(n) {
    return {
      url: n.src,
      width: n.naturalWidth,
      height: n.naturalHeight,
      ratio: n.naturalWidth / n.naturalHeight,
    };
  }
  function Es(n, e, t) {
    return Fr(this, null, function* () {
      let i = e || n.dataset.src,
        r = $1.find((s) => s.url === i);
      if (!r) {
        if (((r = yield iy(i)), !r.url)) return;
        $1.push(r);
      }
      n.src !== i &&
        (n.tagName === "IMG"
          ? (n.src = r.url)
          : (n.style.backgroundImage = `url(${r.url})`),
        requestAnimationFrame(() => {
          let s = n.closest(".c-image");
          s && (s.classList.add("-loaded"), (s.style.backgroundImage = "")),
            n.classList.add("-loaded"),
            t == null || t();
        }));
    });
  }
  function rr(n) {
    return Fr(this, null, function* () {
      let e = n.parentNode;
      e.classList.add("-pixelated");
      let t = e.querySelector("canvas");
      t && t.remove();
      let i = document.createElement("canvas");
      (i.style.zIndex = 10), e.appendChild(i);
      let r = i.getContext("2d", { willReadFrequently: !0 }),
        s = 128,
        a = n.naturalWidth,
        o = n.naturalHeight;
      a > s && ((o = s * (o / a)), (a = s));
      let l = (f) =>
          Fr(this, null, function* () {
            return new Promise((d) => {
              if (!i.parentNode) {
                d();
                return;
              }
              let m = Math.round(a / f);
              (r.canvas.width = a),
                (r.canvas.height = o),
                r.drawImage(n, 0, 0, a, o);
              let x = r.getImageData(0, 0, a, o).data;
              for (let y = 0; y < o; y += m)
                for (let g = 0; g < a; g += m) {
                  let b = (g + y * a) * 4;
                  (r.fillStyle =
                    "rgba(" +
                    x[b] +
                    "," +
                    x[b + 1] +
                    "," +
                    x[b + 2] +
                    "," +
                    x[b + 3] +
                    ")"),
                    r.fillRect(g, y, m, m);
                }
              d();
            });
          }),
        c = 100,
        u = (f) => new Promise((d) => setTimeout(d, f));
      yield l(8),
        yield u(c),
        yield l(16),
        yield u(c),
        yield l(32),
        yield u(c),
        yield l(48),
        yield u(c),
        yield l(96),
        yield u(c),
        yield l(128),
        i.remove(),
        e.classList.remove("-pixelated");
    });
  }
  function z5(n, e) {
    return Math.sqrt(Math.pow(n.x - e.x, 2) + Math.pow(n.y - e.y, 2));
  }
  var ny = class extends St {
    constructor(n) {
      super(n);
      (this.rotationAmplitude = 16),
        (this.distanceToSpawn = 80),
        (this.delayToSpawn = 500),
        (this.minImages = 60),
        (this.$images = []),
        (this.timelines = []),
        (this.currentIndex = 0),
        (this.lastSpawnTime = Date.now());
    }
    init() {
      if (!this.$("image").length)
        return console.error("[FancyGallery] no images given"), !1;
      this.compute(), this.populateImages(), this.bindEvents(), this.render();
    }
    compute() {
      (this.isMobile = window.innerWidth < 700),
        (this.canHover = window.matchMedia("(hover: hover)").matches);
      let n = this.el.getBoundingClientRect(),
        e = { x: n.width / 2, y: n.height / 2 };
      (this.target = Ki({}, e)),
        (this.lerp = Ki({}, e)),
        (this.lastSpawn = Ki({}, e));
    }
    checkResize() {
      this.resizeTick ||
        ((this.resizeTick = !0),
        requestAnimationFrame(() => {
          this.compute(), (this.resizeTick = !1);
        }));
    }
    bindEvents() {
      (this.onMouseEnter = (n) => {
        let e = { x: n.layerX, y: n.layerY };
        (this.target = Ki({}, e)),
          (this.lerp = Ki({}, e)),
          (this.lastSpawn = Ki({}, e));
      }),
        (this.onMouseMove = (n) => {
          this.target = { x: n.layerX, y: n.layerY };
        }),
        this.canHover &&
          !this.isMobile &&
          (this.el.addEventListener("mouseenter", this.onMouseEnter),
          this.el.addEventListener("mousemove", this.onMouseMove)),
        (this.checkResizeBind = this.checkResize.bind(this)),
        window.addEventListener("resize", this.checkResizeBind);
    }
    unbindEvents() {
      this.el.removeEventListener("mouseenter", this.onMouseEnter),
        this.el.removeEventListener("mousemove", this.onMouseMove),
        window.removeEventListener("resize", this.checkResizeBind);
    }
    render() {
      (this.lerp = {
        x: ey(this.lerp.x, this.target.x, 0.1),
        y: ey(this.lerp.y, this.target.y, 0.1),
      }),
        this.checkSpawn(),
        (this.raf = requestAnimationFrame(this.render.bind(this)));
    }
    checkSpawn() {
      this.canHover && !this.isMobile
        ? Math.abs(z5(this.lastSpawn, this.lerp)) > this.distanceToSpawn &&
          this.spawn()
        : Date.now() - this.lastSpawnTime > this.delayToSpawn && this.spawn();
    }
    spawn() {
      (this.lastSpawn = this.lerp), (this.lastSpawnTime = Date.now());
      let n = this.$images[this.currentIndex % this.$images.length],
        e = n.querySelector(".c-image_inner"),
        t = n.querySelector("img");
      t && (t.classList.contains("-loaded") || Es(t, null));
      let i = yt.timeline({
        onComplete: () => {
          this.timelines.splice(this.timelines.indexOf(i), 1);
        },
      });
      i.set(n, {
        force3D: !0,
        x: this.lastSpawn.x,
        y: this.lastSpawn.y,
        zIndex: this.currentIndex,
      }),
        i.set(e, { opacity: 0, scale: 0.5, force3D: !0 }),
        i.to(e, { opacity: 1, duration: 0.15 }, 0),
        i.to(
          e,
          {
            force3D: !0,
            scale: 1,
            rotation:
              Math.random() * this.rotationAmplitude -
              this.rotationAmplitude / 2,
            duration: 0.25,
          },
          0
        ),
        i.to(e, { force3D: !0, scale: 1.2, duration: 1 }),
        i.to(e, {
          force3D: !0,
          scale: 0.5,
          rotation:
            Math.random() * this.rotationAmplitude - this.rotationAmplitude / 2,
          opacity: 0,
          duration: 0.3,
          ease: "power2.in",
        }),
        this.timelines.push(i),
        this.currentIndex++;
    }
    populateImages() {
      let n = mr(Array.from(this.$("image")));
      for (let e of n) e.parentNode.appendChild(e);
      for (let e = 0; e < Math.ceil(this.minImages / n.length); e++)
        for (let t of Array.from(n)) {
          let i = t.cloneNode(!0);
          t.parentNode.appendChild(i);
        }
      this.$images = Array.from(this.$("image"));
    }
    destroy() {
      super.destroy();
      for (let n of this.timelines) n.kill(), (n = null);
      this.unbindEvents();
    }
  };
  var q1 =
    /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
  function ry(n) {
    var e = n.nodeType,
      t = "";
    if (e === 1 || e === 9 || e === 11) {
      if (typeof n.textContent == "string") return n.textContent;
      for (n = n.firstChild; n; n = n.nextSibling) t += ry(n);
    } else if (e === 3 || e === 4) return n.nodeValue;
    return t;
  }
  var Xo,
    K1,
    J1,
    U5 = /(?:\r|\n|\t\t)/g,
    V5 = /(?:\s\s+)/g,
    G5 = function () {
      (Xo = document), (K1 = window), (J1 = 1);
    },
    H5 = 1,
    Z1 = function (e) {
      return K1.getComputedStyle(e);
    },
    $5 = Array.isArray,
    j1 = [].slice,
    ay = function (e, t) {
      var i;
      return $5(e)
        ? e
        : (i = typeof e) == "string" && !t && e
        ? j1.call(Xo.querySelectorAll(e), 0)
        : e && i === "object" && "length" in e
        ? j1.call(e, 0)
        : e
        ? [e]
        : [];
    },
    oy = function (e) {
      return e.position === "absolute" || e.absolute === !0;
    },
    W5 = function (e, t) {
      for (var i = t.length, r; --i > -1; )
        if (((r = t[i]), e.substr(0, r.length) === r)) return r.length;
    },
    q5 = " style='position:relative;display:inline-block;'",
    X1 = function (e, t) {
      e === void 0 && (e = "");
      var i = ~e.indexOf("++"),
        r = 1;
      return (
        i && (e = e.split("++").join("")),
        function () {
          return (
            "<" + t + q5 + (e ? " class='" + e + (i ? r++ : "") + "'>" : ">")
          );
        }
      );
    },
    Q1 = function n(e, t, i) {
      var r = e.nodeType;
      if (r === 1 || r === 9 || r === 11)
        for (e = e.firstChild; e; e = e.nextSibling) n(e, t, i);
      else (r === 3 || r === 4) && (e.nodeValue = e.nodeValue.split(t).join(i));
    },
    sy = function (e, t) {
      for (var i = t.length; --i > -1; ) e.push(t[i]);
    },
    Y1 = function (e, t, i) {
      for (var r; e && e !== t; ) {
        if (((r = e._next || e.nextSibling), r))
          return r.textContent.charAt(0) === i;
        e = e.parentNode || e._parent;
      }
    },
    j5 = function n(e) {
      var t = ay(e.childNodes),
        i = t.length,
        r,
        s;
      for (r = 0; r < i; r++)
        (s = t[r]),
          s._isSplit
            ? n(s)
            : r && s.previousSibling && s.previousSibling.nodeType === 3
            ? ((s.previousSibling.nodeValue +=
                s.nodeType === 3 ? s.nodeValue : s.firstChild.nodeValue),
              e.removeChild(s))
            : s.nodeType !== 3 &&
              (e.insertBefore(s.firstChild, s), e.removeChild(s));
    },
    Ts = function (e, t) {
      return parseFloat(t[e]) || 0;
    },
    X5 = function (e, t, i, r, s, a, o) {
      var l = Z1(e),
        c = Ts("paddingLeft", l),
        u = -999,
        f = Ts("borderBottomWidth", l) + Ts("borderTopWidth", l),
        d = Ts("borderLeftWidth", l) + Ts("borderRightWidth", l),
        m = Ts("paddingTop", l) + Ts("paddingBottom", l),
        x = Ts("paddingLeft", l) + Ts("paddingRight", l),
        y = Ts("fontSize", l) * (t.lineThreshold || 0.2),
        g = l.textAlign,
        b = [],
        _ = [],
        E = [],
        w = t.wordDelimiter || " ",
        P = t.tag ? t.tag : t.span ? "span" : "div",
        L = t.type || t.split || "chars,words,lines",
        I = s && ~L.indexOf("lines") ? [] : null,
        M = ~L.indexOf("words"),
        R = ~L.indexOf("chars"),
        O = oy(t),
        U = t.linesClass,
        X = ~(U || "").indexOf("++"),
        $ = [],
        W = l.display === "flex",
        ue = e.style.display,
        ae,
        he,
        ce,
        te,
        Me,
        ge,
        pe,
        We,
        Fe,
        Be,
        be,
        ut;
      for (
        X && (U = U.split("++").join("")),
          W && (e.style.display = "block"),
          he = e.getElementsByTagName("*"),
          ce = he.length,
          Me = [],
          ae = 0;
        ae < ce;
        ae++
      )
        Me[ae] = he[ae];
      if (I || O)
        for (ae = 0; ae < ce; ae++)
          (te = Me[ae]),
            (ge = te.parentNode === e),
            (ge || O || (R && !M)) &&
              ((ut = te.offsetTop),
              I &&
                ge &&
                Math.abs(ut - u) > y &&
                (te.nodeName !== "BR" || ae === 0) &&
                ((pe = []), I.push(pe), (u = ut)),
              O &&
                ((te._x = te.offsetLeft),
                (te._y = ut),
                (te._w = te.offsetWidth),
                (te._h = te.offsetHeight)),
              I &&
                (((te._isSplit && ge) ||
                  (!R && ge) ||
                  (M && ge) ||
                  (!M &&
                    te.parentNode.parentNode === e &&
                    !te.parentNode._isSplit)) &&
                  (pe.push(te),
                  (te._x -= c),
                  Y1(te, e, w) && (te._wordEnd = !0)),
                te.nodeName === "BR" &&
                  ((te.nextSibling && te.nextSibling.nodeName === "BR") ||
                    ae === 0) &&
                  I.push([])));
      for (ae = 0; ae < ce; ae++) {
        if (((te = Me[ae]), (ge = te.parentNode === e), te.nodeName === "BR")) {
          I || O
            ? (te.parentNode && te.parentNode.removeChild(te),
              Me.splice(ae--, 1),
              ce--)
            : M || e.appendChild(te);
          continue;
        }
        if (
          (O &&
            ((Fe = te.style),
            !M &&
              !ge &&
              ((te._x += te.parentNode._x), (te._y += te.parentNode._y)),
            (Fe.left = te._x + "px"),
            (Fe.top = te._y + "px"),
            (Fe.position = "absolute"),
            (Fe.display = "block"),
            (Fe.width = te._w + 1 + "px"),
            (Fe.height = te._h + "px")),
          !M && R)
        )
          if (te._isSplit)
            for (
              te._next = he = te.nextSibling, te.parentNode.appendChild(te);
              he && he.nodeType === 3 && he.textContent === " ";

            )
              (te._next = he.nextSibling),
                te.parentNode.appendChild(he),
                (he = he.nextSibling);
          else
            te.parentNode._isSplit
              ? ((te._parent = te.parentNode),
                !te.previousSibling &&
                  te.firstChild &&
                  (te.firstChild._isFirst = !0),
                te.nextSibling &&
                  te.nextSibling.textContent === " " &&
                  !te.nextSibling.nextSibling &&
                  $.push(te.nextSibling),
                (te._next =
                  te.nextSibling && te.nextSibling._isFirst
                    ? null
                    : te.nextSibling),
                te.parentNode.removeChild(te),
                Me.splice(ae--, 1),
                ce--)
              : ge ||
                ((ut = !te.nextSibling && Y1(te.parentNode, e, w)),
                te.parentNode._parent && te.parentNode._parent.appendChild(te),
                ut && te.parentNode.appendChild(Xo.createTextNode(" ")),
                P === "span" && (te.style.display = "inline"),
                b.push(te));
        else
          te.parentNode._isSplit && !te._isSplit && te.innerHTML !== ""
            ? _.push(te)
            : R &&
              !te._isSplit &&
              (P === "span" && (te.style.display = "inline"), b.push(te));
      }
      for (ae = $.length; --ae > -1; ) $[ae].parentNode.removeChild($[ae]);
      if (I) {
        for (
          O &&
            ((Be = Xo.createElement(P)),
            e.appendChild(Be),
            (be = Be.offsetWidth + "px"),
            (ut = Be.offsetParent === e ? 0 : e.offsetLeft),
            e.removeChild(Be)),
            Fe = e.style.cssText,
            e.style.cssText = "display:none;";
          e.firstChild;

        )
          e.removeChild(e.firstChild);
        for (
          We = w === " " && (!O || (!M && !R)), ae = 0;
          ae < I.length;
          ae++
        ) {
          for (
            pe = I[ae],
              Be = Xo.createElement(P),
              Be.style.cssText =
                "display:block;text-align:" +
                g +
                ";position:" +
                (O ? "absolute;" : "relative;"),
              U && (Be.className = U + (X ? ae + 1 : "")),
              E.push(Be),
              ce = pe.length,
              he = 0;
            he < ce;
            he++
          )
            pe[he].nodeName !== "BR" &&
              ((te = pe[he]),
              Be.appendChild(te),
              We && te._wordEnd && Be.appendChild(Xo.createTextNode(" ")),
              O &&
                (he === 0 &&
                  ((Be.style.top = te._y + "px"),
                  (Be.style.left = c + ut + "px")),
                (te.style.top = "0px"),
                ut && (te.style.left = te._x - ut + "px")));
          ce === 0
            ? (Be.innerHTML = "&nbsp;")
            : !M && !R && (j5(Be), Q1(Be, String.fromCharCode(160), " ")),
            O && ((Be.style.width = be), (Be.style.height = te._h + "px")),
            e.appendChild(Be);
        }
        e.style.cssText = Fe;
      }
      O &&
        (o > e.clientHeight &&
          ((e.style.height = o - m + "px"),
          e.clientHeight < o && (e.style.height = o + f + "px")),
        a > e.clientWidth &&
          ((e.style.width = a - x + "px"),
          e.clientWidth < a && (e.style.width = a + d + "px"))),
        W && (ue ? (e.style.display = ue) : e.style.removeProperty("display")),
        sy(i, b),
        M && sy(r, _),
        sy(s, E);
    },
    Y5 = function (e, t, i, r) {
      var s = t.tag ? t.tag : t.span ? "span" : "div",
        a = t.type || t.split || "chars,words,lines",
        o = ~a.indexOf("chars"),
        l = oy(t),
        c = t.wordDelimiter || " ",
        u = c !== " " ? "" : l ? "&#173; " : " ",
        f = "</" + s + ">",
        d = 1,
        m = t.specialChars
          ? typeof t.specialChars == "function"
            ? t.specialChars
            : W5
          : null,
        x,
        y,
        g,
        b,
        _,
        E,
        w,
        P,
        L = Xo.createElement("div"),
        I = e.parentNode;
      for (
        I.insertBefore(L, e),
          L.textContent = e.nodeValue,
          I.removeChild(e),
          e = L,
          x = ry(e),
          w = x.indexOf("<") !== -1,
          t.reduceWhiteSpace !== !1 && (x = x.replace(V5, " ").replace(U5, "")),
          w && (x = x.split("<").join("{{LT}}")),
          _ = x.length,
          y = (x.charAt(0) === " " ? u : "") + i(),
          g = 0;
        g < _;
        g++
      )
        if (((E = x.charAt(g)), m && (P = m(x.substr(g), t.specialChars))))
          (E = x.substr(g, P || 1)),
            (y += o && E !== " " ? r() + E + "</" + s + ">" : E),
            (g += P - 1);
        else if (E === c && x.charAt(g - 1) !== c && g) {
          for (y += d ? f : "", d = 0; x.charAt(g + 1) === c; ) (y += u), g++;
          g === _ - 1
            ? (y += u)
            : x.charAt(g + 1) !== ")" && ((y += u + i()), (d = 1));
        } else
          E === "{" && x.substr(g, 6) === "{{LT}}"
            ? ((y += o ? r() + "{{LT}}</" + s + ">" : "{{LT}}"), (g += 5))
            : (E.charCodeAt(0) >= 55296 && E.charCodeAt(0) <= 56319) ||
              (x.charCodeAt(g + 1) >= 65024 && x.charCodeAt(g + 1) <= 65039)
            ? ((b = ((x.substr(g, 12).split(q1) || [])[1] || "").length || 2),
              (y +=
                o && E !== " "
                  ? r() + x.substr(g, b) + "</" + s + ">"
                  : x.substr(g, b)),
              (g += b - 1))
            : (y += o && E !== " " ? r() + E + "</" + s + ">" : E);
      (e.outerHTML = y + (d ? f : "")), w && Q1(I, "{{LT}}", "<");
    },
    K5 = function n(e, t, i, r) {
      var s = ay(e.childNodes),
        a = s.length,
        o = oy(t),
        l,
        c;
      if (e.nodeType !== 3 || a > 1) {
        for (t.absolute = !1, l = 0; l < a; l++)
          (c = s[l]),
            (c._next = c._isFirst = c._parent = c._wordEnd = null),
            (c.nodeType !== 3 || /\S+/.test(c.nodeValue)) &&
              (o &&
                c.nodeType !== 3 &&
                Z1(c).display === "inline" &&
                ((c.style.display = "inline-block"),
                (c.style.position = "relative")),
              (c._isSplit = !0),
              n(c, t, i, r));
        (t.absolute = o), (e._isSplit = !0);
        return;
      }
      Y5(e, t, i, r);
    },
    Ss = (function () {
      function n(t, i) {
        J1 || G5(),
          (this.elements = ay(t)),
          (this.chars = []),
          (this.words = []),
          (this.lines = []),
          (this._originals = []),
          (this.vars = i || {}),
          H5 && this.split(i);
      }
      var e = n.prototype;
      return (
        (e.split = function (i) {
          this.isSplit && this.revert(),
            (this.vars = i = i || this.vars),
            (this._originals.length =
              this.chars.length =
              this.words.length =
              this.lines.length =
                0);
          for (
            var r = this.elements.length,
              s = i.tag ? i.tag : i.span ? "span" : "div",
              a = X1(i.wordsClass, s),
              o = X1(i.charsClass, s),
              l,
              c,
              u;
            --r > -1;

          )
            (u = this.elements[r]),
              (this._originals[r] = u.innerHTML),
              (l = u.clientHeight),
              (c = u.clientWidth),
              K5(u, i, a, o),
              X5(u, i, this.chars, this.words, this.lines, c, l);
          return (
            this.chars.reverse(),
            this.words.reverse(),
            this.lines.reverse(),
            (this.isSplit = !0),
            this
          );
        }),
        (e.revert = function () {
          var i = this._originals;
          if (!i) throw "revert() call wasn't scoped properly.";
          return (
            this.elements.forEach(function (r, s) {
              return (r.innerHTML = i[s]);
            }),
            (this.chars = []),
            (this.words = []),
            (this.lines = []),
            (this.isSplit = !1),
            this
          );
        }),
        (n.create = function (i, r) {
          return new n(i, r);
        }),
        n
      );
    })();
  Ss.version = "3.11.3";
  yt.registerPlugin(Ss);
  var ly = class extends St {
    constructor(n) {
      super(n);
      (this.$cols = Array.from(this.$("col"))), (this.timelines = {});
    }
    init() {
      if (!this.$cols.length)
        return console.error("[FancyTexts] no cols given"), !1;
      for (let n of this.$cols) {
        let e = this.getData("animations", n)
            ? this.getData("animations", n).split(",")
            : ["base", "stagger", "shuffle", "scramble", "fast"],
          t = -1,
          i = this.getData("contents", n).split("|"),
          r = this.getData("rows", n);
        r != "manual" && (r = parseInt(r));
        let s,
          a = (l) => {
            n.innerHTML = "";
            let c = document.createElement("div");
            if (((c.innerText = l), r == "manual")) {
              let u = l.split(",");
              for (let f of u)
                (c.innerText = f), n.appendChild(c.cloneNode(!0));
            } else for (let u = 0; u < r; u++) n.appendChild(c.cloneNode(!0));
          },
          o = () => {
            var f, d;
            t++;
            let l = i[t % i.length];
            a(l, 7),
              this.timelines[this.$cols.indexOf(n)] &&
                ((d = (f = this.timelines[this.$cols.indexOf(n)]).kill) ==
                  null ||
                  d.call(f)),
              (s = yt.timeline({
                onComplete: () => {
                  yt.set(n, { opacity: 0 }),
                    c.revert(),
                    requestAnimationFrame(() => {
                      o();
                    });
                },
              })),
              (this.timelines[this.$cols.indexOf(n)] = s);
            let c = new Ss(n, { type: "chars" });
            switch (
              (s.set(c.chars, { opacity: 0 }),
              s.set(n, { opacity: 1 }),
              e[Math.floor(e.length * Math.random())])
            ) {
              case "base":
                for (let m = 0; m < n.children.length; m++)
                  s.set(
                    [...n.children[m].children],
                    { opacity: 1, stagger: 0.04 },
                    "row" + m
                  );
                s.set(mr(Array.from(c.chars)), { opacity: 0, stagger: 0.04 }),
                  s.add(() => {}, "+=1");
                break;
              case "stagger":
                for (let m = 0; m < n.children.length; m++)
                  s.set(
                    [...n.children[m].children],
                    { opacity: 1, stagger: 0.04 },
                    m * 0.1
                  ),
                    s.addLabel(m + "first"),
                    m > 0 &&
                      s.set(
                        [...n.children[m - 1].children],
                        { opacity: 0, stagger: 0.04 },
                        m - 1 + "first"
                      );
                break;
              case "shuffle":
                for (let m = 0; m < n.children.length; m++)
                  s.set(
                    [...n.children[m].children],
                    { opacity: 1, stagger: 0.04 },
                    m * 0.1
                  ),
                    s.addLabel(m + "out"),
                    m > 0 &&
                      s.set(
                        mr([...n.children[m - 1].children]),
                        { opacity: 0, stagger: 0.08 },
                        m - 1 + "out"
                      );
                break;
              case "scramble":
                for (let m = 0; m < n.children.length; m++)
                  s.set([...n.children[m].children], {
                    opacity: 1,
                    stagger: 0.04,
                  }),
                    s.addLabel(m + "out"),
                    m > 0 &&
                      s.add(() => {
                        let x = "~!@#$%&*{}/?;;<>[]".split(""),
                          y = mr([...n.children[m - 1].children]);
                        for (let g = 0; g < y.length; g++)
                          setTimeout(() => {
                            y[g].innerText =
                              x[Math.floor(x.length * Math.random())];
                          }, 200 * g),
                            setTimeout(() => {
                              yt.set(y[g], { opacity: 0 });
                            }, 400 * g);
                      }, m - 1 + "out");
                s.set(mr(Array.from(c.chars)), { opacity: 0, stagger: 0.01 });
                break;
              case "fast":
                for (let m = 0; m < n.children.length; m++)
                  s.set(
                    [...n.children[m].children],
                    { opacity: 1, stagger: 0.02 },
                    "row" + m
                  ),
                    m > 0 &&
                      s.set(
                        [...n.children[m - 1].children],
                        { opacity: 0, stagger: 0.02 },
                        "row" + m
                      );
                break;
              case "slow":
                for (let m = 0; m < n.children.length; m++)
                  s.set(
                    [...n.children[m].children],
                    { opacity: 1, stagger: 0.1 },
                    "row" + m
                  ),
                    s.add(() => {}, "row" + m + "+=.5"),
                    m > 0 &&
                      s.set(
                        mr([...n.children[m - 1].children]),
                        { opacity: 0, stagger: 0.2 },
                        "row" + m
                      );
                s.add(() => {}, "+=1");
                break;
            }
          };
        o();
      }
    }
    destroy() {
      var n, e;
      for (let t of Object.keys(this.timelines))
        this.timelines[t] &&
          ((e = (n = this.timelines[t]).kill) == null || e.call(n));
    }
  };
  var cy = class extends St {
    constructor(n) {
      super(n);
      this.$items = Array.from(this.$("item"));
    }
    init() {
      (this.touchStartBind = () => {
        this.isTouch = !0;
      }),
        this.el.addEventListener("touchstart", this.touchStartBind, {
          once: !0,
        }),
        (this.enter = (n) => {
          if (this.isTouch) return;
          let e = n.target.querySelector("img");
          e &&
            (e.classList.contains("-loaded")
              ? rr(e)
              : Es(e, null, () => {
                  rr(e);
                }));
        });
      for (let n of this.$items)
        n.addEventListener("mouseenter", this.enter),
          n.addEventListener("focusin", this.enter);
    }
    destroy() {
      for (let n of this.$items)
        n.removeEventListener("mouseenter", this.enter),
          n.removeEventListener("focusin", this.enter);
    }
  };
  function ew(n) {
    return (
      n !== null &&
      typeof n == "object" &&
      "constructor" in n &&
      n.constructor === Object
    );
  }
  function uy(n = {}, e = {}) {
    Object.keys(e).forEach((t) => {
      typeof n[t] == "undefined"
        ? (n[t] = e[t])
        : ew(e[t]) &&
          ew(n[t]) &&
          Object.keys(e[t]).length > 0 &&
          uy(n[t], e[t]);
    });
  }
  var tw = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: { blur() {}, nodeName: "" },
    querySelector() {
      return null;
    },
    querySelectorAll() {
      return [];
    },
    getElementById() {
      return null;
    },
    createEvent() {
      return { initEvent() {} };
    },
    createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {},
        getElementsByTagName() {
          return [];
        },
      };
    },
    createElementNS() {
      return {};
    },
    importNode() {
      return null;
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: "",
    },
  };
  function Pi() {
    let n = typeof document != "undefined" ? document : {};
    return uy(n, tw), n;
  }
  var J5 = {
    document: tw,
    navigator: { userAgent: "" },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: "",
    },
    history: { replaceState() {}, pushState() {}, go() {}, back() {} },
    CustomEvent: function () {
      return this;
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
      return {
        getPropertyValue() {
          return "";
        },
      };
    },
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia() {
      return {};
    },
    requestAnimationFrame(n) {
      return typeof setTimeout == "undefined" ? (n(), null) : setTimeout(n, 0);
    },
    cancelAnimationFrame(n) {
      typeof setTimeout != "undefined" && clearTimeout(n);
    },
  };
  function ai() {
    let n = typeof window != "undefined" ? window : {};
    return uy(n, J5), n;
  }
  function Z5(n) {
    let e = n.__proto__;
    Object.defineProperty(n, "__proto__", {
      get() {
        return e;
      },
      set(t) {
        e.__proto__ = t;
      },
    });
  }
  var Xs = class extends Array {
    constructor(e) {
      if (typeof e == "number") super(e);
      else {
        super(...(e || []));
        Z5(this);
      }
    }
  };
  function Gu(n = []) {
    let e = [];
    return (
      n.forEach((t) => {
        Array.isArray(t) ? e.push(...Gu(t)) : e.push(t);
      }),
      e
    );
  }
  function iw(n, e) {
    return Array.prototype.filter.call(n, e);
  }
  function Q5(n) {
    let e = [];
    for (let t = 0; t < n.length; t += 1)
      e.indexOf(n[t]) === -1 && e.push(n[t]);
    return e;
  }
  function e4(n, e) {
    if (typeof n != "string") return [n];
    let t = [],
      i = e.querySelectorAll(n);
    for (let r = 0; r < i.length; r += 1) t.push(i[r]);
    return t;
  }
  function Vt(n, e) {
    let t = ai(),
      i = Pi(),
      r = [];
    if (!e && n instanceof Xs) return n;
    if (!n) return new Xs(r);
    if (typeof n == "string") {
      let s = n.trim();
      if (s.indexOf("<") >= 0 && s.indexOf(">") >= 0) {
        let a = "div";
        s.indexOf("<li") === 0 && (a = "ul"),
          s.indexOf("<tr") === 0 && (a = "tbody"),
          (s.indexOf("<td") === 0 || s.indexOf("<th") === 0) && (a = "tr"),
          s.indexOf("<tbody") === 0 && (a = "table"),
          s.indexOf("<option") === 0 && (a = "select");
        let o = i.createElement(a);
        o.innerHTML = s;
        for (let l = 0; l < o.childNodes.length; l += 1)
          r.push(o.childNodes[l]);
      } else r = e4(n.trim(), e || i);
    } else if (n.nodeType || n === t || n === i) r.push(n);
    else if (Array.isArray(n)) {
      if (n instanceof Xs) return n;
      r = n;
    }
    return new Xs(Q5(r));
  }
  Vt.fn = Xs.prototype;
  function nw(...n) {
    let e = Gu(n.map((t) => t.split(" ")));
    return (
      this.forEach((t) => {
        t.classList.add(...e);
      }),
      this
    );
  }
  function rw(...n) {
    let e = Gu(n.map((t) => t.split(" ")));
    return (
      this.forEach((t) => {
        t.classList.remove(...e);
      }),
      this
    );
  }
  function sw(...n) {
    let e = Gu(n.map((t) => t.split(" ")));
    this.forEach((t) => {
      e.forEach((i) => {
        t.classList.toggle(i);
      });
    });
  }
  function aw(...n) {
    let e = Gu(n.map((t) => t.split(" ")));
    return (
      iw(this, (t) => e.filter((i) => t.classList.contains(i)).length > 0)
        .length > 0
    );
  }
  function ow(n, e) {
    if (arguments.length === 1 && typeof n == "string")
      return this[0] ? this[0].getAttribute(n) : void 0;
    for (let t = 0; t < this.length; t += 1)
      if (arguments.length === 2) this[t].setAttribute(n, e);
      else for (let i in n) (this[t][i] = n[i]), this[t].setAttribute(i, n[i]);
    return this;
  }
  function lw(n) {
    for (let e = 0; e < this.length; e += 1) this[e].removeAttribute(n);
    return this;
  }
  function cw(n) {
    for (let e = 0; e < this.length; e += 1) this[e].style.transform = n;
    return this;
  }
  function uw(n) {
    for (let e = 0; e < this.length; e += 1)
      this[e].style.transitionDuration = typeof n != "string" ? `${n}ms` : n;
    return this;
  }
  function hw(...n) {
    let [e, t, i, r] = n;
    typeof n[1] == "function" && (([e, i, r] = n), (t = void 0)), r || (r = !1);
    function s(c) {
      let u = c.target;
      if (!u) return;
      let f = c.target.dom7EventData || [];
      if ((f.indexOf(c) < 0 && f.unshift(c), Vt(u).is(t))) i.apply(u, f);
      else {
        let d = Vt(u).parents();
        for (let m = 0; m < d.length; m += 1)
          Vt(d[m]).is(t) && i.apply(d[m], f);
      }
    }
    function a(c) {
      let u = c && c.target ? c.target.dom7EventData || [] : [];
      u.indexOf(c) < 0 && u.unshift(c), i.apply(this, u);
    }
    let o = e.split(" "),
      l;
    for (let c = 0; c < this.length; c += 1) {
      let u = this[c];
      if (t)
        for (l = 0; l < o.length; l += 1) {
          let f = o[l];
          u.dom7LiveListeners || (u.dom7LiveListeners = {}),
            u.dom7LiveListeners[f] || (u.dom7LiveListeners[f] = []),
            u.dom7LiveListeners[f].push({ listener: i, proxyListener: s }),
            u.addEventListener(f, s, r);
        }
      else
        for (l = 0; l < o.length; l += 1) {
          let f = o[l];
          u.dom7Listeners || (u.dom7Listeners = {}),
            u.dom7Listeners[f] || (u.dom7Listeners[f] = []),
            u.dom7Listeners[f].push({ listener: i, proxyListener: a }),
            u.addEventListener(f, a, r);
        }
    }
    return this;
  }
  function fw(...n) {
    let [e, t, i, r] = n;
    typeof n[1] == "function" && (([e, i, r] = n), (t = void 0)), r || (r = !1);
    let s = e.split(" ");
    for (let a = 0; a < s.length; a += 1) {
      let o = s[a];
      for (let l = 0; l < this.length; l += 1) {
        let c = this[l],
          u;
        if (
          (!t && c.dom7Listeners
            ? (u = c.dom7Listeners[o])
            : t && c.dom7LiveListeners && (u = c.dom7LiveListeners[o]),
          u && u.length)
        )
          for (let f = u.length - 1; f >= 0; f -= 1) {
            let d = u[f];
            (i && d.listener === i) ||
            (i &&
              d.listener &&
              d.listener.dom7proxy &&
              d.listener.dom7proxy === i)
              ? (c.removeEventListener(o, d.proxyListener, r), u.splice(f, 1))
              : i ||
                (c.removeEventListener(o, d.proxyListener, r), u.splice(f, 1));
          }
      }
    }
    return this;
  }
  function dw(...n) {
    let e = ai(),
      t = n[0].split(" "),
      i = n[1];
    for (let r = 0; r < t.length; r += 1) {
      let s = t[r];
      for (let a = 0; a < this.length; a += 1) {
        let o = this[a];
        if (e.CustomEvent) {
          let l = new e.CustomEvent(s, {
            detail: i,
            bubbles: !0,
            cancelable: !0,
          });
          (o.dom7EventData = n.filter((c, u) => u > 0)),
            o.dispatchEvent(l),
            (o.dom7EventData = []),
            delete o.dom7EventData;
        }
      }
    }
    return this;
  }
  function pw(n) {
    let e = this;
    function t(i) {
      i.target === this && (n.call(this, i), e.off("transitionend", t));
    }
    return n && e.on("transitionend", t), this;
  }
  function mw(n) {
    if (this.length > 0) {
      if (n) {
        let e = this.styles();
        return (
          this[0].offsetWidth +
          parseFloat(e.getPropertyValue("margin-right")) +
          parseFloat(e.getPropertyValue("margin-left"))
        );
      }
      return this[0].offsetWidth;
    }
    return null;
  }
  function gw(n) {
    if (this.length > 0) {
      if (n) {
        let e = this.styles();
        return (
          this[0].offsetHeight +
          parseFloat(e.getPropertyValue("margin-top")) +
          parseFloat(e.getPropertyValue("margin-bottom"))
        );
      }
      return this[0].offsetHeight;
    }
    return null;
  }
  function yw() {
    if (this.length > 0) {
      let n = ai(),
        e = Pi(),
        t = this[0],
        i = t.getBoundingClientRect(),
        r = e.body,
        s = t.clientTop || r.clientTop || 0,
        a = t.clientLeft || r.clientLeft || 0,
        o = t === n ? n.scrollY : t.scrollTop,
        l = t === n ? n.scrollX : t.scrollLeft;
      return { top: i.top + o - s, left: i.left + l - a };
    }
    return null;
  }
  function vw() {
    let n = ai();
    return this[0] ? n.getComputedStyle(this[0], null) : {};
  }
  function xw(n, e) {
    let t = ai(),
      i;
    if (arguments.length === 1)
      if (typeof n == "string") {
        if (this[0])
          return t.getComputedStyle(this[0], null).getPropertyValue(n);
      } else {
        for (i = 0; i < this.length; i += 1)
          for (let r in n) this[i].style[r] = n[r];
        return this;
      }
    if (arguments.length === 2 && typeof n == "string") {
      for (i = 0; i < this.length; i += 1) this[i].style[n] = e;
      return this;
    }
    return this;
  }
  function bw(n) {
    return n
      ? (this.forEach((e, t) => {
          n.apply(e, [e, t]);
        }),
        this)
      : this;
  }
  function _w(n) {
    let e = iw(this, n);
    return Vt(e);
  }
  function Ew(n) {
    if (typeof n == "undefined") return this[0] ? this[0].innerHTML : null;
    for (let e = 0; e < this.length; e += 1) this[e].innerHTML = n;
    return this;
  }
  function Tw(n) {
    if (typeof n == "undefined")
      return this[0] ? this[0].textContent.trim() : null;
    for (let e = 0; e < this.length; e += 1) this[e].textContent = n;
    return this;
  }
  function Sw(n) {
    let e = ai(),
      t = Pi(),
      i = this[0],
      r,
      s;
    if (!i || typeof n == "undefined") return !1;
    if (typeof n == "string") {
      if (i.matches) return i.matches(n);
      if (i.webkitMatchesSelector) return i.webkitMatchesSelector(n);
      if (i.msMatchesSelector) return i.msMatchesSelector(n);
      for (r = Vt(n), s = 0; s < r.length; s += 1) if (r[s] === i) return !0;
      return !1;
    }
    if (n === t) return i === t;
    if (n === e) return i === e;
    if (n.nodeType || n instanceof Xs) {
      for (r = n.nodeType ? [n] : n, s = 0; s < r.length; s += 1)
        if (r[s] === i) return !0;
      return !1;
    }
    return !1;
  }
  function ww() {
    let n = this[0],
      e;
    if (n) {
      for (e = 0; (n = n.previousSibling) !== null; )
        n.nodeType === 1 && (e += 1);
      return e;
    }
  }
  function Mw(n) {
    if (typeof n == "undefined") return this;
    let e = this.length;
    if (n > e - 1) return Vt([]);
    if (n < 0) {
      let t = e + n;
      return t < 0 ? Vt([]) : Vt([this[t]]);
    }
    return Vt([this[n]]);
  }
  function Aw(...n) {
    let e,
      t = Pi();
    for (let i = 0; i < n.length; i += 1) {
      e = n[i];
      for (let r = 0; r < this.length; r += 1)
        if (typeof e == "string") {
          let s = t.createElement("div");
          for (s.innerHTML = e; s.firstChild; )
            this[r].appendChild(s.firstChild);
        } else if (e instanceof Xs)
          for (let s = 0; s < e.length; s += 1) this[r].appendChild(e[s]);
        else this[r].appendChild(e);
    }
    return this;
  }
  function Cw(n) {
    let e = Pi(),
      t,
      i;
    for (t = 0; t < this.length; t += 1)
      if (typeof n == "string") {
        let r = e.createElement("div");
        for (r.innerHTML = n, i = r.childNodes.length - 1; i >= 0; i -= 1)
          this[t].insertBefore(r.childNodes[i], this[t].childNodes[0]);
      } else if (n instanceof Xs)
        for (i = 0; i < n.length; i += 1)
          this[t].insertBefore(n[i], this[t].childNodes[0]);
      else this[t].insertBefore(n, this[t].childNodes[0]);
    return this;
  }
  function Pw(n) {
    return this.length > 0
      ? n
        ? this[0].nextElementSibling && Vt(this[0].nextElementSibling).is(n)
          ? Vt([this[0].nextElementSibling])
          : Vt([])
        : this[0].nextElementSibling
        ? Vt([this[0].nextElementSibling])
        : Vt([])
      : Vt([]);
  }
  function Dw(n) {
    let e = [],
      t = this[0];
    if (!t) return Vt([]);
    for (; t.nextElementSibling; ) {
      let i = t.nextElementSibling;
      n ? Vt(i).is(n) && e.push(i) : e.push(i), (t = i);
    }
    return Vt(e);
  }
  function Iw(n) {
    if (this.length > 0) {
      let e = this[0];
      return n
        ? e.previousElementSibling && Vt(e.previousElementSibling).is(n)
          ? Vt([e.previousElementSibling])
          : Vt([])
        : e.previousElementSibling
        ? Vt([e.previousElementSibling])
        : Vt([]);
    }
    return Vt([]);
  }
  function Lw(n) {
    let e = [],
      t = this[0];
    if (!t) return Vt([]);
    for (; t.previousElementSibling; ) {
      let i = t.previousElementSibling;
      n ? Vt(i).is(n) && e.push(i) : e.push(i), (t = i);
    }
    return Vt(e);
  }
  function Rw(n) {
    let e = [];
    for (let t = 0; t < this.length; t += 1)
      this[t].parentNode !== null &&
        (n
          ? Vt(this[t].parentNode).is(n) && e.push(this[t].parentNode)
          : e.push(this[t].parentNode));
    return Vt(e);
  }
  function Ow(n) {
    let e = [];
    for (let t = 0; t < this.length; t += 1) {
      let i = this[t].parentNode;
      for (; i; ) n ? Vt(i).is(n) && e.push(i) : e.push(i), (i = i.parentNode);
    }
    return Vt(e);
  }
  function Nw(n) {
    let e = this;
    return typeof n == "undefined"
      ? Vt([])
      : (e.is(n) || (e = e.parents(n).eq(0)), e);
  }
  function kw(n) {
    let e = [];
    for (let t = 0; t < this.length; t += 1) {
      let i = this[t].querySelectorAll(n);
      for (let r = 0; r < i.length; r += 1) e.push(i[r]);
    }
    return Vt(e);
  }
  function Fw(n) {
    let e = [];
    for (let t = 0; t < this.length; t += 1) {
      let i = this[t].children;
      for (let r = 0; r < i.length; r += 1)
        (!n || Vt(i[r]).is(n)) && e.push(i[r]);
    }
    return Vt(e);
  }
  function Bw() {
    for (let n = 0; n < this.length; n += 1)
      this[n].parentNode && this[n].parentNode.removeChild(this[n]);
    return this;
  }
  var t4 = "resize scroll".split(" ");
  function Gi(n) {
    function e(...t) {
      if (typeof t[0] == "undefined") {
        for (let i = 0; i < this.length; i += 1)
          t4.indexOf(n) < 0 &&
            (n in this[i] ? this[i][n]() : Vt(this[i]).trigger(n));
        return this;
      }
      return this.on(n, ...t);
    }
    return e;
  }
  var SJ = Gi("click"),
    wJ = Gi("blur"),
    MJ = Gi("focus"),
    AJ = Gi("focusin"),
    CJ = Gi("focusout"),
    PJ = Gi("keyup"),
    DJ = Gi("keydown"),
    IJ = Gi("keypress"),
    LJ = Gi("submit"),
    RJ = Gi("change"),
    OJ = Gi("mousedown"),
    NJ = Gi("mousemove"),
    kJ = Gi("mouseup"),
    FJ = Gi("mouseenter"),
    BJ = Gi("mouseleave"),
    zJ = Gi("mouseout"),
    UJ = Gi("mouseover"),
    VJ = Gi("touchstart"),
    GJ = Gi("touchend"),
    HJ = Gi("touchmove"),
    $J = Gi("resize"),
    WJ = Gi("scroll");
  var zw = {
    addClass: nw,
    removeClass: rw,
    hasClass: aw,
    toggleClass: sw,
    attr: ow,
    removeAttr: lw,
    transform: cw,
    transition: uw,
    on: hw,
    off: fw,
    trigger: dw,
    transitionEnd: pw,
    outerWidth: mw,
    outerHeight: gw,
    styles: vw,
    offset: yw,
    css: xw,
    each: bw,
    html: Ew,
    text: Tw,
    is: Sw,
    index: ww,
    eq: Mw,
    append: Aw,
    prepend: Cw,
    next: Pw,
    nextAll: Dw,
    prev: Iw,
    prevAll: Lw,
    parent: Rw,
    parents: Ow,
    closest: Nw,
    find: kw,
    children: Fw,
    filter: _w,
    remove: Bw,
  };
  Object.keys(zw).forEach((n) => {
    Object.defineProperty(Vt.fn, n, { value: zw[n], writable: !0 });
  });
  var ft = Vt;
  function Uw(n) {
    let e = n;
    Object.keys(e).forEach((t) => {
      try {
        e[t] = null;
      } catch (i) {}
      try {
        delete e[t];
      } catch (i) {}
    });
  }
  function Ys(n, e = 0) {
    return setTimeout(n, e);
  }
  function ls() {
    return Date.now();
  }
  function i4(n) {
    let e = ai(),
      t;
    return (
      e.getComputedStyle && (t = e.getComputedStyle(n, null)),
      !t && n.currentStyle && (t = n.currentStyle),
      t || (t = n.style),
      t
    );
  }
  function hy(n, e = "x") {
    let t = ai(),
      i,
      r,
      s,
      a = i4(n, null);
    return (
      t.WebKitCSSMatrix
        ? ((r = a.transform || a.webkitTransform),
          r.split(",").length > 6 &&
            (r = r
              .split(", ")
              .map((o) => o.replace(",", "."))
              .join(", ")),
          (s = new t.WebKitCSSMatrix(r === "none" ? "" : r)))
        : ((s =
            a.MozTransform ||
            a.OTransform ||
            a.MsTransform ||
            a.msTransform ||
            a.transform ||
            a
              .getPropertyValue("transform")
              .replace("translate(", "matrix(1, 0, 0, 1,")),
          (i = s.toString().split(","))),
      e === "x" &&
        (t.WebKitCSSMatrix
          ? (r = s.m41)
          : i.length === 16
          ? (r = parseFloat(i[12]))
          : (r = parseFloat(i[4]))),
      e === "y" &&
        (t.WebKitCSSMatrix
          ? (r = s.m42)
          : i.length === 16
          ? (r = parseFloat(i[13]))
          : (r = parseFloat(i[5]))),
      r || 0
    );
  }
  function Hu(n) {
    return (
      typeof n == "object" &&
      n !== null &&
      n.constructor &&
      Object.prototype.toString.call(n).slice(8, -1) === "Object"
    );
  }
  function n4(n) {
    return typeof window != "undefined" &&
      typeof window.HTMLElement != "undefined"
      ? n instanceof HTMLElement
      : n && (n.nodeType === 1 || n.nodeType === 11);
  }
  function Cn(...n) {
    let e = Object(n[0]),
      t = ["__proto__", "constructor", "prototype"];
    for (let i = 1; i < n.length; i += 1) {
      let r = n[i];
      if (r != null && !n4(r)) {
        let s = Object.keys(Object(r)).filter((a) => t.indexOf(a) < 0);
        for (let a = 0, o = s.length; a < o; a += 1) {
          let l = s[a],
            c = Object.getOwnPropertyDescriptor(r, l);
          c !== void 0 &&
            c.enumerable &&
            (Hu(e[l]) && Hu(r[l])
              ? r[l].__swiper__
                ? (e[l] = r[l])
                : Cn(e[l], r[l])
              : !Hu(e[l]) && Hu(r[l])
              ? ((e[l] = {}), r[l].__swiper__ ? (e[l] = r[l]) : Cn(e[l], r[l]))
              : (e[l] = r[l]));
        }
      }
    }
    return e;
  }
  function sc(n, e, t) {
    n.style.setProperty(e, t);
  }
  function Dd({ swiper: n, targetPosition: e, side: t }) {
    let i = ai(),
      r = -n.translate,
      s = null,
      a,
      o = n.params.speed;
    (n.wrapperEl.style.scrollSnapType = "none"),
      i.cancelAnimationFrame(n.cssModeFrameID);
    let l = e > r ? "next" : "prev",
      c = (f, d) => (l === "next" && f >= d) || (l === "prev" && f <= d),
      u = () => {
        (a = new Date().getTime()), s === null && (s = a);
        let f = Math.max(Math.min((a - s) / o, 1), 0),
          d = 0.5 - Math.cos(f * Math.PI) / 2,
          m = r + d * (e - r);
        if ((c(m, e) && (m = e), n.wrapperEl.scrollTo({ [t]: m }), c(m, e))) {
          (n.wrapperEl.style.overflow = "hidden"),
            (n.wrapperEl.style.scrollSnapType = ""),
            setTimeout(() => {
              (n.wrapperEl.style.overflow = ""),
                n.wrapperEl.scrollTo({ [t]: m });
            }),
            i.cancelAnimationFrame(n.cssModeFrameID);
          return;
        }
        n.cssModeFrameID = i.requestAnimationFrame(u);
      };
    u();
  }
  var fy;
  function r4() {
    let n = ai(),
      e = Pi();
    return {
      smoothScroll:
        e.documentElement && "scrollBehavior" in e.documentElement.style,
      touch: !!(
        "ontouchstart" in n ||
        (n.DocumentTouch && e instanceof n.DocumentTouch)
      ),
      passiveListener: (function () {
        let i = !1;
        try {
          let r = Object.defineProperty({}, "passive", {
            get() {
              i = !0;
            },
          });
          n.addEventListener("testPassiveListener", null, r);
        } catch (r) {}
        return i;
      })(),
      gestures: (function () {
        return "ongesturestart" in n;
      })(),
    };
  }
  function Id() {
    return fy || (fy = r4()), fy;
  }
  var dy;
  function s4({ userAgent: n } = {}) {
    let e = Id(),
      t = ai(),
      i = t.navigator.platform,
      r = n || t.navigator.userAgent,
      s = { ios: !1, android: !1 },
      a = t.screen.width,
      o = t.screen.height,
      l = r.match(/(Android);?[\s\/]+([\d.]+)?/),
      c = r.match(/(iPad).*OS\s([\d_]+)/),
      u = r.match(/(iPod)(.*OS\s([\d_]+))?/),
      f = !c && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
      d = i === "Win32",
      m = i === "MacIntel",
      x = [
        "1024x1366",
        "1366x1024",
        "834x1194",
        "1194x834",
        "834x1112",
        "1112x834",
        "768x1024",
        "1024x768",
        "820x1180",
        "1180x820",
        "810x1080",
        "1080x810",
      ];
    return (
      !c &&
        m &&
        e.touch &&
        x.indexOf(`${a}x${o}`) >= 0 &&
        ((c = r.match(/(Version)\/([\d.]+)/)),
        c || (c = [0, 1, "13_0_0"]),
        (m = !1)),
      l && !d && ((s.os = "android"), (s.android = !0)),
      (c || f || u) && ((s.os = "ios"), (s.ios = !0)),
      s
    );
  }
  function Vw(n = {}) {
    return dy || (dy = s4(n)), dy;
  }
  var py;
  function a4() {
    let n = ai();
    function e() {
      let t = n.navigator.userAgent.toLowerCase();
      return (
        t.indexOf("safari") >= 0 &&
        t.indexOf("chrome") < 0 &&
        t.indexOf("android") < 0
      );
    }
    return {
      isSafari: e(),
      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
        n.navigator.userAgent
      ),
    };
  }
  function Gw() {
    return py || (py = a4()), py;
  }
  function my({ swiper: n, on: e, emit: t }) {
    let i = ai(),
      r = null,
      s = null,
      a = () => {
        !n || n.destroyed || !n.initialized || (t("beforeResize"), t("resize"));
      },
      o = () => {
        !n ||
          n.destroyed ||
          !n.initialized ||
          ((r = new ResizeObserver((u) => {
            s = i.requestAnimationFrame(() => {
              let { width: f, height: d } = n,
                m = f,
                x = d;
              u.forEach(({ contentBoxSize: y, contentRect: g, target: b }) => {
                (b && b !== n.el) ||
                  ((m = g ? g.width : (y[0] || y).inlineSize),
                  (x = g ? g.height : (y[0] || y).blockSize));
              }),
                (m !== f || x !== d) && a();
            });
          })),
          r.observe(n.el));
      },
      l = () => {
        s && i.cancelAnimationFrame(s),
          r && r.unobserve && n.el && (r.unobserve(n.el), (r = null));
      },
      c = () => {
        !n || n.destroyed || !n.initialized || t("orientationchange");
      };
    e("init", () => {
      if (n.params.resizeObserver && typeof i.ResizeObserver != "undefined") {
        o();
        return;
      }
      i.addEventListener("resize", a),
        i.addEventListener("orientationchange", c);
    }),
      e("destroy", () => {
        l(),
          i.removeEventListener("resize", a),
          i.removeEventListener("orientationchange", c);
      });
  }
  function gy({ swiper: n, extendParams: e, on: t, emit: i }) {
    let r = [],
      s = ai(),
      a = (c, u = {}) => {
        let f = s.MutationObserver || s.WebkitMutationObserver,
          d = new f((m) => {
            if (m.length === 1) {
              i("observerUpdate", m[0]);
              return;
            }
            let x = function () {
              i("observerUpdate", m[0]);
            };
            s.requestAnimationFrame
              ? s.requestAnimationFrame(x)
              : s.setTimeout(x, 0);
          });
        d.observe(c, {
          attributes: typeof u.attributes == "undefined" ? !0 : u.attributes,
          childList: typeof u.childList == "undefined" ? !0 : u.childList,
          characterData:
            typeof u.characterData == "undefined" ? !0 : u.characterData,
        }),
          r.push(d);
      },
      o = () => {
        if (!!n.params.observer) {
          if (n.params.observeParents) {
            let c = n.$el.parents();
            for (let u = 0; u < c.length; u += 1) a(c[u]);
          }
          a(n.$el[0], { childList: n.params.observeSlideChildren }),
            a(n.$wrapperEl[0], { attributes: !1 });
        }
      },
      l = () => {
        r.forEach((c) => {
          c.disconnect();
        }),
          r.splice(0, r.length);
      };
    e({ observer: !1, observeParents: !1, observeSlideChildren: !1 }),
      t("init", o),
      t("destroy", l);
  }
  var Hw = {
    on(n, e, t) {
      let i = this;
      if (!i.eventsListeners || i.destroyed || typeof e != "function") return i;
      let r = t ? "unshift" : "push";
      return (
        n.split(" ").forEach((s) => {
          i.eventsListeners[s] || (i.eventsListeners[s] = []),
            i.eventsListeners[s][r](e);
        }),
        i
      );
    },
    once(n, e, t) {
      let i = this;
      if (!i.eventsListeners || i.destroyed || typeof e != "function") return i;
      function r(...s) {
        i.off(n, r), r.__emitterProxy && delete r.__emitterProxy, e.apply(i, s);
      }
      return (r.__emitterProxy = e), i.on(n, r, t);
    },
    onAny(n, e) {
      let t = this;
      if (!t.eventsListeners || t.destroyed || typeof n != "function") return t;
      let i = e ? "unshift" : "push";
      return (
        t.eventsAnyListeners.indexOf(n) < 0 && t.eventsAnyListeners[i](n), t
      );
    },
    offAny(n) {
      let e = this;
      if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e;
      let t = e.eventsAnyListeners.indexOf(n);
      return t >= 0 && e.eventsAnyListeners.splice(t, 1), e;
    },
    off(n, e) {
      let t = this;
      return (
        !t.eventsListeners ||
          t.destroyed ||
          !t.eventsListeners ||
          n.split(" ").forEach((i) => {
            typeof e == "undefined"
              ? (t.eventsListeners[i] = [])
              : t.eventsListeners[i] &&
                t.eventsListeners[i].forEach((r, s) => {
                  (r === e || (r.__emitterProxy && r.__emitterProxy === e)) &&
                    t.eventsListeners[i].splice(s, 1);
                });
          }),
        t
      );
    },
    emit(...n) {
      let e = this;
      if (!e.eventsListeners || e.destroyed || !e.eventsListeners) return e;
      let t, i, r;
      return (
        typeof n[0] == "string" || Array.isArray(n[0])
          ? ((t = n[0]), (i = n.slice(1, n.length)), (r = e))
          : ((t = n[0].events), (i = n[0].data), (r = n[0].context || e)),
        i.unshift(r),
        (Array.isArray(t) ? t : t.split(" ")).forEach((a) => {
          e.eventsAnyListeners &&
            e.eventsAnyListeners.length &&
            e.eventsAnyListeners.forEach((o) => {
              o.apply(r, [a, ...i]);
            }),
            e.eventsListeners &&
              e.eventsListeners[a] &&
              e.eventsListeners[a].forEach((o) => {
                o.apply(r, i);
              });
        }),
        e
      );
    },
  };
  function yy() {
    let n = this,
      e,
      t,
      i = n.$el;
    typeof n.params.width != "undefined" && n.params.width !== null
      ? (e = n.params.width)
      : (e = i[0].clientWidth),
      typeof n.params.height != "undefined" && n.params.height !== null
        ? (t = n.params.height)
        : (t = i[0].clientHeight),
      !((e === 0 && n.isHorizontal()) || (t === 0 && n.isVertical())) &&
        ((e =
          e -
          parseInt(i.css("padding-left") || 0, 10) -
          parseInt(i.css("padding-right") || 0, 10)),
        (t =
          t -
          parseInt(i.css("padding-top") || 0, 10) -
          parseInt(i.css("padding-bottom") || 0, 10)),
        Number.isNaN(e) && (e = 0),
        Number.isNaN(t) && (t = 0),
        Object.assign(n, {
          width: e,
          height: t,
          size: n.isHorizontal() ? e : t,
        }));
  }
  function vy() {
    let n = this;
    function e(O) {
      return n.isHorizontal()
        ? O
        : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom",
          }[O];
    }
    function t(O, U) {
      return parseFloat(O.getPropertyValue(e(U)) || 0);
    }
    let i = n.params,
      { $wrapperEl: r, size: s, rtlTranslate: a, wrongRTL: o } = n,
      l = n.virtual && i.virtual.enabled,
      c = l ? n.virtual.slides.length : n.slides.length,
      u = r.children(`.${n.params.slideClass}`),
      f = l ? n.virtual.slides.length : u.length,
      d = [],
      m = [],
      x = [],
      y = i.slidesOffsetBefore;
    typeof y == "function" && (y = i.slidesOffsetBefore.call(n));
    let g = i.slidesOffsetAfter;
    typeof g == "function" && (g = i.slidesOffsetAfter.call(n));
    let b = n.snapGrid.length,
      _ = n.slidesGrid.length,
      E = i.spaceBetween,
      w = -y,
      P = 0,
      L = 0;
    if (typeof s == "undefined") return;
    typeof E == "string" &&
      E.indexOf("%") >= 0 &&
      (E = (parseFloat(E.replace("%", "")) / 100) * s),
      (n.virtualSize = -E),
      a
        ? u.css({ marginLeft: "", marginBottom: "", marginTop: "" })
        : u.css({ marginRight: "", marginBottom: "", marginTop: "" }),
      i.centeredSlides &&
        i.cssMode &&
        (sc(n.wrapperEl, "--swiper-centered-offset-before", ""),
        sc(n.wrapperEl, "--swiper-centered-offset-after", ""));
    let I = i.grid && i.grid.rows > 1 && n.grid;
    I && n.grid.initSlides(f);
    let M,
      R =
        i.slidesPerView === "auto" &&
        i.breakpoints &&
        Object.keys(i.breakpoints).filter(
          (O) => typeof i.breakpoints[O].slidesPerView != "undefined"
        ).length > 0;
    for (let O = 0; O < f; O += 1) {
      M = 0;
      let U = u.eq(O);
      if ((I && n.grid.updateSlide(O, U, f, e), U.css("display") !== "none")) {
        if (i.slidesPerView === "auto") {
          R && (u[O].style[e("width")] = "");
          let X = getComputedStyle(U[0]),
            $ = U[0].style.transform,
            W = U[0].style.webkitTransform;
          if (
            ($ && (U[0].style.transform = "none"),
            W && (U[0].style.webkitTransform = "none"),
            i.roundLengths)
          )
            M = n.isHorizontal() ? U.outerWidth(!0) : U.outerHeight(!0);
          else {
            let ue = t(X, "width"),
              ae = t(X, "padding-left"),
              he = t(X, "padding-right"),
              ce = t(X, "margin-left"),
              te = t(X, "margin-right"),
              Me = X.getPropertyValue("box-sizing");
            if (Me && Me === "border-box") M = ue + ce + te;
            else {
              let { clientWidth: ge, offsetWidth: pe } = U[0];
              M = ue + ae + he + ce + te + (pe - ge);
            }
          }
          $ && (U[0].style.transform = $),
            W && (U[0].style.webkitTransform = W),
            i.roundLengths && (M = Math.floor(M));
        } else
          (M = (s - (i.slidesPerView - 1) * E) / i.slidesPerView),
            i.roundLengths && (M = Math.floor(M)),
            u[O] && (u[O].style[e("width")] = `${M}px`);
        u[O] && (u[O].swiperSlideSize = M),
          x.push(M),
          i.centeredSlides
            ? ((w = w + M / 2 + P / 2 + E),
              P === 0 && O !== 0 && (w = w - s / 2 - E),
              O === 0 && (w = w - s / 2 - E),
              Math.abs(w) < 1 / 1e3 && (w = 0),
              i.roundLengths && (w = Math.floor(w)),
              L % i.slidesPerGroup === 0 && d.push(w),
              m.push(w))
            : (i.roundLengths && (w = Math.floor(w)),
              (L - Math.min(n.params.slidesPerGroupSkip, L)) %
                n.params.slidesPerGroup ===
                0 && d.push(w),
              m.push(w),
              (w = w + M + E)),
          (n.virtualSize += M + E),
          (P = M),
          (L += 1);
      }
    }
    if (
      ((n.virtualSize = Math.max(n.virtualSize, s) + g),
      a &&
        o &&
        (i.effect === "slide" || i.effect === "coverflow") &&
        r.css({ width: `${n.virtualSize + i.spaceBetween}px` }),
      i.setWrapperSize &&
        r.css({ [e("width")]: `${n.virtualSize + i.spaceBetween}px` }),
      I && n.grid.updateWrapperSize(M, d, e),
      !i.centeredSlides)
    ) {
      let O = [];
      for (let U = 0; U < d.length; U += 1) {
        let X = d[U];
        i.roundLengths && (X = Math.floor(X)),
          d[U] <= n.virtualSize - s && O.push(X);
      }
      (d = O),
        Math.floor(n.virtualSize - s) - Math.floor(d[d.length - 1]) > 1 &&
          d.push(n.virtualSize - s);
    }
    if ((d.length === 0 && (d = [0]), i.spaceBetween !== 0)) {
      let O = n.isHorizontal() && a ? "marginLeft" : e("marginRight");
      u.filter((U, X) => (i.cssMode ? X !== u.length - 1 : !0)).css({
        [O]: `${E}px`,
      });
    }
    if (i.centeredSlides && i.centeredSlidesBounds) {
      let O = 0;
      x.forEach((X) => {
        O += X + (i.spaceBetween ? i.spaceBetween : 0);
      }),
        (O -= i.spaceBetween);
      let U = O - s;
      d = d.map((X) => (X < 0 ? -y : X > U ? U + g : X));
    }
    if (i.centerInsufficientSlides) {
      let O = 0;
      if (
        (x.forEach((U) => {
          O += U + (i.spaceBetween ? i.spaceBetween : 0);
        }),
        (O -= i.spaceBetween),
        O < s)
      ) {
        let U = (s - O) / 2;
        d.forEach((X, $) => {
          d[$] = X - U;
        }),
          m.forEach((X, $) => {
            m[$] = X + U;
          });
      }
    }
    if (
      (Object.assign(n, {
        slides: u,
        snapGrid: d,
        slidesGrid: m,
        slidesSizesGrid: x,
      }),
      i.centeredSlides && i.cssMode && !i.centeredSlidesBounds)
    ) {
      sc(n.wrapperEl, "--swiper-centered-offset-before", `${-d[0]}px`),
        sc(
          n.wrapperEl,
          "--swiper-centered-offset-after",
          `${n.size / 2 - x[x.length - 1] / 2}px`
        );
      let O = -n.snapGrid[0],
        U = -n.slidesGrid[0];
      (n.snapGrid = n.snapGrid.map((X) => X + O)),
        (n.slidesGrid = n.slidesGrid.map((X) => X + U));
    }
    if (
      (f !== c && n.emit("slidesLengthChange"),
      d.length !== b &&
        (n.params.watchOverflow && n.checkOverflow(),
        n.emit("snapGridLengthChange")),
      m.length !== _ && n.emit("slidesGridLengthChange"),
      i.watchSlidesProgress && n.updateSlidesOffset(),
      !l && !i.cssMode && (i.effect === "slide" || i.effect === "fade"))
    ) {
      let O = `${i.containerModifierClass}backface-hidden`,
        U = n.$el.hasClass(O);
      f <= i.maxBackfaceHiddenSlides
        ? U || n.$el.addClass(O)
        : U && n.$el.removeClass(O);
    }
  }
  function xy(n) {
    let e = this,
      t = [],
      i = e.virtual && e.params.virtual.enabled,
      r = 0,
      s;
    typeof n == "number"
      ? e.setTransition(n)
      : n === !0 && e.setTransition(e.params.speed);
    let a = (o) =>
      i
        ? e.slides.filter(
            (l) => parseInt(l.getAttribute("data-swiper-slide-index"), 10) === o
          )[0]
        : e.slides.eq(o)[0];
    if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1)
      if (e.params.centeredSlides)
        (e.visibleSlides || ft([])).each((o) => {
          t.push(o);
        });
      else
        for (s = 0; s < Math.ceil(e.params.slidesPerView); s += 1) {
          let o = e.activeIndex + s;
          if (o > e.slides.length && !i) break;
          t.push(a(o));
        }
    else t.push(a(e.activeIndex));
    for (s = 0; s < t.length; s += 1)
      if (typeof t[s] != "undefined") {
        let o = t[s].offsetHeight;
        r = o > r ? o : r;
      }
    (r || r === 0) && e.$wrapperEl.css("height", `${r}px`);
  }
  function by() {
    let n = this,
      e = n.slides;
    for (let t = 0; t < e.length; t += 1)
      e[t].swiperSlideOffset = n.isHorizontal()
        ? e[t].offsetLeft
        : e[t].offsetTop;
  }
  function _y(n = (this && this.translate) || 0) {
    let e = this,
      t = e.params,
      { slides: i, rtlTranslate: r, snapGrid: s } = e;
    if (i.length === 0) return;
    typeof i[0].swiperSlideOffset == "undefined" && e.updateSlidesOffset();
    let a = -n;
    r && (a = n),
      i.removeClass(t.slideVisibleClass),
      (e.visibleSlidesIndexes = []),
      (e.visibleSlides = []);
    for (let o = 0; o < i.length; o += 1) {
      let l = i[o],
        c = l.swiperSlideOffset;
      t.cssMode && t.centeredSlides && (c -= i[0].swiperSlideOffset);
      let u =
          (a + (t.centeredSlides ? e.minTranslate() : 0) - c) /
          (l.swiperSlideSize + t.spaceBetween),
        f =
          (a - s[0] + (t.centeredSlides ? e.minTranslate() : 0) - c) /
          (l.swiperSlideSize + t.spaceBetween),
        d = -(a - c),
        m = d + e.slidesSizesGrid[o];
      ((d >= 0 && d < e.size - 1) ||
        (m > 1 && m <= e.size) ||
        (d <= 0 && m >= e.size)) &&
        (e.visibleSlides.push(l),
        e.visibleSlidesIndexes.push(o),
        i.eq(o).addClass(t.slideVisibleClass)),
        (l.progress = r ? -u : u),
        (l.originalProgress = r ? -f : f);
    }
    e.visibleSlides = ft(e.visibleSlides);
  }
  function Ey(n) {
    let e = this;
    if (typeof n == "undefined") {
      let c = e.rtlTranslate ? -1 : 1;
      n = (e && e.translate && e.translate * c) || 0;
    }
    let t = e.params,
      i = e.maxTranslate() - e.minTranslate(),
      { progress: r, isBeginning: s, isEnd: a } = e,
      o = s,
      l = a;
    i === 0
      ? ((r = 0), (s = !0), (a = !0))
      : ((r = (n - e.minTranslate()) / i), (s = r <= 0), (a = r >= 1)),
      Object.assign(e, { progress: r, isBeginning: s, isEnd: a }),
      (t.watchSlidesProgress || (t.centeredSlides && t.autoHeight)) &&
        e.updateSlidesProgress(n),
      s && !o && e.emit("reachBeginning toEdge"),
      a && !l && e.emit("reachEnd toEdge"),
      ((o && !s) || (l && !a)) && e.emit("fromEdge"),
      e.emit("progress", r);
  }
  function Ty() {
    let n = this,
      { slides: e, params: t, $wrapperEl: i, activeIndex: r, realIndex: s } = n,
      a = n.virtual && t.virtual.enabled;
    e.removeClass(
      `${t.slideActiveClass} ${t.slideNextClass} ${t.slidePrevClass} ${t.slideDuplicateActiveClass} ${t.slideDuplicateNextClass} ${t.slideDuplicatePrevClass}`
    );
    let o;
    a
      ? (o = n.$wrapperEl.find(
          `.${t.slideClass}[data-swiper-slide-index="${r}"]`
        ))
      : (o = e.eq(r)),
      o.addClass(t.slideActiveClass),
      t.loop &&
        (o.hasClass(t.slideDuplicateClass)
          ? i
              .children(
                `.${t.slideClass}:not(.${t.slideDuplicateClass})[data-swiper-slide-index="${s}"]`
              )
              .addClass(t.slideDuplicateActiveClass)
          : i
              .children(
                `.${t.slideClass}.${t.slideDuplicateClass}[data-swiper-slide-index="${s}"]`
              )
              .addClass(t.slideDuplicateActiveClass));
    let l = o.nextAll(`.${t.slideClass}`).eq(0).addClass(t.slideNextClass);
    t.loop && l.length === 0 && ((l = e.eq(0)), l.addClass(t.slideNextClass));
    let c = o.prevAll(`.${t.slideClass}`).eq(0).addClass(t.slidePrevClass);
    t.loop && c.length === 0 && ((c = e.eq(-1)), c.addClass(t.slidePrevClass)),
      t.loop &&
        (l.hasClass(t.slideDuplicateClass)
          ? i
              .children(
                `.${t.slideClass}:not(.${
                  t.slideDuplicateClass
                })[data-swiper-slide-index="${l.attr(
                  "data-swiper-slide-index"
                )}"]`
              )
              .addClass(t.slideDuplicateNextClass)
          : i
              .children(
                `.${t.slideClass}.${
                  t.slideDuplicateClass
                }[data-swiper-slide-index="${l.attr(
                  "data-swiper-slide-index"
                )}"]`
              )
              .addClass(t.slideDuplicateNextClass),
        c.hasClass(t.slideDuplicateClass)
          ? i
              .children(
                `.${t.slideClass}:not(.${
                  t.slideDuplicateClass
                })[data-swiper-slide-index="${c.attr(
                  "data-swiper-slide-index"
                )}"]`
              )
              .addClass(t.slideDuplicatePrevClass)
          : i
              .children(
                `.${t.slideClass}.${
                  t.slideDuplicateClass
                }[data-swiper-slide-index="${c.attr(
                  "data-swiper-slide-index"
                )}"]`
              )
              .addClass(t.slideDuplicatePrevClass)),
      n.emitSlidesClasses();
  }
  function Sy(n) {
    let e = this,
      t = e.rtlTranslate ? e.translate : -e.translate,
      {
        slidesGrid: i,
        snapGrid: r,
        params: s,
        activeIndex: a,
        realIndex: o,
        snapIndex: l,
      } = e,
      c = n,
      u;
    if (typeof c == "undefined") {
      for (let d = 0; d < i.length; d += 1)
        typeof i[d + 1] != "undefined"
          ? t >= i[d] && t < i[d + 1] - (i[d + 1] - i[d]) / 2
            ? (c = d)
            : t >= i[d] && t < i[d + 1] && (c = d + 1)
          : t >= i[d] && (c = d);
      s.normalizeSlideIndex && (c < 0 || typeof c == "undefined") && (c = 0);
    }
    if (r.indexOf(t) >= 0) u = r.indexOf(t);
    else {
      let d = Math.min(s.slidesPerGroupSkip, c);
      u = d + Math.floor((c - d) / s.slidesPerGroup);
    }
    if ((u >= r.length && (u = r.length - 1), c === a)) {
      u !== l && ((e.snapIndex = u), e.emit("snapIndexChange"));
      return;
    }
    let f = parseInt(e.slides.eq(c).attr("data-swiper-slide-index") || c, 10);
    Object.assign(e, {
      snapIndex: u,
      realIndex: f,
      previousIndex: a,
      activeIndex: c,
    }),
      e.emit("activeIndexChange"),
      e.emit("snapIndexChange"),
      o !== f && e.emit("realIndexChange"),
      (e.initialized || e.params.runCallbacksOnInit) && e.emit("slideChange");
  }
  function wy(n) {
    let e = this,
      t = e.params,
      i = ft(n).closest(`.${t.slideClass}`)[0],
      r = !1,
      s;
    if (i) {
      for (let a = 0; a < e.slides.length; a += 1)
        if (e.slides[a] === i) {
          (r = !0), (s = a);
          break;
        }
    }
    if (i && r)
      (e.clickedSlide = i),
        e.virtual && e.params.virtual.enabled
          ? (e.clickedIndex = parseInt(
              ft(i).attr("data-swiper-slide-index"),
              10
            ))
          : (e.clickedIndex = s);
    else {
      (e.clickedSlide = void 0), (e.clickedIndex = void 0);
      return;
    }
    t.slideToClickedSlide &&
      e.clickedIndex !== void 0 &&
      e.clickedIndex !== e.activeIndex &&
      e.slideToClickedSlide();
  }
  var $w = {
    updateSize: yy,
    updateSlides: vy,
    updateAutoHeight: xy,
    updateSlidesOffset: by,
    updateSlidesProgress: _y,
    updateProgress: Ey,
    updateSlidesClasses: Ty,
    updateActiveIndex: Sy,
    updateClickedSlide: wy,
  };
  function My(n = this.isHorizontal() ? "x" : "y") {
    let e = this,
      { params: t, rtlTranslate: i, translate: r, $wrapperEl: s } = e;
    if (t.virtualTranslate) return i ? -r : r;
    if (t.cssMode) return r;
    let a = hy(s[0], n);
    return i && (a = -a), a || 0;
  }
  function Ay(n, e) {
    let t = this,
      {
        rtlTranslate: i,
        params: r,
        $wrapperEl: s,
        wrapperEl: a,
        progress: o,
      } = t,
      l = 0,
      c = 0,
      u = 0;
    t.isHorizontal() ? (l = i ? -n : n) : (c = n),
      r.roundLengths && ((l = Math.floor(l)), (c = Math.floor(c))),
      r.cssMode
        ? (a[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal()
            ? -l
            : -c)
        : r.virtualTranslate ||
          s.transform(`translate3d(${l}px, ${c}px, ${u}px)`),
      (t.previousTranslate = t.translate),
      (t.translate = t.isHorizontal() ? l : c);
    let f,
      d = t.maxTranslate() - t.minTranslate();
    d === 0 ? (f = 0) : (f = (n - t.minTranslate()) / d),
      f !== o && t.updateProgress(n),
      t.emit("setTranslate", t.translate, e);
  }
  function Cy() {
    return -this.snapGrid[0];
  }
  function Py() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }
  function Dy(n = 0, e = this.params.speed, t = !0, i = !0, r) {
    let s = this,
      { params: a, wrapperEl: o } = s;
    if (s.animating && a.preventInteractionOnTransition) return !1;
    let l = s.minTranslate(),
      c = s.maxTranslate(),
      u;
    if (
      (i && n > l ? (u = l) : i && n < c ? (u = c) : (u = n),
      s.updateProgress(u),
      a.cssMode)
    ) {
      let f = s.isHorizontal();
      if (e === 0) o[f ? "scrollLeft" : "scrollTop"] = -u;
      else {
        if (!s.support.smoothScroll)
          return (
            Dd({ swiper: s, targetPosition: -u, side: f ? "left" : "top" }), !0
          );
        o.scrollTo({ [f ? "left" : "top"]: -u, behavior: "smooth" });
      }
      return !0;
    }
    return (
      e === 0
        ? (s.setTransition(0),
          s.setTranslate(u),
          t && (s.emit("beforeTransitionStart", e, r), s.emit("transitionEnd")))
        : (s.setTransition(e),
          s.setTranslate(u),
          t &&
            (s.emit("beforeTransitionStart", e, r), s.emit("transitionStart")),
          s.animating ||
            ((s.animating = !0),
            s.onTranslateToWrapperTransitionEnd ||
              (s.onTranslateToWrapperTransitionEnd = function (d) {
                !s ||
                  s.destroyed ||
                  (d.target === this &&
                    (s.$wrapperEl[0].removeEventListener(
                      "transitionend",
                      s.onTranslateToWrapperTransitionEnd
                    ),
                    s.$wrapperEl[0].removeEventListener(
                      "webkitTransitionEnd",
                      s.onTranslateToWrapperTransitionEnd
                    ),
                    (s.onTranslateToWrapperTransitionEnd = null),
                    delete s.onTranslateToWrapperTransitionEnd,
                    t && s.emit("transitionEnd")));
              }),
            s.$wrapperEl[0].addEventListener(
              "transitionend",
              s.onTranslateToWrapperTransitionEnd
            ),
            s.$wrapperEl[0].addEventListener(
              "webkitTransitionEnd",
              s.onTranslateToWrapperTransitionEnd
            ))),
      !0
    );
  }
  var Ww = {
    getTranslate: My,
    setTranslate: Ay,
    minTranslate: Cy,
    maxTranslate: Py,
    translateTo: Dy,
  };
  function Iy(n, e) {
    let t = this;
    t.params.cssMode || t.$wrapperEl.transition(n),
      t.emit("setTransition", n, e);
  }
  function $u({ swiper: n, runCallbacks: e, direction: t, step: i }) {
    let { activeIndex: r, previousIndex: s } = n,
      a = t;
    if (
      (a || (r > s ? (a = "next") : r < s ? (a = "prev") : (a = "reset")),
      n.emit(`transition${i}`),
      e && r !== s)
    ) {
      if (a === "reset") {
        n.emit(`slideResetTransition${i}`);
        return;
      }
      n.emit(`slideChangeTransition${i}`),
        a === "next"
          ? n.emit(`slideNextTransition${i}`)
          : n.emit(`slidePrevTransition${i}`);
    }
  }
  function Ly(n = !0, e) {
    let t = this,
      { params: i } = t;
    i.cssMode ||
      (i.autoHeight && t.updateAutoHeight(),
      $u({ swiper: t, runCallbacks: n, direction: e, step: "Start" }));
  }
  function Ry(n = !0, e) {
    let t = this,
      { params: i } = t;
    (t.animating = !1),
      !i.cssMode &&
        (t.setTransition(0),
        $u({ swiper: t, runCallbacks: n, direction: e, step: "End" }));
  }
  var qw = { setTransition: Iy, transitionStart: Ly, transitionEnd: Ry };
  function Oy(n = 0, e = this.params.speed, t = !0, i, r) {
    if (typeof n != "number" && typeof n != "string")
      throw new Error(
        `The 'index' argument cannot have type other than 'number' or 'string'. [${typeof n}] given.`
      );
    if (typeof n == "string") {
      let E = parseInt(n, 10);
      if (!isFinite(E))
        throw new Error(
          `The passed-in 'index' (string) couldn't be converted to 'number'. [${n}] given.`
        );
      n = E;
    }
    let s = this,
      a = n;
    a < 0 && (a = 0);
    let {
      params: o,
      snapGrid: l,
      slidesGrid: c,
      previousIndex: u,
      activeIndex: f,
      rtlTranslate: d,
      wrapperEl: m,
      enabled: x,
    } = s;
    if ((s.animating && o.preventInteractionOnTransition) || (!x && !i && !r))
      return !1;
    let y = Math.min(s.params.slidesPerGroupSkip, a),
      g = y + Math.floor((a - y) / s.params.slidesPerGroup);
    g >= l.length && (g = l.length - 1);
    let b = -l[g];
    if (o.normalizeSlideIndex)
      for (let E = 0; E < c.length; E += 1) {
        let w = -Math.floor(b * 100),
          P = Math.floor(c[E] * 100),
          L = Math.floor(c[E + 1] * 100);
        typeof c[E + 1] != "undefined"
          ? w >= P && w < L - (L - P) / 2
            ? (a = E)
            : w >= P && w < L && (a = E + 1)
          : w >= P && (a = E);
      }
    if (
      s.initialized &&
      a !== f &&
      ((!s.allowSlideNext && b < s.translate && b < s.minTranslate()) ||
        (!s.allowSlidePrev &&
          b > s.translate &&
          b > s.maxTranslate() &&
          (f || 0) !== a))
    )
      return !1;
    a !== (u || 0) && t && s.emit("beforeSlideChangeStart"),
      s.updateProgress(b);
    let _;
    if (
      (a > f ? (_ = "next") : a < f ? (_ = "prev") : (_ = "reset"),
      (d && -b === s.translate) || (!d && b === s.translate))
    )
      return (
        s.updateActiveIndex(a),
        o.autoHeight && s.updateAutoHeight(),
        s.updateSlidesClasses(),
        o.effect !== "slide" && s.setTranslate(b),
        _ !== "reset" && (s.transitionStart(t, _), s.transitionEnd(t, _)),
        !1
      );
    if (o.cssMode) {
      let E = s.isHorizontal(),
        w = d ? b : -b;
      if (e === 0) {
        let P = s.virtual && s.params.virtual.enabled;
        P &&
          ((s.wrapperEl.style.scrollSnapType = "none"),
          (s._immediateVirtual = !0)),
          (m[E ? "scrollLeft" : "scrollTop"] = w),
          P &&
            requestAnimationFrame(() => {
              (s.wrapperEl.style.scrollSnapType = ""),
                (s._swiperImmediateVirtual = !1);
            });
      } else {
        if (!s.support.smoothScroll)
          return (
            Dd({ swiper: s, targetPosition: w, side: E ? "left" : "top" }), !0
          );
        m.scrollTo({ [E ? "left" : "top"]: w, behavior: "smooth" });
      }
      return !0;
    }
    return (
      s.setTransition(e),
      s.setTranslate(b),
      s.updateActiveIndex(a),
      s.updateSlidesClasses(),
      s.emit("beforeTransitionStart", e, i),
      s.transitionStart(t, _),
      e === 0
        ? s.transitionEnd(t, _)
        : s.animating ||
          ((s.animating = !0),
          s.onSlideToWrapperTransitionEnd ||
            (s.onSlideToWrapperTransitionEnd = function (w) {
              !s ||
                s.destroyed ||
                (w.target === this &&
                  (s.$wrapperEl[0].removeEventListener(
                    "transitionend",
                    s.onSlideToWrapperTransitionEnd
                  ),
                  s.$wrapperEl[0].removeEventListener(
                    "webkitTransitionEnd",
                    s.onSlideToWrapperTransitionEnd
                  ),
                  (s.onSlideToWrapperTransitionEnd = null),
                  delete s.onSlideToWrapperTransitionEnd,
                  s.transitionEnd(t, _)));
            }),
          s.$wrapperEl[0].addEventListener(
            "transitionend",
            s.onSlideToWrapperTransitionEnd
          ),
          s.$wrapperEl[0].addEventListener(
            "webkitTransitionEnd",
            s.onSlideToWrapperTransitionEnd
          )),
      !0
    );
  }
  function Ny(n = 0, e = this.params.speed, t = !0, i) {
    if (typeof n == "string") {
      let a = parseInt(n, 10);
      if (!isFinite(a))
        throw new Error(
          `The passed-in 'index' (string) couldn't be converted to 'number'. [${n}] given.`
        );
      n = a;
    }
    let r = this,
      s = n;
    return r.params.loop && (s += r.loopedSlides), r.slideTo(s, e, t, i);
  }
  function ky(n = this.params.speed, e = !0, t) {
    let i = this,
      { animating: r, enabled: s, params: a } = i;
    if (!s) return i;
    let o = a.slidesPerGroup;
    a.slidesPerView === "auto" &&
      a.slidesPerGroup === 1 &&
      a.slidesPerGroupAuto &&
      (o = Math.max(i.slidesPerViewDynamic("current", !0), 1));
    let l = i.activeIndex < a.slidesPerGroupSkip ? 1 : o;
    if (a.loop) {
      if (r && a.loopPreventsSlide) return !1;
      i.loopFix(), (i._clientLeft = i.$wrapperEl[0].clientLeft);
    }
    return a.rewind && i.isEnd
      ? i.slideTo(0, n, e, t)
      : i.slideTo(i.activeIndex + l, n, e, t);
  }
  function Fy(n = this.params.speed, e = !0, t) {
    let i = this,
      {
        params: r,
        animating: s,
        snapGrid: a,
        slidesGrid: o,
        rtlTranslate: l,
        enabled: c,
      } = i;
    if (!c) return i;
    if (r.loop) {
      if (s && r.loopPreventsSlide) return !1;
      i.loopFix(), (i._clientLeft = i.$wrapperEl[0].clientLeft);
    }
    let u = l ? i.translate : -i.translate;
    function f(g) {
      return g < 0 ? -Math.floor(Math.abs(g)) : Math.floor(g);
    }
    let d = f(u),
      m = a.map((g) => f(g)),
      x = a[m.indexOf(d) - 1];
    if (typeof x == "undefined" && r.cssMode) {
      let g;
      a.forEach((b, _) => {
        d >= b && (g = _);
      }),
        typeof g != "undefined" && (x = a[g > 0 ? g - 1 : g]);
    }
    let y = 0;
    if (
      (typeof x != "undefined" &&
        ((y = o.indexOf(x)),
        y < 0 && (y = i.activeIndex - 1),
        r.slidesPerView === "auto" &&
          r.slidesPerGroup === 1 &&
          r.slidesPerGroupAuto &&
          ((y = y - i.slidesPerViewDynamic("previous", !0) + 1),
          (y = Math.max(y, 0)))),
      r.rewind && i.isBeginning)
    ) {
      let g =
        i.params.virtual && i.params.virtual.enabled && i.virtual
          ? i.virtual.slides.length - 1
          : i.slides.length - 1;
      return i.slideTo(g, n, e, t);
    }
    return i.slideTo(y, n, e, t);
  }
  function By(n = this.params.speed, e = !0, t) {
    let i = this;
    return i.slideTo(i.activeIndex, n, e, t);
  }
  function zy(n = this.params.speed, e = !0, t, i = 0.5) {
    let r = this,
      s = r.activeIndex,
      a = Math.min(r.params.slidesPerGroupSkip, s),
      o = a + Math.floor((s - a) / r.params.slidesPerGroup),
      l = r.rtlTranslate ? r.translate : -r.translate;
    if (l >= r.snapGrid[o]) {
      let c = r.snapGrid[o],
        u = r.snapGrid[o + 1];
      l - c > (u - c) * i && (s += r.params.slidesPerGroup);
    } else {
      let c = r.snapGrid[o - 1],
        u = r.snapGrid[o];
      l - c <= (u - c) * i && (s -= r.params.slidesPerGroup);
    }
    return (
      (s = Math.max(s, 0)),
      (s = Math.min(s, r.slidesGrid.length - 1)),
      r.slideTo(s, n, e, t)
    );
  }
  function Uy() {
    let n = this,
      { params: e, $wrapperEl: t } = n,
      i =
        e.slidesPerView === "auto" ? n.slidesPerViewDynamic() : e.slidesPerView,
      r = n.clickedIndex,
      s;
    if (e.loop) {
      if (n.animating) return;
      (s = parseInt(ft(n.clickedSlide).attr("data-swiper-slide-index"), 10)),
        e.centeredSlides
          ? r < n.loopedSlides - i / 2 ||
            r > n.slides.length - n.loopedSlides + i / 2
            ? (n.loopFix(),
              (r = t
                .children(
                  `.${e.slideClass}[data-swiper-slide-index="${s}"]:not(.${e.slideDuplicateClass})`
                )
                .eq(0)
                .index()),
              Ys(() => {
                n.slideTo(r);
              }))
            : n.slideTo(r)
          : r > n.slides.length - i
          ? (n.loopFix(),
            (r = t
              .children(
                `.${e.slideClass}[data-swiper-slide-index="${s}"]:not(.${e.slideDuplicateClass})`
              )
              .eq(0)
              .index()),
            Ys(() => {
              n.slideTo(r);
            }))
          : n.slideTo(r);
    } else n.slideTo(r);
  }
  var jw = {
    slideTo: Oy,
    slideToLoop: Ny,
    slideNext: ky,
    slidePrev: Fy,
    slideReset: By,
    slideToClosest: zy,
    slideToClickedSlide: Uy,
  };
  function Vy() {
    let n = this,
      e = Pi(),
      { params: t, $wrapperEl: i } = n,
      r = i.children().length > 0 ? ft(i.children()[0].parentNode) : i;
    r.children(`.${t.slideClass}.${t.slideDuplicateClass}`).remove();
    let s = r.children(`.${t.slideClass}`);
    if (t.loopFillGroupWithBlank) {
      let l = t.slidesPerGroup - (s.length % t.slidesPerGroup);
      if (l !== t.slidesPerGroup) {
        for (let c = 0; c < l; c += 1) {
          let u = ft(e.createElement("div")).addClass(
            `${t.slideClass} ${t.slideBlankClass}`
          );
          r.append(u);
        }
        s = r.children(`.${t.slideClass}`);
      }
    }
    t.slidesPerView === "auto" &&
      !t.loopedSlides &&
      (t.loopedSlides = s.length),
      (n.loopedSlides = Math.ceil(
        parseFloat(t.loopedSlides || t.slidesPerView, 10)
      )),
      (n.loopedSlides += t.loopAdditionalSlides),
      n.loopedSlides > s.length &&
        n.params.loopedSlidesLimit &&
        (n.loopedSlides = s.length);
    let a = [],
      o = [];
    s.each((l, c) => {
      ft(l).attr("data-swiper-slide-index", c);
    });
    for (let l = 0; l < n.loopedSlides; l += 1) {
      let c = l - Math.floor(l / s.length) * s.length;
      o.push(s.eq(c)[0]), a.unshift(s.eq(s.length - c - 1)[0]);
    }
    for (let l = 0; l < o.length; l += 1)
      r.append(ft(o[l].cloneNode(!0)).addClass(t.slideDuplicateClass));
    for (let l = a.length - 1; l >= 0; l -= 1)
      r.prepend(ft(a[l].cloneNode(!0)).addClass(t.slideDuplicateClass));
  }
  function Gy() {
    let n = this;
    n.emit("beforeLoopFix");
    let {
        activeIndex: e,
        slides: t,
        loopedSlides: i,
        allowSlidePrev: r,
        allowSlideNext: s,
        snapGrid: a,
        rtlTranslate: o,
      } = n,
      l;
    (n.allowSlidePrev = !0), (n.allowSlideNext = !0);
    let u = -a[e] - n.getTranslate();
    e < i
      ? ((l = t.length - i * 3 + e),
        (l += i),
        n.slideTo(l, 0, !1, !0) &&
          u !== 0 &&
          n.setTranslate((o ? -n.translate : n.translate) - u))
      : e >= t.length - i &&
        ((l = -t.length + e + i),
        (l += i),
        n.slideTo(l, 0, !1, !0) &&
          u !== 0 &&
          n.setTranslate((o ? -n.translate : n.translate) - u)),
      (n.allowSlidePrev = r),
      (n.allowSlideNext = s),
      n.emit("loopFix");
  }
  function Hy() {
    let n = this,
      { $wrapperEl: e, params: t, slides: i } = n;
    e
      .children(
        `.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`
      )
      .remove(),
      i.removeAttr("data-swiper-slide-index");
  }
  var Xw = { loopCreate: Vy, loopFix: Gy, loopDestroy: Hy };
  function $y(n) {
    let e = this;
    if (
      e.support.touch ||
      !e.params.simulateTouch ||
      (e.params.watchOverflow && e.isLocked) ||
      e.params.cssMode
    )
      return;
    let t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl;
    (t.style.cursor = "move"), (t.style.cursor = n ? "grabbing" : "grab");
  }
  function Wy() {
    let n = this;
    n.support.touch ||
      (n.params.watchOverflow && n.isLocked) ||
      n.params.cssMode ||
      (n[
        n.params.touchEventsTarget === "container" ? "el" : "wrapperEl"
      ].style.cursor = "");
  }
  var Yw = { setGrabCursor: $y, unsetGrabCursor: Wy };
  function o4(n, e = this) {
    function t(i) {
      if (!i || i === Pi() || i === ai()) return null;
      i.assignedSlot && (i = i.assignedSlot);
      let r = i.closest(n);
      return !r && !i.getRootNode ? null : r || t(i.getRootNode().host);
    }
    return t(e);
  }
  function qy(n) {
    let e = this,
      t = Pi(),
      i = ai(),
      r = e.touchEventsData,
      { params: s, touches: a, enabled: o } = e;
    if (!o || (e.animating && s.preventInteractionOnTransition)) return;
    !e.animating && s.cssMode && s.loop && e.loopFix();
    let l = n;
    l.originalEvent && (l = l.originalEvent);
    let c = ft(l.target);
    if (
      (s.touchEventsTarget === "wrapper" && !c.closest(e.wrapperEl).length) ||
      ((r.isTouchEvent = l.type === "touchstart"),
      !r.isTouchEvent && "which" in l && l.which === 3) ||
      (!r.isTouchEvent && "button" in l && l.button > 0) ||
      (r.isTouched && r.isMoved)
    )
      return;
    let u = !!s.noSwipingClass && s.noSwipingClass !== "",
      f = n.composedPath ? n.composedPath() : n.path;
    u && l.target && l.target.shadowRoot && f && (c = ft(f[0]));
    let d = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`,
      m = !!(l.target && l.target.shadowRoot);
    if (s.noSwiping && (m ? o4(d, c[0]) : c.closest(d)[0])) {
      e.allowClick = !0;
      return;
    }
    if (s.swipeHandler && !c.closest(s.swipeHandler)[0]) return;
    (a.currentX = l.type === "touchstart" ? l.targetTouches[0].pageX : l.pageX),
      (a.currentY =
        l.type === "touchstart" ? l.targetTouches[0].pageY : l.pageY);
    let x = a.currentX,
      y = a.currentY,
      g = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection,
      b = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold;
    if (g && (x <= b || x >= i.innerWidth - b))
      if (g === "prevent") n.preventDefault();
      else return;
    if (
      (Object.assign(r, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0,
      }),
      (a.startX = x),
      (a.startY = y),
      (r.touchStartTime = ls()),
      (e.allowClick = !0),
      e.updateSize(),
      (e.swipeDirection = void 0),
      s.threshold > 0 && (r.allowThresholdMove = !1),
      l.type !== "touchstart")
    ) {
      let _ = !0;
      c.is(r.focusableElements) &&
        ((_ = !1), c[0].nodeName === "SELECT" && (r.isTouched = !1)),
        t.activeElement &&
          ft(t.activeElement).is(r.focusableElements) &&
          t.activeElement !== c[0] &&
          t.activeElement.blur();
      let E = _ && e.allowTouchMove && s.touchStartPreventDefault;
      (s.touchStartForcePreventDefault || E) &&
        !c[0].isContentEditable &&
        l.preventDefault();
    }
    e.params.freeMode &&
      e.params.freeMode.enabled &&
      e.freeMode &&
      e.animating &&
      !s.cssMode &&
      e.freeMode.onTouchStart(),
      e.emit("touchStart", l);
  }
  function jy(n) {
    let e = Pi(),
      t = this,
      i = t.touchEventsData,
      { params: r, touches: s, rtlTranslate: a, enabled: o } = t;
    if (!o) return;
    let l = n;
    if ((l.originalEvent && (l = l.originalEvent), !i.isTouched)) {
      i.startMoving && i.isScrolling && t.emit("touchMoveOpposite", l);
      return;
    }
    if (i.isTouchEvent && l.type !== "touchmove") return;
    let c =
        l.type === "touchmove" &&
        l.targetTouches &&
        (l.targetTouches[0] || l.changedTouches[0]),
      u = l.type === "touchmove" ? c.pageX : l.pageX,
      f = l.type === "touchmove" ? c.pageY : l.pageY;
    if (l.preventedByNestedSwiper) {
      (s.startX = u), (s.startY = f);
      return;
    }
    if (!t.allowTouchMove) {
      ft(l.target).is(i.focusableElements) || (t.allowClick = !1),
        i.isTouched &&
          (Object.assign(s, { startX: u, startY: f, currentX: u, currentY: f }),
          (i.touchStartTime = ls()));
      return;
    }
    if (i.isTouchEvent && r.touchReleaseOnEdges && !r.loop) {
      if (t.isVertical()) {
        if (
          (f < s.startY && t.translate <= t.maxTranslate()) ||
          (f > s.startY && t.translate >= t.minTranslate())
        ) {
          (i.isTouched = !1), (i.isMoved = !1);
          return;
        }
      } else if (
        (u < s.startX && t.translate <= t.maxTranslate()) ||
        (u > s.startX && t.translate >= t.minTranslate())
      )
        return;
    }
    if (
      i.isTouchEvent &&
      e.activeElement &&
      l.target === e.activeElement &&
      ft(l.target).is(i.focusableElements)
    ) {
      (i.isMoved = !0), (t.allowClick = !1);
      return;
    }
    if (
      (i.allowTouchCallbacks && t.emit("touchMove", l),
      l.targetTouches && l.targetTouches.length > 1)
    )
      return;
    (s.currentX = u), (s.currentY = f);
    let d = s.currentX - s.startX,
      m = s.currentY - s.startY;
    if (
      t.params.threshold &&
      Math.sqrt(Vs(d, 2) + Vs(m, 2)) < t.params.threshold
    )
      return;
    if (typeof i.isScrolling == "undefined") {
      let b;
      (t.isHorizontal() && s.currentY === s.startY) ||
      (t.isVertical() && s.currentX === s.startX)
        ? (i.isScrolling = !1)
        : d * d + m * m >= 25 &&
          ((b = (Math.atan2(Math.abs(m), Math.abs(d)) * 180) / Math.PI),
          (i.isScrolling = t.isHorizontal()
            ? b > r.touchAngle
            : 90 - b > r.touchAngle));
    }
    if (
      (i.isScrolling && t.emit("touchMoveOpposite", l),
      typeof i.startMoving == "undefined" &&
        (s.currentX !== s.startX || s.currentY !== s.startY) &&
        (i.startMoving = !0),
      i.isScrolling)
    ) {
      i.isTouched = !1;
      return;
    }
    if (!i.startMoving) return;
    (t.allowClick = !1),
      !r.cssMode && l.cancelable && l.preventDefault(),
      r.touchMoveStopPropagation && !r.nested && l.stopPropagation(),
      i.isMoved ||
        (r.loop && !r.cssMode && t.loopFix(),
        (i.startTranslate = t.getTranslate()),
        t.setTransition(0),
        t.animating &&
          t.$wrapperEl.trigger("webkitTransitionEnd transitionend"),
        (i.allowMomentumBounce = !1),
        r.grabCursor &&
          (t.allowSlideNext === !0 || t.allowSlidePrev === !0) &&
          t.setGrabCursor(!0),
        t.emit("sliderFirstMove", l)),
      t.emit("sliderMove", l),
      (i.isMoved = !0);
    let x = t.isHorizontal() ? d : m;
    (s.diff = x),
      (x *= r.touchRatio),
      a && (x = -x),
      (t.swipeDirection = x > 0 ? "prev" : "next"),
      (i.currentTranslate = x + i.startTranslate);
    let y = !0,
      g = r.resistanceRatio;
    if (
      (r.touchReleaseOnEdges && (g = 0),
      x > 0 && i.currentTranslate > t.minTranslate()
        ? ((y = !1),
          r.resistance &&
            (i.currentTranslate =
              t.minTranslate() -
              1 +
              Vs(-t.minTranslate() + i.startTranslate + x, g)))
        : x < 0 &&
          i.currentTranslate < t.maxTranslate() &&
          ((y = !1),
          r.resistance &&
            (i.currentTranslate =
              t.maxTranslate() +
              1 -
              Vs(t.maxTranslate() - i.startTranslate - x, g))),
      y && (l.preventedByNestedSwiper = !0),
      !t.allowSlideNext &&
        t.swipeDirection === "next" &&
        i.currentTranslate < i.startTranslate &&
        (i.currentTranslate = i.startTranslate),
      !t.allowSlidePrev &&
        t.swipeDirection === "prev" &&
        i.currentTranslate > i.startTranslate &&
        (i.currentTranslate = i.startTranslate),
      !t.allowSlidePrev &&
        !t.allowSlideNext &&
        (i.currentTranslate = i.startTranslate),
      r.threshold > 0)
    )
      if (Math.abs(x) > r.threshold || i.allowThresholdMove) {
        if (!i.allowThresholdMove) {
          (i.allowThresholdMove = !0),
            (s.startX = s.currentX),
            (s.startY = s.currentY),
            (i.currentTranslate = i.startTranslate),
            (s.diff = t.isHorizontal()
              ? s.currentX - s.startX
              : s.currentY - s.startY);
          return;
        }
      } else {
        i.currentTranslate = i.startTranslate;
        return;
      }
    !r.followFinger ||
      r.cssMode ||
      (((r.freeMode && r.freeMode.enabled && t.freeMode) ||
        r.watchSlidesProgress) &&
        (t.updateActiveIndex(), t.updateSlidesClasses()),
      t.params.freeMode &&
        r.freeMode.enabled &&
        t.freeMode &&
        t.freeMode.onTouchMove(),
      t.updateProgress(i.currentTranslate),
      t.setTranslate(i.currentTranslate));
  }
  function Xy(n) {
    let e = this,
      t = e.touchEventsData,
      { params: i, touches: r, rtlTranslate: s, slidesGrid: a, enabled: o } = e;
    if (!o) return;
    let l = n;
    if (
      (l.originalEvent && (l = l.originalEvent),
      t.allowTouchCallbacks && e.emit("touchEnd", l),
      (t.allowTouchCallbacks = !1),
      !t.isTouched)
    ) {
      t.isMoved && i.grabCursor && e.setGrabCursor(!1),
        (t.isMoved = !1),
        (t.startMoving = !1);
      return;
    }
    i.grabCursor &&
      t.isMoved &&
      t.isTouched &&
      (e.allowSlideNext === !0 || e.allowSlidePrev === !0) &&
      e.setGrabCursor(!1);
    let c = ls(),
      u = c - t.touchStartTime;
    if (e.allowClick) {
      let _ = l.path || (l.composedPath && l.composedPath());
      e.updateClickedSlide((_ && _[0]) || l.target),
        e.emit("tap click", l),
        u < 300 &&
          c - t.lastClickTime < 300 &&
          e.emit("doubleTap doubleClick", l);
    }
    if (
      ((t.lastClickTime = ls()),
      Ys(() => {
        e.destroyed || (e.allowClick = !0);
      }),
      !t.isTouched ||
        !t.isMoved ||
        !e.swipeDirection ||
        r.diff === 0 ||
        t.currentTranslate === t.startTranslate)
    ) {
      (t.isTouched = !1), (t.isMoved = !1), (t.startMoving = !1);
      return;
    }
    (t.isTouched = !1), (t.isMoved = !1), (t.startMoving = !1);
    let f;
    if (
      (i.followFinger
        ? (f = s ? e.translate : -e.translate)
        : (f = -t.currentTranslate),
      i.cssMode)
    )
      return;
    if (e.params.freeMode && i.freeMode.enabled) {
      e.freeMode.onTouchEnd({ currentPos: f });
      return;
    }
    let d = 0,
      m = e.slidesSizesGrid[0];
    for (
      let _ = 0;
      _ < a.length;
      _ += _ < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup
    ) {
      let E = _ < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
      typeof a[_ + E] != "undefined"
        ? f >= a[_] && f < a[_ + E] && ((d = _), (m = a[_ + E] - a[_]))
        : f >= a[_] && ((d = _), (m = a[a.length - 1] - a[a.length - 2]));
    }
    let x = null,
      y = null;
    i.rewind &&
      (e.isBeginning
        ? (y =
            e.params.virtual && e.params.virtual.enabled && e.virtual
              ? e.virtual.slides.length - 1
              : e.slides.length - 1)
        : e.isEnd && (x = 0));
    let g = (f - a[d]) / m,
      b = d < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
    if (u > i.longSwipesMs) {
      if (!i.longSwipes) {
        e.slideTo(e.activeIndex);
        return;
      }
      e.swipeDirection === "next" &&
        (g >= i.longSwipesRatio
          ? e.slideTo(i.rewind && e.isEnd ? x : d + b)
          : e.slideTo(d)),
        e.swipeDirection === "prev" &&
          (g > 1 - i.longSwipesRatio
            ? e.slideTo(d + b)
            : y !== null && g < 0 && Math.abs(g) > i.longSwipesRatio
            ? e.slideTo(y)
            : e.slideTo(d));
    } else {
      if (!i.shortSwipes) {
        e.slideTo(e.activeIndex);
        return;
      }
      e.navigation &&
      (l.target === e.navigation.nextEl || l.target === e.navigation.prevEl)
        ? l.target === e.navigation.nextEl
          ? e.slideTo(d + b)
          : e.slideTo(d)
        : (e.swipeDirection === "next" && e.slideTo(x !== null ? x : d + b),
          e.swipeDirection === "prev" && e.slideTo(y !== null ? y : d));
    }
  }
  function Ld() {
    let n = this,
      { params: e, el: t } = n;
    if (t && t.offsetWidth === 0) return;
    e.breakpoints && n.setBreakpoint();
    let { allowSlideNext: i, allowSlidePrev: r, snapGrid: s } = n;
    (n.allowSlideNext = !0),
      (n.allowSlidePrev = !0),
      n.updateSize(),
      n.updateSlides(),
      n.updateSlidesClasses(),
      (e.slidesPerView === "auto" || e.slidesPerView > 1) &&
      n.isEnd &&
      !n.isBeginning &&
      !n.params.centeredSlides
        ? n.slideTo(n.slides.length - 1, 0, !1, !0)
        : n.slideTo(n.activeIndex, 0, !1, !0),
      n.autoplay && n.autoplay.running && n.autoplay.paused && n.autoplay.run(),
      (n.allowSlidePrev = r),
      (n.allowSlideNext = i),
      n.params.watchOverflow && s !== n.snapGrid && n.checkOverflow();
  }
  function Yy(n) {
    let e = this;
    !e.enabled ||
      e.allowClick ||
      (e.params.preventClicks && n.preventDefault(),
      e.params.preventClicksPropagation &&
        e.animating &&
        (n.stopPropagation(), n.stopImmediatePropagation()));
  }
  function Ky() {
    let n = this,
      { wrapperEl: e, rtlTranslate: t, enabled: i } = n;
    if (!i) return;
    (n.previousTranslate = n.translate),
      n.isHorizontal()
        ? (n.translate = -e.scrollLeft)
        : (n.translate = -e.scrollTop),
      n.translate === 0 && (n.translate = 0),
      n.updateActiveIndex(),
      n.updateSlidesClasses();
    let r,
      s = n.maxTranslate() - n.minTranslate();
    s === 0 ? (r = 0) : (r = (n.translate - n.minTranslate()) / s),
      r !== n.progress && n.updateProgress(t ? -n.translate : n.translate),
      n.emit("setTranslate", n.translate, !1);
  }
  var Kw = !1;
  function l4() {}
  var Jw = (n, e) => {
    let t = Pi(),
      {
        params: i,
        touchEvents: r,
        el: s,
        wrapperEl: a,
        device: o,
        support: l,
      } = n,
      c = !!i.nested,
      u = e === "on" ? "addEventListener" : "removeEventListener",
      f = e;
    if (!l.touch)
      s[u](r.start, n.onTouchStart, !1),
        t[u](r.move, n.onTouchMove, c),
        t[u](r.end, n.onTouchEnd, !1);
    else {
      let d =
        r.start === "touchstart" && l.passiveListener && i.passiveListeners
          ? { passive: !0, capture: !1 }
          : !1;
      s[u](r.start, n.onTouchStart, d),
        s[u](
          r.move,
          n.onTouchMove,
          l.passiveListener ? { passive: !1, capture: c } : c
        ),
        s[u](r.end, n.onTouchEnd, d),
        r.cancel && s[u](r.cancel, n.onTouchEnd, d);
    }
    (i.preventClicks || i.preventClicksPropagation) &&
      s[u]("click", n.onClick, !0),
      i.cssMode && a[u]("scroll", n.onScroll),
      i.updateOnWindowResize
        ? n[f](
            o.ios || o.android
              ? "resize orientationchange observerUpdate"
              : "resize observerUpdate",
            Ld,
            !0
          )
        : n[f]("observerUpdate", Ld, !0);
  };
  function c4() {
    let n = this,
      e = Pi(),
      { params: t, support: i } = n;
    (n.onTouchStart = qy.bind(n)),
      (n.onTouchMove = jy.bind(n)),
      (n.onTouchEnd = Xy.bind(n)),
      t.cssMode && (n.onScroll = Ky.bind(n)),
      (n.onClick = Yy.bind(n)),
      i.touch && !Kw && (e.addEventListener("touchstart", l4), (Kw = !0)),
      Jw(n, "on");
  }
  function u4() {
    Jw(this, "off");
  }
  var Zw = { attachEvents: c4, detachEvents: u4 };
  var Qw = (n, e) => n.grid && e.grid && e.grid.rows > 1;
  function Jy() {
    let n = this,
      {
        activeIndex: e,
        initialized: t,
        loopedSlides: i = 0,
        params: r,
        $el: s,
      } = n,
      a = r.breakpoints;
    if (!a || (a && Object.keys(a).length === 0)) return;
    let o = n.getBreakpoint(a, n.params.breakpointsBase, n.el);
    if (!o || n.currentBreakpoint === o) return;
    let c = (o in a ? a[o] : void 0) || n.originalParams,
      u = Qw(n, r),
      f = Qw(n, c),
      d = r.enabled;
    u && !f
      ? (s.removeClass(
          `${r.containerModifierClass}grid ${r.containerModifierClass}grid-column`
        ),
        n.emitContainerClasses())
      : !u &&
        f &&
        (s.addClass(`${r.containerModifierClass}grid`),
        ((c.grid.fill && c.grid.fill === "column") ||
          (!c.grid.fill && r.grid.fill === "column")) &&
          s.addClass(`${r.containerModifierClass}grid-column`),
        n.emitContainerClasses()),
      ["navigation", "pagination", "scrollbar"].forEach((g) => {
        let b = r[g] && r[g].enabled,
          _ = c[g] && c[g].enabled;
        b && !_ && n[g].disable(), !b && _ && n[g].enable();
      });
    let m = c.direction && c.direction !== r.direction,
      x = r.loop && (c.slidesPerView !== r.slidesPerView || m);
    m && t && n.changeDirection(), Cn(n.params, c);
    let y = n.params.enabled;
    Object.assign(n, {
      allowTouchMove: n.params.allowTouchMove,
      allowSlideNext: n.params.allowSlideNext,
      allowSlidePrev: n.params.allowSlidePrev,
    }),
      d && !y ? n.disable() : !d && y && n.enable(),
      (n.currentBreakpoint = o),
      n.emit("_beforeBreakpoint", c),
      x &&
        t &&
        (n.loopDestroy(),
        n.loopCreate(),
        n.updateSlides(),
        n.slideTo(e - i + n.loopedSlides, 0, !1)),
      n.emit("breakpoint", c);
  }
  function Zy(n, e = "window", t) {
    if (!n || (e === "container" && !t)) return;
    let i = !1,
      r = ai(),
      s = e === "window" ? r.innerHeight : t.clientHeight,
      a = Object.keys(n).map((o) => {
        if (typeof o == "string" && o.indexOf("@") === 0) {
          let l = parseFloat(o.substr(1));
          return { value: s * l, point: o };
        }
        return { value: o, point: o };
      });
    a.sort((o, l) => parseInt(o.value, 10) - parseInt(l.value, 10));
    for (let o = 0; o < a.length; o += 1) {
      let { point: l, value: c } = a[o];
      e === "window"
        ? r.matchMedia(`(min-width: ${c}px)`).matches && (i = l)
        : c <= t.clientWidth && (i = l);
    }
    return i || "max";
  }
  var eM = { setBreakpoint: Jy, getBreakpoint: Zy };
  function h4(n, e) {
    let t = [];
    return (
      n.forEach((i) => {
        typeof i == "object"
          ? Object.keys(i).forEach((r) => {
              i[r] && t.push(e + r);
            })
          : typeof i == "string" && t.push(e + i);
      }),
      t
    );
  }
  function Qy() {
    let n = this,
      { classNames: e, params: t, rtl: i, $el: r, device: s, support: a } = n,
      o = h4(
        [
          "initialized",
          t.direction,
          { "pointer-events": !a.touch },
          { "free-mode": n.params.freeMode && t.freeMode.enabled },
          { autoheight: t.autoHeight },
          { rtl: i },
          { grid: t.grid && t.grid.rows > 1 },
          {
            "grid-column":
              t.grid && t.grid.rows > 1 && t.grid.fill === "column",
          },
          { android: s.android },
          { ios: s.ios },
          { "css-mode": t.cssMode },
          { centered: t.cssMode && t.centeredSlides },
          { "watch-progress": t.watchSlidesProgress },
        ],
        t.containerModifierClass
      );
    e.push(...o), r.addClass([...e].join(" ")), n.emitContainerClasses();
  }
  function ev() {
    let n = this,
      { $el: e, classNames: t } = n;
    e.removeClass(t.join(" ")), n.emitContainerClasses();
  }
  var tM = { addClasses: Qy, removeClasses: ev };
  function tv(n, e, t, i, r, s) {
    let a = ai(),
      o;
    function l() {
      s && s();
    }
    !ft(n).parent("picture")[0] && (!n.complete || !r) && e
      ? ((o = new a.Image()),
        (o.onload = l),
        (o.onerror = l),
        i && (o.sizes = i),
        t && (o.srcset = t),
        e && (o.src = e))
      : l();
  }
  function iv() {
    let n = this;
    n.imagesToLoad = n.$el.find("img");
    function e() {
      typeof n == "undefined" ||
        n === null ||
        !n ||
        n.destroyed ||
        (n.imagesLoaded !== void 0 && (n.imagesLoaded += 1),
        n.imagesLoaded === n.imagesToLoad.length &&
          (n.params.updateOnImagesReady && n.update(), n.emit("imagesReady")));
    }
    for (let t = 0; t < n.imagesToLoad.length; t += 1) {
      let i = n.imagesToLoad[t];
      n.loadImage(
        i,
        i.currentSrc || i.getAttribute("src"),
        i.srcset || i.getAttribute("srcset"),
        i.sizes || i.getAttribute("sizes"),
        !0,
        e
      );
    }
  }
  var iM = { loadImage: tv, preloadImages: iv };
  function f4() {
    let n = this,
      { isLocked: e, params: t } = n,
      { slidesOffsetBefore: i } = t;
    if (i) {
      let r = n.slides.length - 1,
        s = n.slidesGrid[r] + n.slidesSizesGrid[r] + i * 2;
      n.isLocked = n.size > s;
    } else n.isLocked = n.snapGrid.length === 1;
    t.allowSlideNext === !0 && (n.allowSlideNext = !n.isLocked),
      t.allowSlidePrev === !0 && (n.allowSlidePrev = !n.isLocked),
      e && e !== n.isLocked && (n.isEnd = !1),
      e !== n.isLocked && n.emit(n.isLocked ? "lock" : "unlock");
  }
  var nM = { checkOverflow: f4 };
  var nv = {
    init: !0,
    direction: "horizontal",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 0,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: 0.85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    preloadImages: !0,
    updateOnImagesReady: !0,
    loop: !1,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopedSlidesLimit: !0,
    loopFillGroupWithBlank: !1,
    loopPreventsSlide: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-invisible-blank",
    slideActiveClass: "swiper-slide-active",
    slideDuplicateActiveClass: "swiper-slide-duplicate-active",
    slideVisibleClass: "swiper-slide-visible",
    slideDuplicateClass: "swiper-slide-duplicate",
    slideNextClass: "swiper-slide-next",
    slideDuplicateNextClass: "swiper-slide-duplicate-next",
    slidePrevClass: "swiper-slide-prev",
    slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
    wrapperClass: "swiper-wrapper",
    runCallbacksOnInit: !0,
    _emitClasses: !1,
  };
  function rv(n, e) {
    return function (i = {}) {
      let r = Object.keys(i)[0],
        s = i[r];
      if (typeof s != "object" || s === null) {
        Cn(e, i);
        return;
      }
      if (
        (["navigation", "pagination", "scrollbar"].indexOf(r) >= 0 &&
          n[r] === !0 &&
          (n[r] = { auto: !0 }),
        !(r in n && "enabled" in s))
      ) {
        Cn(e, i);
        return;
      }
      n[r] === !0 && (n[r] = { enabled: !0 }),
        typeof n[r] == "object" && !("enabled" in n[r]) && (n[r].enabled = !0),
        n[r] || (n[r] = { enabled: !1 }),
        Cn(e, i);
    };
  }
  var sv = {
      eventsEmitter: Hw,
      update: $w,
      translate: Ww,
      transition: qw,
      slide: jw,
      loop: Xw,
      grabCursor: Yw,
      events: Zw,
      breakpoints: eM,
      checkOverflow: nM,
      classes: tM,
      images: iM,
    },
    av = {},
    gr = class {
      constructor(...e) {
        let t, i;
        if (
          (e.length === 1 &&
          e[0].constructor &&
          Object.prototype.toString.call(e[0]).slice(8, -1) === "Object"
            ? (i = e[0])
            : ([t, i] = e),
          i || (i = {}),
          (i = Cn({}, i)),
          t && !i.el && (i.el = t),
          i.el && ft(i.el).length > 1)
        ) {
          let o = [];
          return (
            ft(i.el).each((l) => {
              let c = Cn({}, i, { el: l });
              o.push(new gr(c));
            }),
            o
          );
        }
        let r = this;
        (r.__swiper__ = !0),
          (r.support = Id()),
          (r.device = Vw({ userAgent: i.userAgent })),
          (r.browser = Gw()),
          (r.eventsListeners = {}),
          (r.eventsAnyListeners = []),
          (r.modules = [...r.__modules__]),
          i.modules && Array.isArray(i.modules) && r.modules.push(...i.modules);
        let s = {};
        r.modules.forEach((o) => {
          o({
            swiper: r,
            extendParams: rv(i, s),
            on: r.on.bind(r),
            once: r.once.bind(r),
            off: r.off.bind(r),
            emit: r.emit.bind(r),
          });
        });
        let a = Cn({}, nv, s);
        return (
          (r.params = Cn({}, a, av, i)),
          (r.originalParams = Cn({}, r.params)),
          (r.passedParams = Cn({}, i)),
          r.params &&
            r.params.on &&
            Object.keys(r.params.on).forEach((o) => {
              r.on(o, r.params.on[o]);
            }),
          r.params && r.params.onAny && r.onAny(r.params.onAny),
          (r.$ = ft),
          Object.assign(r, {
            enabled: r.params.enabled,
            el: t,
            classNames: [],
            slides: ft(),
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() {
              return r.params.direction === "horizontal";
            },
            isVertical() {
              return r.params.direction === "vertical";
            },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            allowSlideNext: r.params.allowSlideNext,
            allowSlidePrev: r.params.allowSlidePrev,
            touchEvents: (function () {
              let l = ["touchstart", "touchmove", "touchend", "touchcancel"],
                c = ["pointerdown", "pointermove", "pointerup"];
              return (
                (r.touchEventsTouch = {
                  start: l[0],
                  move: l[1],
                  end: l[2],
                  cancel: l[3],
                }),
                (r.touchEventsDesktop = { start: c[0], move: c[1], end: c[2] }),
                r.support.touch || !r.params.simulateTouch
                  ? r.touchEventsTouch
                  : r.touchEventsDesktop
              );
            })(),
            touchEventsData: {
              isTouched: void 0,
              isMoved: void 0,
              allowTouchCallbacks: void 0,
              touchStartTime: void 0,
              isScrolling: void 0,
              currentTranslate: void 0,
              startTranslate: void 0,
              allowThresholdMove: void 0,
              focusableElements: r.params.focusableElements,
              lastClickTime: ls(),
              clickTimeout: void 0,
              velocities: [],
              allowMomentumBounce: void 0,
              isTouchEvent: void 0,
              startMoving: void 0,
            },
            allowClick: !0,
            allowTouchMove: r.params.allowTouchMove,
            touches: {
              startX: 0,
              startY: 0,
              currentX: 0,
              currentY: 0,
              diff: 0,
            },
            imagesToLoad: [],
            imagesLoaded: 0,
          }),
          r.emit("_swiper"),
          r.params.init && r.init(),
          r
        );
      }
      enable() {
        let e = this;
        e.enabled ||
          ((e.enabled = !0),
          e.params.grabCursor && e.setGrabCursor(),
          e.emit("enable"));
      }
      disable() {
        let e = this;
        !e.enabled ||
          ((e.enabled = !1),
          e.params.grabCursor && e.unsetGrabCursor(),
          e.emit("disable"));
      }
      setProgress(e, t) {
        let i = this;
        e = Math.min(Math.max(e, 0), 1);
        let r = i.minTranslate(),
          a = (i.maxTranslate() - r) * e + r;
        i.translateTo(a, typeof t == "undefined" ? 0 : t),
          i.updateActiveIndex(),
          i.updateSlidesClasses();
      }
      emitContainerClasses() {
        let e = this;
        if (!e.params._emitClasses || !e.el) return;
        let t = e.el.className
          .split(" ")
          .filter(
            (i) =>
              i.indexOf("swiper") === 0 ||
              i.indexOf(e.params.containerModifierClass) === 0
          );
        e.emit("_containerClasses", t.join(" "));
      }
      getSlideClasses(e) {
        let t = this;
        return t.destroyed
          ? ""
          : e.className
              .split(" ")
              .filter(
                (i) =>
                  i.indexOf("swiper-slide") === 0 ||
                  i.indexOf(t.params.slideClass) === 0
              )
              .join(" ");
      }
      emitSlidesClasses() {
        let e = this;
        if (!e.params._emitClasses || !e.el) return;
        let t = [];
        e.slides.each((i) => {
          let r = e.getSlideClasses(i);
          t.push({ slideEl: i, classNames: r }), e.emit("_slideClass", i, r);
        }),
          e.emit("_slideClasses", t);
      }
      slidesPerViewDynamic(e = "current", t = !1) {
        let i = this,
          {
            params: r,
            slides: s,
            slidesGrid: a,
            slidesSizesGrid: o,
            size: l,
            activeIndex: c,
          } = i,
          u = 1;
        if (r.centeredSlides) {
          let f = s[c].swiperSlideSize,
            d;
          for (let m = c + 1; m < s.length; m += 1)
            s[m] &&
              !d &&
              ((f += s[m].swiperSlideSize), (u += 1), f > l && (d = !0));
          for (let m = c - 1; m >= 0; m -= 1)
            s[m] &&
              !d &&
              ((f += s[m].swiperSlideSize), (u += 1), f > l && (d = !0));
        } else if (e === "current")
          for (let f = c + 1; f < s.length; f += 1)
            (t ? a[f] + o[f] - a[c] < l : a[f] - a[c] < l) && (u += 1);
        else for (let f = c - 1; f >= 0; f -= 1) a[c] - a[f] < l && (u += 1);
        return u;
      }
      update() {
        let e = this;
        if (!e || e.destroyed) return;
        let { snapGrid: t, params: i } = e;
        i.breakpoints && e.setBreakpoint(),
          e.updateSize(),
          e.updateSlides(),
          e.updateProgress(),
          e.updateSlidesClasses();
        function r() {
          let a = e.rtlTranslate ? e.translate * -1 : e.translate,
            o = Math.min(Math.max(a, e.maxTranslate()), e.minTranslate());
          e.setTranslate(o), e.updateActiveIndex(), e.updateSlidesClasses();
        }
        let s;
        e.params.freeMode && e.params.freeMode.enabled
          ? (r(), e.params.autoHeight && e.updateAutoHeight())
          : ((e.params.slidesPerView === "auto" ||
              e.params.slidesPerView > 1) &&
            e.isEnd &&
            !e.params.centeredSlides
              ? (s = e.slideTo(e.slides.length - 1, 0, !1, !0))
              : (s = e.slideTo(e.activeIndex, 0, !1, !0)),
            s || r()),
          i.watchOverflow && t !== e.snapGrid && e.checkOverflow(),
          e.emit("update");
      }
      changeDirection(e, t = !0) {
        let i = this,
          r = i.params.direction;
        return (
          e || (e = r === "horizontal" ? "vertical" : "horizontal"),
          e === r ||
            (e !== "horizontal" && e !== "vertical") ||
            (i.$el
              .removeClass(`${i.params.containerModifierClass}${r}`)
              .addClass(`${i.params.containerModifierClass}${e}`),
            i.emitContainerClasses(),
            (i.params.direction = e),
            i.slides.each((s) => {
              e === "vertical" ? (s.style.width = "") : (s.style.height = "");
            }),
            i.emit("changeDirection"),
            t && i.update()),
          i
        );
      }
      changeLanguageDirection(e) {
        let t = this;
        (t.rtl && e === "rtl") ||
          (!t.rtl && e === "ltr") ||
          ((t.rtl = e === "rtl"),
          (t.rtlTranslate = t.params.direction === "horizontal" && t.rtl),
          t.rtl
            ? (t.$el.addClass(`${t.params.containerModifierClass}rtl`),
              (t.el.dir = "rtl"))
            : (t.$el.removeClass(`${t.params.containerModifierClass}rtl`),
              (t.el.dir = "ltr")),
          t.update());
      }
      mount(e) {
        let t = this;
        if (t.mounted) return !0;
        let i = ft(e || t.params.el);
        if (((e = i[0]), !e)) return !1;
        e.swiper = t;
        let r = () =>
            `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`,
          a = (() => {
            if (e && e.shadowRoot && e.shadowRoot.querySelector) {
              let o = ft(e.shadowRoot.querySelector(r()));
              return (o.children = (l) => i.children(l)), o;
            }
            return i.children ? i.children(r()) : ft(i).children(r());
          })();
        if (a.length === 0 && t.params.createElements) {
          let l = Pi().createElement("div");
          (a = ft(l)),
            (l.className = t.params.wrapperClass),
            i.append(l),
            i.children(`.${t.params.slideClass}`).each((c) => {
              a.append(c);
            });
        }
        return (
          Object.assign(t, {
            $el: i,
            el: e,
            $wrapperEl: a,
            wrapperEl: a[0],
            mounted: !0,
            rtl: e.dir.toLowerCase() === "rtl" || i.css("direction") === "rtl",
            rtlTranslate:
              t.params.direction === "horizontal" &&
              (e.dir.toLowerCase() === "rtl" || i.css("direction") === "rtl"),
            wrongRTL: a.css("display") === "-webkit-box",
          }),
          !0
        );
      }
      init(e) {
        let t = this;
        return (
          t.initialized ||
            t.mount(e) === !1 ||
            (t.emit("beforeInit"),
            t.params.breakpoints && t.setBreakpoint(),
            t.addClasses(),
            t.params.loop && t.loopCreate(),
            t.updateSize(),
            t.updateSlides(),
            t.params.watchOverflow && t.checkOverflow(),
            t.params.grabCursor && t.enabled && t.setGrabCursor(),
            t.params.preloadImages && t.preloadImages(),
            t.params.loop
              ? t.slideTo(
                  t.params.initialSlide + t.loopedSlides,
                  0,
                  t.params.runCallbacksOnInit,
                  !1,
                  !0
                )
              : t.slideTo(
                  t.params.initialSlide,
                  0,
                  t.params.runCallbacksOnInit,
                  !1,
                  !0
                ),
            t.attachEvents(),
            (t.initialized = !0),
            t.emit("init"),
            t.emit("afterInit")),
          t
        );
      }
      destroy(e = !0, t = !0) {
        let i = this,
          { params: r, $el: s, $wrapperEl: a, slides: o } = i;
        return (
          typeof i.params == "undefined" ||
            i.destroyed ||
            (i.emit("beforeDestroy"),
            (i.initialized = !1),
            i.detachEvents(),
            r.loop && i.loopDestroy(),
            t &&
              (i.removeClasses(),
              s.removeAttr("style"),
              a.removeAttr("style"),
              o &&
                o.length &&
                o
                  .removeClass(
                    [
                      r.slideVisibleClass,
                      r.slideActiveClass,
                      r.slideNextClass,
                      r.slidePrevClass,
                    ].join(" ")
                  )
                  .removeAttr("style")
                  .removeAttr("data-swiper-slide-index")),
            i.emit("destroy"),
            Object.keys(i.eventsListeners).forEach((l) => {
              i.off(l);
            }),
            e !== !1 && ((i.$el[0].swiper = null), Uw(i)),
            (i.destroyed = !0)),
          null
        );
      }
      static extendDefaults(e) {
        Cn(av, e);
      }
      static get extendedDefaults() {
        return av;
      }
      static get defaults() {
        return nv;
      }
      static installModule(e) {
        gr.prototype.__modules__ || (gr.prototype.__modules__ = []);
        let t = gr.prototype.__modules__;
        typeof e == "function" && t.indexOf(e) < 0 && t.push(e);
      }
      static use(e) {
        return Array.isArray(e)
          ? (e.forEach((t) => gr.installModule(t)), gr)
          : (gr.installModule(e), gr);
      }
    };
  Object.keys(sv).forEach((n) => {
    Object.keys(sv[n]).forEach((e) => {
      gr.prototype[e] = sv[n][e];
    });
  });
  gr.use([my, gy]);
  var Rd = gr;
  function ac(n, e, t, i) {
    let r = Pi();
    return (
      n.params.createElements &&
        Object.keys(i).forEach((s) => {
          if (!t[s] && t.auto === !0) {
            let a = n.$el.children(`.${i[s]}`)[0];
            a ||
              ((a = r.createElement("div")),
              (a.className = i[s]),
              n.$el.append(a)),
              (t[s] = a),
              (e[s] = a);
          }
        }),
      t
    );
  }
  function Od({ swiper: n, extendParams: e, on: t, emit: i }) {
    e({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: !1,
        disabledClass: "swiper-button-disabled",
        hiddenClass: "swiper-button-hidden",
        lockClass: "swiper-button-lock",
        navigationDisabledClass: "swiper-navigation-disabled",
      },
    }),
      (n.navigation = {
        nextEl: null,
        $nextEl: null,
        prevEl: null,
        $prevEl: null,
      });
    function r(m) {
      let x;
      return (
        m &&
          ((x = ft(m)),
          n.params.uniqueNavElements &&
            typeof m == "string" &&
            x.length > 1 &&
            n.$el.find(m).length === 1 &&
            (x = n.$el.find(m))),
        x
      );
    }
    function s(m, x) {
      let y = n.params.navigation;
      m &&
        m.length > 0 &&
        (m[x ? "addClass" : "removeClass"](y.disabledClass),
        m[0] && m[0].tagName === "BUTTON" && (m[0].disabled = x),
        n.params.watchOverflow &&
          n.enabled &&
          m[n.isLocked ? "addClass" : "removeClass"](y.lockClass));
    }
    function a() {
      if (n.params.loop) return;
      let { $nextEl: m, $prevEl: x } = n.navigation;
      s(x, n.isBeginning && !n.params.rewind),
        s(m, n.isEnd && !n.params.rewind);
    }
    function o(m) {
      m.preventDefault(),
        !(n.isBeginning && !n.params.loop && !n.params.rewind) &&
          (n.slidePrev(), i("navigationPrev"));
    }
    function l(m) {
      m.preventDefault(),
        !(n.isEnd && !n.params.loop && !n.params.rewind) &&
          (n.slideNext(), i("navigationNext"));
    }
    function c() {
      let m = n.params.navigation;
      if (
        ((n.params.navigation = ac(
          n,
          n.originalParams.navigation,
          n.params.navigation,
          { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }
        )),
        !(m.nextEl || m.prevEl))
      )
        return;
      let x = r(m.nextEl),
        y = r(m.prevEl);
      x && x.length > 0 && x.on("click", l),
        y && y.length > 0 && y.on("click", o),
        Object.assign(n.navigation, {
          $nextEl: x,
          nextEl: x && x[0],
          $prevEl: y,
          prevEl: y && y[0],
        }),
        n.enabled ||
          (x && x.addClass(m.lockClass), y && y.addClass(m.lockClass));
    }
    function u() {
      let { $nextEl: m, $prevEl: x } = n.navigation;
      m &&
        m.length &&
        (m.off("click", l), m.removeClass(n.params.navigation.disabledClass)),
        x &&
          x.length &&
          (x.off("click", o), x.removeClass(n.params.navigation.disabledClass));
    }
    t("init", () => {
      n.params.navigation.enabled === !1 ? d() : (c(), a());
    }),
      t("toEdge fromEdge lock unlock", () => {
        a();
      }),
      t("destroy", () => {
        u();
      }),
      t("enable disable", () => {
        let { $nextEl: m, $prevEl: x } = n.navigation;
        m &&
          m[n.enabled ? "removeClass" : "addClass"](
            n.params.navigation.lockClass
          ),
          x &&
            x[n.enabled ? "removeClass" : "addClass"](
              n.params.navigation.lockClass
            );
      }),
      t("click", (m, x) => {
        let { $nextEl: y, $prevEl: g } = n.navigation,
          b = x.target;
        if (n.params.navigation.hideOnClick && !ft(b).is(g) && !ft(b).is(y)) {
          if (
            n.pagination &&
            n.params.pagination &&
            n.params.pagination.clickable &&
            (n.pagination.el === b || n.pagination.el.contains(b))
          )
            return;
          let _;
          y
            ? (_ = y.hasClass(n.params.navigation.hiddenClass))
            : g && (_ = g.hasClass(n.params.navigation.hiddenClass)),
            i(_ === !0 ? "navigationShow" : "navigationHide"),
            y && y.toggleClass(n.params.navigation.hiddenClass),
            g && g.toggleClass(n.params.navigation.hiddenClass);
        }
      });
    let f = () => {
        n.$el.removeClass(n.params.navigation.navigationDisabledClass),
          c(),
          a();
      },
      d = () => {
        n.$el.addClass(n.params.navigation.navigationDisabledClass), u();
      };
    Object.assign(n.navigation, {
      enable: f,
      disable: d,
      update: a,
      init: c,
      destroy: u,
    });
  }
  function Ks(n = "") {
    return `.${n
      .trim()
      .replace(/([\.:!\/])/g, "\\$1")
      .replace(/ /g, ".")}`;
  }
  function Nd({ swiper: n, extendParams: e, on: t, emit: i }) {
    let r = "swiper-pagination";
    e({
      pagination: {
        el: null,
        bulletElement: "span",
        clickable: !1,
        hideOnClick: !1,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: !1,
        type: "bullets",
        dynamicBullets: !1,
        dynamicMainBullets: 1,
        formatFractionCurrent: (y) => y,
        formatFractionTotal: (y) => y,
        bulletClass: `${r}-bullet`,
        bulletActiveClass: `${r}-bullet-active`,
        modifierClass: `${r}-`,
        currentClass: `${r}-current`,
        totalClass: `${r}-total`,
        hiddenClass: `${r}-hidden`,
        progressbarFillClass: `${r}-progressbar-fill`,
        progressbarOppositeClass: `${r}-progressbar-opposite`,
        clickableClass: `${r}-clickable`,
        lockClass: `${r}-lock`,
        horizontalClass: `${r}-horizontal`,
        verticalClass: `${r}-vertical`,
        paginationDisabledClass: `${r}-disabled`,
      },
    }),
      (n.pagination = { el: null, $el: null, bullets: [] });
    let s,
      a = 0;
    function o() {
      return (
        !n.params.pagination.el ||
        !n.pagination.el ||
        !n.pagination.$el ||
        n.pagination.$el.length === 0
      );
    }
    function l(y, g) {
      let { bulletActiveClass: b } = n.params.pagination;
      y[g]().addClass(`${b}-${g}`)[g]().addClass(`${b}-${g}-${g}`);
    }
    function c() {
      let y = n.rtl,
        g = n.params.pagination;
      if (o()) return;
      let b =
          n.virtual && n.params.virtual.enabled
            ? n.virtual.slides.length
            : n.slides.length,
        _ = n.pagination.$el,
        E,
        w = n.params.loop
          ? Math.ceil((b - n.loopedSlides * 2) / n.params.slidesPerGroup)
          : n.snapGrid.length;
      if (
        (n.params.loop
          ? ((E = Math.ceil(
              (n.activeIndex - n.loopedSlides) / n.params.slidesPerGroup
            )),
            E > b - 1 - n.loopedSlides * 2 && (E -= b - n.loopedSlides * 2),
            E > w - 1 && (E -= w),
            E < 0 && n.params.paginationType !== "bullets" && (E = w + E))
          : typeof n.snapIndex != "undefined"
          ? (E = n.snapIndex)
          : (E = n.activeIndex || 0),
        g.type === "bullets" &&
          n.pagination.bullets &&
          n.pagination.bullets.length > 0)
      ) {
        let P = n.pagination.bullets,
          L,
          I,
          M;
        if (
          (g.dynamicBullets &&
            ((s = P.eq(0)[n.isHorizontal() ? "outerWidth" : "outerHeight"](!0)),
            _.css(
              n.isHorizontal() ? "width" : "height",
              `${s * (g.dynamicMainBullets + 4)}px`
            ),
            g.dynamicMainBullets > 1 &&
              n.previousIndex !== void 0 &&
              ((a += E - (n.previousIndex - n.loopedSlides || 0)),
              a > g.dynamicMainBullets - 1
                ? (a = g.dynamicMainBullets - 1)
                : a < 0 && (a = 0)),
            (L = Math.max(E - a, 0)),
            (I = L + (Math.min(P.length, g.dynamicMainBullets) - 1)),
            (M = (I + L) / 2)),
          P.removeClass(
            ["", "-next", "-next-next", "-prev", "-prev-prev", "-main"]
              .map((R) => `${g.bulletActiveClass}${R}`)
              .join(" ")
          ),
          _.length > 1)
        )
          P.each((R) => {
            let O = ft(R),
              U = O.index();
            U === E && O.addClass(g.bulletActiveClass),
              g.dynamicBullets &&
                (U >= L && U <= I && O.addClass(`${g.bulletActiveClass}-main`),
                U === L && l(O, "prev"),
                U === I && l(O, "next"));
          });
        else {
          let R = P.eq(E),
            O = R.index();
          if ((R.addClass(g.bulletActiveClass), g.dynamicBullets)) {
            let U = P.eq(L),
              X = P.eq(I);
            for (let $ = L; $ <= I; $ += 1)
              P.eq($).addClass(`${g.bulletActiveClass}-main`);
            if (n.params.loop)
              if (O >= P.length) {
                for (let $ = g.dynamicMainBullets; $ >= 0; $ -= 1)
                  P.eq(P.length - $).addClass(`${g.bulletActiveClass}-main`);
                P.eq(P.length - g.dynamicMainBullets - 1).addClass(
                  `${g.bulletActiveClass}-prev`
                );
              } else l(U, "prev"), l(X, "next");
            else l(U, "prev"), l(X, "next");
          }
        }
        if (g.dynamicBullets) {
          let R = Math.min(P.length, g.dynamicMainBullets + 4),
            O = (s * R - s) / 2 - M * s,
            U = y ? "right" : "left";
          P.css(n.isHorizontal() ? U : "top", `${O}px`);
        }
      }
      if (
        (g.type === "fraction" &&
          (_.find(Ks(g.currentClass)).text(g.formatFractionCurrent(E + 1)),
          _.find(Ks(g.totalClass)).text(g.formatFractionTotal(w))),
        g.type === "progressbar")
      ) {
        let P;
        g.progressbarOpposite
          ? (P = n.isHorizontal() ? "vertical" : "horizontal")
          : (P = n.isHorizontal() ? "horizontal" : "vertical");
        let L = (E + 1) / w,
          I = 1,
          M = 1;
        P === "horizontal" ? (I = L) : (M = L),
          _.find(Ks(g.progressbarFillClass))
            .transform(`translate3d(0,0,0) scaleX(${I}) scaleY(${M})`)
            .transition(n.params.speed);
      }
      g.type === "custom" && g.renderCustom
        ? (_.html(g.renderCustom(n, E + 1, w)), i("paginationRender", _[0]))
        : i("paginationUpdate", _[0]),
        n.params.watchOverflow &&
          n.enabled &&
          _[n.isLocked ? "addClass" : "removeClass"](g.lockClass);
    }
    function u() {
      let y = n.params.pagination;
      if (o()) return;
      let g =
          n.virtual && n.params.virtual.enabled
            ? n.virtual.slides.length
            : n.slides.length,
        b = n.pagination.$el,
        _ = "";
      if (y.type === "bullets") {
        let E = n.params.loop
          ? Math.ceil((g - n.loopedSlides * 2) / n.params.slidesPerGroup)
          : n.snapGrid.length;
        n.params.freeMode &&
          n.params.freeMode.enabled &&
          !n.params.loop &&
          E > g &&
          (E = g);
        for (let w = 0; w < E; w += 1)
          y.renderBullet
            ? (_ += y.renderBullet.call(n, w, y.bulletClass))
            : (_ += `<${y.bulletElement} class="${y.bulletClass}"></${y.bulletElement}>`);
        b.html(_), (n.pagination.bullets = b.find(Ks(y.bulletClass)));
      }
      y.type === "fraction" &&
        (y.renderFraction
          ? (_ = y.renderFraction.call(n, y.currentClass, y.totalClass))
          : (_ = `<span class="${y.currentClass}"></span> / <span class="${y.totalClass}"></span>`),
        b.html(_)),
        y.type === "progressbar" &&
          (y.renderProgressbar
            ? (_ = y.renderProgressbar.call(n, y.progressbarFillClass))
            : (_ = `<span class="${y.progressbarFillClass}"></span>`),
          b.html(_)),
        y.type !== "custom" && i("paginationRender", n.pagination.$el[0]);
    }
    function f() {
      n.params.pagination = ac(
        n,
        n.originalParams.pagination,
        n.params.pagination,
        { el: "swiper-pagination" }
      );
      let y = n.params.pagination;
      if (!y.el) return;
      let g = ft(y.el);
      g.length !== 0 &&
        (n.params.uniqueNavElements &&
          typeof y.el == "string" &&
          g.length > 1 &&
          ((g = n.$el.find(y.el)),
          g.length > 1 &&
            (g = g.filter((b) => ft(b).parents(".swiper")[0] === n.el))),
        y.type === "bullets" && y.clickable && g.addClass(y.clickableClass),
        g.addClass(y.modifierClass + y.type),
        g.addClass(n.isHorizontal() ? y.horizontalClass : y.verticalClass),
        y.type === "bullets" &&
          y.dynamicBullets &&
          (g.addClass(`${y.modifierClass}${y.type}-dynamic`),
          (a = 0),
          y.dynamicMainBullets < 1 && (y.dynamicMainBullets = 1)),
        y.type === "progressbar" &&
          y.progressbarOpposite &&
          g.addClass(y.progressbarOppositeClass),
        y.clickable &&
          g.on("click", Ks(y.bulletClass), function (_) {
            _.preventDefault();
            let E = ft(this).index() * n.params.slidesPerGroup;
            n.params.loop && (E += n.loopedSlides), n.slideTo(E);
          }),
        Object.assign(n.pagination, { $el: g, el: g[0] }),
        n.enabled || g.addClass(y.lockClass));
    }
    function d() {
      let y = n.params.pagination;
      if (o()) return;
      let g = n.pagination.$el;
      g.removeClass(y.hiddenClass),
        g.removeClass(y.modifierClass + y.type),
        g.removeClass(n.isHorizontal() ? y.horizontalClass : y.verticalClass),
        n.pagination.bullets &&
          n.pagination.bullets.removeClass &&
          n.pagination.bullets.removeClass(y.bulletActiveClass),
        y.clickable && g.off("click", Ks(y.bulletClass));
    }
    t("init", () => {
      n.params.pagination.enabled === !1 ? x() : (f(), u(), c());
    }),
      t("activeIndexChange", () => {
        (n.params.loop || typeof n.snapIndex == "undefined") && c();
      }),
      t("snapIndexChange", () => {
        n.params.loop || c();
      }),
      t("slidesLengthChange", () => {
        n.params.loop && (u(), c());
      }),
      t("snapGridLengthChange", () => {
        n.params.loop || (u(), c());
      }),
      t("destroy", () => {
        d();
      }),
      t("enable disable", () => {
        let { $el: y } = n.pagination;
        y &&
          y[n.enabled ? "removeClass" : "addClass"](
            n.params.pagination.lockClass
          );
      }),
      t("lock unlock", () => {
        c();
      }),
      t("click", (y, g) => {
        let b = g.target,
          { $el: _ } = n.pagination;
        if (
          n.params.pagination.el &&
          n.params.pagination.hideOnClick &&
          _ &&
          _.length > 0 &&
          !ft(b).hasClass(n.params.pagination.bulletClass)
        ) {
          if (
            n.navigation &&
            ((n.navigation.nextEl && b === n.navigation.nextEl) ||
              (n.navigation.prevEl && b === n.navigation.prevEl))
          )
            return;
          let E = _.hasClass(n.params.pagination.hiddenClass);
          i(E === !0 ? "paginationShow" : "paginationHide"),
            _.toggleClass(n.params.pagination.hiddenClass);
        }
      });
    let m = () => {
        n.$el.removeClass(n.params.pagination.paginationDisabledClass),
          n.pagination.$el &&
            n.pagination.$el.removeClass(
              n.params.pagination.paginationDisabledClass
            ),
          f(),
          u(),
          c();
      },
      x = () => {
        n.$el.addClass(n.params.pagination.paginationDisabledClass),
          n.pagination.$el &&
            n.pagination.$el.addClass(
              n.params.pagination.paginationDisabledClass
            ),
          d();
      };
    Object.assign(n.pagination, {
      enable: m,
      disable: x,
      render: u,
      update: c,
      init: f,
      destroy: d,
    });
  }
  function kd({ swiper: n, extendParams: e, on: t, emit: i }) {
    e({
      lazy: {
        checkInView: !1,
        enabled: !1,
        loadPrevNext: !1,
        loadPrevNextAmount: 1,
        loadOnTransitionStart: !1,
        scrollingElement: "",
        elementClass: "swiper-lazy",
        loadingClass: "swiper-lazy-loading",
        loadedClass: "swiper-lazy-loaded",
        preloaderClass: "swiper-lazy-preloader",
      },
    }),
      (n.lazy = {});
    let r = !1,
      s = !1;
    function a(c, u = !0) {
      let f = n.params.lazy;
      if (typeof c == "undefined" || n.slides.length === 0) return;
      let m =
          n.virtual && n.params.virtual.enabled
            ? n.$wrapperEl.children(
                `.${n.params.slideClass}[data-swiper-slide-index="${c}"]`
              )
            : n.slides.eq(c),
        x = m.find(
          `.${f.elementClass}:not(.${f.loadedClass}):not(.${f.loadingClass})`
        );
      m.hasClass(f.elementClass) &&
        !m.hasClass(f.loadedClass) &&
        !m.hasClass(f.loadingClass) &&
        x.push(m[0]),
        x.length !== 0 &&
          x.each((y) => {
            let g = ft(y);
            g.addClass(f.loadingClass);
            let b = g.attr("data-background"),
              _ = g.attr("data-src"),
              E = g.attr("data-srcset"),
              w = g.attr("data-sizes"),
              P = g.parent("picture");
            n.loadImage(g[0], _ || b, E, w, !1, () => {
              if (
                !(
                  typeof n == "undefined" ||
                  n === null ||
                  !n ||
                  (n && !n.params) ||
                  n.destroyed
                )
              ) {
                if (
                  (b
                    ? (g.css("background-image", `url("${b}")`),
                      g.removeAttr("data-background"))
                    : (E && (g.attr("srcset", E), g.removeAttr("data-srcset")),
                      w && (g.attr("sizes", w), g.removeAttr("data-sizes")),
                      P.length &&
                        P.children("source").each((L) => {
                          let I = ft(L);
                          I.attr("data-srcset") &&
                            (I.attr("srcset", I.attr("data-srcset")),
                            I.removeAttr("data-srcset"));
                        }),
                      _ && (g.attr("src", _), g.removeAttr("data-src"))),
                  g.addClass(f.loadedClass).removeClass(f.loadingClass),
                  m.find(`.${f.preloaderClass}`).remove(),
                  n.params.loop && u)
                ) {
                  let L = m.attr("data-swiper-slide-index");
                  if (m.hasClass(n.params.slideDuplicateClass)) {
                    let I = n.$wrapperEl.children(
                      `[data-swiper-slide-index="${L}"]:not(.${n.params.slideDuplicateClass})`
                    );
                    a(I.index(), !1);
                  } else {
                    let I = n.$wrapperEl.children(
                      `.${n.params.slideDuplicateClass}[data-swiper-slide-index="${L}"]`
                    );
                    a(I.index(), !1);
                  }
                }
                i("lazyImageReady", m[0], g[0]),
                  n.params.autoHeight && n.updateAutoHeight();
              }
            }),
              i("lazyImageLoad", m[0], g[0]);
          });
    }
    function o() {
      let { $wrapperEl: c, params: u, slides: f, activeIndex: d } = n,
        m = n.virtual && u.virtual.enabled,
        x = u.lazy,
        y = u.slidesPerView;
      y === "auto" && (y = 0);
      function g(_) {
        if (m) {
          if (
            c.children(`.${u.slideClass}[data-swiper-slide-index="${_}"]`)
              .length
          )
            return !0;
        } else if (f[_]) return !0;
        return !1;
      }
      function b(_) {
        return m ? ft(_).attr("data-swiper-slide-index") : ft(_).index();
      }
      if ((s || (s = !0), n.params.watchSlidesProgress))
        c.children(`.${u.slideVisibleClass}`).each((_) => {
          let E = m ? ft(_).attr("data-swiper-slide-index") : ft(_).index();
          a(E);
        });
      else if (y > 1) for (let _ = d; _ < d + y; _ += 1) g(_) && a(_);
      else a(d);
      if (x.loadPrevNext)
        if (y > 1 || (x.loadPrevNextAmount && x.loadPrevNextAmount > 1)) {
          let _ = x.loadPrevNextAmount,
            E = Math.ceil(y),
            w = Math.min(d + E + Math.max(_, E), f.length),
            P = Math.max(d - Math.max(E, _), 0);
          for (let L = d + E; L < w; L += 1) g(L) && a(L);
          for (let L = P; L < d; L += 1) g(L) && a(L);
        } else {
          let _ = c.children(`.${u.slideNextClass}`);
          _.length > 0 && a(b(_));
          let E = c.children(`.${u.slidePrevClass}`);
          E.length > 0 && a(b(E));
        }
    }
    function l() {
      let c = ai();
      if (!n || n.destroyed) return;
      let u = n.params.lazy.scrollingElement
          ? ft(n.params.lazy.scrollingElement)
          : ft(c),
        f = u[0] === c,
        d = f ? c.innerWidth : u[0].offsetWidth,
        m = f ? c.innerHeight : u[0].offsetHeight,
        x = n.$el.offset(),
        { rtlTranslate: y } = n,
        g = !1;
      y && (x.left -= n.$el[0].scrollLeft);
      let b = [
        [x.left, x.top],
        [x.left + n.width, x.top],
        [x.left, x.top + n.height],
        [x.left + n.width, x.top + n.height],
      ];
      for (let E = 0; E < b.length; E += 1) {
        let w = b[E];
        if (w[0] >= 0 && w[0] <= d && w[1] >= 0 && w[1] <= m) {
          if (w[0] === 0 && w[1] === 0) continue;
          g = !0;
        }
      }
      let _ =
        n.touchEvents.start === "touchstart" &&
        n.support.passiveListener &&
        n.params.passiveListeners
          ? { passive: !0, capture: !1 }
          : !1;
      g ? (o(), u.off("scroll", l, _)) : r || ((r = !0), u.on("scroll", l, _));
    }
    t("beforeInit", () => {
      n.params.lazy.enabled &&
        n.params.preloadImages &&
        (n.params.preloadImages = !1);
    }),
      t("init", () => {
        n.params.lazy.enabled && (n.params.lazy.checkInView ? l() : o());
      }),
      t("scroll", () => {
        n.params.freeMode &&
          n.params.freeMode.enabled &&
          !n.params.freeMode.sticky &&
          o();
      }),
      t("scrollbarDragMove resize _freeModeNoMomentumRelease", () => {
        n.params.lazy.enabled && (n.params.lazy.checkInView ? l() : o());
      }),
      t("transitionStart", () => {
        n.params.lazy.enabled &&
          (n.params.lazy.loadOnTransitionStart ||
            (!n.params.lazy.loadOnTransitionStart && !s)) &&
          (n.params.lazy.checkInView ? l() : o());
      }),
      t("transitionEnd", () => {
        n.params.lazy.enabled &&
          !n.params.lazy.loadOnTransitionStart &&
          (n.params.lazy.checkInView ? l() : o());
      }),
      t("slideChange", () => {
        let {
          lazy: c,
          cssMode: u,
          watchSlidesProgress: f,
          touchReleaseOnEdges: d,
          resistanceRatio: m,
        } = n.params;
        c.enabled && (u || (f && (d || m === 0))) && o();
      }),
      t("destroy", () => {
        !n.$el ||
          n.$el
            .find(`.${n.params.lazy.loadingClass}`)
            .removeClass(n.params.lazy.loadingClass);
      }),
      Object.assign(n.lazy, { load: o, loadInSlide: a });
  }
  var cv = class extends St {
    constructor(n) {
      super(n);
      (this.$container = this.$("container")[0]),
        (this.$pagination = this.$("pagination")[0]),
        (this.$nextBtn = this.$("next")[0]),
        console.log(this);
    }
    init() {
      this.swiper = new Rd(this.$container, {
        modules: [kd, Nd, Od],
        loop: !0,
        loopAdditionalSlides: 1,
        preloadImages: !1,
        grabCursor: !0,
        lazy: { checkInView: !0, loadPrevNext: !0 },
        pagination: {
          el: this.$pagination,
          type: "custom",
          renderCustom(n, e, t) {
            return `${e.toString().padStart(2, "0")} / ${t
              .toString()
              .padStart(2, "0")}`;
          },
        },
        navigation: { nextEl: this.$nextBtn },
        on: {
          init(n) {
            if (n.lazy && n.lazy.enabled !== !1)
              for (let e of n.slides) e.classList.add("-pixelated");
          },
          lazyImageReady(n, e, t) {
            rr(t), e.classList.remove("-pixelated");
          },
          slideChange(n) {
            let t = n.slides[n.activeIndex].getAttribute(
              "data-swiper-slide-index"
            );
            for (let i of n.slides.filter(
              (r) => r.getAttribute("data-swiper-slide-index") == t
            )) {
              let r = i.querySelector("video");
              r == null || r.play();
            }
          },
          click(n, e) {
            n.clickedSlide.classList.contains("swiper-slide-next") &&
              n.slideNext();
          },
        },
      });
    }
    inview(n) {
      n.target == this.el && this.swiper.lazy.load();
    }
  };
  var Js = class extends St {
    static get settings() {
      return {
        GUTTER: "var(--grid-gutter, 0)",
        MARGIN: "var(--grid-margin, 0)",
        COLOR: "var(--grid-color)",
      };
    }
    constructor(e) {
      super(e);
    }
    init() {
      this.setColumns(),
        this.setStyles(),
        this.bindEvents(),
        window.addEventListener(
          "resize",
          (this.onResize = () => this.setColumns())
        );
    }
    setColumns() {
      this.el.innerHTML = "";
      let e = Number(
          window.getComputedStyle(this.el).getPropertyValue("--grid-columns")
        ),
        t;
      for (var i = 0; i < e; i++)
        (t = document.createElement("div")),
          (t.style.flex = "1 1 0"),
          (t.style.backgroundColor = Js.settings.COLOR),
          this.el.appendChild(t);
    }
    setStyles() {
      let e = this.el.style;
      (e.zIndex = "10000"),
        (e.position = "fixed"),
        (e.top = "0"),
        (e.left = "0"),
        (e.display = "flex"),
        (e.width = "100%"),
        (e.height = "100%"),
        (e.columnGap = Js.settings.GUTTER),
        (e.paddingLeft = `calc(${Js.settings.MARGIN}`),
        (e.paddingRight = `calc(${Js.settings.MARGIN}`),
        (e.pointerEvents = "none"),
        (e.visibility = "hidden"),
        (e.opacity = 0.1);
    }
    bindEvents() {
      let e = !1,
        t = !1;
      document.addEventListener("keydown", (i) => {
        i.key == "Control"
          ? (e = !0)
          : e &&
            i.key == "g" &&
            (t
              ? (this.el.style.visibility = "visible")
              : (this.el.style.visibility = "hidden"),
            (t = !t));
      }),
        document.addEventListener("keyup", (i) => {
          i.key == "Control" && (e = !1);
        });
    }
    destroy() {
      window.removeEventListener("resize", this.onResize);
    }
  };
  var Gt = document.documentElement,
    zne = document.body,
    Une = Gt.hasAttribute("data-debug"),
    rM = document.createElement("canvas"),
    sM;
  try {
    sM = rM.getContext("webgl") || rM.getContext("experimental-webgl");
  } catch (n) {
    console.error(n);
  }
  var oc = !!sM;
  oc ||
    (Gt.classList.add("has-no-webgl-support"),
    alert(
      "Your browser does not support WebGL. Unfortunately that means you will not get the full experience from our website and miss out on cool features. We recommend you to update your browser to a modern version!"
    ));
  var Dt = [];
  var oM = [
      "input",
      "select",
      "textarea",
      "a[href]",
      "button",
      "[tabindex]:not(slot)",
      "audio[controls]",
      "video[controls]",
      '[contenteditable]:not([contenteditable="false"])',
      "details>summary:first-of-type",
      "details",
    ],
    Bd = oM.join(","),
    lM = typeof Element == "undefined",
    Yo = lM
      ? function () {}
      : Element.prototype.matches ||
        Element.prototype.msMatchesSelector ||
        Element.prototype.webkitMatchesSelector,
    zd =
      !lM && Element.prototype.getRootNode
        ? function (n) {
            return n.getRootNode();
          }
        : function (n) {
            return n.ownerDocument;
          },
    cM = function (e, t, i) {
      var r = Array.prototype.slice.apply(e.querySelectorAll(Bd));
      return t && Yo.call(e, Bd) && r.unshift(e), (r = r.filter(i)), r;
    },
    uM = function n(e, t, i) {
      for (var r = [], s = Array.from(e); s.length; ) {
        var a = s.shift();
        if (a.tagName === "SLOT") {
          var o = a.assignedElements(),
            l = o.length ? o : a.children,
            c = n(l, !0, i);
          i.flatten ? r.push.apply(r, c) : r.push({ scope: a, candidates: c });
        } else {
          var u = Yo.call(a, Bd);
          u && i.filter(a) && (t || !e.includes(a)) && r.push(a);
          var f =
              a.shadowRoot ||
              (typeof i.getShadowRoot == "function" && i.getShadowRoot(a)),
            d = !i.shadowRootFilter || i.shadowRootFilter(a);
          if (f && d) {
            var m = n(f === !0 ? a.children : f.children, !0, i);
            i.flatten
              ? r.push.apply(r, m)
              : r.push({ scope: a, candidates: m });
          } else s.unshift.apply(s, a.children);
        }
      }
      return r;
    },
    hM = function (e, t) {
      return e.tabIndex < 0 &&
        (t ||
          /^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) ||
          e.isContentEditable) &&
        isNaN(parseInt(e.getAttribute("tabindex"), 10))
        ? 0
        : e.tabIndex;
    },
    d4 = function (e, t) {
      return e.tabIndex === t.tabIndex
        ? e.documentOrder - t.documentOrder
        : e.tabIndex - t.tabIndex;
    },
    fM = function (e) {
      return e.tagName === "INPUT";
    },
    p4 = function (e) {
      return fM(e) && e.type === "hidden";
    },
    m4 = function (e) {
      var t =
        e.tagName === "DETAILS" &&
        Array.prototype.slice.apply(e.children).some(function (i) {
          return i.tagName === "SUMMARY";
        });
      return t;
    },
    g4 = function (e, t) {
      for (var i = 0; i < e.length; i++)
        if (e[i].checked && e[i].form === t) return e[i];
    },
    y4 = function (e) {
      if (!e.name) return !0;
      var t = e.form || zd(e),
        i = function (o) {
          return t.querySelectorAll('input[type="radio"][name="' + o + '"]');
        },
        r;
      if (
        typeof window != "undefined" &&
        typeof window.CSS != "undefined" &&
        typeof window.CSS.escape == "function"
      )
        r = i(window.CSS.escape(e.name));
      else
        try {
          r = i(e.name);
        } catch (a) {
          return (
            console.error(
              "Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s",
              a.message
            ),
            !1
          );
        }
      var s = g4(r, e.form);
      return !s || s === e;
    },
    v4 = function (e) {
      return fM(e) && e.type === "radio";
    },
    x4 = function (e) {
      return v4(e) && !y4(e);
    },
    b4 = function (e) {
      for (
        var t,
          i = zd(e).host,
          r = !!(
            ((t = i) !== null && t !== void 0 && t.ownerDocument.contains(i)) ||
            e.ownerDocument.contains(e)
          );
        !r && i;

      ) {
        var s;
        (i = zd(i).host),
          (r = !!(
            (s = i) !== null &&
            s !== void 0 &&
            s.ownerDocument.contains(i)
          ));
      }
      return r;
    },
    aM = function (e) {
      var t = e.getBoundingClientRect(),
        i = t.width,
        r = t.height;
      return i === 0 && r === 0;
    },
    _4 = function (e, t) {
      var i = t.displayCheck,
        r = t.getShadowRoot;
      if (getComputedStyle(e).visibility === "hidden") return !0;
      var s = Yo.call(e, "details>summary:first-of-type"),
        a = s ? e.parentElement : e;
      if (Yo.call(a, "details:not([open]) *")) return !0;
      if (!i || i === "full" || i === "legacy-full") {
        if (typeof r == "function") {
          for (var o = e; e; ) {
            var l = e.parentElement,
              c = zd(e);
            if (l && !l.shadowRoot && r(l) === !0) return aM(e);
            e.assignedSlot
              ? (e = e.assignedSlot)
              : !l && c !== e.ownerDocument
              ? (e = c.host)
              : (e = l);
          }
          e = o;
        }
        if (b4(e)) return !e.getClientRects().length;
        if (i !== "legacy-full") return !0;
      } else if (i === "non-zero-area") return aM(e);
      return !1;
    },
    E4 = function (e) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
        for (var t = e.parentElement; t; ) {
          if (t.tagName === "FIELDSET" && t.disabled) {
            for (var i = 0; i < t.children.length; i++) {
              var r = t.children.item(i);
              if (r.tagName === "LEGEND")
                return Yo.call(t, "fieldset[disabled] *") ? !0 : !r.contains(e);
            }
            return !0;
          }
          t = t.parentElement;
        }
      return !1;
    },
    Ud = function (e, t) {
      return !(t.disabled || p4(t) || _4(t, e) || m4(t) || E4(t));
    },
    uv = function (e, t) {
      return !(x4(t) || hM(t) < 0 || !Ud(e, t));
    },
    T4 = function (e) {
      var t = parseInt(e.getAttribute("tabindex"), 10);
      return !!(isNaN(t) || t >= 0);
    },
    S4 = function n(e) {
      var t = [],
        i = [];
      return (
        e.forEach(function (r, s) {
          var a = !!r.scope,
            o = a ? r.scope : r,
            l = hM(o, a),
            c = a ? n(r.candidates) : o;
          l === 0
            ? a
              ? t.push.apply(t, c)
              : t.push(o)
            : i.push({
                documentOrder: s,
                tabIndex: l,
                item: r,
                isScope: a,
                content: c,
              });
        }),
        i
          .sort(d4)
          .reduce(function (r, s) {
            return (
              s.isScope ? r.push.apply(r, s.content) : r.push(s.content), r
            );
          }, [])
          .concat(t)
      );
    },
    dM = function (e, t) {
      t = t || {};
      var i;
      return (
        t.getShadowRoot
          ? (i = uM([e], t.includeContainer, {
              filter: uv.bind(null, t),
              flatten: !1,
              getShadowRoot: t.getShadowRoot,
              shadowRootFilter: T4,
            }))
          : (i = cM(e, t.includeContainer, uv.bind(null, t))),
        S4(i)
      );
    },
    pM = function (e, t) {
      t = t || {};
      var i;
      return (
        t.getShadowRoot
          ? (i = uM([e], t.includeContainer, {
              filter: Ud.bind(null, t),
              flatten: !0,
              getShadowRoot: t.getShadowRoot,
            }))
          : (i = cM(e, t.includeContainer, Ud.bind(null, t))),
        i
      );
    },
    qu = function (e, t) {
      if (((t = t || {}), !e)) throw new Error("No node provided");
      return Yo.call(e, Bd) === !1 ? !1 : uv(t, e);
    },
    w4 = oM.concat("iframe").join(","),
    Vd = function (e, t) {
      if (((t = t || {}), !e)) throw new Error("No node provided");
      return Yo.call(e, w4) === !1 ? !1 : Ud(t, e);
    };
  function mM(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(n);
      e &&
        (i = i.filter(function (r) {
          return Object.getOwnPropertyDescriptor(n, r).enumerable;
        })),
        t.push.apply(t, i);
    }
    return t;
  }
  function gM(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e] != null ? arguments[e] : {};
      e % 2
        ? mM(Object(t), !0).forEach(function (i) {
            M4(n, i, t[i]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
        : mM(Object(t)).forEach(function (i) {
            Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
          });
    }
    return n;
  }
  function M4(n, e, t) {
    return (
      e in n
        ? Object.defineProperty(n, e, {
            value: t,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (n[e] = t),
      n
    );
  }
  var yM = (function () {
      var n = [];
      return {
        activateTrap: function (t) {
          if (n.length > 0) {
            var i = n[n.length - 1];
            i !== t && i.pause();
          }
          var r = n.indexOf(t);
          r === -1 || n.splice(r, 1), n.push(t);
        },
        deactivateTrap: function (t) {
          var i = n.indexOf(t);
          i !== -1 && n.splice(i, 1), n.length > 0 && n[n.length - 1].unpause();
        },
      };
    })(),
    A4 = function (e) {
      return (
        e.tagName &&
        e.tagName.toLowerCase() === "input" &&
        typeof e.select == "function"
      );
    },
    C4 = function (e) {
      return e.key === "Escape" || e.key === "Esc" || e.keyCode === 27;
    },
    P4 = function (e) {
      return e.key === "Tab" || e.keyCode === 9;
    },
    vM = function (e) {
      return setTimeout(e, 0);
    },
    xM = function (e, t) {
      var i = -1;
      return (
        e.every(function (r, s) {
          return t(r) ? ((i = s), !1) : !0;
        }),
        i
      );
    },
    ju = function (e) {
      for (
        var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1;
        r < t;
        r++
      )
        i[r - 1] = arguments[r];
      return typeof e == "function" ? e.apply(void 0, i) : e;
    },
    Gd = function (e) {
      return e.target.shadowRoot && typeof e.composedPath == "function"
        ? e.composedPath()[0]
        : e.target;
    },
    ws = function (e, t) {
      var i = (t == null ? void 0 : t.document) || document,
        r = gM(
          {
            returnFocusOnDeactivate: !0,
            escapeDeactivates: !0,
            delayInitialFocus: !0,
          },
          t
        ),
        s = {
          containers: [],
          containerGroups: [],
          tabbableGroups: [],
          nodeFocusedBeforeActivation: null,
          mostRecentlyFocusedNode: null,
          active: !1,
          paused: !1,
          delayInitialFocusTimer: void 0,
        },
        a,
        o = function (L, I, M) {
          return L && L[I] !== void 0 ? L[I] : r[M || I];
        },
        l = function (L) {
          return s.containerGroups.findIndex(function (I) {
            var M = I.container,
              R = I.tabbableNodes;
            return (
              M.contains(L) ||
              R.find(function (O) {
                return O === L;
              })
            );
          });
        },
        c = function (L) {
          var I = r[L];
          if (typeof I == "function") {
            for (
              var M = arguments.length, R = new Array(M > 1 ? M - 1 : 0), O = 1;
              O < M;
              O++
            )
              R[O - 1] = arguments[O];
            I = I.apply(void 0, R);
          }
          if ((I === !0 && (I = void 0), !I)) {
            if (I === void 0 || I === !1) return I;
            throw new Error(
              "`".concat(
                L,
                "` was specified but was not a node, or did not return a node"
              )
            );
          }
          var U = I;
          if (typeof I == "string" && ((U = i.querySelector(I)), !U))
            throw new Error(
              "`".concat(L, "` as selector refers to no known node")
            );
          return U;
        },
        u = function () {
          var L = c("initialFocus");
          if (L === !1) return !1;
          if (L === void 0)
            if (l(i.activeElement) >= 0) L = i.activeElement;
            else {
              var I = s.tabbableGroups[0],
                M = I && I.firstTabbableNode;
              L = M || c("fallbackFocus");
            }
          if (!L)
            throw new Error(
              "Your focus-trap needs to have at least one focusable element"
            );
          return L;
        },
        f = function () {
          if (
            ((s.containerGroups = s.containers.map(function (L) {
              var I = dM(L, r.tabbableOptions),
                M = pM(L, r.tabbableOptions);
              return {
                container: L,
                tabbableNodes: I,
                focusableNodes: M,
                firstTabbableNode: I.length > 0 ? I[0] : null,
                lastTabbableNode: I.length > 0 ? I[I.length - 1] : null,
                nextTabbableNode: function (O) {
                  var U =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : !0,
                    X = M.findIndex(function ($) {
                      return $ === O;
                    });
                  if (!(X < 0))
                    return U
                      ? M.slice(X + 1).find(function ($) {
                          return qu($, r.tabbableOptions);
                        })
                      : M.slice(0, X)
                          .reverse()
                          .find(function ($) {
                            return qu($, r.tabbableOptions);
                          });
                },
              };
            })),
            (s.tabbableGroups = s.containerGroups.filter(function (L) {
              return L.tabbableNodes.length > 0;
            })),
            s.tabbableGroups.length <= 0 && !c("fallbackFocus"))
          )
            throw new Error(
              "Your focus-trap must have at least one container with at least one tabbable node in it at all times"
            );
        },
        d = function P(L) {
          if (L !== !1 && L !== i.activeElement) {
            if (!L || !L.focus) {
              P(u());
              return;
            }
            L.focus({ preventScroll: !!r.preventScroll }),
              (s.mostRecentlyFocusedNode = L),
              A4(L) && L.select();
          }
        },
        m = function (L) {
          var I = c("setReturnFocus", L);
          return I || (I === !1 ? !1 : L);
        },
        x = function (L) {
          var I = Gd(L);
          if (!(l(I) >= 0)) {
            if (ju(r.clickOutsideDeactivates, L)) {
              a.deactivate({
                returnFocus:
                  r.returnFocusOnDeactivate && !Vd(I, r.tabbableOptions),
              });
              return;
            }
            ju(r.allowOutsideClick, L) || L.preventDefault();
          }
        },
        y = function (L) {
          var I = Gd(L),
            M = l(I) >= 0;
          M || I instanceof Document
            ? M && (s.mostRecentlyFocusedNode = I)
            : (L.stopImmediatePropagation(),
              d(s.mostRecentlyFocusedNode || u()));
        },
        g = function (L) {
          var I = Gd(L);
          f();
          var M = null;
          if (s.tabbableGroups.length > 0) {
            var R = l(I),
              O = R >= 0 ? s.containerGroups[R] : void 0;
            if (R < 0)
              L.shiftKey
                ? (M =
                    s.tabbableGroups[s.tabbableGroups.length - 1]
                      .lastTabbableNode)
                : (M = s.tabbableGroups[0].firstTabbableNode);
            else if (L.shiftKey) {
              var U = xM(s.tabbableGroups, function (he) {
                var ce = he.firstTabbableNode;
                return I === ce;
              });
              if (
                (U < 0 &&
                  (O.container === I ||
                    (Vd(I, r.tabbableOptions) &&
                      !qu(I, r.tabbableOptions) &&
                      !O.nextTabbableNode(I, !1))) &&
                  (U = R),
                U >= 0)
              ) {
                var X = U === 0 ? s.tabbableGroups.length - 1 : U - 1,
                  $ = s.tabbableGroups[X];
                M = $.lastTabbableNode;
              }
            } else {
              var W = xM(s.tabbableGroups, function (he) {
                var ce = he.lastTabbableNode;
                return I === ce;
              });
              if (
                (W < 0 &&
                  (O.container === I ||
                    (Vd(I, r.tabbableOptions) &&
                      !qu(I, r.tabbableOptions) &&
                      !O.nextTabbableNode(I))) &&
                  (W = R),
                W >= 0)
              ) {
                var ue = W === s.tabbableGroups.length - 1 ? 0 : W + 1,
                  ae = s.tabbableGroups[ue];
                M = ae.firstTabbableNode;
              }
            }
          } else M = c("fallbackFocus");
          M && (L.preventDefault(), d(M));
        },
        b = function (L) {
          if (C4(L) && ju(r.escapeDeactivates, L) !== !1) {
            L.preventDefault(), a.deactivate();
            return;
          }
          if (P4(L)) {
            g(L);
            return;
          }
        },
        _ = function (L) {
          var I = Gd(L);
          l(I) >= 0 ||
            ju(r.clickOutsideDeactivates, L) ||
            ju(r.allowOutsideClick, L) ||
            (L.preventDefault(), L.stopImmediatePropagation());
        },
        E = function () {
          if (!!s.active)
            return (
              yM.activateTrap(a),
              (s.delayInitialFocusTimer = r.delayInitialFocus
                ? vM(function () {
                    d(u());
                  })
                : d(u())),
              i.addEventListener("focusin", y, !0),
              i.addEventListener("mousedown", x, { capture: !0, passive: !1 }),
              i.addEventListener("touchstart", x, { capture: !0, passive: !1 }),
              i.addEventListener("click", _, { capture: !0, passive: !1 }),
              i.addEventListener("keydown", b, { capture: !0, passive: !1 }),
              a
            );
        },
        w = function () {
          if (!!s.active)
            return (
              i.removeEventListener("focusin", y, !0),
              i.removeEventListener("mousedown", x, !0),
              i.removeEventListener("touchstart", x, !0),
              i.removeEventListener("click", _, !0),
              i.removeEventListener("keydown", b, !0),
              a
            );
        };
      return (
        (a = {
          get active() {
            return s.active;
          },
          get paused() {
            return s.paused;
          },
          activate: function (L) {
            if (s.active) return this;
            var I = o(L, "onActivate"),
              M = o(L, "onPostActivate"),
              R = o(L, "checkCanFocusTrap");
            R || f(),
              (s.active = !0),
              (s.paused = !1),
              (s.nodeFocusedBeforeActivation = i.activeElement),
              I && I();
            var O = function () {
              R && f(), E(), M && M();
            };
            return R
              ? (R(s.containers.concat()).then(O, O), this)
              : (O(), this);
          },
          deactivate: function (L) {
            if (!s.active) return this;
            var I = gM(
              {
                onDeactivate: r.onDeactivate,
                onPostDeactivate: r.onPostDeactivate,
                checkCanReturnFocus: r.checkCanReturnFocus,
              },
              L
            );
            clearTimeout(s.delayInitialFocusTimer),
              (s.delayInitialFocusTimer = void 0),
              w(),
              (s.active = !1),
              (s.paused = !1),
              yM.deactivateTrap(a);
            var M = o(I, "onDeactivate"),
              R = o(I, "onPostDeactivate"),
              O = o(I, "checkCanReturnFocus"),
              U = o(I, "returnFocus", "returnFocusOnDeactivate");
            M && M();
            var X = function () {
              vM(function () {
                U && d(m(s.nodeFocusedBeforeActivation)), R && R();
              });
            };
            return U && O
              ? (O(m(s.nodeFocusedBeforeActivation)).then(X, X), this)
              : (X(), this);
          },
          pause: function () {
            return s.paused || !s.active ? this : ((s.paused = !0), w(), this);
          },
          unpause: function () {
            return !s.paused || !s.active
              ? this
              : ((s.paused = !1), f(), E(), this);
          },
          updateContainerElements: function (L) {
            var I = [].concat(L).filter(Boolean);
            return (
              (s.containers = I.map(function (M) {
                return typeof M == "string" ? i.querySelector(M) : M;
              })),
              s.active && f(),
              this
            );
          },
        }),
        a.updateContainerElements(e),
        a
      );
    };
  function bM(n) {
    for (
      var e = typeof n == "string" ? n.split("") : n, t = e.length, i = t - 1;
      i > 0;
      i--
    ) {
      var r = Math.floor(Math.random() * (i + 1)),
        s = e[i];
      (e[i] = e[r]), (e[r] = s);
    }
    return e.join("");
  }
  function lc(n) {
    let e = typeof n == "string" ? n.split("") : n,
      t = Math.floor(Math.random() * e.length),
      i = e.splice(t, 1)[0],
      r = Math.floor(Math.random() * e.length);
    return e.splice(r, 0, i), e.join("");
  }
  var hv = class extends St {
    constructor(n) {
      super(n);
      (this.$header = this.$("header")[0]),
        (this.$menuToggler = this.$("menu-toggler")[0]),
        (this.$menu = this.$("menu")[0]),
        (this.events = {
          click: { "menu-toggler": "toggleMenu", logo: "hideMenu" },
        });
    }
    init() {
      window.addEventListener(
        "keydown",
        (this.onKeyDown = (n) => {
          n.keyCode === 27 && this.hasMenuOpened() && this.hideMenu();
        })
      ),
        (this.focusTrap = ws([this.$header, this.$menu]));
    }
    hasMenuOpened() {
      return Gt.classList.contains("has-menu-opened");
    }
    showMenu() {
      Gt.classList.add("has-menu-opened"),
        (this.$menuToggler.innerText = this.getData(
          "close-label",
          this.$menuToggler
        )),
        this.$menuToggler.setAttribute("aria-expanded", !0),
        this.focusTrap.activate();
    }
    hideMenu() {
      Gt.classList.remove("has-menu-opened"),
        (this.$menuToggler.innerText = this.getData(
          "open-label",
          this.$menuToggler
        )),
        this.$menuToggler.setAttribute("aria-expanded", !1),
        this.focusTrap.deactivate();
    }
    toggleMenu() {
      this.hasMenuOpened() ? this.hideMenu() : this.showMenu();
    }
    destroy() {
      super.destroy(), this.focusTrap.deactivate();
    }
  };
  var fv = class extends St {
    constructor(n) {
      super(n);
    }
    inview(n) {
      n.target == this.el &&
        Gt.classList.toggle("is-over-home-hero", n.way == "enter");
    }
    destroy() {
      Gt.classList.remove("is-over-home-hero");
    }
  };
  var D4 = 0.25,
    dv = class extends St {
      constructor(n) {
        super(n);
        this.shuffleElements = [];
      }
      init() {
        (this.onItemEnterBind = this.onItemEnter.bind(this)),
          (this.onItemLeaveBind = this.onItemLeave.bind(this)),
          this.update();
      }
      onItemEnter(n) {
        let e = n.currentTarget,
          t = [];
        e.dataset.hoverShuffle == "children"
          ? e.querySelectorAll("[data-hover-shuffle-child]").forEach((s) => {
              t.push(s), s.setAttribute("aria-label", s.innerText);
            })
          : ((t = [e]), e.setAttribute("aria-label", e.innerText)),
          (this.tw = yt.timeline({
            onComplete: () => {
              t.forEach((s) => {
                (s.innerText = s.getAttribute("aria-label")),
                  s.removeAttribute("aria-label");
              });
            },
          }));
        let i = 4,
          r = D4 / i;
        for (let s = 0; s < i; s++)
          for (let a of t)
            this.tw.add(() => {
              Fa(a, bM);
            }, r * s);
      }
      onItemLeave(n) {
        this.tw && this.tw.kill();
        let e = n.currentTarget,
          t = [];
        e.dataset.hoverShuffle == "children"
          ? e.querySelectorAll("[data-hover-shuffle-child]").forEach((i) => {
              t.push(i);
            })
          : (t = [e]),
          t.forEach((i) => {
            i.getAttribute("aria-label") &&
              (i.innerText = i.getAttribute("aria-label")),
              i.removeAttribute("aria-label");
          });
      }
      reset() {
        this.shuffleElements.forEach((n) => {
          n.removeEventListener("mouseenter", this.onItemEnterBind),
            n.removeEventListener("mouseleave", this.onItemLeaveBind);
        }),
          (this.shuffleElements = []);
      }
      update() {
        this.reset(),
          document.querySelectorAll("[data-hover-shuffle]").forEach((n) => {
            n.addEventListener("mouseenter", this.onItemEnterBind),
              n.addEventListener("mouseleave", this.onItemLeaveBind),
              this.shuffleElements.push(n);
          });
      }
    };
  var I4 = 0;
  Promise.pending = Promise.race.bind(Promise, []);
  var pv = class extends St {
    constructor(n) {
      super(n);
      let e = this.getData("images-path");
      if (!e) {
        console.warn(
          "Please add the sequence path in data-images-sequence-images-path"
        );
        return;
      }
      (this.onResizeBind = this.onResize.bind(this)),
        (this.onUpdateBind = this.onUpdate.bind(this)),
        (this.$el = this.$("ref")[0]),
        (this.$canvas = this.$("canvas")[0]),
        (this.width = !1),
        (this.height = this.$el.offsetHeight),
        (this.dpr = window.devicePixelRatio),
        (this.progress = 0),
        (this.preloadStep = 16),
        (this.isSequenceReady = !1),
        (this.totalFrames = this.getData("total-frames") || 0),
        (this.images = {
          path: e,
          exension: ".jpg",
          totalLength: parseInt(this.totalFrames),
          framesToLoad: [],
          framesLoaded: [],
        }),
        (this.autoplay = this.getData("autoplay") || !1),
        (this.raf = {
          framerate: (1 / 120) * 1e3,
          deltaTime: 0,
          time: performance.now(),
          lt: performance.now(),
          elapsedInterval: 0,
        });
    }
    init() {
      this.updateSize(),
        this.bindEvents(),
        window.isFontsLoaded && this.onFontsLoaded(),
        this.setImages(),
        this.getData("force-launch") != null && this.launch();
    }
    launch() {
      return Fr(this, null, function* () {
        (this.launched = !0),
          yield this.loadSequence(!0),
          (this.isSequenceReady = !0),
          this.el.classList.add("is-sequence-loaded"),
          this.onUpdate(),
          this.autoplay &&
            setTimeout(() => {
              this.play();
            }, 1e3);
      });
    }
    destroy() {
      super.destroy(), (this.aborted = !0), this.unbindEvents(), this.onLeave();
    }
    bindEvents() {
      window.addEventListener("resize", this.onResizeBind);
    }
    unbindEvents() {
      window.removeEventListener("resize", this.onResizeBind);
    }
    onResize() {
      this.resizeTick ||
        ((this.resizeTick = !0),
        requestAnimationFrame(() => {
          this.updateSize(), (this.resizeTick = !1);
        }));
    }
    onUpdate() {
      !this.isPlaying ||
        !this.isSequenceReady ||
        ((this.raf.time = performance.now()),
        (this.raf.deltaTime = this.raf.time - this.raf.lt),
        (this.raf.elapsedInterval += this.raf.deltaTime),
        this.raf.elapsedInterval >= this.raf.framerate &&
          ((this.raf.elapsedInterval = 0),
          this.setCurrentFrame(),
          this.drawImage()),
        (this.raf.lt = this.raf.time));
    }
    onScrollProgress(n) {
      this.progress = n;
    }
    onEnter() {
      this.launched || this.launch(), this.play();
    }
    onLeave() {
      this.pause();
    }
    onToggle(n) {
      n.target == this.el &&
        (n.way === "enter"
          ? this.onEnter()
          : n.way === "exit" && this.onLeave());
    }
    updateSize() {
      (this.width && this.width == this.$el.offsetWidth) ||
        ((this.width = this.$el.offsetWidth),
        (this.height = this.$el.offsetHeight),
        (this.$canvas.width = Math.ceil((this.dpr * this.width) / 4) * 4),
        (this.$canvas.height = Math.ceil((this.dpr * this.height) / 4) * 4),
        (this.$canvas.style = `width: ${this.width}px; height: ${this.height}px;`),
        (this.ctx = this.$canvas.getContext("2d")),
        this.onUpdate());
    }
    play() {
      this.isPlaying ||
        ((this.isPlaying = !0), yt.ticker.add(this.onUpdateBind));
    }
    pause() {
      !this.isPlaying ||
        ((this.isPlaying = !1), yt.ticker.remove(this.onUpdateBind));
    }
    setImages() {
      for (let n = 0; n <= this.images.totalLength; n++)
        this.images.framesToLoad[n] = {
          index: n,
          src: `${this.images.path}${this._pad(n, 4)}${this.images.exension}`,
        };
    }
    loadSequence(n = !0) {
      return new Promise((e, t) =>
        Fr(this, null, function* () {
          let i = [],
            r = this.preloadStep,
            s = 0;
          for (; s < this.images.framesToLoad.length; ) {
            if (this.aborted) {
              e();
              return;
            }
            let o = this.images.framesToLoad[s];
            if (
              (n && s % r === 0) ||
              (!n && s > 0 && s % r === 0 && (s / 2) % r !== 0)
            ) {
              let l = yield iy(o.src, { index: o.index });
              i.push(l);
            }
            s++;
          }
          let a = [...this.images.framesLoaded, ...i];
          a.sort((o, l) => o.index - l.index),
            (this.images.framesLoaded = a),
            e(),
            r > 1 &&
              ((this.preloadStep = r / 2),
              requestAnimationFrame(() => {
                this.loadSequence(!1);
              }));
        })
      );
    }
    setCurrentFrame() {
      this.currentFrame =
        (I4 +
          Math.min(
            Math.floor(this.progress * this.images.framesLoaded.length),
            this.images.framesLoaded.length - 1
          )) %
        this.images.framesLoaded.length;
    }
    drawImage() {
      let n = this.images.framesLoaded[this.currentFrame],
        e = this.$canvas.width / n.width,
        t = this.$canvas.height / n.height,
        i = Math.max(e, t),
        r = n.width * i,
        s = n.height * i,
        a = (this.$canvas.width - r) * 0.5,
        o = (this.$canvas.height - s) * 0.5;
      this.ctx.clearRect(0, 0, this.$canvas.width, this.$canvas.height),
        this.ctx.drawImage(n.element, a, o, r, s),
        this.autoplay && (this.progress = (this.progress + 0.002) % 1);
    }
    _pad(n, e) {
      return String(n).padStart(e, "0");
    }
  };
  var cs = bn(Yu(), 1);
  var L4 = 0.25,
    Ms,
    _M = {
      name: "default",
      leave(n) {
        let e = new Promise((i) => {
            setTimeout(i, 250);
          }),
          t = new Promise((i) => {
            let r = [],
              s = new IntersectionObserver(
                (a, o) => {
                  a.forEach((c) => {
                    if (c.isIntersecting) {
                      let u = c.target;
                      (!u.children.length || u.dataset.allowShuffle != null) &&
                        u.innerText &&
                        r.push(u);
                    }
                  }),
                    o.disconnect(),
                    (o = null),
                    Ms && Ms.kill && Ms.kill(),
                    (Ms = yt.timeline({ onComplete: i }));
                  let l = 16;
                  for (let c = 0; c < l * 10; c++)
                    for (let u of r)
                      (u.style.fontKerning = "none"),
                        Ms.call(
                          () => {
                            Fa(u, lc);
                          },
                          {},
                          (1 / l) * c
                        );
                },
                { threshold: [0] }
              );
            n.current.container.querySelectorAll("*").forEach((a) => {
              s.observe(a);
            });
          });
        return Promise.all([e]);
      },
      enter(n) {
        return (
          (document.documentElement.scrollTop = 0),
          new Promise((t) => {
            let i = [],
              r = new IntersectionObserver(
                (s, a) => {
                  s.forEach((c) => {
                    if (c.isIntersecting) {
                      let u = c.target;
                      (!u.children.length || u.dataset.allowShuffle != null) &&
                        u.innerText &&
                        (i.push(u), u.setAttribute("aria-label", u.innerText));
                    }
                  }),
                    a.disconnect(),
                    (a = null),
                    Ms && Ms.kill && Ms.kill(),
                    (Ms = yt.timeline({
                      onComplete: () => {
                        for (let c of i)
                          (c.innerText = c.getAttribute("aria-label")),
                            c.removeAttribute("aria-label"),
                            (c.style.fontKerning = "");
                        t();
                      },
                    }));
                  let o = 4,
                    l = L4 / o;
                  for (let c = 0; c < o; c++)
                    for (let u of i)
                      (u.style.fontKerning = "none"),
                        Ms.call(
                          () => {
                            Fa(u, lc);
                          },
                          {},
                          l * c
                        );
                },
                { threshold: [0] }
              );
            n.next.container.querySelectorAll("*").forEach((s) => {
              r.observe(s);
            });
          })
        );
      },
    };
  var EM = {
    name: "work-list",
    leave(n) {
      let e = new Promise((i) => {
          i();
        }),
        t = yt.to(n.current.container.querySelector(".c-work-list_list"), {
          duration: 0.25,
          opacity: 0.25,
        });
      return Promise.all([e, t]);
    },
    enter(n) {
      return yt.from(n.next.container.querySelector(".c-work-list_list"), {
        duration: 0.25,
        opacity: 0.25,
      });
    },
    from: {
      custom({ trigger: n }) {
        return n && n.dataset && n.dataset.loadTransition == "work-list";
      },
    },
  };
  var TM = 0.25,
    SM = {
      name: "work-next",
      leave(n) {
        let e = n.current.container.querySelector(".c-work-next_overline"),
          t = yt.timeline(),
          i = 16,
          r = TM / i;
        for (let s = 0; s < i; s++)
          t.call(
            () => {
              BS(e, lc);
            },
            {},
            r * s
          );
        return Promise.all([t]);
      },
      enter(n) {
        document.documentElement.scrollTop = 0;
        let e = n.next.container.querySelector(".c-work-single-hero_grid.-top"),
          t = [],
          i = e.querySelectorAll("*");
        for (let o of i)
          (!o.children.length || o.dataset.allowShuffle != null) &&
            o.innerText &&
            (t.push(o), o.setAttribute("aria-label", o.innerText));
        let r = yt.timeline({
            onComplete: () => {
              for (let o of t)
                (o.innerText = o.getAttribute("aria-label")),
                  o.removeAttribute("aria-label");
            },
          }),
          s = 16,
          a = TM / s;
        for (let o = 0; o < s; o++)
          for (let l of t)
            r.call(
              () => {
                Fa(l, lc);
              },
              {},
              a * o
            );
        return r;
      },
      from: {
        custom({ trigger: n }) {
          return n && n.dataset && n.dataset.loadTransition == "work-next";
        },
      },
    };
  var R4 = (n) =>
      n
        .split(/(?=[A-Z])/)
        .join("-")
        .toLowerCase(),
    yv = class extends St {
      constructor(n) {
        super(n);
      }
      init() {
        cs.default.init({
          timeout: 1e4,
          schema: { prefix: "data-load" },
          transitions: [_M, EM, SM],
          prevent: ({ el: n, event: e, href: t }) => {
            if (window.confirmPageChange && e.type == "click")
              return (
                this.call("close", null, "Nav"),
                cs.default.prefetch(t),
                window.confirm(window.confirmPageChange.message) &&
                  (cs.default.go(t) || (window.location = t)),
                e.preventDefault(),
                !0
              );
            {
              let i = n.getAttribute("data-load") == "false" || !1;
              return window.location.href == t
                ? (e.preventDefault(), e.stopPropagation(), !0)
                : !!i;
            }
          },
        }),
          cs.default.hooks.before(this.before.bind(this)),
          cs.default.hooks.beforeLeave(this.beforeLeave.bind(this)),
          cs.default.hooks.leave(this.leave.bind(this)),
          cs.default.hooks.afterLeave(this.afterLeave.bind(this)),
          cs.default.hooks.enter(this.enter.bind(this)),
          cs.default.hooks.after(this.after.bind(this));
      }
      before(n, e) {}
      beforeLeave() {}
      leave() {
        this.call("reset", null, "Hovers"),
          this.call("hideMenu", null, "Header"),
          Gt.classList.add("is-loading"),
          Gt.classList.remove("is-loaded"),
          Gt.classList.remove("is-ready");
      }
      afterLeave(n) {
        this.call("destroy", n.current.container, "app"),
          n.current.container.remove();
      }
      beforeEnter() {}
      enter(n) {
        let t = new DOMParser().parseFromString(n.next.html, "text/html"),
          i = Object.assign({}, t.querySelector("html").dataset);
        Object.entries(i).forEach(([r, s]) => {
          Gt.setAttribute("data-" + R4(r), s);
        }),
          requestAnimationFrame(() => {
            Gt.classList.remove("is-loading"),
              Gt.classList.add("is-loaded"),
              this.call("update", n.next.container, "app");
          });
      }
      beforeLeave() {}
      manualGo(n) {
        cs.default.go(n.href, n);
      }
      after(n) {
        Gt.classList.add("is-ready"), this.call("update", null, "Hovers");
      }
    };
  var ax = "148",
    ul = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
    hl = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
    O4 = 0,
    wM = 1,
    N4 = 2;
  var KA = 1,
    yh = 2,
    sh = 3,
    aa = 0,
    qr = 1,
    vh = 2,
    Hd = 3,
    Qa = 0,
    Ac = 1,
    MM = 2,
    AM = 3,
    CM = 4,
    k4 = 5,
    Tc = 100,
    F4 = 101,
    B4 = 102,
    PM = 103,
    DM = 104,
    z4 = 200,
    U4 = 201,
    V4 = 202,
    G4 = 203,
    JA = 204,
    ZA = 205,
    H4 = 206,
    $4 = 207,
    W4 = 208,
    q4 = 209,
    j4 = 210,
    X4 = 0,
    Y4 = 1,
    K4 = 2,
    Kv = 3,
    J4 = 4,
    Z4 = 5,
    Q4 = 6,
    ez = 7,
    QA = 0,
    tz = 1,
    iz = 2,
    sa = 0,
    nz = 1,
    rz = 2,
    sz = 3,
    az = 4,
    oz = 5,
    eC = 300,
    Pc = 301,
    Dc = 302,
    Jv = 303,
    Zv = 304,
    vp = 306,
    rl = 1e3,
    xr = 1001,
    hh = 1002,
    un = 1003,
    mp = 1004;
  var oh = 1005;
  var Wn = 1006,
    ox = 1007;
  var eo = 1008;
  var sl = 1009,
    lz = 1010,
    cz = 1011,
    tC = 1012,
    uz = 1013,
    tl = 1014,
    Za = 1015,
    fh = 1016,
    hz = 1017,
    fz = 1018,
    Cc = 1020,
    dz = 1021,
    pz = 1022,
    Wr = 1023,
    mz = 1024,
    gz = 1025,
    il = 1026,
    Ic = 1027,
    yz = 1028,
    vz = 1029,
    xz = 1030,
    bz = 1031,
    _z = 1033,
    vv = 33776,
    xv = 33777,
    bv = 33778,
    _v = 33779,
    IM = 35840,
    LM = 35841,
    RM = 35842,
    OM = 35843,
    Ez = 36196,
    NM = 37492,
    kM = 37496,
    FM = 37808,
    BM = 37809,
    zM = 37810,
    UM = 37811,
    VM = 37812,
    GM = 37813,
    HM = 37814,
    $M = 37815,
    WM = 37816,
    qM = 37817,
    jM = 37818,
    XM = 37819,
    YM = 37820,
    KM = 37821,
    JM = 36492,
    Tz = 2200,
    Sz = 2201,
    wz = 2202,
    Lc = 2300,
    al = 2301,
    Ev = 2302,
    Sc = 2400,
    wc = 2401,
    gp = 2402,
    lx = 2500,
    Mz = 2501;
  var iC = 1,
    cx = 2,
    ol = 3e3,
    oi = 3001,
    Az = 3200,
    Cz = 3201,
    nC = 0,
    Pz = 1;
  var As = "srgb",
    dh = "srgb-linear";
  var Tv = 7680;
  var Dz = 519,
    Qv = 35044;
  var ZM = "300 es",
    ex = 1035,
    Ds = class {
      addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        let i = this._listeners;
        i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
      }
      hasEventListener(e, t) {
        if (this._listeners === void 0) return !1;
        let i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1;
      }
      removeEventListener(e, t) {
        if (this._listeners === void 0) return;
        let r = this._listeners[e];
        if (r !== void 0) {
          let s = r.indexOf(t);
          s !== -1 && r.splice(s, 1);
        }
      }
      dispatchEvent(e) {
        if (this._listeners === void 0) return;
        let i = this._listeners[e.type];
        if (i !== void 0) {
          e.target = this;
          let r = i.slice(0);
          for (let s = 0, a = r.length; s < a; s++) r[s].call(this, e);
          e.target = null;
        }
      }
    },
    Pn = [
      "00",
      "01",
      "02",
      "03",
      "04",
      "05",
      "06",
      "07",
      "08",
      "09",
      "0a",
      "0b",
      "0c",
      "0d",
      "0e",
      "0f",
      "10",
      "11",
      "12",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "1a",
      "1b",
      "1c",
      "1d",
      "1e",
      "1f",
      "20",
      "21",
      "22",
      "23",
      "24",
      "25",
      "26",
      "27",
      "28",
      "29",
      "2a",
      "2b",
      "2c",
      "2d",
      "2e",
      "2f",
      "30",
      "31",
      "32",
      "33",
      "34",
      "35",
      "36",
      "37",
      "38",
      "39",
      "3a",
      "3b",
      "3c",
      "3d",
      "3e",
      "3f",
      "40",
      "41",
      "42",
      "43",
      "44",
      "45",
      "46",
      "47",
      "48",
      "49",
      "4a",
      "4b",
      "4c",
      "4d",
      "4e",
      "4f",
      "50",
      "51",
      "52",
      "53",
      "54",
      "55",
      "56",
      "57",
      "58",
      "59",
      "5a",
      "5b",
      "5c",
      "5d",
      "5e",
      "5f",
      "60",
      "61",
      "62",
      "63",
      "64",
      "65",
      "66",
      "67",
      "68",
      "69",
      "6a",
      "6b",
      "6c",
      "6d",
      "6e",
      "6f",
      "70",
      "71",
      "72",
      "73",
      "74",
      "75",
      "76",
      "77",
      "78",
      "79",
      "7a",
      "7b",
      "7c",
      "7d",
      "7e",
      "7f",
      "80",
      "81",
      "82",
      "83",
      "84",
      "85",
      "86",
      "87",
      "88",
      "89",
      "8a",
      "8b",
      "8c",
      "8d",
      "8e",
      "8f",
      "90",
      "91",
      "92",
      "93",
      "94",
      "95",
      "96",
      "97",
      "98",
      "99",
      "9a",
      "9b",
      "9c",
      "9d",
      "9e",
      "9f",
      "a0",
      "a1",
      "a2",
      "a3",
      "a4",
      "a5",
      "a6",
      "a7",
      "a8",
      "a9",
      "aa",
      "ab",
      "ac",
      "ad",
      "ae",
      "af",
      "b0",
      "b1",
      "b2",
      "b3",
      "b4",
      "b5",
      "b6",
      "b7",
      "b8",
      "b9",
      "ba",
      "bb",
      "bc",
      "bd",
      "be",
      "bf",
      "c0",
      "c1",
      "c2",
      "c3",
      "c4",
      "c5",
      "c6",
      "c7",
      "c8",
      "c9",
      "ca",
      "cb",
      "cc",
      "cd",
      "ce",
      "cf",
      "d0",
      "d1",
      "d2",
      "d3",
      "d4",
      "d5",
      "d6",
      "d7",
      "d8",
      "d9",
      "da",
      "db",
      "dc",
      "dd",
      "de",
      "df",
      "e0",
      "e1",
      "e2",
      "e3",
      "e4",
      "e5",
      "e6",
      "e7",
      "e8",
      "e9",
      "ea",
      "eb",
      "ec",
      "ed",
      "ee",
      "ef",
      "f0",
      "f1",
      "f2",
      "f3",
      "f4",
      "f5",
      "f6",
      "f7",
      "f8",
      "f9",
      "fa",
      "fb",
      "fc",
      "fd",
      "fe",
      "ff",
    ],
    QM = 1234567,
    lh = Math.PI / 180,
    ph = 180 / Math.PI;
  function ds() {
    let n = (Math.random() * 4294967295) | 0,
      e = (Math.random() * 4294967295) | 0,
      t = (Math.random() * 4294967295) | 0,
      i = (Math.random() * 4294967295) | 0;
    return (
      Pn[n & 255] +
      Pn[(n >> 8) & 255] +
      Pn[(n >> 16) & 255] +
      Pn[(n >> 24) & 255] +
      "-" +
      Pn[e & 255] +
      Pn[(e >> 8) & 255] +
      "-" +
      Pn[((e >> 16) & 15) | 64] +
      Pn[(e >> 24) & 255] +
      "-" +
      Pn[(t & 63) | 128] +
      Pn[(t >> 8) & 255] +
      "-" +
      Pn[(t >> 16) & 255] +
      Pn[(t >> 24) & 255] +
      Pn[i & 255] +
      Pn[(i >> 8) & 255] +
      Pn[(i >> 16) & 255] +
      Pn[(i >> 24) & 255]
    ).toLowerCase();
  }
  function Dn(n, e, t) {
    return Math.max(e, Math.min(t, n));
  }
  function ux(n, e) {
    return ((n % e) + e) % e;
  }
  function Iz(n, e, t, i, r) {
    return i + ((n - e) * (r - i)) / (t - e);
  }
  function Lz(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0;
  }
  function ch(n, e, t) {
    return (1 - t) * n + t * e;
  }
  function Rz(n, e, t, i) {
    return ch(n, e, 1 - Math.exp(-t * i));
  }
  function Oz(n, e = 1) {
    return e - Math.abs(ux(n, e * 2) - e);
  }
  function Nz(n, e, t) {
    return n <= e
      ? 0
      : n >= t
      ? 1
      : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
  }
  function kz(n, e, t) {
    return n <= e
      ? 0
      : n >= t
      ? 1
      : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
  }
  function Fz(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1));
  }
  function Bz(n, e) {
    return n + Math.random() * (e - n);
  }
  function zz(n) {
    return n * (0.5 - Math.random());
  }
  function Uz(n) {
    n !== void 0 && (QM = n);
    let e = (QM += 1831565813);
    return (
      (e = Math.imul(e ^ (e >>> 15), e | 1)),
      (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
      ((e ^ (e >>> 14)) >>> 0) / 4294967296
    );
  }
  function Vz(n) {
    return n * lh;
  }
  function Gz(n) {
    return n * ph;
  }
  function tx(n) {
    return (n & (n - 1)) === 0 && n !== 0;
  }
  function rC(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
  }
  function yp(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
  }
  function Hz(n, e, t, i, r) {
    let s = Math.cos,
      a = Math.sin,
      o = s(t / 2),
      l = a(t / 2),
      c = s((e + i) / 2),
      u = a((e + i) / 2),
      f = s((e - i) / 2),
      d = a((e - i) / 2),
      m = s((i - e) / 2),
      x = a((i - e) / 2);
    switch (r) {
      case "XYX":
        n.set(o * u, l * f, l * d, o * c);
        break;
      case "YZY":
        n.set(l * d, o * u, l * f, o * c);
        break;
      case "ZXZ":
        n.set(l * f, l * d, o * u, o * c);
        break;
      case "XZX":
        n.set(o * u, l * x, l * m, o * c);
        break;
      case "YXY":
        n.set(l * m, o * u, l * x, o * c);
        break;
      case "ZYZ":
        n.set(l * x, l * m, o * u, o * c);
        break;
      default:
        console.warn(
          "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
            r
        );
    }
  }
  function ra(n, e) {
    switch (e.constructor) {
      case Float32Array:
        return n;
      case Uint16Array:
        return n / 65535;
      case Uint8Array:
        return n / 255;
      case Int16Array:
        return Math.max(n / 32767, -1);
      case Int8Array:
        return Math.max(n / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function Mi(n, e) {
    switch (e.constructor) {
      case Float32Array:
        return n;
      case Uint16Array:
        return Math.round(n * 65535);
      case Uint8Array:
        return Math.round(n * 255);
      case Int16Array:
        return Math.round(n * 32767);
      case Int8Array:
        return Math.round(n * 127);
      default:
        throw new Error("Invalid component type.");
    }
  }
  var sC = Object.freeze({
      __proto__: null,
      DEG2RAD: lh,
      RAD2DEG: ph,
      generateUUID: ds,
      clamp: Dn,
      euclideanModulo: ux,
      mapLinear: Iz,
      inverseLerp: Lz,
      lerp: ch,
      damp: Rz,
      pingpong: Oz,
      smoothstep: Nz,
      smootherstep: kz,
      randInt: Fz,
      randFloat: Bz,
      randFloatSpread: zz,
      seededRandom: Uz,
      degToRad: Vz,
      radToDeg: Gz,
      isPowerOfTwo: tx,
      ceilPowerOfTwo: rC,
      floorPowerOfTwo: yp,
      setQuaternionFromProperEuler: Hz,
      normalize: Mi,
      denormalize: ra,
    }),
    It = class {
      constructor(e = 0, t = 0) {
        (It.prototype.isVector2 = !0), (this.x = e), (this.y = t);
      }
      get width() {
        return this.x;
      }
      set width(e) {
        this.x = e;
      }
      get height() {
        return this.y;
      }
      set height(e) {
        this.y = e;
      }
      set(e, t) {
        return (this.x = e), (this.y = t), this;
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(e) {
        return (this.x = e.x), (this.y = e.y), this;
      }
      add(e) {
        return (this.x += e.x), (this.y += e.y), this;
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), this;
      }
      addVectors(e, t) {
        return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
      }
      addScaledVector(e, t) {
        return (this.x += e.x * t), (this.y += e.y * t), this;
      }
      sub(e) {
        return (this.x -= e.x), (this.y -= e.y), this;
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), this;
      }
      subVectors(e, t) {
        return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
      }
      multiply(e) {
        return (this.x *= e.x), (this.y *= e.y), this;
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), this;
      }
      divide(e) {
        return (this.x /= e.x), (this.y /= e.y), this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      applyMatrix3(e) {
        let t = this.x,
          i = this.y,
          r = e.elements;
        return (
          (this.x = r[0] * t + r[3] * i + r[6]),
          (this.y = r[1] * t + r[4] * i + r[7]),
          this
        );
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          this
        );
      }
      clampLength(e, t) {
        let i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(
          Math.max(e, Math.min(t, i))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
        );
      }
      ceil() {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
      }
      round() {
        return (
          (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y;
      }
      cross(e) {
        return this.x * e.y - this.y * e.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        let t = this.x - e.x,
          i = this.y - e.y;
        return t * t + i * i;
      }
      manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
        );
      }
      lerpVectors(e, t, i) {
        return (
          (this.x = e.x + (t.x - e.x) * i),
          (this.y = e.y + (t.y - e.y) * i),
          this
        );
      }
      equals(e) {
        return e.x === this.x && e.y === this.y;
      }
      fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), e;
      }
      fromBufferAttribute(e, t) {
        return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
      }
      rotateAround(e, t) {
        let i = Math.cos(t),
          r = Math.sin(t),
          s = this.x - e.x,
          a = this.y - e.y;
        return (
          (this.x = s * i - a * r + e.x), (this.y = s * r + a * i + e.y), this
        );
      }
      random() {
        return (this.x = Math.random()), (this.y = Math.random()), this;
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y;
      }
    },
    sr = class {
      constructor() {
        (sr.prototype.isMatrix3 = !0),
          (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
      }
      set(e, t, i, r, s, a, o, l, c) {
        let u = this.elements;
        return (
          (u[0] = e),
          (u[1] = r),
          (u[2] = o),
          (u[3] = t),
          (u[4] = s),
          (u[5] = l),
          (u[6] = i),
          (u[7] = a),
          (u[8] = c),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }
      copy(e) {
        let t = this.elements,
          i = e.elements;
        return (
          (t[0] = i[0]),
          (t[1] = i[1]),
          (t[2] = i[2]),
          (t[3] = i[3]),
          (t[4] = i[4]),
          (t[5] = i[5]),
          (t[6] = i[6]),
          (t[7] = i[7]),
          (t[8] = i[8]),
          this
        );
      }
      extractBasis(e, t, i) {
        return (
          e.setFromMatrix3Column(this, 0),
          t.setFromMatrix3Column(this, 1),
          i.setFromMatrix3Column(this, 2),
          this
        );
      }
      setFromMatrix4(e) {
        let t = e.elements;
        return (
          this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        );
      }
      multiply(e) {
        return this.multiplyMatrices(this, e);
      }
      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }
      multiplyMatrices(e, t) {
        let i = e.elements,
          r = t.elements,
          s = this.elements,
          a = i[0],
          o = i[3],
          l = i[6],
          c = i[1],
          u = i[4],
          f = i[7],
          d = i[2],
          m = i[5],
          x = i[8],
          y = r[0],
          g = r[3],
          b = r[6],
          _ = r[1],
          E = r[4],
          w = r[7],
          P = r[2],
          L = r[5],
          I = r[8];
        return (
          (s[0] = a * y + o * _ + l * P),
          (s[3] = a * g + o * E + l * L),
          (s[6] = a * b + o * w + l * I),
          (s[1] = c * y + u * _ + f * P),
          (s[4] = c * g + u * E + f * L),
          (s[7] = c * b + u * w + f * I),
          (s[2] = d * y + m * _ + x * P),
          (s[5] = d * g + m * E + x * L),
          (s[8] = d * b + m * w + x * I),
          this
        );
      }
      multiplyScalar(e) {
        let t = this.elements;
        return (
          (t[0] *= e),
          (t[3] *= e),
          (t[6] *= e),
          (t[1] *= e),
          (t[4] *= e),
          (t[7] *= e),
          (t[2] *= e),
          (t[5] *= e),
          (t[8] *= e),
          this
        );
      }
      determinant() {
        let e = this.elements,
          t = e[0],
          i = e[1],
          r = e[2],
          s = e[3],
          a = e[4],
          o = e[5],
          l = e[6],
          c = e[7],
          u = e[8];
        return (
          t * a * u - t * o * c - i * s * u + i * o * l + r * s * c - r * a * l
        );
      }
      invert() {
        let e = this.elements,
          t = e[0],
          i = e[1],
          r = e[2],
          s = e[3],
          a = e[4],
          o = e[5],
          l = e[6],
          c = e[7],
          u = e[8],
          f = u * a - o * c,
          d = o * l - u * s,
          m = c * s - a * l,
          x = t * f + i * d + r * m;
        if (x === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        let y = 1 / x;
        return (
          (e[0] = f * y),
          (e[1] = (r * c - u * i) * y),
          (e[2] = (o * i - r * a) * y),
          (e[3] = d * y),
          (e[4] = (u * t - r * l) * y),
          (e[5] = (r * s - o * t) * y),
          (e[6] = m * y),
          (e[7] = (i * l - c * t) * y),
          (e[8] = (a * t - i * s) * y),
          this
        );
      }
      transpose() {
        let e,
          t = this.elements;
        return (
          (e = t[1]),
          (t[1] = t[3]),
          (t[3] = e),
          (e = t[2]),
          (t[2] = t[6]),
          (t[6] = e),
          (e = t[5]),
          (t[5] = t[7]),
          (t[7] = e),
          this
        );
      }
      getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose();
      }
      transposeIntoArray(e) {
        let t = this.elements;
        return (
          (e[0] = t[0]),
          (e[1] = t[3]),
          (e[2] = t[6]),
          (e[3] = t[1]),
          (e[4] = t[4]),
          (e[5] = t[7]),
          (e[6] = t[2]),
          (e[7] = t[5]),
          (e[8] = t[8]),
          this
        );
      }
      setUvTransform(e, t, i, r, s, a, o) {
        let l = Math.cos(s),
          c = Math.sin(s);
        return (
          this.set(
            i * l,
            i * c,
            -i * (l * a + c * o) + a + e,
            -r * c,
            r * l,
            -r * (-c * a + l * o) + o + t,
            0,
            0,
            1
          ),
          this
        );
      }
      scale(e, t) {
        return this.premultiply(Sv.makeScale(e, t)), this;
      }
      rotate(e) {
        return this.premultiply(Sv.makeRotation(-e)), this;
      }
      translate(e, t) {
        return this.premultiply(Sv.makeTranslation(e, t)), this;
      }
      makeTranslation(e, t) {
        return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
      }
      makeRotation(e) {
        let t = Math.cos(e),
          i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
      }
      makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
      }
      equals(e) {
        let t = this.elements,
          i = e.elements;
        for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
        return !0;
      }
      fromArray(e, t = 0) {
        for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
        return this;
      }
      toArray(e = [], t = 0) {
        let i = this.elements;
        return (
          (e[t] = i[0]),
          (e[t + 1] = i[1]),
          (e[t + 2] = i[2]),
          (e[t + 3] = i[3]),
          (e[t + 4] = i[4]),
          (e[t + 5] = i[5]),
          (e[t + 6] = i[6]),
          (e[t + 7] = i[7]),
          (e[t + 8] = i[8]),
          e
        );
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    },
    Sv = new sr();
  function aC(n) {
    for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
    return !1;
  }
  function mh(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n);
  }
  function nl(n) {
    return n < 0.04045
      ? n * 0.0773993808
      : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
  }
  function dp(n) {
    return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
  }
  var wv = { [As]: { [dh]: nl }, [dh]: { [As]: dp } },
    Gn = {
      legacyMode: !0,
      get workingColorSpace() {
        return dh;
      },
      set workingColorSpace(n) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
      },
      convert: function (n, e, t) {
        if (this.legacyMode || e === t || !e || !t) return n;
        if (wv[e] && wv[e][t] !== void 0) {
          let i = wv[e][t];
          return (n.r = i(n.r)), (n.g = i(n.g)), (n.b = i(n.b)), n;
        }
        throw new Error("Unsupported color space conversion.");
      },
      fromWorkingColorSpace: function (n, e) {
        return this.convert(n, this.workingColorSpace, e);
      },
      toWorkingColorSpace: function (n, e) {
        return this.convert(n, e, this.workingColorSpace);
      },
    },
    oC = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    },
    cn = { r: 0, g: 0, b: 0 },
    us = { h: 0, s: 0, l: 0 },
    $d = { h: 0, s: 0, l: 0 };
  function Mv(n, e, t) {
    return (
      t < 0 && (t += 1),
      t > 1 && (t -= 1),
      t < 1 / 6
        ? n + (e - n) * 6 * t
        : t < 1 / 2
        ? e
        : t < 2 / 3
        ? n + (e - n) * 6 * (2 / 3 - t)
        : n
    );
  }
  function Wd(n, e) {
    return (e.r = n.r), (e.g = n.g), (e.b = n.b), e;
  }
  var Bt = class {
    constructor(e, t, i) {
      return (
        (this.isColor = !0),
        (this.r = 1),
        (this.g = 1),
        (this.b = 1),
        t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i)
      );
    }
    set(e) {
      return (
        e && e.isColor
          ? this.copy(e)
          : typeof e == "number"
          ? this.setHex(e)
          : typeof e == "string" && this.setStyle(e),
        this
      );
    }
    setScalar(e) {
      return (this.r = e), (this.g = e), (this.b = e), this;
    }
    setHex(e, t = As) {
      return (
        (e = Math.floor(e)),
        (this.r = ((e >> 16) & 255) / 255),
        (this.g = ((e >> 8) & 255) / 255),
        (this.b = (e & 255) / 255),
        Gn.toWorkingColorSpace(this, t),
        this
      );
    }
    setRGB(e, t, i, r = Gn.workingColorSpace) {
      return (
        (this.r = e),
        (this.g = t),
        (this.b = i),
        Gn.toWorkingColorSpace(this, r),
        this
      );
    }
    setHSL(e, t, i, r = Gn.workingColorSpace) {
      if (((e = ux(e, 1)), (t = Dn(t, 0, 1)), (i = Dn(i, 0, 1)), t === 0))
        this.r = this.g = this.b = i;
      else {
        let s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
          a = 2 * i - s;
        (this.r = Mv(a, s, e + 1 / 3)),
          (this.g = Mv(a, s, e)),
          (this.b = Mv(a, s, e - 1 / 3));
      }
      return Gn.toWorkingColorSpace(this, r), this;
    }
    setStyle(e, t = As) {
      function i(s) {
        s !== void 0 &&
          parseFloat(s) < 1 &&
          console.warn(
            "THREE.Color: Alpha component of " + e + " will be ignored."
          );
      }
      let r;
      if ((r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
        let s,
          a = r[1],
          o = r[2];
        switch (a) {
          case "rgb":
          case "rgba":
            if (
              (s =
                /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  o
                ))
            )
              return (
                (this.r = Math.min(255, parseInt(s[1], 10)) / 255),
                (this.g = Math.min(255, parseInt(s[2], 10)) / 255),
                (this.b = Math.min(255, parseInt(s[3], 10)) / 255),
                Gn.toWorkingColorSpace(this, t),
                i(s[4]),
                this
              );
            if (
              (s =
                /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  o
                ))
            )
              return (
                (this.r = Math.min(100, parseInt(s[1], 10)) / 100),
                (this.g = Math.min(100, parseInt(s[2], 10)) / 100),
                (this.b = Math.min(100, parseInt(s[3], 10)) / 100),
                Gn.toWorkingColorSpace(this, t),
                i(s[4]),
                this
              );
            break;
          case "hsl":
          case "hsla":
            if (
              (s =
                /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  o
                ))
            ) {
              let l = parseFloat(s[1]) / 360,
                c = parseFloat(s[2]) / 100,
                u = parseFloat(s[3]) / 100;
              return i(s[4]), this.setHSL(l, c, u, t);
            }
            break;
        }
      } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
        let s = r[1],
          a = s.length;
        if (a === 3)
          return (
            (this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255),
            (this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255),
            (this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255),
            Gn.toWorkingColorSpace(this, t),
            this
          );
        if (a === 6)
          return (
            (this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255),
            (this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255),
            (this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255),
            Gn.toWorkingColorSpace(this, t),
            this
          );
      }
      return e && e.length > 0 ? this.setColorName(e, t) : this;
    }
    setColorName(e, t = As) {
      let i = oC[e.toLowerCase()];
      return (
        i !== void 0
          ? this.setHex(i, t)
          : console.warn("THREE.Color: Unknown color " + e),
        this
      );
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(e) {
      return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
    }
    copySRGBToLinear(e) {
      return (this.r = nl(e.r)), (this.g = nl(e.g)), (this.b = nl(e.b)), this;
    }
    copyLinearToSRGB(e) {
      return (this.r = dp(e.r)), (this.g = dp(e.g)), (this.b = dp(e.b)), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(e = As) {
      return (
        Gn.fromWorkingColorSpace(Wd(this, cn), e),
        (Dn(cn.r * 255, 0, 255) << 16) ^
          (Dn(cn.g * 255, 0, 255) << 8) ^
          (Dn(cn.b * 255, 0, 255) << 0)
      );
    }
    getHexString(e = As) {
      return ("000000" + this.getHex(e).toString(16)).slice(-6);
    }
    getHSL(e, t = Gn.workingColorSpace) {
      Gn.fromWorkingColorSpace(Wd(this, cn), t);
      let i = cn.r,
        r = cn.g,
        s = cn.b,
        a = Math.max(i, r, s),
        o = Math.min(i, r, s),
        l,
        c,
        u = (o + a) / 2;
      if (o === a) (l = 0), (c = 0);
      else {
        let f = a - o;
        switch (((c = u <= 0.5 ? f / (a + o) : f / (2 - a - o)), a)) {
          case i:
            l = (r - s) / f + (r < s ? 6 : 0);
            break;
          case r:
            l = (s - i) / f + 2;
            break;
          case s:
            l = (i - r) / f + 4;
            break;
        }
        l /= 6;
      }
      return (e.h = l), (e.s = c), (e.l = u), e;
    }
    getRGB(e, t = Gn.workingColorSpace) {
      return (
        Gn.fromWorkingColorSpace(Wd(this, cn), t),
        (e.r = cn.r),
        (e.g = cn.g),
        (e.b = cn.b),
        e
      );
    }
    getStyle(e = As) {
      return (
        Gn.fromWorkingColorSpace(Wd(this, cn), e),
        e !== As
          ? `color(${e} ${cn.r} ${cn.g} ${cn.b})`
          : `rgb(${(cn.r * 255) | 0},${(cn.g * 255) | 0},${(cn.b * 255) | 0})`
      );
    }
    offsetHSL(e, t, i) {
      return (
        this.getHSL(us),
        (us.h += e),
        (us.s += t),
        (us.l += i),
        this.setHSL(us.h, us.s, us.l),
        this
      );
    }
    add(e) {
      return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
    }
    addColors(e, t) {
      return (
        (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
      );
    }
    addScalar(e) {
      return (this.r += e), (this.g += e), (this.b += e), this;
    }
    sub(e) {
      return (
        (this.r = Math.max(0, this.r - e.r)),
        (this.g = Math.max(0, this.g - e.g)),
        (this.b = Math.max(0, this.b - e.b)),
        this
      );
    }
    multiply(e) {
      return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
    }
    multiplyScalar(e) {
      return (this.r *= e), (this.g *= e), (this.b *= e), this;
    }
    lerp(e, t) {
      return (
        (this.r += (e.r - this.r) * t),
        (this.g += (e.g - this.g) * t),
        (this.b += (e.b - this.b) * t),
        this
      );
    }
    lerpColors(e, t, i) {
      return (
        (this.r = e.r + (t.r - e.r) * i),
        (this.g = e.g + (t.g - e.g) * i),
        (this.b = e.b + (t.b - e.b) * i),
        this
      );
    }
    lerpHSL(e, t) {
      this.getHSL(us), e.getHSL($d);
      let i = ch(us.h, $d.h, t),
        r = ch(us.s, $d.s, t),
        s = ch(us.l, $d.l, t);
      return this.setHSL(i, r, s), this;
    }
    equals(e) {
      return e.r === this.r && e.g === this.g && e.b === this.b;
    }
    fromArray(e, t = 0) {
      return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
    }
    toArray(e = [], t = 0) {
      return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
    }
    fromBufferAttribute(e, t) {
      return (
        (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
      );
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  };
  Bt.NAMES = oC;
  var cc,
    hx = class {
      static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
          return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
          cc === void 0 && (cc = mh("canvas")),
            (cc.width = e.width),
            (cc.height = e.height);
          let i = cc.getContext("2d");
          e instanceof ImageData
            ? i.putImageData(e, 0, 0)
            : i.drawImage(e, 0, 0, e.width, e.height),
            (t = cc);
        }
        return t.width > 2048 || t.height > 2048
          ? (console.warn(
              "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
              e
            ),
            t.toDataURL("image/jpeg", 0.6))
          : t.toDataURL("image/png");
      }
      static sRGBToLinear(e) {
        if (
          (typeof HTMLImageElement != "undefined" &&
            e instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement != "undefined" &&
            e instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap != "undefined" && e instanceof ImageBitmap)
        ) {
          let t = mh("canvas");
          (t.width = e.width), (t.height = e.height);
          let i = t.getContext("2d");
          i.drawImage(e, 0, 0, e.width, e.height);
          let r = i.getImageData(0, 0, e.width, e.height),
            s = r.data;
          for (let a = 0; a < s.length; a++) s[a] = nl(s[a] / 255) * 255;
          return i.putImageData(r, 0, 0), t;
        } else if (e.data) {
          let t = e.data.slice(0);
          for (let i = 0; i < t.length; i++)
            t instanceof Uint8Array || t instanceof Uint8ClampedArray
              ? (t[i] = Math.floor(nl(t[i] / 255) * 255))
              : (t[i] = nl(t[i]));
          return { data: t, width: e.width, height: e.height };
        } else
          return (
            console.warn(
              "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
            ),
            e
          );
      }
    },
    fx = class {
      constructor(e = null) {
        (this.isSource = !0),
          (this.uuid = ds()),
          (this.data = e),
          (this.version = 0);
      }
      set needsUpdate(e) {
        e === !0 && this.version++;
      }
      toJSON(e) {
        let t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
        let i = { uuid: this.uuid, url: "" },
          r = this.data;
        if (r !== null) {
          let s;
          if (Array.isArray(r)) {
            s = [];
            for (let a = 0, o = r.length; a < o; a++)
              r[a].isDataTexture ? s.push(Av(r[a].image)) : s.push(Av(r[a]));
          } else s = Av(r);
          i.url = s;
        }
        return t || (e.images[this.uuid] = i), i;
      }
    };
  function Av(n) {
    return (typeof HTMLImageElement != "undefined" &&
      n instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement != "undefined" &&
        n instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap != "undefined" && n instanceof ImageBitmap)
      ? hx.getDataURL(n)
      : n.data
      ? {
          data: Array.from(n.data),
          width: n.width,
          height: n.height,
          type: n.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  var $z = 0,
    hn = class extends Ds {
      constructor(
        e = hn.DEFAULT_IMAGE,
        t = hn.DEFAULT_MAPPING,
        i = xr,
        r = xr,
        s = Wn,
        a = eo,
        o = Wr,
        l = sl,
        c = hn.DEFAULT_ANISOTROPY,
        u = ol
      ) {
        super();
        (this.isTexture = !0),
          Object.defineProperty(this, "id", { value: $z++ }),
          (this.uuid = ds()),
          (this.name = ""),
          (this.source = new fx(e)),
          (this.mipmaps = []),
          (this.mapping = t),
          (this.wrapS = i),
          (this.wrapT = r),
          (this.magFilter = s),
          (this.minFilter = a),
          (this.anisotropy = c),
          (this.format = o),
          (this.internalFormat = null),
          (this.type = l),
          (this.offset = new It(0, 0)),
          (this.repeat = new It(1, 1)),
          (this.center = new It(0, 0)),
          (this.rotation = 0),
          (this.matrixAutoUpdate = !0),
          (this.matrix = new sr()),
          (this.generateMipmaps = !0),
          (this.premultiplyAlpha = !1),
          (this.flipY = !0),
          (this.unpackAlignment = 4),
          (this.encoding = u),
          (this.userData = {}),
          (this.version = 0),
          (this.onUpdate = null),
          (this.isRenderTargetTexture = !1),
          (this.needsPMREMUpdate = !1);
      }
      get image() {
        return this.source.data;
      }
      set image(e) {
        this.source.data = e;
      }
      updateMatrix() {
        this.matrix.setUvTransform(
          this.offset.x,
          this.offset.y,
          this.repeat.x,
          this.repeat.y,
          this.rotation,
          this.center.x,
          this.center.y
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return (
          (this.name = e.name),
          (this.source = e.source),
          (this.mipmaps = e.mipmaps.slice(0)),
          (this.mapping = e.mapping),
          (this.wrapS = e.wrapS),
          (this.wrapT = e.wrapT),
          (this.magFilter = e.magFilter),
          (this.minFilter = e.minFilter),
          (this.anisotropy = e.anisotropy),
          (this.format = e.format),
          (this.internalFormat = e.internalFormat),
          (this.type = e.type),
          this.offset.copy(e.offset),
          this.repeat.copy(e.repeat),
          this.center.copy(e.center),
          (this.rotation = e.rotation),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          this.matrix.copy(e.matrix),
          (this.generateMipmaps = e.generateMipmaps),
          (this.premultiplyAlpha = e.premultiplyAlpha),
          (this.flipY = e.flipY),
          (this.unpackAlignment = e.unpackAlignment),
          (this.encoding = e.encoding),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          (this.needsUpdate = !0),
          this
        );
      }
      toJSON(e) {
        let t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
          return e.textures[this.uuid];
        let i = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON",
          },
          uuid: this.uuid,
          name: this.name,
          image: this.source.toJSON(e).uuid,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          generateMipmaps: this.generateMipmaps,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment,
        };
        return (
          Object.keys(this.userData).length > 0 && (i.userData = this.userData),
          t || (e.textures[this.uuid] = i),
          i
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      transformUv(e) {
        if (this.mapping !== eC) return e;
        if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
          switch (this.wrapS) {
            case rl:
              e.x = e.x - Math.floor(e.x);
              break;
            case xr:
              e.x = e.x < 0 ? 0 : 1;
              break;
            case hh:
              Math.abs(Math.floor(e.x) % 2) === 1
                ? (e.x = Math.ceil(e.x) - e.x)
                : (e.x = e.x - Math.floor(e.x));
              break;
          }
        if (e.y < 0 || e.y > 1)
          switch (this.wrapT) {
            case rl:
              e.y = e.y - Math.floor(e.y);
              break;
            case xr:
              e.y = e.y < 0 ? 0 : 1;
              break;
            case hh:
              Math.abs(Math.floor(e.y) % 2) === 1
                ? (e.y = Math.ceil(e.y) - e.y)
                : (e.y = e.y - Math.floor(e.y));
              break;
          }
        return this.flipY && (e.y = 1 - e.y), e;
      }
      set needsUpdate(e) {
        e === !0 && (this.version++, (this.source.needsUpdate = !0));
      }
    };
  hn.DEFAULT_IMAGE = null;
  hn.DEFAULT_MAPPING = eC;
  hn.DEFAULT_ANISOTROPY = 1;
  var Ti = class {
      constructor(e = 0, t = 0, i = 0, r = 1) {
        (Ti.prototype.isVector4 = !0),
          (this.x = e),
          (this.y = t),
          (this.z = i),
          (this.w = r);
      }
      get width() {
        return this.z;
      }
      set width(e) {
        this.z = e;
      }
      get height() {
        return this.w;
      }
      set height(e) {
        this.w = e;
      }
      set(e, t, i, r) {
        return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setZ(e) {
        return (this.z = e), this;
      }
      setW(e) {
        return (this.w = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          case 3:
            this.w = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(e) {
        return (
          (this.x = e.x),
          (this.y = e.y),
          (this.z = e.z),
          (this.w = e.w !== void 0 ? e.w : 1),
          this
        );
      }
      add(e) {
        return (
          (this.x += e.x),
          (this.y += e.y),
          (this.z += e.z),
          (this.w += e.w),
          this
        );
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
      }
      addVectors(e, t) {
        return (
          (this.x = e.x + t.x),
          (this.y = e.y + t.y),
          (this.z = e.z + t.z),
          (this.w = e.w + t.w),
          this
        );
      }
      addScaledVector(e, t) {
        return (
          (this.x += e.x * t),
          (this.y += e.y * t),
          (this.z += e.z * t),
          (this.w += e.w * t),
          this
        );
      }
      sub(e) {
        return (
          (this.x -= e.x),
          (this.y -= e.y),
          (this.z -= e.z),
          (this.w -= e.w),
          this
        );
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
      }
      subVectors(e, t) {
        return (
          (this.x = e.x - t.x),
          (this.y = e.y - t.y),
          (this.z = e.z - t.z),
          (this.w = e.w - t.w),
          this
        );
      }
      multiply(e) {
        return (
          (this.x *= e.x),
          (this.y *= e.y),
          (this.z *= e.z),
          (this.w *= e.w),
          this
        );
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
      }
      applyMatrix4(e) {
        let t = this.x,
          i = this.y,
          r = this.z,
          s = this.w,
          a = e.elements;
        return (
          (this.x = a[0] * t + a[4] * i + a[8] * r + a[12] * s),
          (this.y = a[1] * t + a[5] * i + a[9] * r + a[13] * s),
          (this.z = a[2] * t + a[6] * i + a[10] * r + a[14] * s),
          (this.w = a[3] * t + a[7] * i + a[11] * r + a[15] * s),
          this
        );
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        let t = Math.sqrt(1 - e.w * e.w);
        return (
          t < 1e-4
            ? ((this.x = 1), (this.y = 0), (this.z = 0))
            : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
          this
        );
      }
      setAxisAngleFromRotationMatrix(e) {
        let t,
          i,
          r,
          s,
          l = e.elements,
          c = l[0],
          u = l[4],
          f = l[8],
          d = l[1],
          m = l[5],
          x = l[9],
          y = l[2],
          g = l[6],
          b = l[10];
        if (
          Math.abs(u - d) < 0.01 &&
          Math.abs(f - y) < 0.01 &&
          Math.abs(x - g) < 0.01
        ) {
          if (
            Math.abs(u + d) < 0.1 &&
            Math.abs(f + y) < 0.1 &&
            Math.abs(x + g) < 0.1 &&
            Math.abs(c + m + b - 3) < 0.1
          )
            return this.set(1, 0, 0, 0), this;
          t = Math.PI;
          let E = (c + 1) / 2,
            w = (m + 1) / 2,
            P = (b + 1) / 2,
            L = (u + d) / 4,
            I = (f + y) / 4,
            M = (x + g) / 4;
          return (
            E > w && E > P
              ? E < 0.01
                ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
                : ((i = Math.sqrt(E)), (r = L / i), (s = I / i))
              : w > P
              ? w < 0.01
                ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
                : ((r = Math.sqrt(w)), (i = L / r), (s = M / r))
              : P < 0.01
              ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
              : ((s = Math.sqrt(P)), (i = I / s), (r = M / s)),
            this.set(i, r, s, t),
            this
          );
        }
        let _ = Math.sqrt(
          (g - x) * (g - x) + (f - y) * (f - y) + (d - u) * (d - u)
        );
        return (
          Math.abs(_) < 0.001 && (_ = 1),
          (this.x = (g - x) / _),
          (this.y = (f - y) / _),
          (this.z = (d - u) / _),
          (this.w = Math.acos((c + m + b - 1) / 2)),
          this
        );
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          (this.z = Math.min(this.z, e.z)),
          (this.w = Math.min(this.w, e.w)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          (this.z = Math.max(this.z, e.z)),
          (this.w = Math.max(this.w, e.w)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          (this.z = Math.max(e.z, Math.min(t.z, this.z))),
          (this.w = Math.max(e.w, Math.min(t.w, this.w))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          (this.z = Math.max(e, Math.min(t, this.z))),
          (this.w = Math.max(e, Math.min(t, this.w))),
          this
        );
      }
      clampLength(e, t) {
        let i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(
          Math.max(e, Math.min(t, i))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          (this.w = Math.floor(this.w)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          (this.w = Math.ceil(this.w)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          (this.w = Math.round(this.w)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
          this
        );
      }
      negate() {
        return (
          (this.x = -this.x),
          (this.y = -this.y),
          (this.z = -this.z),
          (this.w = -this.w),
          this
        );
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
      }
      lengthSq() {
        return (
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      length() {
        return Math.sqrt(
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      manhattanLength() {
        return (
          Math.abs(this.x) +
          Math.abs(this.y) +
          Math.abs(this.z) +
          Math.abs(this.w)
        );
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t),
          (this.y += (e.y - this.y) * t),
          (this.z += (e.z - this.z) * t),
          (this.w += (e.w - this.w) * t),
          this
        );
      }
      lerpVectors(e, t, i) {
        return (
          (this.x = e.x + (t.x - e.x) * i),
          (this.y = e.y + (t.y - e.y) * i),
          (this.z = e.z + (t.z - e.z) * i),
          (this.w = e.w + (t.w - e.w) * i),
          this
        );
      }
      equals(e) {
        return (
          e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        );
      }
      fromArray(e, t = 0) {
        return (
          (this.x = e[t]),
          (this.y = e[t + 1]),
          (this.z = e[t + 2]),
          (this.w = e[t + 3]),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (
          (e[t] = this.x),
          (e[t + 1] = this.y),
          (e[t + 2] = this.z),
          (e[t + 3] = this.w),
          e
        );
      }
      fromBufferAttribute(e, t) {
        return (
          (this.x = e.getX(t)),
          (this.y = e.getY(t)),
          (this.z = e.getZ(t)),
          (this.w = e.getW(t)),
          this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          (this.w = Math.random()),
          this
        );
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w;
      }
    },
    to = class extends Ds {
      constructor(e = 1, t = 1, i = {}) {
        super();
        (this.isWebGLRenderTarget = !0),
          (this.width = e),
          (this.height = t),
          (this.depth = 1),
          (this.scissor = new Ti(0, 0, e, t)),
          (this.scissorTest = !1),
          (this.viewport = new Ti(0, 0, e, t));
        let r = { width: e, height: t, depth: 1 };
        (this.texture = new hn(
          r,
          i.mapping,
          i.wrapS,
          i.wrapT,
          i.magFilter,
          i.minFilter,
          i.format,
          i.type,
          i.anisotropy,
          i.encoding
        )),
          (this.texture.isRenderTargetTexture = !0),
          (this.texture.flipY = !1),
          (this.texture.generateMipmaps =
            i.generateMipmaps !== void 0 ? i.generateMipmaps : !1),
          (this.texture.internalFormat =
            i.internalFormat !== void 0 ? i.internalFormat : null),
          (this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : Wn),
          (this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0),
          (this.stencilBuffer =
            i.stencilBuffer !== void 0 ? i.stencilBuffer : !1),
          (this.depthTexture =
            i.depthTexture !== void 0 ? i.depthTexture : null),
          (this.samples = i.samples !== void 0 ? i.samples : 0);
      }
      setSize(e, t, i = 1) {
        (this.width !== e || this.height !== t || this.depth !== i) &&
          ((this.width = e),
          (this.height = t),
          (this.depth = i),
          (this.texture.image.width = e),
          (this.texture.image.height = t),
          (this.texture.image.depth = i),
          this.dispose()),
          this.viewport.set(0, 0, e, t),
          this.scissor.set(0, 0, e, t);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        (this.width = e.width),
          (this.height = e.height),
          (this.depth = e.depth),
          this.viewport.copy(e.viewport),
          (this.texture = e.texture.clone()),
          (this.texture.isRenderTargetTexture = !0);
        let t = Object.assign({}, e.texture.image);
        return (
          (this.texture.source = new fx(t)),
          (this.depthBuffer = e.depthBuffer),
          (this.stencilBuffer = e.stencilBuffer),
          e.depthTexture !== null &&
            (this.depthTexture = e.depthTexture.clone()),
          (this.samples = e.samples),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    },
    dx = class extends hn {
      constructor(e = null, t = 1, i = 1, r = 1) {
        super(null);
        (this.isDataArrayTexture = !0),
          (this.image = { data: e, width: t, height: i, depth: r }),
          (this.magFilter = un),
          (this.minFilter = un),
          (this.wrapR = xr),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1);
      }
    };
  var lC = class extends hn {
    constructor(e = null, t = 1, i = 1, r = 1) {
      super(null);
      (this.isData3DTexture = !0),
        (this.image = { data: e, width: t, height: i, depth: r }),
        (this.magFilter = un),
        (this.minFilter = un),
        (this.wrapR = xr),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  };
  var In = class {
      constructor(e = 0, t = 0, i = 0, r = 1) {
        (this.isQuaternion = !0),
          (this._x = e),
          (this._y = t),
          (this._z = i),
          (this._w = r);
      }
      static slerpFlat(e, t, i, r, s, a, o) {
        let l = i[r + 0],
          c = i[r + 1],
          u = i[r + 2],
          f = i[r + 3],
          d = s[a + 0],
          m = s[a + 1],
          x = s[a + 2],
          y = s[a + 3];
        if (o === 0) {
          (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = f);
          return;
        }
        if (o === 1) {
          (e[t + 0] = d), (e[t + 1] = m), (e[t + 2] = x), (e[t + 3] = y);
          return;
        }
        if (f !== y || l !== d || c !== m || u !== x) {
          let g = 1 - o,
            b = l * d + c * m + u * x + f * y,
            _ = b >= 0 ? 1 : -1,
            E = 1 - b * b;
          if (E > Number.EPSILON) {
            let P = Math.sqrt(E),
              L = Math.atan2(P, b * _);
            (g = Math.sin(g * L) / P), (o = Math.sin(o * L) / P);
          }
          let w = o * _;
          if (
            ((l = l * g + d * w),
            (c = c * g + m * w),
            (u = u * g + x * w),
            (f = f * g + y * w),
            g === 1 - o)
          ) {
            let P = 1 / Math.sqrt(l * l + c * c + u * u + f * f);
            (l *= P), (c *= P), (u *= P), (f *= P);
          }
        }
        (e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = f);
      }
      static multiplyQuaternionsFlat(e, t, i, r, s, a) {
        let o = i[r],
          l = i[r + 1],
          c = i[r + 2],
          u = i[r + 3],
          f = s[a],
          d = s[a + 1],
          m = s[a + 2],
          x = s[a + 3];
        return (
          (e[t] = o * x + u * f + l * m - c * d),
          (e[t + 1] = l * x + u * d + c * f - o * m),
          (e[t + 2] = c * x + u * m + o * d - l * f),
          (e[t + 3] = u * x - o * f - l * d - c * m),
          e
        );
      }
      get x() {
        return this._x;
      }
      set x(e) {
        (this._x = e), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        (this._y = e), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        (this._z = e), this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(e) {
        (this._w = e), this._onChangeCallback();
      }
      set(e, t, i, r) {
        return (
          (this._x = e),
          (this._y = t),
          (this._z = i),
          (this._w = r),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(e) {
        return (
          (this._x = e.x),
          (this._y = e.y),
          (this._z = e.z),
          (this._w = e.w),
          this._onChangeCallback(),
          this
        );
      }
      setFromEuler(e, t) {
        let i = e._x,
          r = e._y,
          s = e._z,
          a = e._order,
          o = Math.cos,
          l = Math.sin,
          c = o(i / 2),
          u = o(r / 2),
          f = o(s / 2),
          d = l(i / 2),
          m = l(r / 2),
          x = l(s / 2);
        switch (a) {
          case "XYZ":
            (this._x = d * u * f + c * m * x),
              (this._y = c * m * f - d * u * x),
              (this._z = c * u * x + d * m * f),
              (this._w = c * u * f - d * m * x);
            break;
          case "YXZ":
            (this._x = d * u * f + c * m * x),
              (this._y = c * m * f - d * u * x),
              (this._z = c * u * x - d * m * f),
              (this._w = c * u * f + d * m * x);
            break;
          case "ZXY":
            (this._x = d * u * f - c * m * x),
              (this._y = c * m * f + d * u * x),
              (this._z = c * u * x + d * m * f),
              (this._w = c * u * f - d * m * x);
            break;
          case "ZYX":
            (this._x = d * u * f - c * m * x),
              (this._y = c * m * f + d * u * x),
              (this._z = c * u * x - d * m * f),
              (this._w = c * u * f + d * m * x);
            break;
          case "YZX":
            (this._x = d * u * f + c * m * x),
              (this._y = c * m * f + d * u * x),
              (this._z = c * u * x - d * m * f),
              (this._w = c * u * f - d * m * x);
            break;
          case "XZY":
            (this._x = d * u * f - c * m * x),
              (this._y = c * m * f - d * u * x),
              (this._z = c * u * x + d * m * f),
              (this._w = c * u * f + d * m * x);
            break;
          default:
            console.warn(
              "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                a
            );
        }
        return t !== !1 && this._onChangeCallback(), this;
      }
      setFromAxisAngle(e, t) {
        let i = t / 2,
          r = Math.sin(i);
        return (
          (this._x = e.x * r),
          (this._y = e.y * r),
          (this._z = e.z * r),
          (this._w = Math.cos(i)),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(e) {
        let t = e.elements,
          i = t[0],
          r = t[4],
          s = t[8],
          a = t[1],
          o = t[5],
          l = t[9],
          c = t[2],
          u = t[6],
          f = t[10],
          d = i + o + f;
        if (d > 0) {
          let m = 0.5 / Math.sqrt(d + 1);
          (this._w = 0.25 / m),
            (this._x = (u - l) * m),
            (this._y = (s - c) * m),
            (this._z = (a - r) * m);
        } else if (i > o && i > f) {
          let m = 2 * Math.sqrt(1 + i - o - f);
          (this._w = (u - l) / m),
            (this._x = 0.25 * m),
            (this._y = (r + a) / m),
            (this._z = (s + c) / m);
        } else if (o > f) {
          let m = 2 * Math.sqrt(1 + o - i - f);
          (this._w = (s - c) / m),
            (this._x = (r + a) / m),
            (this._y = 0.25 * m),
            (this._z = (l + u) / m);
        } else {
          let m = 2 * Math.sqrt(1 + f - i - o);
          (this._w = (a - r) / m),
            (this._x = (s + c) / m),
            (this._y = (l + u) / m),
            (this._z = 0.25 * m);
        }
        return this._onChangeCallback(), this;
      }
      setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return (
          i < Number.EPSILON
            ? ((i = 0),
              Math.abs(e.x) > Math.abs(e.z)
                ? ((this._x = -e.y),
                  (this._y = e.x),
                  (this._z = 0),
                  (this._w = i))
                : ((this._x = 0),
                  (this._y = -e.z),
                  (this._z = e.y),
                  (this._w = i)))
            : ((this._x = e.y * t.z - e.z * t.y),
              (this._y = e.z * t.x - e.x * t.z),
              (this._z = e.x * t.y - e.y * t.x),
              (this._w = i)),
          this.normalize()
        );
      }
      angleTo(e) {
        return 2 * Math.acos(Math.abs(Dn(this.dot(e), -1, 1)));
      }
      rotateTowards(e, t) {
        let i = this.angleTo(e);
        if (i === 0) return this;
        let r = Math.min(1, t / i);
        return this.slerp(e, r), this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        return (
          (this._x *= -1),
          (this._y *= -1),
          (this._z *= -1),
          this._onChangeCallback(),
          this
        );
      }
      dot(e) {
        return (
          this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        );
      }
      lengthSq() {
        return (
          this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
        );
      }
      length() {
        return Math.sqrt(
          this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
        );
      }
      normalize() {
        let e = this.length();
        return (
          e === 0
            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
            : ((e = 1 / e),
              (this._x = this._x * e),
              (this._y = this._y * e),
              (this._z = this._z * e),
              (this._w = this._w * e)),
          this._onChangeCallback(),
          this
        );
      }
      multiply(e) {
        return this.multiplyQuaternions(this, e);
      }
      premultiply(e) {
        return this.multiplyQuaternions(e, this);
      }
      multiplyQuaternions(e, t) {
        let i = e._x,
          r = e._y,
          s = e._z,
          a = e._w,
          o = t._x,
          l = t._y,
          c = t._z,
          u = t._w;
        return (
          (this._x = i * u + a * o + r * c - s * l),
          (this._y = r * u + a * l + s * o - i * c),
          (this._z = s * u + a * c + i * l - r * o),
          (this._w = a * u - i * o - r * l - s * c),
          this._onChangeCallback(),
          this
        );
      }
      slerp(e, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(e);
        let i = this._x,
          r = this._y,
          s = this._z,
          a = this._w,
          o = a * e._w + i * e._x + r * e._y + s * e._z;
        if (
          (o < 0
            ? ((this._w = -e._w),
              (this._x = -e._x),
              (this._y = -e._y),
              (this._z = -e._z),
              (o = -o))
            : this.copy(e),
          o >= 1)
        )
          return (
            (this._w = a), (this._x = i), (this._y = r), (this._z = s), this
          );
        let l = 1 - o * o;
        if (l <= Number.EPSILON) {
          let m = 1 - t;
          return (
            (this._w = m * a + t * this._w),
            (this._x = m * i + t * this._x),
            (this._y = m * r + t * this._y),
            (this._z = m * s + t * this._z),
            this.normalize(),
            this._onChangeCallback(),
            this
          );
        }
        let c = Math.sqrt(l),
          u = Math.atan2(c, o),
          f = Math.sin((1 - t) * u) / c,
          d = Math.sin(t * u) / c;
        return (
          (this._w = a * f + this._w * d),
          (this._x = i * f + this._x * d),
          (this._y = r * f + this._y * d),
          (this._z = s * f + this._z * d),
          this._onChangeCallback(),
          this
        );
      }
      slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i);
      }
      random() {
        let e = Math.random(),
          t = Math.sqrt(1 - e),
          i = Math.sqrt(e),
          r = 2 * Math.PI * Math.random(),
          s = 2 * Math.PI * Math.random();
        return this.set(
          t * Math.cos(r),
          i * Math.sin(s),
          i * Math.cos(s),
          t * Math.sin(r)
        );
      }
      equals(e) {
        return (
          e._x === this._x &&
          e._y === this._y &&
          e._z === this._z &&
          e._w === this._w
        );
      }
      fromArray(e, t = 0) {
        return (
          (this._x = e[t]),
          (this._y = e[t + 1]),
          (this._z = e[t + 2]),
          (this._w = e[t + 3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (
          (e[t] = this._x),
          (e[t + 1] = this._y),
          (e[t + 2] = this._z),
          (e[t + 3] = this._w),
          e
        );
      }
      fromBufferAttribute(e, t) {
        return (
          (this._x = e.getX(t)),
          (this._y = e.getY(t)),
          (this._z = e.getZ(t)),
          (this._w = e.getW(t)),
          this
        );
      }
      _onChange(e) {
        return (this._onChangeCallback = e), this;
      }
      _onChangeCallback() {}
      *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w;
      }
    },
    le = class {
      constructor(e = 0, t = 0, i = 0) {
        (le.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
      }
      set(e, t, i) {
        return (
          i === void 0 && (i = this.z),
          (this.x = e),
          (this.y = t),
          (this.z = i),
          this
        );
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setZ(e) {
        return (this.z = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(e) {
        return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
      }
      add(e) {
        return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), this;
      }
      addVectors(e, t) {
        return (
          (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
        );
      }
      addScaledVector(e, t) {
        return (
          (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
        );
      }
      sub(e) {
        return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), this;
      }
      subVectors(e, t) {
        return (
          (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
        );
      }
      multiply(e) {
        return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), this;
      }
      multiplyVectors(e, t) {
        return (
          (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
        );
      }
      applyEuler(e) {
        return this.applyQuaternion(eA.setFromEuler(e));
      }
      applyAxisAngle(e, t) {
        return this.applyQuaternion(eA.setFromAxisAngle(e, t));
      }
      applyMatrix3(e) {
        let t = this.x,
          i = this.y,
          r = this.z,
          s = e.elements;
        return (
          (this.x = s[0] * t + s[3] * i + s[6] * r),
          (this.y = s[1] * t + s[4] * i + s[7] * r),
          (this.z = s[2] * t + s[5] * i + s[8] * r),
          this
        );
      }
      applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize();
      }
      applyMatrix4(e) {
        let t = this.x,
          i = this.y,
          r = this.z,
          s = e.elements,
          a = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
        return (
          (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * a),
          (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * a),
          (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * a),
          this
        );
      }
      applyQuaternion(e) {
        let t = this.x,
          i = this.y,
          r = this.z,
          s = e.x,
          a = e.y,
          o = e.z,
          l = e.w,
          c = l * t + a * r - o * i,
          u = l * i + o * t - s * r,
          f = l * r + s * i - a * t,
          d = -s * t - a * i - o * r;
        return (
          (this.x = c * l + d * -s + u * -o - f * -a),
          (this.y = u * l + d * -a + f * -s - c * -o),
          (this.z = f * l + d * -o + c * -a - u * -s),
          this
        );
      }
      project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
          e.projectionMatrix
        );
      }
      unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
          e.matrixWorld
        );
      }
      transformDirection(e) {
        let t = this.x,
          i = this.y,
          r = this.z,
          s = e.elements;
        return (
          (this.x = s[0] * t + s[4] * i + s[8] * r),
          (this.y = s[1] * t + s[5] * i + s[9] * r),
          (this.z = s[2] * t + s[6] * i + s[10] * r),
          this.normalize()
        );
      }
      divide(e) {
        return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          (this.z = Math.min(this.z, e.z)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          (this.z = Math.max(this.z, e.z)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          (this.z = Math.max(e.z, Math.min(t.z, this.z))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          (this.z = Math.max(e, Math.min(t, this.z))),
          this
        );
      }
      clampLength(e, t) {
        let i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(
          Math.max(e, Math.min(t, i))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t),
          (this.y += (e.y - this.y) * t),
          (this.z += (e.z - this.z) * t),
          this
        );
      }
      lerpVectors(e, t, i) {
        return (
          (this.x = e.x + (t.x - e.x) * i),
          (this.y = e.y + (t.y - e.y) * i),
          (this.z = e.z + (t.z - e.z) * i),
          this
        );
      }
      cross(e) {
        return this.crossVectors(this, e);
      }
      crossVectors(e, t) {
        let i = e.x,
          r = e.y,
          s = e.z,
          a = t.x,
          o = t.y,
          l = t.z;
        return (
          (this.x = r * l - s * o),
          (this.y = s * a - i * l),
          (this.z = i * o - r * a),
          this
        );
      }
      projectOnVector(e) {
        let t = e.lengthSq();
        if (t === 0) return this.set(0, 0, 0);
        let i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i);
      }
      projectOnPlane(e) {
        return Cv.copy(this).projectOnVector(e), this.sub(Cv);
      }
      reflect(e) {
        return this.sub(Cv.copy(e).multiplyScalar(2 * this.dot(e)));
      }
      angleTo(e) {
        let t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        let i = this.dot(e) / t;
        return Math.acos(Dn(i, -1, 1));
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        let t = this.x - e.x,
          i = this.y - e.y,
          r = this.z - e.z;
        return t * t + i * i + r * r;
      }
      manhattanDistanceTo(e) {
        return (
          Math.abs(this.x - e.x) +
          Math.abs(this.y - e.y) +
          Math.abs(this.z - e.z)
        );
      }
      setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
      }
      setFromSphericalCoords(e, t, i) {
        let r = Math.sin(t) * e;
        return (
          (this.x = r * Math.sin(i)),
          (this.y = Math.cos(t) * e),
          (this.z = r * Math.cos(i)),
          this
        );
      }
      setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
      }
      setFromCylindricalCoords(e, t, i) {
        return (
          (this.x = e * Math.sin(t)),
          (this.y = i),
          (this.z = e * Math.cos(t)),
          this
        );
      }
      setFromMatrixPosition(e) {
        let t = e.elements;
        return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
      }
      setFromMatrixScale(e) {
        let t = this.setFromMatrixColumn(e, 0).length(),
          i = this.setFromMatrixColumn(e, 1).length(),
          r = this.setFromMatrixColumn(e, 2).length();
        return (this.x = t), (this.y = i), (this.z = r), this;
      }
      setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4);
      }
      setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3);
      }
      setFromEuler(e) {
        return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
      }
      equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z;
      }
      fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
      }
      fromBufferAttribute(e, t) {
        return (
          (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          this
        );
      }
      randomDirection() {
        let e = (Math.random() - 0.5) * 2,
          t = Math.random() * Math.PI * 2,
          i = Math.sqrt(1 - Vs(e, 2));
        return (
          (this.x = i * Math.cos(t)),
          (this.y = i * Math.sin(t)),
          (this.z = e),
          this
        );
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z;
      }
    },
    Cv = new le(),
    eA = new In(),
    no = class {
      constructor(
        e = new le(1 / 0, 1 / 0, 1 / 0),
        t = new le(-1 / 0, -1 / 0, -1 / 0)
      ) {
        (this.isBox3 = !0), (this.min = e), (this.max = t);
      }
      set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
      }
      setFromArray(e) {
        let t = 1 / 0,
          i = 1 / 0,
          r = 1 / 0,
          s = -1 / 0,
          a = -1 / 0,
          o = -1 / 0;
        for (let l = 0, c = e.length; l < c; l += 3) {
          let u = e[l],
            f = e[l + 1],
            d = e[l + 2];
          u < t && (t = u),
            f < i && (i = f),
            d < r && (r = d),
            u > s && (s = u),
            f > a && (a = f),
            d > o && (o = d);
        }
        return this.min.set(t, i, r), this.max.set(s, a, o), this;
      }
      setFromBufferAttribute(e) {
        let t = 1 / 0,
          i = 1 / 0,
          r = 1 / 0,
          s = -1 / 0,
          a = -1 / 0,
          o = -1 / 0;
        for (let l = 0, c = e.count; l < c; l++) {
          let u = e.getX(l),
            f = e.getY(l),
            d = e.getZ(l);
          u < t && (t = u),
            f < i && (i = f),
            d < r && (r = d),
            u > s && (s = u),
            f > a && (a = f),
            d > o && (o = d);
        }
        return this.min.set(t, i, r), this.max.set(s, a, o), this;
      }
      setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
        return this;
      }
      setFromCenterAndSize(e, t) {
        let i = Ko.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
      }
      setFromObject(e, t = !1) {
        return this.makeEmpty(), this.expandByObject(e, t);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
      }
      makeEmpty() {
        return (
          (this.min.x = this.min.y = this.min.z = 1 / 0),
          (this.max.x = this.max.y = this.max.z = -1 / 0),
          this
        );
      }
      isEmpty() {
        return (
          this.max.x < this.min.x ||
          this.max.y < this.min.y ||
          this.max.z < this.min.z
        );
      }
      getCenter(e) {
        return this.isEmpty()
          ? e.set(0, 0, 0)
          : e.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(e) {
        return this.isEmpty()
          ? e.set(0, 0, 0)
          : e.subVectors(this.max, this.min);
      }
      expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
      }
      expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
      }
      expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
      }
      expandByObject(e, t = !1) {
        e.updateWorldMatrix(!1, !1);
        let i = e.geometry;
        if (i !== void 0)
          if (t && i.attributes != null && i.attributes.position !== void 0) {
            let s = i.attributes.position;
            for (let a = 0, o = s.count; a < o; a++)
              Ko.fromBufferAttribute(s, a).applyMatrix4(e.matrixWorld),
                this.expandByPoint(Ko);
          } else
            i.boundingBox === null && i.computeBoundingBox(),
              Pv.copy(i.boundingBox),
              Pv.applyMatrix4(e.matrixWorld),
              this.union(Pv);
        let r = e.children;
        for (let s = 0, a = r.length; s < a; s++) this.expandByObject(r[s], t);
        return this;
      }
      containsPoint(e) {
        return !(
          e.x < this.min.x ||
          e.x > this.max.x ||
          e.y < this.min.y ||
          e.y > this.max.y ||
          e.z < this.min.z ||
          e.z > this.max.z
        );
      }
      containsBox(e) {
        return (
          this.min.x <= e.min.x &&
          e.max.x <= this.max.x &&
          this.min.y <= e.min.y &&
          e.max.y <= this.max.y &&
          this.min.z <= e.min.z &&
          e.max.z <= this.max.z
        );
      }
      getParameter(e, t) {
        return t.set(
          (e.x - this.min.x) / (this.max.x - this.min.x),
          (e.y - this.min.y) / (this.max.y - this.min.y),
          (e.z - this.min.z) / (this.max.z - this.min.z)
        );
      }
      intersectsBox(e) {
        return !(
          e.max.x < this.min.x ||
          e.min.x > this.max.x ||
          e.max.y < this.min.y ||
          e.min.y > this.max.y ||
          e.max.z < this.min.z ||
          e.min.z > this.max.z
        );
      }
      intersectsSphere(e) {
        return (
          this.clampPoint(e.center, Ko),
          Ko.distanceToSquared(e.center) <= e.radius * e.radius
        );
      }
      intersectsPlane(e) {
        let t, i;
        return (
          e.normal.x > 0
            ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
            : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
          e.normal.y > 0
            ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
            : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
          e.normal.z > 0
            ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
            : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
          t <= -e.constant && i >= -e.constant
        );
      }
      intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(Ku),
          qd.subVectors(this.max, Ku),
          uc.subVectors(e.a, Ku),
          hc.subVectors(e.b, Ku),
          fc.subVectors(e.c, Ku),
          qa.subVectors(hc, uc),
          ja.subVectors(fc, hc),
          Jo.subVectors(uc, fc);
        let t = [
          0,
          -qa.z,
          qa.y,
          0,
          -ja.z,
          ja.y,
          0,
          -Jo.z,
          Jo.y,
          qa.z,
          0,
          -qa.x,
          ja.z,
          0,
          -ja.x,
          Jo.z,
          0,
          -Jo.x,
          -qa.y,
          qa.x,
          0,
          -ja.y,
          ja.x,
          0,
          -Jo.y,
          Jo.x,
          0,
        ];
        return !Dv(t, uc, hc, fc, qd) ||
          ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Dv(t, uc, hc, fc, qd))
          ? !1
          : (jd.crossVectors(qa, ja),
            (t = [jd.x, jd.y, jd.z]),
            Dv(t, uc, hc, fc, qd));
      }
      clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
      }
      distanceToPoint(e) {
        return Ko.copy(e).clamp(this.min, this.max).sub(e).length();
      }
      getBoundingSphere(e) {
        return (
          this.getCenter(e.center),
          (e.radius = this.getSize(Ko).length() * 0.5),
          e
        );
      }
      intersect(e) {
        return (
          this.min.max(e.min),
          this.max.min(e.max),
          this.isEmpty() && this.makeEmpty(),
          this
        );
      }
      union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
      }
      applyMatrix4(e) {
        return this.isEmpty()
          ? this
          : (Zs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
            Zs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
            Zs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
            Zs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
            Zs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
            Zs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
            Zs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
            Zs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
            this.setFromPoints(Zs),
            this);
      }
      translate(e) {
        return this.min.add(e), this.max.add(e), this;
      }
      equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
      }
    },
    Zs = [
      new le(),
      new le(),
      new le(),
      new le(),
      new le(),
      new le(),
      new le(),
      new le(),
    ],
    Ko = new le(),
    Pv = new no(),
    uc = new le(),
    hc = new le(),
    fc = new le(),
    qa = new le(),
    ja = new le(),
    Jo = new le(),
    Ku = new le(),
    qd = new le(),
    jd = new le(),
    Zo = new le();
  function Dv(n, e, t, i, r) {
    for (let s = 0, a = n.length - 3; s <= a; s += 3) {
      Zo.fromArray(n, s);
      let o =
          r.x * Math.abs(Zo.x) + r.y * Math.abs(Zo.y) + r.z * Math.abs(Zo.z),
        l = e.dot(Zo),
        c = t.dot(Zo),
        u = i.dot(Zo);
      if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o) return !1;
    }
    return !0;
  }
  var Wz = new no(),
    Ju = new le(),
    Iv = new le(),
    ro = class {
      constructor(e = new le(), t = -1) {
        (this.center = e), (this.radius = t);
      }
      set(e, t) {
        return this.center.copy(e), (this.radius = t), this;
      }
      setFromPoints(e, t) {
        let i = this.center;
        t !== void 0 ? i.copy(t) : Wz.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, a = e.length; s < a; s++)
          r = Math.max(r, i.distanceToSquared(e[s]));
        return (this.radius = Math.sqrt(r)), this;
      }
      copy(e) {
        return this.center.copy(e.center), (this.radius = e.radius), this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), (this.radius = -1), this;
      }
      containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(e) {
        let t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t;
      }
      intersectsBox(e) {
        return e.intersectsSphere(this);
      }
      intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(e, t) {
        let i = this.center.distanceToSquared(e);
        return (
          t.copy(e),
          i > this.radius * this.radius &&
            (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
          t
        );
      }
      getBoundingBox(e) {
        return this.isEmpty()
          ? (e.makeEmpty(), e)
          : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
      }
      applyMatrix4(e) {
        return (
          this.center.applyMatrix4(e),
          (this.radius = this.radius * e.getMaxScaleOnAxis()),
          this
        );
      }
      translate(e) {
        return this.center.add(e), this;
      }
      expandByPoint(e) {
        if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
        Ju.subVectors(e, this.center);
        let t = Ju.lengthSq();
        if (t > this.radius * this.radius) {
          let i = Math.sqrt(t),
            r = (i - this.radius) * 0.5;
          this.center.addScaledVector(Ju, r / i), (this.radius += r);
        }
        return this;
      }
      union(e) {
        return e.isEmpty()
          ? this
          : this.isEmpty()
          ? (this.copy(e), this)
          : (this.center.equals(e.center) === !0
              ? (this.radius = Math.max(this.radius, e.radius))
              : (Iv.subVectors(e.center, this.center).setLength(e.radius),
                this.expandByPoint(Ju.copy(e.center).add(Iv)),
                this.expandByPoint(Ju.copy(e.center).sub(Iv))),
            this);
      }
      equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    },
    Qs = new le(),
    Lv = new le(),
    Xd = new le(),
    Xa = new le(),
    Rv = new le(),
    Yd = new le(),
    Ov = new le(),
    xp = class {
      constructor(e = new le(), t = new le(0, 0, -1)) {
        (this.origin = e), (this.direction = t);
      }
      set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this;
      }
      copy(e) {
        return (
          this.origin.copy(e.origin), this.direction.copy(e.direction), this
        );
      }
      at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin);
      }
      lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this;
      }
      recast(e) {
        return this.origin.copy(this.at(e, Qs)), this;
      }
      closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        let i = t.dot(this.direction);
        return i < 0
          ? t.copy(this.origin)
          : t.copy(this.direction).multiplyScalar(i).add(this.origin);
      }
      distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e));
      }
      distanceSqToPoint(e) {
        let t = Qs.subVectors(e, this.origin).dot(this.direction);
        return t < 0
          ? this.origin.distanceToSquared(e)
          : (Qs.copy(this.direction).multiplyScalar(t).add(this.origin),
            Qs.distanceToSquared(e));
      }
      distanceSqToSegment(e, t, i, r) {
        Lv.copy(e).add(t).multiplyScalar(0.5),
          Xd.copy(t).sub(e).normalize(),
          Xa.copy(this.origin).sub(Lv);
        let s = e.distanceTo(t) * 0.5,
          a = -this.direction.dot(Xd),
          o = Xa.dot(this.direction),
          l = -Xa.dot(Xd),
          c = Xa.lengthSq(),
          u = Math.abs(1 - a * a),
          f,
          d,
          m,
          x;
        if (u > 0)
          if (((f = a * l - o), (d = a * o - l), (x = s * u), f >= 0))
            if (d >= -x)
              if (d <= x) {
                let y = 1 / u;
                (f *= y),
                  (d *= y),
                  (m = f * (f + a * d + 2 * o) + d * (a * f + d + 2 * l) + c);
              } else
                (d = s),
                  (f = Math.max(0, -(a * d + o))),
                  (m = -f * f + d * (d + 2 * l) + c);
            else
              (d = -s),
                (f = Math.max(0, -(a * d + o))),
                (m = -f * f + d * (d + 2 * l) + c);
          else
            d <= -x
              ? ((f = Math.max(0, -(-a * s + o))),
                (d = f > 0 ? -s : Math.min(Math.max(-s, -l), s)),
                (m = -f * f + d * (d + 2 * l) + c))
              : d <= x
              ? ((f = 0),
                (d = Math.min(Math.max(-s, -l), s)),
                (m = d * (d + 2 * l) + c))
              : ((f = Math.max(0, -(a * s + o))),
                (d = f > 0 ? s : Math.min(Math.max(-s, -l), s)),
                (m = -f * f + d * (d + 2 * l) + c));
        else
          (d = a > 0 ? -s : s),
            (f = Math.max(0, -(a * d + o))),
            (m = -f * f + d * (d + 2 * l) + c);
        return (
          i && i.copy(this.direction).multiplyScalar(f).add(this.origin),
          r && r.copy(Xd).multiplyScalar(d).add(Lv),
          m
        );
      }
      intersectSphere(e, t) {
        Qs.subVectors(e.center, this.origin);
        let i = Qs.dot(this.direction),
          r = Qs.dot(Qs) - i * i,
          s = e.radius * e.radius;
        if (r > s) return null;
        let a = Math.sqrt(s - r),
          o = i - a,
          l = i + a;
        return o < 0 && l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
      }
      intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
      }
      distanceToPlane(e) {
        let t = e.normal.dot(this.direction);
        if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        let i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null;
      }
      intersectPlane(e, t) {
        let i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t);
      }
      intersectsPlane(e) {
        let t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0;
      }
      intersectBox(e, t) {
        let i,
          r,
          s,
          a,
          o,
          l,
          c = 1 / this.direction.x,
          u = 1 / this.direction.y,
          f = 1 / this.direction.z,
          d = this.origin;
        return (
          c >= 0
            ? ((i = (e.min.x - d.x) * c), (r = (e.max.x - d.x) * c))
            : ((i = (e.max.x - d.x) * c), (r = (e.min.x - d.x) * c)),
          u >= 0
            ? ((s = (e.min.y - d.y) * u), (a = (e.max.y - d.y) * u))
            : ((s = (e.max.y - d.y) * u), (a = (e.min.y - d.y) * u)),
          i > a ||
          s > r ||
          ((s > i || isNaN(i)) && (i = s),
          (a < r || isNaN(r)) && (r = a),
          f >= 0
            ? ((o = (e.min.z - d.z) * f), (l = (e.max.z - d.z) * f))
            : ((o = (e.max.z - d.z) * f), (l = (e.min.z - d.z) * f)),
          i > l || o > r) ||
          ((o > i || i !== i) && (i = o), (l < r || r !== r) && (r = l), r < 0)
            ? null
            : this.at(i >= 0 ? i : r, t)
        );
      }
      intersectsBox(e) {
        return this.intersectBox(e, Qs) !== null;
      }
      intersectTriangle(e, t, i, r, s) {
        Rv.subVectors(t, e), Yd.subVectors(i, e), Ov.crossVectors(Rv, Yd);
        let a = this.direction.dot(Ov),
          o;
        if (a > 0) {
          if (r) return null;
          o = 1;
        } else if (a < 0) (o = -1), (a = -a);
        else return null;
        Xa.subVectors(this.origin, e);
        let l = o * this.direction.dot(Yd.crossVectors(Xa, Yd));
        if (l < 0) return null;
        let c = o * this.direction.dot(Rv.cross(Xa));
        if (c < 0 || l + c > a) return null;
        let u = -o * Xa.dot(Ov);
        return u < 0 ? null : this.at(u / a, s);
      }
      applyMatrix4(e) {
        return (
          this.origin.applyMatrix4(e),
          this.direction.transformDirection(e),
          this
        );
      }
      equals(e) {
        return (
          e.origin.equals(this.origin) && e.direction.equals(this.direction)
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
    },
    Wt = class {
      constructor() {
        (Wt.prototype.isMatrix4 = !0),
          (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      }
      set(e, t, i, r, s, a, o, l, c, u, f, d, m, x, y, g) {
        let b = this.elements;
        return (
          (b[0] = e),
          (b[4] = t),
          (b[8] = i),
          (b[12] = r),
          (b[1] = s),
          (b[5] = a),
          (b[9] = o),
          (b[13] = l),
          (b[2] = c),
          (b[6] = u),
          (b[10] = f),
          (b[14] = d),
          (b[3] = m),
          (b[7] = x),
          (b[11] = y),
          (b[15] = g),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      clone() {
        return new Wt().fromArray(this.elements);
      }
      copy(e) {
        let t = this.elements,
          i = e.elements;
        return (
          (t[0] = i[0]),
          (t[1] = i[1]),
          (t[2] = i[2]),
          (t[3] = i[3]),
          (t[4] = i[4]),
          (t[5] = i[5]),
          (t[6] = i[6]),
          (t[7] = i[7]),
          (t[8] = i[8]),
          (t[9] = i[9]),
          (t[10] = i[10]),
          (t[11] = i[11]),
          (t[12] = i[12]),
          (t[13] = i[13]),
          (t[14] = i[14]),
          (t[15] = i[15]),
          this
        );
      }
      copyPosition(e) {
        let t = this.elements,
          i = e.elements;
        return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
      }
      setFromMatrix3(e) {
        let t = e.elements;
        return (
          this.set(
            t[0],
            t[3],
            t[6],
            0,
            t[1],
            t[4],
            t[7],
            0,
            t[2],
            t[5],
            t[8],
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      extractBasis(e, t, i) {
        return (
          e.setFromMatrixColumn(this, 0),
          t.setFromMatrixColumn(this, 1),
          i.setFromMatrixColumn(this, 2),
          this
        );
      }
      makeBasis(e, t, i) {
        return (
          this.set(
            e.x,
            t.x,
            i.x,
            0,
            e.y,
            t.y,
            i.y,
            0,
            e.z,
            t.z,
            i.z,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      extractRotation(e) {
        let t = this.elements,
          i = e.elements,
          r = 1 / dc.setFromMatrixColumn(e, 0).length(),
          s = 1 / dc.setFromMatrixColumn(e, 1).length(),
          a = 1 / dc.setFromMatrixColumn(e, 2).length();
        return (
          (t[0] = i[0] * r),
          (t[1] = i[1] * r),
          (t[2] = i[2] * r),
          (t[3] = 0),
          (t[4] = i[4] * s),
          (t[5] = i[5] * s),
          (t[6] = i[6] * s),
          (t[7] = 0),
          (t[8] = i[8] * a),
          (t[9] = i[9] * a),
          (t[10] = i[10] * a),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1),
          this
        );
      }
      makeRotationFromEuler(e) {
        let t = this.elements,
          i = e.x,
          r = e.y,
          s = e.z,
          a = Math.cos(i),
          o = Math.sin(i),
          l = Math.cos(r),
          c = Math.sin(r),
          u = Math.cos(s),
          f = Math.sin(s);
        if (e.order === "XYZ") {
          let d = a * u,
            m = a * f,
            x = o * u,
            y = o * f;
          (t[0] = l * u),
            (t[4] = -l * f),
            (t[8] = c),
            (t[1] = m + x * c),
            (t[5] = d - y * c),
            (t[9] = -o * l),
            (t[2] = y - d * c),
            (t[6] = x + m * c),
            (t[10] = a * l);
        } else if (e.order === "YXZ") {
          let d = l * u,
            m = l * f,
            x = c * u,
            y = c * f;
          (t[0] = d + y * o),
            (t[4] = x * o - m),
            (t[8] = a * c),
            (t[1] = a * f),
            (t[5] = a * u),
            (t[9] = -o),
            (t[2] = m * o - x),
            (t[6] = y + d * o),
            (t[10] = a * l);
        } else if (e.order === "ZXY") {
          let d = l * u,
            m = l * f,
            x = c * u,
            y = c * f;
          (t[0] = d - y * o),
            (t[4] = -a * f),
            (t[8] = x + m * o),
            (t[1] = m + x * o),
            (t[5] = a * u),
            (t[9] = y - d * o),
            (t[2] = -a * c),
            (t[6] = o),
            (t[10] = a * l);
        } else if (e.order === "ZYX") {
          let d = a * u,
            m = a * f,
            x = o * u,
            y = o * f;
          (t[0] = l * u),
            (t[4] = x * c - m),
            (t[8] = d * c + y),
            (t[1] = l * f),
            (t[5] = y * c + d),
            (t[9] = m * c - x),
            (t[2] = -c),
            (t[6] = o * l),
            (t[10] = a * l);
        } else if (e.order === "YZX") {
          let d = a * l,
            m = a * c,
            x = o * l,
            y = o * c;
          (t[0] = l * u),
            (t[4] = y - d * f),
            (t[8] = x * f + m),
            (t[1] = f),
            (t[5] = a * u),
            (t[9] = -o * u),
            (t[2] = -c * u),
            (t[6] = m * f + x),
            (t[10] = d - y * f);
        } else if (e.order === "XZY") {
          let d = a * l,
            m = a * c,
            x = o * l,
            y = o * c;
          (t[0] = l * u),
            (t[4] = -f),
            (t[8] = c * u),
            (t[1] = d * f + y),
            (t[5] = a * u),
            (t[9] = m * f - x),
            (t[2] = x * f - m),
            (t[6] = o * u),
            (t[10] = y * f + d);
        }
        return (
          (t[3] = 0),
          (t[7] = 0),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1),
          this
        );
      }
      makeRotationFromQuaternion(e) {
        return this.compose(qz, e, jz);
      }
      lookAt(e, t, i) {
        let r = this.elements;
        return (
          yr.subVectors(e, t),
          yr.lengthSq() === 0 && (yr.z = 1),
          yr.normalize(),
          Ya.crossVectors(i, yr),
          Ya.lengthSq() === 0 &&
            (Math.abs(i.z) === 1 ? (yr.x += 1e-4) : (yr.z += 1e-4),
            yr.normalize(),
            Ya.crossVectors(i, yr)),
          Ya.normalize(),
          Kd.crossVectors(yr, Ya),
          (r[0] = Ya.x),
          (r[4] = Kd.x),
          (r[8] = yr.x),
          (r[1] = Ya.y),
          (r[5] = Kd.y),
          (r[9] = yr.y),
          (r[2] = Ya.z),
          (r[6] = Kd.z),
          (r[10] = yr.z),
          this
        );
      }
      multiply(e) {
        return this.multiplyMatrices(this, e);
      }
      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }
      multiplyMatrices(e, t) {
        let i = e.elements,
          r = t.elements,
          s = this.elements,
          a = i[0],
          o = i[4],
          l = i[8],
          c = i[12],
          u = i[1],
          f = i[5],
          d = i[9],
          m = i[13],
          x = i[2],
          y = i[6],
          g = i[10],
          b = i[14],
          _ = i[3],
          E = i[7],
          w = i[11],
          P = i[15],
          L = r[0],
          I = r[4],
          M = r[8],
          R = r[12],
          O = r[1],
          U = r[5],
          X = r[9],
          $ = r[13],
          W = r[2],
          ue = r[6],
          ae = r[10],
          he = r[14],
          ce = r[3],
          te = r[7],
          Me = r[11],
          ge = r[15];
        return (
          (s[0] = a * L + o * O + l * W + c * ce),
          (s[4] = a * I + o * U + l * ue + c * te),
          (s[8] = a * M + o * X + l * ae + c * Me),
          (s[12] = a * R + o * $ + l * he + c * ge),
          (s[1] = u * L + f * O + d * W + m * ce),
          (s[5] = u * I + f * U + d * ue + m * te),
          (s[9] = u * M + f * X + d * ae + m * Me),
          (s[13] = u * R + f * $ + d * he + m * ge),
          (s[2] = x * L + y * O + g * W + b * ce),
          (s[6] = x * I + y * U + g * ue + b * te),
          (s[10] = x * M + y * X + g * ae + b * Me),
          (s[14] = x * R + y * $ + g * he + b * ge),
          (s[3] = _ * L + E * O + w * W + P * ce),
          (s[7] = _ * I + E * U + w * ue + P * te),
          (s[11] = _ * M + E * X + w * ae + P * Me),
          (s[15] = _ * R + E * $ + w * he + P * ge),
          this
        );
      }
      multiplyScalar(e) {
        let t = this.elements;
        return (
          (t[0] *= e),
          (t[4] *= e),
          (t[8] *= e),
          (t[12] *= e),
          (t[1] *= e),
          (t[5] *= e),
          (t[9] *= e),
          (t[13] *= e),
          (t[2] *= e),
          (t[6] *= e),
          (t[10] *= e),
          (t[14] *= e),
          (t[3] *= e),
          (t[7] *= e),
          (t[11] *= e),
          (t[15] *= e),
          this
        );
      }
      determinant() {
        let e = this.elements,
          t = e[0],
          i = e[4],
          r = e[8],
          s = e[12],
          a = e[1],
          o = e[5],
          l = e[9],
          c = e[13],
          u = e[2],
          f = e[6],
          d = e[10],
          m = e[14],
          x = e[3],
          y = e[7],
          g = e[11],
          b = e[15];
        return (
          x *
            (+s * l * f -
              r * c * f -
              s * o * d +
              i * c * d +
              r * o * m -
              i * l * m) +
          y *
            (+t * l * m -
              t * c * d +
              s * a * d -
              r * a * m +
              r * c * u -
              s * l * u) +
          g *
            (+t * c * f -
              t * o * m -
              s * a * f +
              i * a * m +
              s * o * u -
              i * c * u) +
          b *
            (-r * o * u -
              t * l * f +
              t * o * d +
              r * a * f -
              i * a * d +
              i * l * u)
        );
      }
      transpose() {
        let e = this.elements,
          t;
        return (
          (t = e[1]),
          (e[1] = e[4]),
          (e[4] = t),
          (t = e[2]),
          (e[2] = e[8]),
          (e[8] = t),
          (t = e[6]),
          (e[6] = e[9]),
          (e[9] = t),
          (t = e[3]),
          (e[3] = e[12]),
          (e[12] = t),
          (t = e[7]),
          (e[7] = e[13]),
          (e[13] = t),
          (t = e[11]),
          (e[11] = e[14]),
          (e[14] = t),
          this
        );
      }
      setPosition(e, t, i) {
        let r = this.elements;
        return (
          e.isVector3
            ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
            : ((r[12] = e), (r[13] = t), (r[14] = i)),
          this
        );
      }
      invert() {
        let e = this.elements,
          t = e[0],
          i = e[1],
          r = e[2],
          s = e[3],
          a = e[4],
          o = e[5],
          l = e[6],
          c = e[7],
          u = e[8],
          f = e[9],
          d = e[10],
          m = e[11],
          x = e[12],
          y = e[13],
          g = e[14],
          b = e[15],
          _ =
            f * g * c -
            y * d * c +
            y * l * m -
            o * g * m -
            f * l * b +
            o * d * b,
          E =
            x * d * c -
            u * g * c -
            x * l * m +
            a * g * m +
            u * l * b -
            a * d * b,
          w =
            u * y * c -
            x * f * c +
            x * o * m -
            a * y * m -
            u * o * b +
            a * f * b,
          P =
            x * f * l -
            u * y * l -
            x * o * d +
            a * y * d +
            u * o * g -
            a * f * g,
          L = t * _ + i * E + r * w + s * P;
        if (L === 0)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        let I = 1 / L;
        return (
          (e[0] = _ * I),
          (e[1] =
            (y * d * s -
              f * g * s -
              y * r * m +
              i * g * m +
              f * r * b -
              i * d * b) *
            I),
          (e[2] =
            (o * g * s -
              y * l * s +
              y * r * c -
              i * g * c -
              o * r * b +
              i * l * b) *
            I),
          (e[3] =
            (f * l * s -
              o * d * s -
              f * r * c +
              i * d * c +
              o * r * m -
              i * l * m) *
            I),
          (e[4] = E * I),
          (e[5] =
            (u * g * s -
              x * d * s +
              x * r * m -
              t * g * m -
              u * r * b +
              t * d * b) *
            I),
          (e[6] =
            (x * l * s -
              a * g * s -
              x * r * c +
              t * g * c +
              a * r * b -
              t * l * b) *
            I),
          (e[7] =
            (a * d * s -
              u * l * s +
              u * r * c -
              t * d * c -
              a * r * m +
              t * l * m) *
            I),
          (e[8] = w * I),
          (e[9] =
            (x * f * s -
              u * y * s -
              x * i * m +
              t * y * m +
              u * i * b -
              t * f * b) *
            I),
          (e[10] =
            (a * y * s -
              x * o * s +
              x * i * c -
              t * y * c -
              a * i * b +
              t * o * b) *
            I),
          (e[11] =
            (u * o * s -
              a * f * s -
              u * i * c +
              t * f * c +
              a * i * m -
              t * o * m) *
            I),
          (e[12] = P * I),
          (e[13] =
            (u * y * r -
              x * f * r +
              x * i * d -
              t * y * d -
              u * i * g +
              t * f * g) *
            I),
          (e[14] =
            (x * o * r -
              a * y * r -
              x * i * l +
              t * y * l +
              a * i * g -
              t * o * g) *
            I),
          (e[15] =
            (a * f * r -
              u * o * r +
              u * i * l -
              t * f * l -
              a * i * d +
              t * o * d) *
            I),
          this
        );
      }
      scale(e) {
        let t = this.elements,
          i = e.x,
          r = e.y,
          s = e.z;
        return (
          (t[0] *= i),
          (t[4] *= r),
          (t[8] *= s),
          (t[1] *= i),
          (t[5] *= r),
          (t[9] *= s),
          (t[2] *= i),
          (t[6] *= r),
          (t[10] *= s),
          (t[3] *= i),
          (t[7] *= r),
          (t[11] *= s),
          this
        );
      }
      getMaxScaleOnAxis() {
        let e = this.elements,
          t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
          i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
          r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, r));
      }
      makeTranslation(e, t, i) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
      }
      makeRotationX(e) {
        let t = Math.cos(e),
          i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationY(e) {
        let t = Math.cos(e),
          i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationZ(e) {
        let t = Math.cos(e),
          i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      makeRotationAxis(e, t) {
        let i = Math.cos(t),
          r = Math.sin(t),
          s = 1 - i,
          a = e.x,
          o = e.y,
          l = e.z,
          c = s * a,
          u = s * o;
        return (
          this.set(
            c * a + i,
            c * o - r * l,
            c * l + r * o,
            0,
            c * o + r * l,
            u * o + i,
            u * l - r * a,
            0,
            c * l - r * o,
            u * l + r * a,
            s * l * l + i,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
      }
      makeShear(e, t, i, r, s, a) {
        return this.set(1, i, s, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this;
      }
      compose(e, t, i) {
        let r = this.elements,
          s = t._x,
          a = t._y,
          o = t._z,
          l = t._w,
          c = s + s,
          u = a + a,
          f = o + o,
          d = s * c,
          m = s * u,
          x = s * f,
          y = a * u,
          g = a * f,
          b = o * f,
          _ = l * c,
          E = l * u,
          w = l * f,
          P = i.x,
          L = i.y,
          I = i.z;
        return (
          (r[0] = (1 - (y + b)) * P),
          (r[1] = (m + w) * P),
          (r[2] = (x - E) * P),
          (r[3] = 0),
          (r[4] = (m - w) * L),
          (r[5] = (1 - (d + b)) * L),
          (r[6] = (g + _) * L),
          (r[7] = 0),
          (r[8] = (x + E) * I),
          (r[9] = (g - _) * I),
          (r[10] = (1 - (d + y)) * I),
          (r[11] = 0),
          (r[12] = e.x),
          (r[13] = e.y),
          (r[14] = e.z),
          (r[15] = 1),
          this
        );
      }
      decompose(e, t, i) {
        let r = this.elements,
          s = dc.set(r[0], r[1], r[2]).length(),
          a = dc.set(r[4], r[5], r[6]).length(),
          o = dc.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
          (e.x = r[12]),
          (e.y = r[13]),
          (e.z = r[14]),
          hs.copy(this);
        let c = 1 / s,
          u = 1 / a,
          f = 1 / o;
        return (
          (hs.elements[0] *= c),
          (hs.elements[1] *= c),
          (hs.elements[2] *= c),
          (hs.elements[4] *= u),
          (hs.elements[5] *= u),
          (hs.elements[6] *= u),
          (hs.elements[8] *= f),
          (hs.elements[9] *= f),
          (hs.elements[10] *= f),
          t.setFromRotationMatrix(hs),
          (i.x = s),
          (i.y = a),
          (i.z = o),
          this
        );
      }
      makePerspective(e, t, i, r, s, a) {
        let o = this.elements,
          l = (2 * s) / (t - e),
          c = (2 * s) / (i - r),
          u = (t + e) / (t - e),
          f = (i + r) / (i - r),
          d = -(a + s) / (a - s),
          m = (-2 * a * s) / (a - s);
        return (
          (o[0] = l),
          (o[4] = 0),
          (o[8] = u),
          (o[12] = 0),
          (o[1] = 0),
          (o[5] = c),
          (o[9] = f),
          (o[13] = 0),
          (o[2] = 0),
          (o[6] = 0),
          (o[10] = d),
          (o[14] = m),
          (o[3] = 0),
          (o[7] = 0),
          (o[11] = -1),
          (o[15] = 0),
          this
        );
      }
      makeOrthographic(e, t, i, r, s, a) {
        let o = this.elements,
          l = 1 / (t - e),
          c = 1 / (i - r),
          u = 1 / (a - s),
          f = (t + e) * l,
          d = (i + r) * c,
          m = (a + s) * u;
        return (
          (o[0] = 2 * l),
          (o[4] = 0),
          (o[8] = 0),
          (o[12] = -f),
          (o[1] = 0),
          (o[5] = 2 * c),
          (o[9] = 0),
          (o[13] = -d),
          (o[2] = 0),
          (o[6] = 0),
          (o[10] = -2 * u),
          (o[14] = -m),
          (o[3] = 0),
          (o[7] = 0),
          (o[11] = 0),
          (o[15] = 1),
          this
        );
      }
      equals(e) {
        let t = this.elements,
          i = e.elements;
        for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
        return !0;
      }
      fromArray(e, t = 0) {
        for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
        return this;
      }
      toArray(e = [], t = 0) {
        let i = this.elements;
        return (
          (e[t] = i[0]),
          (e[t + 1] = i[1]),
          (e[t + 2] = i[2]),
          (e[t + 3] = i[3]),
          (e[t + 4] = i[4]),
          (e[t + 5] = i[5]),
          (e[t + 6] = i[6]),
          (e[t + 7] = i[7]),
          (e[t + 8] = i[8]),
          (e[t + 9] = i[9]),
          (e[t + 10] = i[10]),
          (e[t + 11] = i[11]),
          (e[t + 12] = i[12]),
          (e[t + 13] = i[13]),
          (e[t + 14] = i[14]),
          (e[t + 15] = i[15]),
          e
        );
      }
    },
    dc = new le(),
    hs = new Wt(),
    qz = new le(0, 0, 0),
    jz = new le(1, 1, 1),
    Ya = new le(),
    Kd = new le(),
    yr = new le(),
    tA = new Wt(),
    iA = new In(),
    Nc = class {
      constructor(e = 0, t = 0, i = 0, r = Nc.DefaultOrder) {
        (this.isEuler = !0),
          (this._x = e),
          (this._y = t),
          (this._z = i),
          (this._order = r);
      }
      get x() {
        return this._x;
      }
      set x(e) {
        (this._x = e), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        (this._y = e), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        (this._z = e), this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(e) {
        (this._order = e), this._onChangeCallback();
      }
      set(e, t, i, r = this._order) {
        return (
          (this._x = e),
          (this._y = t),
          (this._z = i),
          (this._order = r),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(e) {
        return (
          (this._x = e._x),
          (this._y = e._y),
          (this._z = e._z),
          (this._order = e._order),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(e, t = this._order, i = !0) {
        let r = e.elements,
          s = r[0],
          a = r[4],
          o = r[8],
          l = r[1],
          c = r[5],
          u = r[9],
          f = r[2],
          d = r[6],
          m = r[10];
        switch (t) {
          case "XYZ":
            (this._y = Math.asin(Dn(o, -1, 1))),
              Math.abs(o) < 0.9999999
                ? ((this._x = Math.atan2(-u, m)), (this._z = Math.atan2(-a, s)))
                : ((this._x = Math.atan2(d, c)), (this._z = 0));
            break;
          case "YXZ":
            (this._x = Math.asin(-Dn(u, -1, 1))),
              Math.abs(u) < 0.9999999
                ? ((this._y = Math.atan2(o, m)), (this._z = Math.atan2(l, c)))
                : ((this._y = Math.atan2(-f, s)), (this._z = 0));
            break;
          case "ZXY":
            (this._x = Math.asin(Dn(d, -1, 1))),
              Math.abs(d) < 0.9999999
                ? ((this._y = Math.atan2(-f, m)), (this._z = Math.atan2(-a, c)))
                : ((this._y = 0), (this._z = Math.atan2(l, s)));
            break;
          case "ZYX":
            (this._y = Math.asin(-Dn(f, -1, 1))),
              Math.abs(f) < 0.9999999
                ? ((this._x = Math.atan2(d, m)), (this._z = Math.atan2(l, s)))
                : ((this._x = 0), (this._z = Math.atan2(-a, c)));
            break;
          case "YZX":
            (this._z = Math.asin(Dn(l, -1, 1))),
              Math.abs(l) < 0.9999999
                ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-f, s)))
                : ((this._x = 0), (this._y = Math.atan2(o, m)));
            break;
          case "XZY":
            (this._z = Math.asin(-Dn(a, -1, 1))),
              Math.abs(a) < 0.9999999
                ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(o, s)))
                : ((this._x = Math.atan2(-u, m)), (this._y = 0));
            break;
          default:
            console.warn(
              "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                t
            );
        }
        return (this._order = t), i === !0 && this._onChangeCallback(), this;
      }
      setFromQuaternion(e, t, i) {
        return (
          tA.makeRotationFromQuaternion(e), this.setFromRotationMatrix(tA, t, i)
        );
      }
      setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t);
      }
      reorder(e) {
        return iA.setFromEuler(this), this.setFromQuaternion(iA, e);
      }
      equals(e) {
        return (
          e._x === this._x &&
          e._y === this._y &&
          e._z === this._z &&
          e._order === this._order
        );
      }
      fromArray(e) {
        return (
          (this._x = e[0]),
          (this._y = e[1]),
          (this._z = e[2]),
          e[3] !== void 0 && (this._order = e[3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (
          (e[t] = this._x),
          (e[t + 1] = this._y),
          (e[t + 2] = this._z),
          (e[t + 3] = this._order),
          e
        );
      }
      _onChange(e) {
        return (this._onChangeCallback = e), this;
      }
      _onChangeCallback() {}
      *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order;
      }
      toVector3() {
        console.error(
          "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"
        );
      }
    };
  Nc.DefaultOrder = "XYZ";
  Nc.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  var px = class {
      constructor() {
        this.mask = 1;
      }
      set(e) {
        this.mask = ((1 << e) | 0) >>> 0;
      }
      enable(e) {
        this.mask |= (1 << e) | 0;
      }
      enableAll() {
        this.mask = -1;
      }
      toggle(e) {
        this.mask ^= (1 << e) | 0;
      }
      disable(e) {
        this.mask &= ~((1 << e) | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(e) {
        return (this.mask & e.mask) !== 0;
      }
      isEnabled(e) {
        return (this.mask & ((1 << e) | 0)) !== 0;
      }
    },
    Xz = 0,
    nA = new le(),
    pc = new In(),
    ea = new Wt(),
    Jd = new le(),
    Zu = new le(),
    Yz = new le(),
    Kz = new In(),
    rA = new le(1, 0, 0),
    sA = new le(0, 1, 0),
    aA = new le(0, 0, 1),
    Jz = { type: "added" },
    oA = { type: "removed" },
    Ai = class extends Ds {
      constructor() {
        super();
        (this.isObject3D = !0),
          Object.defineProperty(this, "id", { value: Xz++ }),
          (this.uuid = ds()),
          (this.name = ""),
          (this.type = "Object3D"),
          (this.parent = null),
          (this.children = []),
          (this.up = Ai.DefaultUp.clone());
        let e = new le(),
          t = new Nc(),
          i = new In(),
          r = new le(1, 1, 1);
        function s() {
          i.setFromEuler(t, !1);
        }
        function a() {
          t.setFromQuaternion(i, void 0, !1);
        }
        t._onChange(s),
          i._onChange(a),
          Object.defineProperties(this, {
            position: { configurable: !0, enumerable: !0, value: e },
            rotation: { configurable: !0, enumerable: !0, value: t },
            quaternion: { configurable: !0, enumerable: !0, value: i },
            scale: { configurable: !0, enumerable: !0, value: r },
            modelViewMatrix: { value: new Wt() },
            normalMatrix: { value: new sr() },
          }),
          (this.matrix = new Wt()),
          (this.matrixWorld = new Wt()),
          (this.matrixAutoUpdate = Ai.DefaultMatrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = !1),
          (this.matrixWorldAutoUpdate = Ai.DefaultMatrixWorldAutoUpdate),
          (this.layers = new px()),
          (this.visible = !0),
          (this.castShadow = !1),
          (this.receiveShadow = !1),
          (this.frustumCulled = !0),
          (this.renderOrder = 0),
          (this.animations = []),
          (this.userData = {});
      }
      onBeforeRender() {}
      onAfterRender() {}
      applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          this.matrix.premultiply(e),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(e) {
        return this.quaternion.premultiply(e), this;
      }
      setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t);
      }
      setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0);
      }
      setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e);
      }
      setRotationFromQuaternion(e) {
        this.quaternion.copy(e);
      }
      rotateOnAxis(e, t) {
        return pc.setFromAxisAngle(e, t), this.quaternion.multiply(pc), this;
      }
      rotateOnWorldAxis(e, t) {
        return pc.setFromAxisAngle(e, t), this.quaternion.premultiply(pc), this;
      }
      rotateX(e) {
        return this.rotateOnAxis(rA, e);
      }
      rotateY(e) {
        return this.rotateOnAxis(sA, e);
      }
      rotateZ(e) {
        return this.rotateOnAxis(aA, e);
      }
      translateOnAxis(e, t) {
        return (
          nA.copy(e).applyQuaternion(this.quaternion),
          this.position.add(nA.multiplyScalar(t)),
          this
        );
      }
      translateX(e) {
        return this.translateOnAxis(rA, e);
      }
      translateY(e) {
        return this.translateOnAxis(sA, e);
      }
      translateZ(e) {
        return this.translateOnAxis(aA, e);
      }
      localToWorld(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          e.applyMatrix4(ea.copy(this.matrixWorld).invert())
        );
      }
      lookAt(e, t, i) {
        e.isVector3 ? Jd.copy(e) : Jd.set(e, t, i);
        let r = this.parent;
        this.updateWorldMatrix(!0, !1),
          Zu.setFromMatrixPosition(this.matrixWorld),
          this.isCamera || this.isLight
            ? ea.lookAt(Zu, Jd, this.up)
            : ea.lookAt(Jd, Zu, this.up),
          this.quaternion.setFromRotationMatrix(ea),
          r &&
            (ea.extractRotation(r.matrixWorld),
            pc.setFromRotationMatrix(ea),
            this.quaternion.premultiply(pc.invert()));
      }
      add(e) {
        if (arguments.length > 1) {
          for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
          return this;
        }
        return e === this
          ? (console.error(
              "THREE.Object3D.add: object can't be added as a child of itself.",
              e
            ),
            this)
          : (e && e.isObject3D
              ? (e.parent !== null && e.parent.remove(e),
                (e.parent = this),
                this.children.push(e),
                e.dispatchEvent(Jz))
              : console.error(
                  "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                  e
                ),
            this);
      }
      remove(e) {
        if (arguments.length > 1) {
          for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
          return this;
        }
        let t = this.children.indexOf(e);
        return (
          t !== -1 &&
            ((e.parent = null),
            this.children.splice(t, 1),
            e.dispatchEvent(oA)),
          this
        );
      }
      removeFromParent() {
        let e = this.parent;
        return e !== null && e.remove(this), this;
      }
      clear() {
        for (let e = 0; e < this.children.length; e++) {
          let t = this.children[e];
          (t.parent = null), t.dispatchEvent(oA);
        }
        return (this.children.length = 0), this;
      }
      attach(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          ea.copy(this.matrixWorld).invert(),
          e.parent !== null &&
            (e.parent.updateWorldMatrix(!0, !1),
            ea.multiply(e.parent.matrixWorld)),
          e.applyMatrix4(ea),
          this.add(e),
          e.updateWorldMatrix(!1, !0),
          this
        );
      }
      getObjectById(e) {
        return this.getObjectByProperty("id", e);
      }
      getObjectByName(e) {
        return this.getObjectByProperty("name", e);
      }
      getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
          let a = this.children[i].getObjectByProperty(e, t);
          if (a !== void 0) return a;
        }
      }
      getObjectsByProperty(e, t) {
        let i = [];
        this[e] === t && i.push(this);
        for (let r = 0, s = this.children.length; r < s; r++) {
          let a = this.children[r].getObjectsByProperty(e, t);
          a.length > 0 && (i = i.concat(a));
        }
        return i;
      }
      getWorldPosition(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          e.setFromMatrixPosition(this.matrixWorld)
        );
      }
      getWorldQuaternion(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(Zu, e, Yz),
          e
        );
      }
      getWorldScale(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(Zu, Kz, e),
          e
        );
      }
      getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        let t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize();
      }
      raycast() {}
      traverse(e) {
        e(this);
        let t = this.children;
        for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
      }
      traverseVisible(e) {
        if (this.visible === !1) return;
        e(this);
        let t = this.children;
        for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
      }
      traverseAncestors(e) {
        let t = this.parent;
        t !== null && (e(t), t.traverseAncestors(e));
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
          (this.matrixWorldNeedsUpdate = !0);
      }
      updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || e) &&
            (this.parent === null
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            (this.matrixWorldNeedsUpdate = !1),
            (e = !0));
        let t = this.children;
        for (let i = 0, r = t.length; i < r; i++) {
          let s = t[i];
          (s.matrixWorldAutoUpdate === !0 || e === !0) &&
            s.updateMatrixWorld(e);
        }
      }
      updateWorldMatrix(e, t) {
        let i = this.parent;
        if (
          (e === !0 &&
            i !== null &&
            i.matrixWorldAutoUpdate === !0 &&
            i.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          t === !0)
        ) {
          let r = this.children;
          for (let s = 0, a = r.length; s < a; s++) {
            let o = r[s];
            o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
          }
        }
      }
      toJSON(e) {
        let t = e === void 0 || typeof e == "string",
          i = {};
        t &&
          ((e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {},
          }),
          (i.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON",
          }));
        let r = {};
        (r.uuid = this.uuid),
          (r.type = this.type),
          this.name !== "" && (r.name = this.name),
          this.castShadow === !0 && (r.castShadow = !0),
          this.receiveShadow === !0 && (r.receiveShadow = !0),
          this.visible === !1 && (r.visible = !1),
          this.frustumCulled === !1 && (r.frustumCulled = !1),
          this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
          Object.keys(this.userData).length > 0 && (r.userData = this.userData),
          (r.layers = this.layers.mask),
          (r.matrix = this.matrix.toArray()),
          this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
          this.isInstancedMesh &&
            ((r.type = "InstancedMesh"),
            (r.count = this.count),
            (r.instanceMatrix = this.instanceMatrix.toJSON()),
            this.instanceColor !== null &&
              (r.instanceColor = this.instanceColor.toJSON()));
        function s(o, l) {
          return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
        }
        if (this.isScene)
          this.background &&
            (this.background.isColor
              ? (r.background = this.background.toJSON())
              : this.background.isTexture &&
                (r.background = this.background.toJSON(e).uuid)),
            this.environment &&
              this.environment.isTexture &&
              this.environment.isRenderTargetTexture !== !0 &&
              (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
          r.geometry = s(e.geometries, this.geometry);
          let o = this.geometry.parameters;
          if (o !== void 0 && o.shapes !== void 0) {
            let l = o.shapes;
            if (Array.isArray(l))
              for (let c = 0, u = l.length; c < u; c++) {
                let f = l[c];
                s(e.shapes, f);
              }
            else s(e.shapes, l);
          }
        }
        if (
          (this.isSkinnedMesh &&
            ((r.bindMode = this.bindMode),
            (r.bindMatrix = this.bindMatrix.toArray()),
            this.skeleton !== void 0 &&
              (s(e.skeletons, this.skeleton),
              (r.skeleton = this.skeleton.uuid))),
          this.material !== void 0)
        )
          if (Array.isArray(this.material)) {
            let o = [];
            for (let l = 0, c = this.material.length; l < c; l++)
              o.push(s(e.materials, this.material[l]));
            r.material = o;
          } else r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
          r.children = [];
          for (let o = 0; o < this.children.length; o++)
            r.children.push(this.children[o].toJSON(e).object);
        }
        if (this.animations.length > 0) {
          r.animations = [];
          for (let o = 0; o < this.animations.length; o++) {
            let l = this.animations[o];
            r.animations.push(s(e.animations, l));
          }
        }
        if (t) {
          let o = a(e.geometries),
            l = a(e.materials),
            c = a(e.textures),
            u = a(e.images),
            f = a(e.shapes),
            d = a(e.skeletons),
            m = a(e.animations),
            x = a(e.nodes);
          o.length > 0 && (i.geometries = o),
            l.length > 0 && (i.materials = l),
            c.length > 0 && (i.textures = c),
            u.length > 0 && (i.images = u),
            f.length > 0 && (i.shapes = f),
            d.length > 0 && (i.skeletons = d),
            m.length > 0 && (i.animations = m),
            x.length > 0 && (i.nodes = x);
        }
        return (i.object = r), i;
        function a(o) {
          let l = [];
          for (let c in o) {
            let u = o[c];
            delete u.metadata, l.push(u);
          }
          return l;
        }
      }
      clone(e) {
        return new this.constructor().copy(this, e);
      }
      copy(e, t = !0) {
        if (
          ((this.name = e.name),
          this.up.copy(e.up),
          this.position.copy(e.position),
          (this.rotation.order = e.rotation.order),
          this.quaternion.copy(e.quaternion),
          this.scale.copy(e.scale),
          this.matrix.copy(e.matrix),
          this.matrixWorld.copy(e.matrixWorld),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
          (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
          (this.layers.mask = e.layers.mask),
          (this.visible = e.visible),
          (this.castShadow = e.castShadow),
          (this.receiveShadow = e.receiveShadow),
          (this.frustumCulled = e.frustumCulled),
          (this.renderOrder = e.renderOrder),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          t === !0)
        )
          for (let i = 0; i < e.children.length; i++) {
            let r = e.children[i];
            this.add(r.clone());
          }
        return this;
      }
    };
  Ai.DefaultUp = new le(0, 1, 0);
  Ai.DefaultMatrixAutoUpdate = !0;
  Ai.DefaultMatrixWorldAutoUpdate = !0;
  var fs = new le(),
    ta = new le(),
    Nv = new le(),
    ia = new le(),
    mc = new le(),
    gc = new le(),
    lA = new le(),
    kv = new le(),
    Fv = new le(),
    Bv = new le(),
    Ps = class {
      constructor(e = new le(), t = new le(), i = new le()) {
        (this.a = e), (this.b = t), (this.c = i);
      }
      static getNormal(e, t, i, r) {
        r.subVectors(i, t), fs.subVectors(e, t), r.cross(fs);
        let s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
      }
      static getBarycoord(e, t, i, r, s) {
        fs.subVectors(r, t), ta.subVectors(i, t), Nv.subVectors(e, t);
        let a = fs.dot(fs),
          o = fs.dot(ta),
          l = fs.dot(Nv),
          c = ta.dot(ta),
          u = ta.dot(Nv),
          f = a * c - o * o;
        if (f === 0) return s.set(-2, -1, -1);
        let d = 1 / f,
          m = (c * l - o * u) * d,
          x = (a * u - o * l) * d;
        return s.set(1 - m - x, x, m);
      }
      static containsPoint(e, t, i, r) {
        return (
          this.getBarycoord(e, t, i, r, ia),
          ia.x >= 0 && ia.y >= 0 && ia.x + ia.y <= 1
        );
      }
      static getUV(e, t, i, r, s, a, o, l) {
        return (
          this.getBarycoord(e, t, i, r, ia),
          l.set(0, 0),
          l.addScaledVector(s, ia.x),
          l.addScaledVector(a, ia.y),
          l.addScaledVector(o, ia.z),
          l
        );
      }
      static isFrontFacing(e, t, i, r) {
        return (
          fs.subVectors(i, t), ta.subVectors(e, t), fs.cross(ta).dot(r) < 0
        );
      }
      set(e, t, i) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
      }
      setFromPointsAndIndices(e, t, i, r) {
        return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
      }
      setFromAttributeAndIndices(e, t, i, r) {
        return (
          this.a.fromBufferAttribute(e, t),
          this.b.fromBufferAttribute(e, i),
          this.c.fromBufferAttribute(e, r),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
      }
      getArea() {
        return (
          fs.subVectors(this.c, this.b),
          ta.subVectors(this.a, this.b),
          fs.cross(ta).length() * 0.5
        );
      }
      getMidpoint(e) {
        return e
          .addVectors(this.a, this.b)
          .add(this.c)
          .multiplyScalar(1 / 3);
      }
      getNormal(e) {
        return Ps.getNormal(this.a, this.b, this.c, e);
      }
      getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(e, t) {
        return Ps.getBarycoord(e, this.a, this.b, this.c, t);
      }
      getUV(e, t, i, r, s) {
        return Ps.getUV(e, this.a, this.b, this.c, t, i, r, s);
      }
      containsPoint(e) {
        return Ps.containsPoint(e, this.a, this.b, this.c);
      }
      isFrontFacing(e) {
        return Ps.isFrontFacing(this.a, this.b, this.c, e);
      }
      intersectsBox(e) {
        return e.intersectsTriangle(this);
      }
      closestPointToPoint(e, t) {
        let i = this.a,
          r = this.b,
          s = this.c,
          a,
          o;
        mc.subVectors(r, i), gc.subVectors(s, i), kv.subVectors(e, i);
        let l = mc.dot(kv),
          c = gc.dot(kv);
        if (l <= 0 && c <= 0) return t.copy(i);
        Fv.subVectors(e, r);
        let u = mc.dot(Fv),
          f = gc.dot(Fv);
        if (u >= 0 && f <= u) return t.copy(r);
        let d = l * f - u * c;
        if (d <= 0 && l >= 0 && u <= 0)
          return (a = l / (l - u)), t.copy(i).addScaledVector(mc, a);
        Bv.subVectors(e, s);
        let m = mc.dot(Bv),
          x = gc.dot(Bv);
        if (x >= 0 && m <= x) return t.copy(s);
        let y = m * c - l * x;
        if (y <= 0 && c >= 0 && x <= 0)
          return (o = c / (c - x)), t.copy(i).addScaledVector(gc, o);
        let g = u * x - m * f;
        if (g <= 0 && f - u >= 0 && m - x >= 0)
          return (
            lA.subVectors(s, r),
            (o = (f - u) / (f - u + (m - x))),
            t.copy(r).addScaledVector(lA, o)
          );
        let b = 1 / (g + y + d);
        return (
          (a = y * b),
          (o = d * b),
          t.copy(i).addScaledVector(mc, a).addScaledVector(gc, o)
        );
      }
      equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
      }
    },
    Zz = 0,
    Xr = class extends Ds {
      constructor() {
        super();
        (this.isMaterial = !0),
          Object.defineProperty(this, "id", { value: Zz++ }),
          (this.uuid = ds()),
          (this.name = ""),
          (this.type = "Material"),
          (this.blending = Ac),
          (this.side = aa),
          (this.vertexColors = !1),
          (this.opacity = 1),
          (this.transparent = !1),
          (this.blendSrc = JA),
          (this.blendDst = ZA),
          (this.blendEquation = Tc),
          (this.blendSrcAlpha = null),
          (this.blendDstAlpha = null),
          (this.blendEquationAlpha = null),
          (this.depthFunc = Kv),
          (this.depthTest = !0),
          (this.depthWrite = !0),
          (this.stencilWriteMask = 255),
          (this.stencilFunc = Dz),
          (this.stencilRef = 0),
          (this.stencilFuncMask = 255),
          (this.stencilFail = Tv),
          (this.stencilZFail = Tv),
          (this.stencilZPass = Tv),
          (this.stencilWrite = !1),
          (this.clippingPlanes = null),
          (this.clipIntersection = !1),
          (this.clipShadows = !1),
          (this.shadowSide = null),
          (this.colorWrite = !0),
          (this.precision = null),
          (this.polygonOffset = !1),
          (this.polygonOffsetFactor = 0),
          (this.polygonOffsetUnits = 0),
          (this.dithering = !1),
          (this.alphaToCoverage = !1),
          (this.premultipliedAlpha = !1),
          (this.visible = !0),
          (this.toneMapped = !0),
          (this.userData = {}),
          (this.version = 0),
          (this._alphaTest = 0);
      }
      get alphaTest() {
        return this._alphaTest;
      }
      set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
      }
      onBuild() {}
      onBeforeRender() {}
      onBeforeCompile() {}
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(e) {
        if (e !== void 0)
          for (let t in e) {
            let i = e[t];
            if (i === void 0) {
              console.warn(
                "THREE.Material: '" + t + "' parameter is undefined."
              );
              continue;
            }
            let r = this[t];
            if (r === void 0) {
              console.warn(
                "THREE." +
                  this.type +
                  ": '" +
                  t +
                  "' is not a property of this material."
              );
              continue;
            }
            r && r.isColor
              ? r.set(i)
              : r && r.isVector3 && i && i.isVector3
              ? r.copy(i)
              : (this[t] = i);
          }
      }
      toJSON(e) {
        let t = e === void 0 || typeof e == "string";
        t && (e = { textures: {}, images: {} });
        let i = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON",
          },
        };
        (i.uuid = this.uuid),
          (i.type = this.type),
          this.name !== "" && (i.name = this.name),
          this.color && this.color.isColor && (i.color = this.color.getHex()),
          this.roughness !== void 0 && (i.roughness = this.roughness),
          this.metalness !== void 0 && (i.metalness = this.metalness),
          this.sheen !== void 0 && (i.sheen = this.sheen),
          this.sheenColor &&
            this.sheenColor.isColor &&
            (i.sheenColor = this.sheenColor.getHex()),
          this.sheenRoughness !== void 0 &&
            (i.sheenRoughness = this.sheenRoughness),
          this.emissive &&
            this.emissive.isColor &&
            (i.emissive = this.emissive.getHex()),
          this.emissiveIntensity &&
            this.emissiveIntensity !== 1 &&
            (i.emissiveIntensity = this.emissiveIntensity),
          this.specular &&
            this.specular.isColor &&
            (i.specular = this.specular.getHex()),
          this.specularIntensity !== void 0 &&
            (i.specularIntensity = this.specularIntensity),
          this.specularColor &&
            this.specularColor.isColor &&
            (i.specularColor = this.specularColor.getHex()),
          this.shininess !== void 0 && (i.shininess = this.shininess),
          this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
          this.clearcoatRoughness !== void 0 &&
            (i.clearcoatRoughness = this.clearcoatRoughness),
          this.clearcoatMap &&
            this.clearcoatMap.isTexture &&
            (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
          this.clearcoatRoughnessMap &&
            this.clearcoatRoughnessMap.isTexture &&
            (i.clearcoatRoughnessMap =
              this.clearcoatRoughnessMap.toJSON(e).uuid),
          this.clearcoatNormalMap &&
            this.clearcoatNormalMap.isTexture &&
            ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
            (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
          this.iridescence !== void 0 && (i.iridescence = this.iridescence),
          this.iridescenceIOR !== void 0 &&
            (i.iridescenceIOR = this.iridescenceIOR),
          this.iridescenceThicknessRange !== void 0 &&
            (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
          this.iridescenceMap &&
            this.iridescenceMap.isTexture &&
            (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
          this.iridescenceThicknessMap &&
            this.iridescenceThicknessMap.isTexture &&
            (i.iridescenceThicknessMap =
              this.iridescenceThicknessMap.toJSON(e).uuid),
          this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
          this.matcap &&
            this.matcap.isTexture &&
            (i.matcap = this.matcap.toJSON(e).uuid),
          this.alphaMap &&
            this.alphaMap.isTexture &&
            (i.alphaMap = this.alphaMap.toJSON(e).uuid),
          this.lightMap &&
            this.lightMap.isTexture &&
            ((i.lightMap = this.lightMap.toJSON(e).uuid),
            (i.lightMapIntensity = this.lightMapIntensity)),
          this.aoMap &&
            this.aoMap.isTexture &&
            ((i.aoMap = this.aoMap.toJSON(e).uuid),
            (i.aoMapIntensity = this.aoMapIntensity)),
          this.bumpMap &&
            this.bumpMap.isTexture &&
            ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
            (i.bumpScale = this.bumpScale)),
          this.normalMap &&
            this.normalMap.isTexture &&
            ((i.normalMap = this.normalMap.toJSON(e).uuid),
            (i.normalMapType = this.normalMapType),
            (i.normalScale = this.normalScale.toArray())),
          this.displacementMap &&
            this.displacementMap.isTexture &&
            ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
            (i.displacementScale = this.displacementScale),
            (i.displacementBias = this.displacementBias)),
          this.roughnessMap &&
            this.roughnessMap.isTexture &&
            (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
          this.metalnessMap &&
            this.metalnessMap.isTexture &&
            (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
          this.emissiveMap &&
            this.emissiveMap.isTexture &&
            (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
          this.specularMap &&
            this.specularMap.isTexture &&
            (i.specularMap = this.specularMap.toJSON(e).uuid),
          this.specularIntensityMap &&
            this.specularIntensityMap.isTexture &&
            (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
          this.specularColorMap &&
            this.specularColorMap.isTexture &&
            (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
          this.envMap &&
            this.envMap.isTexture &&
            ((i.envMap = this.envMap.toJSON(e).uuid),
            this.combine !== void 0 && (i.combine = this.combine)),
          this.envMapIntensity !== void 0 &&
            (i.envMapIntensity = this.envMapIntensity),
          this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
          this.refractionRatio !== void 0 &&
            (i.refractionRatio = this.refractionRatio),
          this.gradientMap &&
            this.gradientMap.isTexture &&
            (i.gradientMap = this.gradientMap.toJSON(e).uuid),
          this.transmission !== void 0 && (i.transmission = this.transmission),
          this.transmissionMap &&
            this.transmissionMap.isTexture &&
            (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
          this.thickness !== void 0 && (i.thickness = this.thickness),
          this.thicknessMap &&
            this.thicknessMap.isTexture &&
            (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
          this.attenuationDistance !== void 0 &&
            this.attenuationDistance !== 1 / 0 &&
            (i.attenuationDistance = this.attenuationDistance),
          this.attenuationColor !== void 0 &&
            (i.attenuationColor = this.attenuationColor.getHex()),
          this.size !== void 0 && (i.size = this.size),
          this.shadowSide !== null && (i.shadowSide = this.shadowSide),
          this.sizeAttenuation !== void 0 &&
            (i.sizeAttenuation = this.sizeAttenuation),
          this.blending !== Ac && (i.blending = this.blending),
          this.side !== aa && (i.side = this.side),
          this.vertexColors && (i.vertexColors = !0),
          this.opacity < 1 && (i.opacity = this.opacity),
          this.transparent === !0 && (i.transparent = this.transparent),
          (i.depthFunc = this.depthFunc),
          (i.depthTest = this.depthTest),
          (i.depthWrite = this.depthWrite),
          (i.colorWrite = this.colorWrite),
          (i.stencilWrite = this.stencilWrite),
          (i.stencilWriteMask = this.stencilWriteMask),
          (i.stencilFunc = this.stencilFunc),
          (i.stencilRef = this.stencilRef),
          (i.stencilFuncMask = this.stencilFuncMask),
          (i.stencilFail = this.stencilFail),
          (i.stencilZFail = this.stencilZFail),
          (i.stencilZPass = this.stencilZPass),
          this.rotation !== void 0 &&
            this.rotation !== 0 &&
            (i.rotation = this.rotation),
          this.polygonOffset === !0 && (i.polygonOffset = !0),
          this.polygonOffsetFactor !== 0 &&
            (i.polygonOffsetFactor = this.polygonOffsetFactor),
          this.polygonOffsetUnits !== 0 &&
            (i.polygonOffsetUnits = this.polygonOffsetUnits),
          this.linewidth !== void 0 &&
            this.linewidth !== 1 &&
            (i.linewidth = this.linewidth),
          this.dashSize !== void 0 && (i.dashSize = this.dashSize),
          this.gapSize !== void 0 && (i.gapSize = this.gapSize),
          this.scale !== void 0 && (i.scale = this.scale),
          this.dithering === !0 && (i.dithering = !0),
          this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
          this.alphaToCoverage === !0 &&
            (i.alphaToCoverage = this.alphaToCoverage),
          this.premultipliedAlpha === !0 &&
            (i.premultipliedAlpha = this.premultipliedAlpha),
          this.wireframe === !0 && (i.wireframe = this.wireframe),
          this.wireframeLinewidth > 1 &&
            (i.wireframeLinewidth = this.wireframeLinewidth),
          this.wireframeLinecap !== "round" &&
            (i.wireframeLinecap = this.wireframeLinecap),
          this.wireframeLinejoin !== "round" &&
            (i.wireframeLinejoin = this.wireframeLinejoin),
          this.flatShading === !0 && (i.flatShading = this.flatShading),
          this.visible === !1 && (i.visible = !1),
          this.toneMapped === !1 && (i.toneMapped = !1),
          this.fog === !1 && (i.fog = !1),
          Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function r(s) {
          let a = [];
          for (let o in s) {
            let l = s[o];
            delete l.metadata, a.push(l);
          }
          return a;
        }
        if (t) {
          let s = r(e.textures),
            a = r(e.images);
          s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
        }
        return i;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        (this.name = e.name),
          (this.blending = e.blending),
          (this.side = e.side),
          (this.vertexColors = e.vertexColors),
          (this.opacity = e.opacity),
          (this.transparent = e.transparent),
          (this.blendSrc = e.blendSrc),
          (this.blendDst = e.blendDst),
          (this.blendEquation = e.blendEquation),
          (this.blendSrcAlpha = e.blendSrcAlpha),
          (this.blendDstAlpha = e.blendDstAlpha),
          (this.blendEquationAlpha = e.blendEquationAlpha),
          (this.depthFunc = e.depthFunc),
          (this.depthTest = e.depthTest),
          (this.depthWrite = e.depthWrite),
          (this.stencilWriteMask = e.stencilWriteMask),
          (this.stencilFunc = e.stencilFunc),
          (this.stencilRef = e.stencilRef),
          (this.stencilFuncMask = e.stencilFuncMask),
          (this.stencilFail = e.stencilFail),
          (this.stencilZFail = e.stencilZFail),
          (this.stencilZPass = e.stencilZPass),
          (this.stencilWrite = e.stencilWrite);
        let t = e.clippingPlanes,
          i = null;
        if (t !== null) {
          let r = t.length;
          i = new Array(r);
          for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
        }
        return (
          (this.clippingPlanes = i),
          (this.clipIntersection = e.clipIntersection),
          (this.clipShadows = e.clipShadows),
          (this.shadowSide = e.shadowSide),
          (this.colorWrite = e.colorWrite),
          (this.precision = e.precision),
          (this.polygonOffset = e.polygonOffset),
          (this.polygonOffsetFactor = e.polygonOffsetFactor),
          (this.polygonOffsetUnits = e.polygonOffsetUnits),
          (this.dithering = e.dithering),
          (this.alphaTest = e.alphaTest),
          (this.alphaToCoverage = e.alphaToCoverage),
          (this.premultipliedAlpha = e.premultipliedAlpha),
          (this.visible = e.visible),
          (this.toneMapped = e.toneMapped),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      set needsUpdate(e) {
        e === !0 && this.version++;
      }
    },
    oa = class extends Xr {
      constructor(e) {
        super();
        (this.isMeshBasicMaterial = !0),
          (this.type = "MeshBasicMaterial"),
          (this.color = new Bt(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = QA),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.fog = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.fog = e.fog),
          this
        );
      }
    },
    Qi = new le(),
    Zd = new It(),
    en = class {
      constructor(e, t, i = !1) {
        if (Array.isArray(e))
          throw new TypeError(
            "THREE.BufferAttribute: array should be a Typed Array."
          );
        (this.isBufferAttribute = !0),
          (this.name = ""),
          (this.array = e),
          (this.itemSize = t),
          (this.count = e !== void 0 ? e.length / t : 0),
          (this.normalized = i),
          (this.usage = Qv),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0);
      }
      onUploadCallback() {}
      set needsUpdate(e) {
        e === !0 && this.version++;
      }
      setUsage(e) {
        return (this.usage = e), this;
      }
      copy(e) {
        return (
          (this.name = e.name),
          (this.array = new e.array.constructor(e.array)),
          (this.itemSize = e.itemSize),
          (this.count = e.count),
          (this.normalized = e.normalized),
          (this.usage = e.usage),
          this
        );
      }
      copyAt(e, t, i) {
        (e *= this.itemSize), (i *= t.itemSize);
        for (let r = 0, s = this.itemSize; r < s; r++)
          this.array[e + r] = t.array[i + r];
        return this;
      }
      copyArray(e) {
        return this.array.set(e), this;
      }
      applyMatrix3(e) {
        if (this.itemSize === 2)
          for (let t = 0, i = this.count; t < i; t++)
            Zd.fromBufferAttribute(this, t),
              Zd.applyMatrix3(e),
              this.setXY(t, Zd.x, Zd.y);
        else if (this.itemSize === 3)
          for (let t = 0, i = this.count; t < i; t++)
            Qi.fromBufferAttribute(this, t),
              Qi.applyMatrix3(e),
              this.setXYZ(t, Qi.x, Qi.y, Qi.z);
        return this;
      }
      applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
          Qi.fromBufferAttribute(this, t),
            Qi.applyMatrix4(e),
            this.setXYZ(t, Qi.x, Qi.y, Qi.z);
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
          Qi.fromBufferAttribute(this, t),
            Qi.applyNormalMatrix(e),
            this.setXYZ(t, Qi.x, Qi.y, Qi.z);
        return this;
      }
      transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
          Qi.fromBufferAttribute(this, t),
            Qi.transformDirection(e),
            this.setXYZ(t, Qi.x, Qi.y, Qi.z);
        return this;
      }
      set(e, t = 0) {
        return this.array.set(e, t), this;
      }
      getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = ra(t, this.array)), t;
      }
      setX(e, t) {
        return (
          this.normalized && (t = Mi(t, this.array)),
          (this.array[e * this.itemSize] = t),
          this
        );
      }
      getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = ra(t, this.array)), t;
      }
      setY(e, t) {
        return (
          this.normalized && (t = Mi(t, this.array)),
          (this.array[e * this.itemSize + 1] = t),
          this
        );
      }
      getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = ra(t, this.array)), t;
      }
      setZ(e, t) {
        return (
          this.normalized && (t = Mi(t, this.array)),
          (this.array[e * this.itemSize + 2] = t),
          this
        );
      }
      getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = ra(t, this.array)), t;
      }
      setW(e, t) {
        return (
          this.normalized && (t = Mi(t, this.array)),
          (this.array[e * this.itemSize + 3] = t),
          this
        );
      }
      setXY(e, t, i) {
        return (
          (e *= this.itemSize),
          this.normalized && ((t = Mi(t, this.array)), (i = Mi(i, this.array))),
          (this.array[e + 0] = t),
          (this.array[e + 1] = i),
          this
        );
      }
      setXYZ(e, t, i, r) {
        return (
          (e *= this.itemSize),
          this.normalized &&
            ((t = Mi(t, this.array)),
            (i = Mi(i, this.array)),
            (r = Mi(r, this.array))),
          (this.array[e + 0] = t),
          (this.array[e + 1] = i),
          (this.array[e + 2] = r),
          this
        );
      }
      setXYZW(e, t, i, r, s) {
        return (
          (e *= this.itemSize),
          this.normalized &&
            ((t = Mi(t, this.array)),
            (i = Mi(i, this.array)),
            (r = Mi(r, this.array)),
            (s = Mi(s, this.array))),
          (this.array[e + 0] = t),
          (this.array[e + 1] = i),
          (this.array[e + 2] = r),
          (this.array[e + 3] = s),
          this
        );
      }
      onUpload(e) {
        return (this.onUploadCallback = e), this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        let e = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.from(this.array),
          normalized: this.normalized,
        };
        return (
          this.name !== "" && (e.name = this.name),
          this.usage !== Qv && (e.usage = this.usage),
          (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
            (e.updateRange = this.updateRange),
          e
        );
      }
      copyColorsArray() {
        console.error(
          "THREE.BufferAttribute: copyColorsArray() was removed in r144."
        );
      }
      copyVector2sArray() {
        console.error(
          "THREE.BufferAttribute: copyVector2sArray() was removed in r144."
        );
      }
      copyVector3sArray() {
        console.error(
          "THREE.BufferAttribute: copyVector3sArray() was removed in r144."
        );
      }
      copyVector4sArray() {
        console.error(
          "THREE.BufferAttribute: copyVector4sArray() was removed in r144."
        );
      }
    };
  var mx = class extends en {
    constructor(e, t, i) {
      super(new Uint16Array(e), t, i);
    }
  };
  var gx = class extends en {
    constructor(e, t, i) {
      super(new Uint32Array(e), t, i);
    }
  };
  var jr = class extends en {
    constructor(e, t, i) {
      super(new Float32Array(e), t, i);
    }
  };
  var Qz = 0,
    $r = new Wt(),
    zv = new Ai(),
    yc = new le(),
    vr = new no(),
    Qu = new no(),
    gn = new le(),
    qn = class extends Ds {
      constructor() {
        super();
        (this.isBufferGeometry = !0),
          Object.defineProperty(this, "id", { value: Qz++ }),
          (this.uuid = ds()),
          (this.name = ""),
          (this.type = "BufferGeometry"),
          (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.morphTargetsRelative = !1),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.drawRange = { start: 0, count: 1 / 0 }),
          (this.userData = {});
      }
      getIndex() {
        return this.index;
      }
      setIndex(e) {
        return (
          Array.isArray(e)
            ? (this.index = new (aC(e) ? gx : mx)(e, 1))
            : (this.index = e),
          this
        );
      }
      getAttribute(e) {
        return this.attributes[e];
      }
      setAttribute(e, t) {
        return (this.attributes[e] = t), this;
      }
      deleteAttribute(e) {
        return delete this.attributes[e], this;
      }
      hasAttribute(e) {
        return this.attributes[e] !== void 0;
      }
      addGroup(e, t, i = 0) {
        this.groups.push({ start: e, count: t, materialIndex: i });
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(e, t) {
        (this.drawRange.start = e), (this.drawRange.count = t);
      }
      applyMatrix4(e) {
        let t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
        let i = this.attributes.normal;
        if (i !== void 0) {
          let s = new sr().getNormalMatrix(e);
          i.applyNormalMatrix(s), (i.needsUpdate = !0);
        }
        let r = this.attributes.tangent;
        return (
          r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
          this.boundingBox !== null && this.computeBoundingBox(),
          this.boundingSphere !== null && this.computeBoundingSphere(),
          this
        );
      }
      applyQuaternion(e) {
        return $r.makeRotationFromQuaternion(e), this.applyMatrix4($r), this;
      }
      rotateX(e) {
        return $r.makeRotationX(e), this.applyMatrix4($r), this;
      }
      rotateY(e) {
        return $r.makeRotationY(e), this.applyMatrix4($r), this;
      }
      rotateZ(e) {
        return $r.makeRotationZ(e), this.applyMatrix4($r), this;
      }
      translate(e, t, i) {
        return $r.makeTranslation(e, t, i), this.applyMatrix4($r), this;
      }
      scale(e, t, i) {
        return $r.makeScale(e, t, i), this.applyMatrix4($r), this;
      }
      lookAt(e) {
        return (
          zv.lookAt(e), zv.updateMatrix(), this.applyMatrix4(zv.matrix), this
        );
      }
      center() {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(yc).negate(),
          this.translate(yc.x, yc.y, yc.z),
          this
        );
      }
      setFromPoints(e) {
        let t = [];
        for (let i = 0, r = e.length; i < r; i++) {
          let s = e[i];
          t.push(s.x, s.y, s.z || 0);
        }
        return this.setAttribute("position", new jr(t, 3)), this;
      }
      computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new no());
        let e = this.attributes.position,
          t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
            this
          ),
            this.boundingBox.set(
              new le(-1 / 0, -1 / 0, -1 / 0),
              new le(1 / 0, 1 / 0, 1 / 0)
            );
          return;
        }
        if (e !== void 0) {
          if ((this.boundingBox.setFromBufferAttribute(e), t))
            for (let i = 0, r = t.length; i < r; i++) {
              let s = t[i];
              vr.setFromBufferAttribute(s),
                this.morphTargetsRelative
                  ? (gn.addVectors(this.boundingBox.min, vr.min),
                    this.boundingBox.expandByPoint(gn),
                    gn.addVectors(this.boundingBox.max, vr.max),
                    this.boundingBox.expandByPoint(gn))
                  : (this.boundingBox.expandByPoint(vr.min),
                    this.boundingBox.expandByPoint(vr.max));
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) ||
          isNaN(this.boundingBox.min.y) ||
          isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this
          );
      }
      computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new ro());
        let e = this.attributes.position,
          t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
            this
          ),
            this.boundingSphere.set(new le(), 1 / 0);
          return;
        }
        if (e) {
          let i = this.boundingSphere.center;
          if ((vr.setFromBufferAttribute(e), t))
            for (let s = 0, a = t.length; s < a; s++) {
              let o = t[s];
              Qu.setFromBufferAttribute(o),
                this.morphTargetsRelative
                  ? (gn.addVectors(vr.min, Qu.min),
                    vr.expandByPoint(gn),
                    gn.addVectors(vr.max, Qu.max),
                    vr.expandByPoint(gn))
                  : (vr.expandByPoint(Qu.min), vr.expandByPoint(Qu.max));
            }
          vr.getCenter(i);
          let r = 0;
          for (let s = 0, a = e.count; s < a; s++)
            gn.fromBufferAttribute(e, s),
              (r = Math.max(r, i.distanceToSquared(gn)));
          if (t)
            for (let s = 0, a = t.length; s < a; s++) {
              let o = t[s],
                l = this.morphTargetsRelative;
              for (let c = 0, u = o.count; c < u; c++)
                gn.fromBufferAttribute(o, c),
                  l && (yc.fromBufferAttribute(e, c), gn.add(yc)),
                  (r = Math.max(r, i.distanceToSquared(gn)));
            }
          (this.boundingSphere.radius = Math.sqrt(r)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this
              );
        }
      }
      computeTangents() {
        let e = this.index,
          t = this.attributes;
        if (
          e === null ||
          t.position === void 0 ||
          t.normal === void 0 ||
          t.uv === void 0
        ) {
          console.error(
            "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
          );
          return;
        }
        let i = e.array,
          r = t.position.array,
          s = t.normal.array,
          a = t.uv.array,
          o = r.length / 3;
        this.hasAttribute("tangent") === !1 &&
          this.setAttribute("tangent", new en(new Float32Array(4 * o), 4));
        let l = this.getAttribute("tangent").array,
          c = [],
          u = [];
        for (let O = 0; O < o; O++) (c[O] = new le()), (u[O] = new le());
        let f = new le(),
          d = new le(),
          m = new le(),
          x = new It(),
          y = new It(),
          g = new It(),
          b = new le(),
          _ = new le();
        function E(O, U, X) {
          f.fromArray(r, O * 3),
            d.fromArray(r, U * 3),
            m.fromArray(r, X * 3),
            x.fromArray(a, O * 2),
            y.fromArray(a, U * 2),
            g.fromArray(a, X * 2),
            d.sub(f),
            m.sub(f),
            y.sub(x),
            g.sub(x);
          let $ = 1 / (y.x * g.y - g.x * y.y);
          !isFinite($) ||
            (b
              .copy(d)
              .multiplyScalar(g.y)
              .addScaledVector(m, -y.y)
              .multiplyScalar($),
            _.copy(m)
              .multiplyScalar(y.x)
              .addScaledVector(d, -g.x)
              .multiplyScalar($),
            c[O].add(b),
            c[U].add(b),
            c[X].add(b),
            u[O].add(_),
            u[U].add(_),
            u[X].add(_));
        }
        let w = this.groups;
        w.length === 0 && (w = [{ start: 0, count: i.length }]);
        for (let O = 0, U = w.length; O < U; ++O) {
          let X = w[O],
            $ = X.start,
            W = X.count;
          for (let ue = $, ae = $ + W; ue < ae; ue += 3)
            E(i[ue + 0], i[ue + 1], i[ue + 2]);
        }
        let P = new le(),
          L = new le(),
          I = new le(),
          M = new le();
        function R(O) {
          I.fromArray(s, O * 3), M.copy(I);
          let U = c[O];
          P.copy(U),
            P.sub(I.multiplyScalar(I.dot(U))).normalize(),
            L.crossVectors(M, U);
          let $ = L.dot(u[O]) < 0 ? -1 : 1;
          (l[O * 4] = P.x),
            (l[O * 4 + 1] = P.y),
            (l[O * 4 + 2] = P.z),
            (l[O * 4 + 3] = $);
        }
        for (let O = 0, U = w.length; O < U; ++O) {
          let X = w[O],
            $ = X.start,
            W = X.count;
          for (let ue = $, ae = $ + W; ue < ae; ue += 3)
            R(i[ue + 0]), R(i[ue + 1]), R(i[ue + 2]);
        }
      }
      computeVertexNormals() {
        let e = this.index,
          t = this.getAttribute("position");
        if (t !== void 0) {
          let i = this.getAttribute("normal");
          if (i === void 0)
            (i = new en(new Float32Array(t.count * 3), 3)),
              this.setAttribute("normal", i);
          else for (let d = 0, m = i.count; d < m; d++) i.setXYZ(d, 0, 0, 0);
          let r = new le(),
            s = new le(),
            a = new le(),
            o = new le(),
            l = new le(),
            c = new le(),
            u = new le(),
            f = new le();
          if (e)
            for (let d = 0, m = e.count; d < m; d += 3) {
              let x = e.getX(d + 0),
                y = e.getX(d + 1),
                g = e.getX(d + 2);
              r.fromBufferAttribute(t, x),
                s.fromBufferAttribute(t, y),
                a.fromBufferAttribute(t, g),
                u.subVectors(a, s),
                f.subVectors(r, s),
                u.cross(f),
                o.fromBufferAttribute(i, x),
                l.fromBufferAttribute(i, y),
                c.fromBufferAttribute(i, g),
                o.add(u),
                l.add(u),
                c.add(u),
                i.setXYZ(x, o.x, o.y, o.z),
                i.setXYZ(y, l.x, l.y, l.z),
                i.setXYZ(g, c.x, c.y, c.z);
            }
          else
            for (let d = 0, m = t.count; d < m; d += 3)
              r.fromBufferAttribute(t, d + 0),
                s.fromBufferAttribute(t, d + 1),
                a.fromBufferAttribute(t, d + 2),
                u.subVectors(a, s),
                f.subVectors(r, s),
                u.cross(f),
                i.setXYZ(d + 0, u.x, u.y, u.z),
                i.setXYZ(d + 1, u.x, u.y, u.z),
                i.setXYZ(d + 2, u.x, u.y, u.z);
          this.normalizeNormals(), (i.needsUpdate = !0);
        }
      }
      merge() {
        return (
          console.error(
            "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."
          ),
          this
        );
      }
      normalizeNormals() {
        let e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
          gn.fromBufferAttribute(e, t),
            gn.normalize(),
            e.setXYZ(t, gn.x, gn.y, gn.z);
      }
      toNonIndexed() {
        function e(o, l) {
          let c = o.array,
            u = o.itemSize,
            f = o.normalized,
            d = new c.constructor(l.length * u),
            m = 0,
            x = 0;
          for (let y = 0, g = l.length; y < g; y++) {
            o.isInterleavedBufferAttribute
              ? (m = l[y] * o.data.stride + o.offset)
              : (m = l[y] * u);
            for (let b = 0; b < u; b++) d[x++] = c[m++];
          }
          return new en(d, u, f);
        }
        if (this.index === null)
          return (
            console.warn(
              "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
            ),
            this
          );
        let t = new qn(),
          i = this.index.array,
          r = this.attributes;
        for (let o in r) {
          let l = r[o],
            c = e(l, i);
          t.setAttribute(o, c);
        }
        let s = this.morphAttributes;
        for (let o in s) {
          let l = [],
            c = s[o];
          for (let u = 0, f = c.length; u < f; u++) {
            let d = c[u],
              m = e(d, i);
            l.push(m);
          }
          t.morphAttributes[o] = l;
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        let a = this.groups;
        for (let o = 0, l = a.length; o < l; o++) {
          let c = a[o];
          t.addGroup(c.start, c.count, c.materialIndex);
        }
        return t;
      }
      toJSON() {
        let e = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON",
          },
        };
        if (
          ((e.uuid = this.uuid),
          (e.type = this.type),
          this.name !== "" && (e.name = this.name),
          Object.keys(this.userData).length > 0 && (e.userData = this.userData),
          this.parameters !== void 0)
        ) {
          let l = this.parameters;
          for (let c in l) l[c] !== void 0 && (e[c] = l[c]);
          return e;
        }
        e.data = { attributes: {} };
        let t = this.index;
        t !== null &&
          (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array),
          });
        let i = this.attributes;
        for (let l in i) {
          let c = i[l];
          e.data.attributes[l] = c.toJSON(e.data);
        }
        let r = {},
          s = !1;
        for (let l in this.morphAttributes) {
          let c = this.morphAttributes[l],
            u = [];
          for (let f = 0, d = c.length; f < d; f++) {
            let m = c[f];
            u.push(m.toJSON(e.data));
          }
          u.length > 0 && ((r[l] = u), (s = !0));
        }
        s &&
          ((e.data.morphAttributes = r),
          (e.data.morphTargetsRelative = this.morphTargetsRelative));
        let a = this.groups;
        a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
        let o = this.boundingSphere;
        return (
          o !== null &&
            (e.data.boundingSphere = {
              center: o.center.toArray(),
              radius: o.radius,
            }),
          e
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null);
        let t = {};
        this.name = e.name;
        let i = e.index;
        i !== null && this.setIndex(i.clone(t));
        let r = e.attributes;
        for (let c in r) {
          let u = r[c];
          this.setAttribute(c, u.clone(t));
        }
        let s = e.morphAttributes;
        for (let c in s) {
          let u = [],
            f = s[c];
          for (let d = 0, m = f.length; d < m; d++) u.push(f[d].clone(t));
          this.morphAttributes[c] = u;
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        let a = e.groups;
        for (let c = 0, u = a.length; c < u; c++) {
          let f = a[c];
          this.addGroup(f.start, f.count, f.materialIndex);
        }
        let o = e.boundingBox;
        o !== null && (this.boundingBox = o.clone());
        let l = e.boundingSphere;
        return (
          l !== null && (this.boundingSphere = l.clone()),
          (this.drawRange.start = e.drawRange.start),
          (this.drawRange.count = e.drawRange.count),
          (this.userData = e.userData),
          e.parameters !== void 0 &&
            (this.parameters = Object.assign({}, e.parameters)),
          this
        );
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    },
    cA = new Wt(),
    vc = new xp(),
    Uv = new ro(),
    eh = new le(),
    th = new le(),
    ih = new le(),
    Vv = new le(),
    Qd = new le(),
    ep = new It(),
    tp = new It(),
    ip = new It(),
    Gv = new le(),
    np = new le(),
    ar = class extends Ai {
      constructor(e = new qn(), t = new oa()) {
        super();
        (this.isMesh = !0),
          (this.type = "Mesh"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          e.morphTargetInfluences !== void 0 &&
            (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
          e.morphTargetDictionary !== void 0 &&
            (this.morphTargetDictionary = Object.assign(
              {},
              e.morphTargetDictionary
            )),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      updateMorphTargets() {
        let t = this.geometry.morphAttributes,
          i = Object.keys(t);
        if (i.length > 0) {
          let r = t[i[0]];
          if (r !== void 0) {
            (this.morphTargetInfluences = []),
              (this.morphTargetDictionary = {});
            for (let s = 0, a = r.length; s < a; s++) {
              let o = r[s].name || String(s);
              this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[o] = s);
            }
          }
        }
      }
      getVertexPosition(e, t) {
        let i = this.geometry,
          r = i.attributes.position,
          s = i.morphAttributes.position,
          a = i.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        let o = this.morphTargetInfluences;
        if (s && o) {
          Qd.set(0, 0, 0);
          for (let l = 0, c = s.length; l < c; l++) {
            let u = o[l],
              f = s[l];
            u !== 0 &&
              (Vv.fromBufferAttribute(f, e),
              a ? Qd.addScaledVector(Vv, u) : Qd.addScaledVector(Vv.sub(t), u));
          }
          t.add(Qd);
        }
        return this.isSkinnedMesh && this.boneTransform(e, t), t;
      }
      raycast(e, t) {
        let i = this.geometry,
          r = this.material,
          s = this.matrixWorld;
        if (
          r === void 0 ||
          (i.boundingSphere === null && i.computeBoundingSphere(),
          Uv.copy(i.boundingSphere),
          Uv.applyMatrix4(s),
          e.ray.intersectsSphere(Uv) === !1) ||
          (cA.copy(s).invert(),
          vc.copy(e.ray).applyMatrix4(cA),
          i.boundingBox !== null && vc.intersectsBox(i.boundingBox) === !1)
        )
          return;
        let a,
          o = i.index,
          l = i.attributes.position,
          c = i.attributes.uv,
          u = i.attributes.uv2,
          f = i.groups,
          d = i.drawRange;
        if (o !== null)
          if (Array.isArray(r))
            for (let m = 0, x = f.length; m < x; m++) {
              let y = f[m],
                g = r[y.materialIndex],
                b = Math.max(y.start, d.start),
                _ = Math.min(
                  o.count,
                  Math.min(y.start + y.count, d.start + d.count)
                );
              for (let E = b, w = _; E < w; E += 3) {
                let P = o.getX(E),
                  L = o.getX(E + 1),
                  I = o.getX(E + 2);
                (a = rp(this, g, e, vc, c, u, P, L, I)),
                  a &&
                    ((a.faceIndex = Math.floor(E / 3)),
                    (a.face.materialIndex = y.materialIndex),
                    t.push(a));
              }
            }
          else {
            let m = Math.max(0, d.start),
              x = Math.min(o.count, d.start + d.count);
            for (let y = m, g = x; y < g; y += 3) {
              let b = o.getX(y),
                _ = o.getX(y + 1),
                E = o.getX(y + 2);
              (a = rp(this, r, e, vc, c, u, b, _, E)),
                a && ((a.faceIndex = Math.floor(y / 3)), t.push(a));
            }
          }
        else if (l !== void 0)
          if (Array.isArray(r))
            for (let m = 0, x = f.length; m < x; m++) {
              let y = f[m],
                g = r[y.materialIndex],
                b = Math.max(y.start, d.start),
                _ = Math.min(
                  l.count,
                  Math.min(y.start + y.count, d.start + d.count)
                );
              for (let E = b, w = _; E < w; E += 3) {
                let P = E,
                  L = E + 1,
                  I = E + 2;
                (a = rp(this, g, e, vc, c, u, P, L, I)),
                  a &&
                    ((a.faceIndex = Math.floor(E / 3)),
                    (a.face.materialIndex = y.materialIndex),
                    t.push(a));
              }
            }
          else {
            let m = Math.max(0, d.start),
              x = Math.min(l.count, d.start + d.count);
            for (let y = m, g = x; y < g; y += 3) {
              let b = y,
                _ = y + 1,
                E = y + 2;
              (a = rp(this, r, e, vc, c, u, b, _, E)),
                a && ((a.faceIndex = Math.floor(y / 3)), t.push(a));
            }
          }
      }
    };
  function eU(n, e, t, i, r, s, a, o) {
    let l;
    if (
      (e.side === qr
        ? (l = i.intersectTriangle(a, s, r, !0, o))
        : (l = i.intersectTriangle(r, s, a, e.side === aa, o)),
      l === null)
    )
      return null;
    np.copy(o), np.applyMatrix4(n.matrixWorld);
    let c = t.ray.origin.distanceTo(np);
    return c < t.near || c > t.far
      ? null
      : { distance: c, point: np.clone(), object: n };
  }
  function rp(n, e, t, i, r, s, a, o, l) {
    n.getVertexPosition(a, eh),
      n.getVertexPosition(o, th),
      n.getVertexPosition(l, ih);
    let c = eU(n, e, t, i, eh, th, ih, Gv);
    if (c) {
      r &&
        (ep.fromBufferAttribute(r, a),
        tp.fromBufferAttribute(r, o),
        ip.fromBufferAttribute(r, l),
        (c.uv = Ps.getUV(Gv, eh, th, ih, ep, tp, ip, new It()))),
        s &&
          (ep.fromBufferAttribute(s, a),
          tp.fromBufferAttribute(s, o),
          ip.fromBufferAttribute(s, l),
          (c.uv2 = Ps.getUV(Gv, eh, th, ih, ep, tp, ip, new It())));
      let u = { a, b: o, c: l, normal: new le(), materialIndex: 0 };
      Ps.getNormal(eh, th, ih, u.normal), (c.face = u);
    }
    return c;
  }
  var kc = class extends qn {
    constructor(e = 1, t = 1, i = 1, r = 1, s = 1, a = 1) {
      super();
      (this.type = "BoxGeometry"),
        (this.parameters = {
          width: e,
          height: t,
          depth: i,
          widthSegments: r,
          heightSegments: s,
          depthSegments: a,
        });
      let o = this;
      (r = Math.floor(r)), (s = Math.floor(s)), (a = Math.floor(a));
      let l = [],
        c = [],
        u = [],
        f = [],
        d = 0,
        m = 0;
      x("z", "y", "x", -1, -1, i, t, e, a, s, 0),
        x("z", "y", "x", 1, -1, i, t, -e, a, s, 1),
        x("x", "z", "y", 1, 1, e, i, t, r, a, 2),
        x("x", "z", "y", 1, -1, e, i, -t, r, a, 3),
        x("x", "y", "z", 1, -1, e, t, i, r, s, 4),
        x("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
        this.setIndex(l),
        this.setAttribute("position", new jr(c, 3)),
        this.setAttribute("normal", new jr(u, 3)),
        this.setAttribute("uv", new jr(f, 2));
      function x(y, g, b, _, E, w, P, L, I, M, R) {
        let O = w / I,
          U = P / M,
          X = w / 2,
          $ = P / 2,
          W = L / 2,
          ue = I + 1,
          ae = M + 1,
          he = 0,
          ce = 0,
          te = new le();
        for (let Me = 0; Me < ae; Me++) {
          let ge = Me * U - $;
          for (let pe = 0; pe < ue; pe++) {
            let We = pe * O - X;
            (te[y] = We * _),
              (te[g] = ge * E),
              (te[b] = W),
              c.push(te.x, te.y, te.z),
              (te[y] = 0),
              (te[g] = 0),
              (te[b] = L > 0 ? 1 : -1),
              u.push(te.x, te.y, te.z),
              f.push(pe / I),
              f.push(1 - Me / M),
              (he += 1);
          }
        }
        for (let Me = 0; Me < M; Me++)
          for (let ge = 0; ge < I; ge++) {
            let pe = d + ge + ue * Me,
              We = d + ge + ue * (Me + 1),
              Fe = d + (ge + 1) + ue * (Me + 1),
              Be = d + (ge + 1) + ue * Me;
            l.push(pe, We, Be), l.push(We, Fe, Be), (ce += 6);
          }
        o.addGroup(m, ce, R), (m += ce), (d += he);
      }
    }
    static fromJSON(e) {
      return new kc(
        e.width,
        e.height,
        e.depth,
        e.widthSegments,
        e.heightSegments,
        e.depthSegments
      );
    }
  };
  function Rc(n) {
    let e = {};
    for (let t in n) {
      e[t] = {};
      for (let i in n[t]) {
        let r = n[t][i];
        r &&
        (r.isColor ||
          r.isMatrix3 ||
          r.isMatrix4 ||
          r.isVector2 ||
          r.isVector3 ||
          r.isVector4 ||
          r.isTexture ||
          r.isQuaternion)
          ? (e[t][i] = r.clone())
          : Array.isArray(r)
          ? (e[t][i] = r.slice())
          : (e[t][i] = r);
      }
    }
    return e;
  }
  function $n(n) {
    let e = {};
    for (let t = 0; t < n.length; t++) {
      let i = Rc(n[t]);
      for (let r in i) e[r] = i[r];
    }
    return e;
  }
  function tU(n) {
    let e = [];
    for (let t = 0; t < n.length; t++) e.push(n[t].clone());
    return e;
  }
  function cC(n) {
    return n.getRenderTarget() === null && n.outputEncoding === oi ? As : dh;
  }
  var iU = { clone: Rc, merge: $n },
    nU = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    rU = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,
    io = class extends Xr {
      constructor(e) {
        super();
        (this.isShaderMaterial = !0),
          (this.type = "ShaderMaterial"),
          (this.defines = {}),
          (this.uniforms = {}),
          (this.uniformsGroups = []),
          (this.vertexShader = nU),
          (this.fragmentShader = rU),
          (this.linewidth = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.clipping = !1),
          (this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
          }),
          (this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0],
          }),
          (this.index0AttributeName = void 0),
          (this.uniformsNeedUpdate = !1),
          (this.glslVersion = null),
          e !== void 0 && this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.fragmentShader = e.fragmentShader),
          (this.vertexShader = e.vertexShader),
          (this.uniforms = Rc(e.uniforms)),
          (this.uniformsGroups = tU(e.uniformsGroups)),
          (this.defines = Object.assign({}, e.defines)),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.fog = e.fog),
          (this.lights = e.lights),
          (this.clipping = e.clipping),
          (this.extensions = Object.assign({}, e.extensions)),
          (this.glslVersion = e.glslVersion),
          this
        );
      }
      toJSON(e) {
        let t = super.toJSON(e);
        (t.glslVersion = this.glslVersion), (t.uniforms = {});
        for (let r in this.uniforms) {
          let a = this.uniforms[r].value;
          a && a.isTexture
            ? (t.uniforms[r] = { type: "t", value: a.toJSON(e).uuid })
            : a && a.isColor
            ? (t.uniforms[r] = { type: "c", value: a.getHex() })
            : a && a.isVector2
            ? (t.uniforms[r] = { type: "v2", value: a.toArray() })
            : a && a.isVector3
            ? (t.uniforms[r] = { type: "v3", value: a.toArray() })
            : a && a.isVector4
            ? (t.uniforms[r] = { type: "v4", value: a.toArray() })
            : a && a.isMatrix3
            ? (t.uniforms[r] = { type: "m3", value: a.toArray() })
            : a && a.isMatrix4
            ? (t.uniforms[r] = { type: "m4", value: a.toArray() })
            : (t.uniforms[r] = { value: a });
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
          (t.vertexShader = this.vertexShader),
          (t.fragmentShader = this.fragmentShader);
        let i = {};
        for (let r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i), t;
      }
    },
    yx = class extends Ai {
      constructor() {
        super();
        (this.isCamera = !0),
          (this.type = "Camera"),
          (this.matrixWorldInverse = new Wt()),
          (this.projectionMatrix = new Wt()),
          (this.projectionMatrixInverse = new Wt());
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          this.matrixWorldInverse.copy(e.matrixWorldInverse),
          this.projectionMatrix.copy(e.projectionMatrix),
          this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
          this
        );
      }
      getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        let t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize();
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return new this.constructor().copy(this);
      }
    },
    yn = class extends yx {
      constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
        super();
        (this.isPerspectiveCamera = !0),
          (this.type = "PerspectiveCamera"),
          (this.fov = e),
          (this.zoom = 1),
          (this.near = i),
          (this.far = r),
          (this.focus = 10),
          (this.aspect = t),
          (this.view = null),
          (this.filmGauge = 35),
          (this.filmOffset = 0),
          this.updateProjectionMatrix();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.fov = e.fov),
          (this.zoom = e.zoom),
          (this.near = e.near),
          (this.far = e.far),
          (this.focus = e.focus),
          (this.aspect = e.aspect),
          (this.view = e.view === null ? null : Object.assign({}, e.view)),
          (this.filmGauge = e.filmGauge),
          (this.filmOffset = e.filmOffset),
          this
        );
      }
      setFocalLength(e) {
        let t = (0.5 * this.getFilmHeight()) / e;
        (this.fov = ph * 2 * Math.atan(t)), this.updateProjectionMatrix();
      }
      getFocalLength() {
        let e = Math.tan(lh * 0.5 * this.fov);
        return (0.5 * this.getFilmHeight()) / e;
      }
      getEffectiveFOV() {
        return ph * 2 * Math.atan(Math.tan(lh * 0.5 * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(e, t, i, r, s, a) {
        (this.aspect = e / t),
          this.view === null &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = i),
          (this.view.offsetY = r),
          (this.view.width = s),
          (this.view.height = a),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        let e = this.near,
          t = (e * Math.tan(lh * 0.5 * this.fov)) / this.zoom,
          i = 2 * t,
          r = this.aspect * i,
          s = -0.5 * r,
          a = this.view;
        if (this.view !== null && this.view.enabled) {
          let l = a.fullWidth,
            c = a.fullHeight;
          (s += (a.offsetX * r) / l),
            (t -= (a.offsetY * i) / c),
            (r *= a.width / l),
            (i *= a.height / c);
        }
        let o = this.filmOffset;
        o !== 0 && (s += (e * o) / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(
            s,
            s + r,
            t,
            t - i,
            e,
            this.far
          ),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(e) {
        let t = super.toJSON(e);
        return (
          (t.object.fov = this.fov),
          (t.object.zoom = this.zoom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          (t.object.focus = this.focus),
          (t.object.aspect = this.aspect),
          this.view !== null && (t.object.view = Object.assign({}, this.view)),
          (t.object.filmGauge = this.filmGauge),
          (t.object.filmOffset = this.filmOffset),
          t
        );
      }
    },
    xc = -90,
    bc = 1,
    uC = class extends Ai {
      constructor(e, t, i) {
        super();
        (this.type = "CubeCamera"), (this.renderTarget = i);
        let r = new yn(xc, bc, e, t);
        (r.layers = this.layers),
          r.up.set(0, 1, 0),
          r.lookAt(1, 0, 0),
          this.add(r);
        let s = new yn(xc, bc, e, t);
        (s.layers = this.layers),
          s.up.set(0, 1, 0),
          s.lookAt(-1, 0, 0),
          this.add(s);
        let a = new yn(xc, bc, e, t);
        (a.layers = this.layers),
          a.up.set(0, 0, -1),
          a.lookAt(0, 1, 0),
          this.add(a);
        let o = new yn(xc, bc, e, t);
        (o.layers = this.layers),
          o.up.set(0, 0, 1),
          o.lookAt(0, -1, 0),
          this.add(o);
        let l = new yn(xc, bc, e, t);
        (l.layers = this.layers),
          l.up.set(0, 1, 0),
          l.lookAt(0, 0, 1),
          this.add(l);
        let c = new yn(xc, bc, e, t);
        (c.layers = this.layers),
          c.up.set(0, 1, 0),
          c.lookAt(0, 0, -1),
          this.add(c);
      }
      update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        let i = this.renderTarget,
          [r, s, a, o, l, c] = this.children,
          u = e.getRenderTarget(),
          f = e.toneMapping,
          d = e.xr.enabled;
        (e.toneMapping = sa), (e.xr.enabled = !1);
        let m = i.texture.generateMipmaps;
        (i.texture.generateMipmaps = !1),
          e.setRenderTarget(i, 0),
          e.render(t, r),
          e.setRenderTarget(i, 1),
          e.render(t, s),
          e.setRenderTarget(i, 2),
          e.render(t, a),
          e.setRenderTarget(i, 3),
          e.render(t, o),
          e.setRenderTarget(i, 4),
          e.render(t, l),
          (i.texture.generateMipmaps = m),
          e.setRenderTarget(i, 5),
          e.render(t, c),
          e.setRenderTarget(u),
          (e.toneMapping = f),
          (e.xr.enabled = d),
          (i.texture.needsPMREMUpdate = !0);
      }
    },
    vx = class extends hn {
      constructor(e, t, i, r, s, a, o, l, c, u) {
        (e = e !== void 0 ? e : []), (t = t !== void 0 ? t : Pc);
        super(e, t, i, r, s, a, o, l, c, u);
        (this.isCubeTexture = !0), (this.flipY = !1);
      }
      get images() {
        return this.image;
      }
      set images(e) {
        this.image = e;
      }
    },
    hC = class extends to {
      constructor(e = 1, t = {}) {
        super(e, e, t);
        this.isWebGLCubeRenderTarget = !0;
        let i = { width: e, height: e, depth: 1 },
          r = [i, i, i, i, i, i];
        (this.texture = new vx(
          r,
          t.mapping,
          t.wrapS,
          t.wrapT,
          t.magFilter,
          t.minFilter,
          t.format,
          t.type,
          t.anisotropy,
          t.encoding
        )),
          (this.texture.isRenderTargetTexture = !0),
          (this.texture.generateMipmaps =
            t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
          (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Wn);
      }
      fromEquirectangularTexture(e, t) {
        (this.texture.type = t.type),
          (this.texture.encoding = t.encoding),
          (this.texture.generateMipmaps = t.generateMipmaps),
          (this.texture.minFilter = t.minFilter),
          (this.texture.magFilter = t.magFilter);
        let i = {
            uniforms: { tEquirect: { value: null } },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
          },
          r = new kc(5, 5, 5),
          s = new io({
            name: "CubemapFromEquirect",
            uniforms: Rc(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: qr,
            blending: Qa,
          });
        s.uniforms.tEquirect.value = t;
        let a = new ar(r, s),
          o = t.minFilter;
        return (
          t.minFilter === eo && (t.minFilter = Wn),
          new uC(1, 10, this).update(e, a),
          (t.minFilter = o),
          a.geometry.dispose(),
          a.material.dispose(),
          this
        );
      }
      clear(e, t, i, r) {
        let s = e.getRenderTarget();
        for (let a = 0; a < 6; a++)
          e.setRenderTarget(this, a), e.clear(t, i, r);
        e.setRenderTarget(s);
      }
    },
    Hv = new le(),
    sU = new le(),
    aU = new sr(),
    Ja = class {
      constructor(e = new le(1, 0, 0), t = 0) {
        (this.isPlane = !0), (this.normal = e), (this.constant = t);
      }
      set(e, t) {
        return this.normal.copy(e), (this.constant = t), this;
      }
      setComponents(e, t, i, r) {
        return this.normal.set(e, t, i), (this.constant = r), this;
      }
      setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
      }
      setFromCoplanarPoints(e, t, i) {
        let r = Hv.subVectors(i, t).cross(sU.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e), this;
      }
      copy(e) {
        return this.normal.copy(e.normal), (this.constant = e.constant), this;
      }
      normalize() {
        let e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), (this.constant *= e), this;
      }
      negate() {
        return (this.constant *= -1), this.normal.negate(), this;
      }
      distanceToPoint(e) {
        return this.normal.dot(e) + this.constant;
      }
      distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius;
      }
      projectPoint(e, t) {
        return t
          .copy(this.normal)
          .multiplyScalar(-this.distanceToPoint(e))
          .add(e);
      }
      intersectLine(e, t) {
        let i = e.delta(Hv),
          r = this.normal.dot(i);
        if (r === 0)
          return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        let s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(i).multiplyScalar(s).add(e.start);
      }
      intersectsLine(e) {
        let t = this.distanceToPoint(e.start),
          i = this.distanceToPoint(e.end);
        return (t < 0 && i > 0) || (i < 0 && t > 0);
      }
      intersectsBox(e) {
        return e.intersectsPlane(this);
      }
      intersectsSphere(e) {
        return e.intersectsPlane(this);
      }
      coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(e, t) {
        let i = t || aU.getNormalMatrix(e),
          r = this.coplanarPoint(Hv).applyMatrix4(e),
          s = this.normal.applyMatrix3(i).normalize();
        return (this.constant = -r.dot(s)), this;
      }
      translate(e) {
        return (this.constant -= e.dot(this.normal)), this;
      }
      equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    },
    _c = new ro(),
    sp = new le(),
    bp = class {
      constructor(
        e = new Ja(),
        t = new Ja(),
        i = new Ja(),
        r = new Ja(),
        s = new Ja(),
        a = new Ja()
      ) {
        this.planes = [e, t, i, r, s, a];
      }
      set(e, t, i, r, s, a) {
        let o = this.planes;
        return (
          o[0].copy(e),
          o[1].copy(t),
          o[2].copy(i),
          o[3].copy(r),
          o[4].copy(s),
          o[5].copy(a),
          this
        );
      }
      copy(e) {
        let t = this.planes;
        for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
        return this;
      }
      setFromProjectionMatrix(e) {
        let t = this.planes,
          i = e.elements,
          r = i[0],
          s = i[1],
          a = i[2],
          o = i[3],
          l = i[4],
          c = i[5],
          u = i[6],
          f = i[7],
          d = i[8],
          m = i[9],
          x = i[10],
          y = i[11],
          g = i[12],
          b = i[13],
          _ = i[14],
          E = i[15];
        return (
          t[0].setComponents(o - r, f - l, y - d, E - g).normalize(),
          t[1].setComponents(o + r, f + l, y + d, E + g).normalize(),
          t[2].setComponents(o + s, f + c, y + m, E + b).normalize(),
          t[3].setComponents(o - s, f - c, y - m, E - b).normalize(),
          t[4].setComponents(o - a, f - u, y - x, E - _).normalize(),
          t[5].setComponents(o + a, f + u, y + x, E + _).normalize(),
          this
        );
      }
      intersectsObject(e) {
        let t = e.geometry;
        return (
          t.boundingSphere === null && t.computeBoundingSphere(),
          _c.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
          this.intersectsSphere(_c)
        );
      }
      intersectsSprite(e) {
        return (
          _c.center.set(0, 0, 0),
          (_c.radius = 0.7071067811865476),
          _c.applyMatrix4(e.matrixWorld),
          this.intersectsSphere(_c)
        );
      }
      intersectsSphere(e) {
        let t = this.planes,
          i = e.center,
          r = -e.radius;
        for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
        return !0;
      }
      intersectsBox(e) {
        let t = this.planes;
        for (let i = 0; i < 6; i++) {
          let r = t[i];
          if (
            ((sp.x = r.normal.x > 0 ? e.max.x : e.min.x),
            (sp.y = r.normal.y > 0 ? e.max.y : e.min.y),
            (sp.z = r.normal.z > 0 ? e.max.z : e.min.z),
            r.distanceToPoint(sp) < 0)
          )
            return !1;
        }
        return !0;
      }
      containsPoint(e) {
        let t = this.planes;
        for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
        return !0;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
  function fC() {
    let n = null,
      e = !1,
      t = null,
      i = null;
    function r(s, a) {
      t(s, a), (i = n.requestAnimationFrame(r));
    }
    return {
      start: function () {
        e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
      },
      stop: function () {
        n.cancelAnimationFrame(i), (e = !1);
      },
      setAnimationLoop: function (s) {
        t = s;
      },
      setContext: function (s) {
        n = s;
      },
    };
  }
  function oU(n, e) {
    let t = e.isWebGL2,
      i = new WeakMap();
    function r(c, u) {
      let f = c.array,
        d = c.usage,
        m = n.createBuffer();
      n.bindBuffer(u, m), n.bufferData(u, f, d), c.onUploadCallback();
      let x;
      if (f instanceof Float32Array) x = 5126;
      else if (f instanceof Uint16Array)
        if (c.isFloat16BufferAttribute)
          if (t) x = 5131;
          else
            throw new Error(
              "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
            );
        else x = 5123;
      else if (f instanceof Int16Array) x = 5122;
      else if (f instanceof Uint32Array) x = 5125;
      else if (f instanceof Int32Array) x = 5124;
      else if (f instanceof Int8Array) x = 5120;
      else if (f instanceof Uint8Array) x = 5121;
      else if (f instanceof Uint8ClampedArray) x = 5121;
      else
        throw new Error(
          "THREE.WebGLAttributes: Unsupported buffer data format: " + f
        );
      return {
        buffer: m,
        type: x,
        bytesPerElement: f.BYTES_PER_ELEMENT,
        version: c.version,
      };
    }
    function s(c, u, f) {
      let d = u.array,
        m = u.updateRange;
      n.bindBuffer(f, c),
        m.count === -1
          ? n.bufferSubData(f, 0, d)
          : (t
              ? n.bufferSubData(
                  f,
                  m.offset * d.BYTES_PER_ELEMENT,
                  d,
                  m.offset,
                  m.count
                )
              : n.bufferSubData(
                  f,
                  m.offset * d.BYTES_PER_ELEMENT,
                  d.subarray(m.offset, m.offset + m.count)
                ),
            (m.count = -1)),
        u.onUploadCallback();
    }
    function a(c) {
      return c.isInterleavedBufferAttribute && (c = c.data), i.get(c);
    }
    function o(c) {
      c.isInterleavedBufferAttribute && (c = c.data);
      let u = i.get(c);
      u && (n.deleteBuffer(u.buffer), i.delete(c));
    }
    function l(c, u) {
      if (c.isGLBufferAttribute) {
        let d = i.get(c);
        (!d || d.version < c.version) &&
          i.set(c, {
            buffer: c.buffer,
            type: c.type,
            bytesPerElement: c.elementSize,
            version: c.version,
          });
        return;
      }
      c.isInterleavedBufferAttribute && (c = c.data);
      let f = i.get(c);
      f === void 0
        ? i.set(c, r(c, u))
        : f.version < c.version && (s(f.buffer, c, u), (f.version = c.version));
    }
    return { get: a, remove: o, update: l };
  }
  var _p = class extends qn {
      constructor(e = 1, t = 1, i = 1, r = 1) {
        super();
        (this.type = "PlaneGeometry"),
          (this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r,
          });
        let s = e / 2,
          a = t / 2,
          o = Math.floor(i),
          l = Math.floor(r),
          c = o + 1,
          u = l + 1,
          f = e / o,
          d = t / l,
          m = [],
          x = [],
          y = [],
          g = [];
        for (let b = 0; b < u; b++) {
          let _ = b * d - a;
          for (let E = 0; E < c; E++) {
            let w = E * f - s;
            x.push(w, -_, 0), y.push(0, 0, 1), g.push(E / o), g.push(1 - b / l);
          }
        }
        for (let b = 0; b < l; b++)
          for (let _ = 0; _ < o; _++) {
            let E = _ + c * b,
              w = _ + c * (b + 1),
              P = _ + 1 + c * (b + 1),
              L = _ + 1 + c * b;
            m.push(E, w, L), m.push(w, P, L);
          }
        this.setIndex(m),
          this.setAttribute("position", new jr(x, 3)),
          this.setAttribute("normal", new jr(y, 3)),
          this.setAttribute("uv", new jr(g, 2));
      }
      static fromJSON(e) {
        return new _p(e.width, e.height, e.widthSegments, e.heightSegments);
      }
    },
    lU = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
    cU = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    uU = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
    hU = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
    fU = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
    dU = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    pU = "vec3 transformed = vec3( position );",
    mU = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
    gU = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
    yU = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
    vU = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
    xU = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
    bU = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
    _U = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
    EU = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
    TU = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
    SU = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
    wU = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
    MU = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
    AU = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
    CU = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
    PU = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
    DU = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
    IU = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
    LU = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
    RU = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
    OU = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    NU = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
    kU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
    FU = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
    BU = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
    zU = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
    UU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
    VU = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
    GU = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
    HU = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
    $U = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
    WU = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
    qU = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
    jU = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    XU = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
    YU = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
    KU = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
    JU = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
    ZU = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
    QU = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
    e6 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
    t6 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
    i6 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
    n6 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
    r6 = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
    s6 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
    a6 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
    o6 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    l6 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    c6 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
    u6 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
    h6 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
    f6 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
    d6 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
    p6 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    m6 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
    g6 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    y6 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
    v6 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
    x6 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
    b6 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
    _6 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
    E6 = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
    T6 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    S6 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    w6 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
    M6 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
    A6 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
    C6 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
    P6 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
    D6 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
    I6 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
    L6 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
    R6 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
    O6 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
    N6 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
    k6 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
    F6 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
    B6 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    z6 = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
    U6 = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
    V6 = `#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
    G6 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
    H6 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    $6 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
    W6 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
    q6 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
    j6 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    X6 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    Y6 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
    K6 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
    J6 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
    Z6 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
    Q6 = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
    eV = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
    tV = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
    iV = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
    nV = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
    rV = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
    sV = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
    aV = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
    oV = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    lV = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    cV = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    uV = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    hV = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    fV = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
    dV = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
    pV = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
    mV = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
    gV = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
    yV = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    vV = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    xV = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    bV = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
    _V = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    EV = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    TV = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    SV = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
    wV = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    MV = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
    AV = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
    CV = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    PV = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    DV = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
    IV = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    LV = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    RV = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    OV = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
    NV = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    kV = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    FV = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
    BV = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    zV = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
    $t = {
      alphamap_fragment: lU,
      alphamap_pars_fragment: cU,
      alphatest_fragment: uU,
      alphatest_pars_fragment: hU,
      aomap_fragment: fU,
      aomap_pars_fragment: dU,
      begin_vertex: pU,
      beginnormal_vertex: mU,
      bsdfs: gU,
      iridescence_fragment: yU,
      bumpmap_pars_fragment: vU,
      clipping_planes_fragment: xU,
      clipping_planes_pars_fragment: bU,
      clipping_planes_pars_vertex: _U,
      clipping_planes_vertex: EU,
      color_fragment: TU,
      color_pars_fragment: SU,
      color_pars_vertex: wU,
      color_vertex: MU,
      common: AU,
      cube_uv_reflection_fragment: CU,
      defaultnormal_vertex: PU,
      displacementmap_pars_vertex: DU,
      displacementmap_vertex: IU,
      emissivemap_fragment: LU,
      emissivemap_pars_fragment: RU,
      encodings_fragment: OU,
      encodings_pars_fragment: NU,
      envmap_fragment: kU,
      envmap_common_pars_fragment: FU,
      envmap_pars_fragment: BU,
      envmap_pars_vertex: zU,
      envmap_physical_pars_fragment: JU,
      envmap_vertex: UU,
      fog_vertex: VU,
      fog_pars_vertex: GU,
      fog_fragment: HU,
      fog_pars_fragment: $U,
      gradientmap_pars_fragment: WU,
      lightmap_fragment: qU,
      lightmap_pars_fragment: jU,
      lights_lambert_fragment: XU,
      lights_lambert_pars_fragment: YU,
      lights_pars_begin: KU,
      lights_toon_fragment: ZU,
      lights_toon_pars_fragment: QU,
      lights_phong_fragment: e6,
      lights_phong_pars_fragment: t6,
      lights_physical_fragment: i6,
      lights_physical_pars_fragment: n6,
      lights_fragment_begin: r6,
      lights_fragment_maps: s6,
      lights_fragment_end: a6,
      logdepthbuf_fragment: o6,
      logdepthbuf_pars_fragment: l6,
      logdepthbuf_pars_vertex: c6,
      logdepthbuf_vertex: u6,
      map_fragment: h6,
      map_pars_fragment: f6,
      map_particle_fragment: d6,
      map_particle_pars_fragment: p6,
      metalnessmap_fragment: m6,
      metalnessmap_pars_fragment: g6,
      morphcolor_vertex: y6,
      morphnormal_vertex: v6,
      morphtarget_pars_vertex: x6,
      morphtarget_vertex: b6,
      normal_fragment_begin: _6,
      normal_fragment_maps: E6,
      normal_pars_fragment: T6,
      normal_pars_vertex: S6,
      normal_vertex: w6,
      normalmap_pars_fragment: M6,
      clearcoat_normal_fragment_begin: A6,
      clearcoat_normal_fragment_maps: C6,
      clearcoat_pars_fragment: P6,
      iridescence_pars_fragment: D6,
      output_fragment: I6,
      packing: L6,
      premultiplied_alpha_fragment: R6,
      project_vertex: O6,
      dithering_fragment: N6,
      dithering_pars_fragment: k6,
      roughnessmap_fragment: F6,
      roughnessmap_pars_fragment: B6,
      shadowmap_pars_fragment: z6,
      shadowmap_pars_vertex: U6,
      shadowmap_vertex: V6,
      shadowmask_pars_fragment: G6,
      skinbase_vertex: H6,
      skinning_pars_vertex: $6,
      skinning_vertex: W6,
      skinnormal_vertex: q6,
      specularmap_fragment: j6,
      specularmap_pars_fragment: X6,
      tonemapping_fragment: Y6,
      tonemapping_pars_fragment: K6,
      transmission_fragment: J6,
      transmission_pars_fragment: Z6,
      uv_pars_fragment: Q6,
      uv_pars_vertex: eV,
      uv_vertex: tV,
      uv2_pars_fragment: iV,
      uv2_pars_vertex: nV,
      uv2_vertex: rV,
      worldpos_vertex: sV,
      background_vert: aV,
      background_frag: oV,
      backgroundCube_vert: lV,
      backgroundCube_frag: cV,
      cube_vert: uV,
      cube_frag: hV,
      depth_vert: fV,
      depth_frag: dV,
      distanceRGBA_vert: pV,
      distanceRGBA_frag: mV,
      equirect_vert: gV,
      equirect_frag: yV,
      linedashed_vert: vV,
      linedashed_frag: xV,
      meshbasic_vert: bV,
      meshbasic_frag: _V,
      meshlambert_vert: EV,
      meshlambert_frag: TV,
      meshmatcap_vert: SV,
      meshmatcap_frag: wV,
      meshnormal_vert: MV,
      meshnormal_frag: AV,
      meshphong_vert: CV,
      meshphong_frag: PV,
      meshphysical_vert: DV,
      meshphysical_frag: IV,
      meshtoon_vert: LV,
      meshtoon_frag: RV,
      points_vert: OV,
      points_frag: NV,
      shadow_vert: kV,
      shadow_frag: FV,
      sprite_vert: BV,
      sprite_frag: zV,
    },
    Je = {
      common: {
        diffuse: { value: new Bt(16777215) },
        opacity: { value: 1 },
        map: { value: null },
        uvTransform: { value: new sr() },
        uv2Transform: { value: new sr() },
        alphaMap: { value: null },
        alphaTest: { value: 0 },
      },
      specularmap: { specularMap: { value: null } },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        ior: { value: 1.5 },
        refractionRatio: { value: 0.98 },
      },
      aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
      lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
      emissivemap: { emissiveMap: { value: null } },
      bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
      normalmap: {
        normalMap: { value: null },
        normalScale: { value: new It(1, 1) },
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 },
      },
      roughnessmap: { roughnessMap: { value: null } },
      metalnessmap: { metalnessMap: { value: null } },
      gradientmap: { gradientMap: { value: null } },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new Bt(16777215) },
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: {
          value: [],
          properties: { direction: {}, color: {} },
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
          },
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        spotLightMap: { value: [] },
        spotShadowMap: { value: [] },
        spotLightMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: { color: {}, position: {}, decay: {}, distance: {} },
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {},
          },
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: {
          value: [],
          properties: { direction: {}, skyColor: {}, groundColor: {} },
        },
        rectAreaLights: {
          value: [],
          properties: { color: {}, position: {}, width: {}, height: {} },
        },
        ltc_1: { value: null },
        ltc_2: { value: null },
      },
      points: {
        diffuse: { value: new Bt(16777215) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        alphaTest: { value: 0 },
        uvTransform: { value: new sr() },
      },
      sprite: {
        diffuse: { value: new Bt(16777215) },
        opacity: { value: 1 },
        center: { value: new It(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        alphaMap: { value: null },
        alphaTest: { value: 0 },
        uvTransform: { value: new sr() },
      },
    },
    Cs = {
      basic: {
        uniforms: $n([
          Je.common,
          Je.specularmap,
          Je.envmap,
          Je.aomap,
          Je.lightmap,
          Je.fog,
        ]),
        vertexShader: $t.meshbasic_vert,
        fragmentShader: $t.meshbasic_frag,
      },
      lambert: {
        uniforms: $n([
          Je.common,
          Je.specularmap,
          Je.envmap,
          Je.aomap,
          Je.lightmap,
          Je.emissivemap,
          Je.bumpmap,
          Je.normalmap,
          Je.displacementmap,
          Je.fog,
          Je.lights,
          { emissive: { value: new Bt(0) } },
        ]),
        vertexShader: $t.meshlambert_vert,
        fragmentShader: $t.meshlambert_frag,
      },
      phong: {
        uniforms: $n([
          Je.common,
          Je.specularmap,
          Je.envmap,
          Je.aomap,
          Je.lightmap,
          Je.emissivemap,
          Je.bumpmap,
          Je.normalmap,
          Je.displacementmap,
          Je.fog,
          Je.lights,
          {
            emissive: { value: new Bt(0) },
            specular: { value: new Bt(1118481) },
            shininess: { value: 30 },
          },
        ]),
        vertexShader: $t.meshphong_vert,
        fragmentShader: $t.meshphong_frag,
      },
      standard: {
        uniforms: $n([
          Je.common,
          Je.envmap,
          Je.aomap,
          Je.lightmap,
          Je.emissivemap,
          Je.bumpmap,
          Je.normalmap,
          Je.displacementmap,
          Je.roughnessmap,
          Je.metalnessmap,
          Je.fog,
          Je.lights,
          {
            emissive: { value: new Bt(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 },
          },
        ]),
        vertexShader: $t.meshphysical_vert,
        fragmentShader: $t.meshphysical_frag,
      },
      toon: {
        uniforms: $n([
          Je.common,
          Je.aomap,
          Je.lightmap,
          Je.emissivemap,
          Je.bumpmap,
          Je.normalmap,
          Je.displacementmap,
          Je.gradientmap,
          Je.fog,
          Je.lights,
          { emissive: { value: new Bt(0) } },
        ]),
        vertexShader: $t.meshtoon_vert,
        fragmentShader: $t.meshtoon_frag,
      },
      matcap: {
        uniforms: $n([
          Je.common,
          Je.bumpmap,
          Je.normalmap,
          Je.displacementmap,
          Je.fog,
          { matcap: { value: null } },
        ]),
        vertexShader: $t.meshmatcap_vert,
        fragmentShader: $t.meshmatcap_frag,
      },
      points: {
        uniforms: $n([Je.points, Je.fog]),
        vertexShader: $t.points_vert,
        fragmentShader: $t.points_frag,
      },
      dashed: {
        uniforms: $n([
          Je.common,
          Je.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 },
          },
        ]),
        vertexShader: $t.linedashed_vert,
        fragmentShader: $t.linedashed_frag,
      },
      depth: {
        uniforms: $n([Je.common, Je.displacementmap]),
        vertexShader: $t.depth_vert,
        fragmentShader: $t.depth_frag,
      },
      normal: {
        uniforms: $n([
          Je.common,
          Je.bumpmap,
          Je.normalmap,
          Je.displacementmap,
          { opacity: { value: 1 } },
        ]),
        vertexShader: $t.meshnormal_vert,
        fragmentShader: $t.meshnormal_frag,
      },
      sprite: {
        uniforms: $n([Je.sprite, Je.fog]),
        vertexShader: $t.sprite_vert,
        fragmentShader: $t.sprite_frag,
      },
      background: {
        uniforms: {
          uvTransform: { value: new sr() },
          t2D: { value: null },
          backgroundIntensity: { value: 1 },
        },
        vertexShader: $t.background_vert,
        fragmentShader: $t.background_frag,
      },
      backgroundCube: {
        uniforms: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          backgroundBlurriness: { value: 0 },
          backgroundIntensity: { value: 1 },
        },
        vertexShader: $t.backgroundCube_vert,
        fragmentShader: $t.backgroundCube_frag,
      },
      cube: {
        uniforms: {
          tCube: { value: null },
          tFlip: { value: -1 },
          opacity: { value: 1 },
        },
        vertexShader: $t.cube_vert,
        fragmentShader: $t.cube_frag,
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: $t.equirect_vert,
        fragmentShader: $t.equirect_frag,
      },
      distanceRGBA: {
        uniforms: $n([
          Je.common,
          Je.displacementmap,
          {
            referencePosition: { value: new le() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 },
          },
        ]),
        vertexShader: $t.distanceRGBA_vert,
        fragmentShader: $t.distanceRGBA_frag,
      },
      shadow: {
        uniforms: $n([
          Je.lights,
          Je.fog,
          { color: { value: new Bt(0) }, opacity: { value: 1 } },
        ]),
        vertexShader: $t.shadow_vert,
        fragmentShader: $t.shadow_frag,
      },
    };
  Cs.physical = {
    uniforms: $n([
      Cs.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatNormalScale: { value: new It(1, 1) },
        clearcoatNormalMap: { value: null },
        iridescence: { value: 0 },
        iridescenceMap: { value: null },
        iridescenceIOR: { value: 1.3 },
        iridescenceThicknessMinimum: { value: 100 },
        iridescenceThicknessMaximum: { value: 400 },
        iridescenceThicknessMap: { value: null },
        sheen: { value: 0 },
        sheenColor: { value: new Bt(0) },
        sheenColorMap: { value: null },
        sheenRoughness: { value: 1 },
        sheenRoughnessMap: { value: null },
        transmission: { value: 0 },
        transmissionMap: { value: null },
        transmissionSamplerSize: { value: new It() },
        transmissionSamplerMap: { value: null },
        thickness: { value: 0 },
        thicknessMap: { value: null },
        attenuationDistance: { value: 0 },
        attenuationColor: { value: new Bt(0) },
        specularIntensity: { value: 1 },
        specularIntensityMap: { value: null },
        specularColor: { value: new Bt(1, 1, 1) },
        specularColorMap: { value: null },
      },
    ]),
    vertexShader: $t.meshphysical_vert,
    fragmentShader: $t.meshphysical_frag,
  };
  var ap = { r: 0, b: 0, g: 0 };
  function UV(n, e, t, i, r, s, a) {
    let o = new Bt(0),
      l = s === !0 ? 0 : 1,
      c,
      u,
      f = null,
      d = 0,
      m = null;
    function x(g, b) {
      let _ = !1,
        E = b.isScene === !0 ? b.background : null;
      E && E.isTexture && (E = (b.backgroundBlurriness > 0 ? t : e).get(E));
      let w = n.xr,
        P = w.getSession && w.getSession();
      P && P.environmentBlendMode === "additive" && (E = null),
        E === null ? y(o, l) : E && E.isColor && (y(E, 1), (_ = !0)),
        (n.autoClear || _) &&
          n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
        E && (E.isCubeTexture || E.mapping === vp)
          ? (u === void 0 &&
              ((u = new ar(
                new kc(1, 1, 1),
                new io({
                  name: "BackgroundCubeMaterial",
                  uniforms: Rc(Cs.backgroundCube.uniforms),
                  vertexShader: Cs.backgroundCube.vertexShader,
                  fragmentShader: Cs.backgroundCube.fragmentShader,
                  side: qr,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              u.geometry.deleteAttribute("normal"),
              u.geometry.deleteAttribute("uv"),
              (u.onBeforeRender = function (L, I, M) {
                this.matrixWorld.copyPosition(M.matrixWorld);
              }),
              Object.defineProperty(u.material, "envMap", {
                get: function () {
                  return this.uniforms.envMap.value;
                },
              }),
              r.update(u)),
            (u.material.uniforms.envMap.value = E),
            (u.material.uniforms.flipEnvMap.value =
              E.isCubeTexture && E.isRenderTargetTexture === !1 ? -1 : 1),
            (u.material.uniforms.backgroundBlurriness.value =
              b.backgroundBlurriness),
            (u.material.uniforms.backgroundIntensity.value =
              b.backgroundIntensity),
            (u.material.toneMapped = E.encoding !== oi),
            (f !== E || d !== E.version || m !== n.toneMapping) &&
              ((u.material.needsUpdate = !0),
              (f = E),
              (d = E.version),
              (m = n.toneMapping)),
            u.layers.enableAll(),
            g.unshift(u, u.geometry, u.material, 0, 0, null))
          : E &&
            E.isTexture &&
            (c === void 0 &&
              ((c = new ar(
                new _p(2, 2),
                new io({
                  name: "BackgroundMaterial",
                  uniforms: Rc(Cs.background.uniforms),
                  vertexShader: Cs.background.vertexShader,
                  fragmentShader: Cs.background.fragmentShader,
                  side: aa,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              c.geometry.deleteAttribute("normal"),
              Object.defineProperty(c.material, "map", {
                get: function () {
                  return this.uniforms.t2D.value;
                },
              }),
              r.update(c)),
            (c.material.uniforms.t2D.value = E),
            (c.material.uniforms.backgroundIntensity.value =
              b.backgroundIntensity),
            (c.material.toneMapped = E.encoding !== oi),
            E.matrixAutoUpdate === !0 && E.updateMatrix(),
            c.material.uniforms.uvTransform.value.copy(E.matrix),
            (f !== E || d !== E.version || m !== n.toneMapping) &&
              ((c.material.needsUpdate = !0),
              (f = E),
              (d = E.version),
              (m = n.toneMapping)),
            c.layers.enableAll(),
            g.unshift(c, c.geometry, c.material, 0, 0, null));
    }
    function y(g, b) {
      g.getRGB(ap, cC(n)), i.buffers.color.setClear(ap.r, ap.g, ap.b, b, a);
    }
    return {
      getClearColor: function () {
        return o;
      },
      setClearColor: function (g, b = 1) {
        o.set(g), (l = b), y(o, l);
      },
      getClearAlpha: function () {
        return l;
      },
      setClearAlpha: function (g) {
        (l = g), y(o, l);
      },
      render: x,
    };
  }
  function VV(n, e, t, i) {
    let r = n.getParameter(34921),
      s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
      a = i.isWebGL2 || s !== null,
      o = {},
      l = g(null),
      c = l,
      u = !1;
    function f(W, ue, ae, he, ce) {
      let te = !1;
      if (a) {
        let Me = y(he, ae, ue);
        c !== Me && ((c = Me), m(c.object)),
          (te = b(W, he, ae, ce)),
          te && _(W, he, ae, ce);
      } else {
        let Me = ue.wireframe === !0;
        (c.geometry !== he.id || c.program !== ae.id || c.wireframe !== Me) &&
          ((c.geometry = he.id),
          (c.program = ae.id),
          (c.wireframe = Me),
          (te = !0));
      }
      ce !== null && t.update(ce, 34963),
        (te || u) &&
          ((u = !1),
          M(W, ue, ae, he),
          ce !== null && n.bindBuffer(34963, t.get(ce).buffer));
    }
    function d() {
      return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
    }
    function m(W) {
      return i.isWebGL2 ? n.bindVertexArray(W) : s.bindVertexArrayOES(W);
    }
    function x(W) {
      return i.isWebGL2 ? n.deleteVertexArray(W) : s.deleteVertexArrayOES(W);
    }
    function y(W, ue, ae) {
      let he = ae.wireframe === !0,
        ce = o[W.id];
      ce === void 0 && ((ce = {}), (o[W.id] = ce));
      let te = ce[ue.id];
      te === void 0 && ((te = {}), (ce[ue.id] = te));
      let Me = te[he];
      return Me === void 0 && ((Me = g(d())), (te[he] = Me)), Me;
    }
    function g(W) {
      let ue = [],
        ae = [],
        he = [];
      for (let ce = 0; ce < r; ce++) (ue[ce] = 0), (ae[ce] = 0), (he[ce] = 0);
      return {
        geometry: null,
        program: null,
        wireframe: !1,
        newAttributes: ue,
        enabledAttributes: ae,
        attributeDivisors: he,
        object: W,
        attributes: {},
        index: null,
      };
    }
    function b(W, ue, ae, he) {
      let ce = c.attributes,
        te = ue.attributes,
        Me = 0,
        ge = ae.getAttributes();
      for (let pe in ge)
        if (ge[pe].location >= 0) {
          let Fe = ce[pe],
            Be = te[pe];
          if (
            (Be === void 0 &&
              (pe === "instanceMatrix" &&
                W.instanceMatrix &&
                (Be = W.instanceMatrix),
              pe === "instanceColor" &&
                W.instanceColor &&
                (Be = W.instanceColor)),
            Fe === void 0 || Fe.attribute !== Be || (Be && Fe.data !== Be.data))
          )
            return !0;
          Me++;
        }
      return c.attributesNum !== Me || c.index !== he;
    }
    function _(W, ue, ae, he) {
      let ce = {},
        te = ue.attributes,
        Me = 0,
        ge = ae.getAttributes();
      for (let pe in ge)
        if (ge[pe].location >= 0) {
          let Fe = te[pe];
          Fe === void 0 &&
            (pe === "instanceMatrix" &&
              W.instanceMatrix &&
              (Fe = W.instanceMatrix),
            pe === "instanceColor" &&
              W.instanceColor &&
              (Fe = W.instanceColor));
          let Be = {};
          (Be.attribute = Fe),
            Fe && Fe.data && (Be.data = Fe.data),
            (ce[pe] = Be),
            Me++;
        }
      (c.attributes = ce), (c.attributesNum = Me), (c.index = he);
    }
    function E() {
      let W = c.newAttributes;
      for (let ue = 0, ae = W.length; ue < ae; ue++) W[ue] = 0;
    }
    function w(W) {
      P(W, 0);
    }
    function P(W, ue) {
      let ae = c.newAttributes,
        he = c.enabledAttributes,
        ce = c.attributeDivisors;
      (ae[W] = 1),
        he[W] === 0 && (n.enableVertexAttribArray(W), (he[W] = 1)),
        ce[W] !== ue &&
          ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
            i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
          ](W, ue),
          (ce[W] = ue));
    }
    function L() {
      let W = c.newAttributes,
        ue = c.enabledAttributes;
      for (let ae = 0, he = ue.length; ae < he; ae++)
        ue[ae] !== W[ae] && (n.disableVertexAttribArray(ae), (ue[ae] = 0));
    }
    function I(W, ue, ae, he, ce, te) {
      i.isWebGL2 === !0 && (ae === 5124 || ae === 5125)
        ? n.vertexAttribIPointer(W, ue, ae, ce, te)
        : n.vertexAttribPointer(W, ue, ae, he, ce, te);
    }
    function M(W, ue, ae, he) {
      if (
        i.isWebGL2 === !1 &&
        (W.isInstancedMesh || he.isInstancedBufferGeometry) &&
        e.get("ANGLE_instanced_arrays") === null
      )
        return;
      E();
      let ce = he.attributes,
        te = ae.getAttributes(),
        Me = ue.defaultAttributeValues;
      for (let ge in te) {
        let pe = te[ge];
        if (pe.location >= 0) {
          let We = ce[ge];
          if (
            (We === void 0 &&
              (ge === "instanceMatrix" &&
                W.instanceMatrix &&
                (We = W.instanceMatrix),
              ge === "instanceColor" &&
                W.instanceColor &&
                (We = W.instanceColor)),
            We !== void 0)
          ) {
            let Fe = We.normalized,
              Be = We.itemSize,
              be = t.get(We);
            if (be === void 0) continue;
            let ut = be.buffer,
              Ye = be.type,
              _t = be.bytesPerElement;
            if (We.isInterleavedBufferAttribute) {
              let Ze = We.data,
                kt = Ze.stride,
                Et = We.offset;
              if (Ze.isInstancedInterleavedBuffer) {
                for (let Y = 0; Y < pe.locationSize; Y++)
                  P(pe.location + Y, Ze.meshPerAttribute);
                W.isInstancedMesh !== !0 &&
                  he._maxInstanceCount === void 0 &&
                  (he._maxInstanceCount = Ze.meshPerAttribute * Ze.count);
              } else
                for (let Y = 0; Y < pe.locationSize; Y++) w(pe.location + Y);
              n.bindBuffer(34962, ut);
              for (let Y = 0; Y < pe.locationSize; Y++)
                I(
                  pe.location + Y,
                  Be / pe.locationSize,
                  Ye,
                  Fe,
                  kt * _t,
                  (Et + (Be / pe.locationSize) * Y) * _t
                );
            } else {
              if (We.isInstancedBufferAttribute) {
                for (let Ze = 0; Ze < pe.locationSize; Ze++)
                  P(pe.location + Ze, We.meshPerAttribute);
                W.isInstancedMesh !== !0 &&
                  he._maxInstanceCount === void 0 &&
                  (he._maxInstanceCount = We.meshPerAttribute * We.count);
              } else
                for (let Ze = 0; Ze < pe.locationSize; Ze++)
                  w(pe.location + Ze);
              n.bindBuffer(34962, ut);
              for (let Ze = 0; Ze < pe.locationSize; Ze++)
                I(
                  pe.location + Ze,
                  Be / pe.locationSize,
                  Ye,
                  Fe,
                  Be * _t,
                  (Be / pe.locationSize) * Ze * _t
                );
            }
          } else if (Me !== void 0) {
            let Fe = Me[ge];
            if (Fe !== void 0)
              switch (Fe.length) {
                case 2:
                  n.vertexAttrib2fv(pe.location, Fe);
                  break;
                case 3:
                  n.vertexAttrib3fv(pe.location, Fe);
                  break;
                case 4:
                  n.vertexAttrib4fv(pe.location, Fe);
                  break;
                default:
                  n.vertexAttrib1fv(pe.location, Fe);
              }
          }
        }
      }
      L();
    }
    function R() {
      X();
      for (let W in o) {
        let ue = o[W];
        for (let ae in ue) {
          let he = ue[ae];
          for (let ce in he) x(he[ce].object), delete he[ce];
          delete ue[ae];
        }
        delete o[W];
      }
    }
    function O(W) {
      if (o[W.id] === void 0) return;
      let ue = o[W.id];
      for (let ae in ue) {
        let he = ue[ae];
        for (let ce in he) x(he[ce].object), delete he[ce];
        delete ue[ae];
      }
      delete o[W.id];
    }
    function U(W) {
      for (let ue in o) {
        let ae = o[ue];
        if (ae[W.id] === void 0) continue;
        let he = ae[W.id];
        for (let ce in he) x(he[ce].object), delete he[ce];
        delete ae[W.id];
      }
    }
    function X() {
      $(), (u = !0), c !== l && ((c = l), m(c.object));
    }
    function $() {
      (l.geometry = null), (l.program = null), (l.wireframe = !1);
    }
    return {
      setup: f,
      reset: X,
      resetDefaultState: $,
      dispose: R,
      releaseStatesOfGeometry: O,
      releaseStatesOfProgram: U,
      initAttributes: E,
      enableAttribute: w,
      disableUnusedAttributes: L,
    };
  }
  function GV(n, e, t, i) {
    let r = i.isWebGL2,
      s;
    function a(c) {
      s = c;
    }
    function o(c, u) {
      n.drawArrays(s, c, u), t.update(u, s, 1);
    }
    function l(c, u, f) {
      if (f === 0) return;
      let d, m;
      if (r) (d = n), (m = "drawArraysInstanced");
      else if (
        ((d = e.get("ANGLE_instanced_arrays")),
        (m = "drawArraysInstancedANGLE"),
        d === null)
      ) {
        console.error(
          "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
        return;
      }
      d[m](s, c, u, f), t.update(u, s, f);
    }
    (this.setMode = a), (this.render = o), (this.renderInstances = l);
  }
  function HV(n, e, t) {
    let i;
    function r() {
      if (i !== void 0) return i;
      if (e.has("EXT_texture_filter_anisotropic") === !0) {
        let I = e.get("EXT_texture_filter_anisotropic");
        i = n.getParameter(I.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else i = 0;
      return i;
    }
    function s(I) {
      if (I === "highp") {
        if (
          n.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
          n.getShaderPrecisionFormat(35632, 36338).precision > 0
        )
          return "highp";
        I = "mediump";
      }
      return I === "mediump" &&
        n.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
        n.getShaderPrecisionFormat(35632, 36337).precision > 0
        ? "mediump"
        : "lowp";
    }
    let a =
        (typeof WebGL2RenderingContext != "undefined" &&
          n instanceof WebGL2RenderingContext) ||
        (typeof WebGL2ComputeRenderingContext != "undefined" &&
          n instanceof WebGL2ComputeRenderingContext),
      o = t.precision !== void 0 ? t.precision : "highp",
      l = s(o);
    l !== o &&
      (console.warn(
        "THREE.WebGLRenderer:",
        o,
        "not supported, using",
        l,
        "instead."
      ),
      (o = l));
    let c = a || e.has("WEBGL_draw_buffers"),
      u = t.logarithmicDepthBuffer === !0,
      f = n.getParameter(34930),
      d = n.getParameter(35660),
      m = n.getParameter(3379),
      x = n.getParameter(34076),
      y = n.getParameter(34921),
      g = n.getParameter(36347),
      b = n.getParameter(36348),
      _ = n.getParameter(36349),
      E = d > 0,
      w = a || e.has("OES_texture_float"),
      P = E && w,
      L = a ? n.getParameter(36183) : 0;
    return {
      isWebGL2: a,
      drawBuffers: c,
      getMaxAnisotropy: r,
      getMaxPrecision: s,
      precision: o,
      logarithmicDepthBuffer: u,
      maxTextures: f,
      maxVertexTextures: d,
      maxTextureSize: m,
      maxCubemapSize: x,
      maxAttributes: y,
      maxVertexUniforms: g,
      maxVaryings: b,
      maxFragmentUniforms: _,
      vertexTextures: E,
      floatFragmentTextures: w,
      floatVertexTextures: P,
      maxSamples: L,
    };
  }
  function $V(n) {
    let e = this,
      t = null,
      i = 0,
      r = !1,
      s = !1,
      a = new Ja(),
      o = new sr(),
      l = { value: null, needsUpdate: !1 };
    (this.uniform = l),
      (this.numPlanes = 0),
      (this.numIntersection = 0),
      (this.init = function (f, d, m) {
        let x = f.length !== 0 || d || i !== 0 || r;
        return (r = d), (t = u(f, m, 0)), (i = f.length), x;
      }),
      (this.beginShadows = function () {
        (s = !0), u(null);
      }),
      (this.endShadows = function () {
        (s = !1), c();
      }),
      (this.setState = function (f, d, m) {
        let x = f.clippingPlanes,
          y = f.clipIntersection,
          g = f.clipShadows,
          b = n.get(f);
        if (!r || x === null || x.length === 0 || (s && !g)) s ? u(null) : c();
        else {
          let _ = s ? 0 : i,
            E = _ * 4,
            w = b.clippingState || null;
          (l.value = w), (w = u(x, d, E, m));
          for (let P = 0; P !== E; ++P) w[P] = t[P];
          (b.clippingState = w),
            (this.numIntersection = y ? this.numPlanes : 0),
            (this.numPlanes += _);
        }
      });
    function c() {
      l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)),
        (e.numPlanes = i),
        (e.numIntersection = 0);
    }
    function u(f, d, m, x) {
      let y = f !== null ? f.length : 0,
        g = null;
      if (y !== 0) {
        if (((g = l.value), x !== !0 || g === null)) {
          let b = m + y * 4,
            _ = d.matrixWorldInverse;
          o.getNormalMatrix(_),
            (g === null || g.length < b) && (g = new Float32Array(b));
          for (let E = 0, w = m; E !== y; ++E, w += 4)
            a.copy(f[E]).applyMatrix4(_, o),
              a.normal.toArray(g, w),
              (g[w + 3] = a.constant);
        }
        (l.value = g), (l.needsUpdate = !0);
      }
      return (e.numPlanes = y), (e.numIntersection = 0), g;
    }
  }
  function WV(n) {
    let e = new WeakMap();
    function t(a, o) {
      return o === Jv ? (a.mapping = Pc) : o === Zv && (a.mapping = Dc), a;
    }
    function i(a) {
      if (a && a.isTexture && a.isRenderTargetTexture === !1) {
        let o = a.mapping;
        if (o === Jv || o === Zv)
          if (e.has(a)) {
            let l = e.get(a).texture;
            return t(l, a.mapping);
          } else {
            let l = a.image;
            if (l && l.height > 0) {
              let c = new hC(l.height / 2);
              return (
                c.fromEquirectangularTexture(n, a),
                e.set(a, c),
                a.addEventListener("dispose", r),
                t(c.texture, a.mapping)
              );
            } else return null;
          }
      }
      return a;
    }
    function r(a) {
      let o = a.target;
      o.removeEventListener("dispose", r);
      let l = e.get(o);
      l !== void 0 && (e.delete(o), l.dispose());
    }
    function s() {
      e = new WeakMap();
    }
    return { get: i, dispose: s };
  }
  var fl = class extends yx {
      constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, a = 2e3) {
        super();
        (this.isOrthographicCamera = !0),
          (this.type = "OrthographicCamera"),
          (this.zoom = 1),
          (this.view = null),
          (this.left = e),
          (this.right = t),
          (this.top = i),
          (this.bottom = r),
          (this.near = s),
          (this.far = a),
          this.updateProjectionMatrix();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.left = e.left),
          (this.right = e.right),
          (this.top = e.top),
          (this.bottom = e.bottom),
          (this.near = e.near),
          (this.far = e.far),
          (this.zoom = e.zoom),
          (this.view = e.view === null ? null : Object.assign({}, e.view)),
          this
        );
      }
      setViewOffset(e, t, i, r, s, a) {
        this.view === null &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = i),
          (this.view.offsetY = r),
          (this.view.width = s),
          (this.view.height = a),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        let e = (this.right - this.left) / (2 * this.zoom),
          t = (this.top - this.bottom) / (2 * this.zoom),
          i = (this.right + this.left) / 2,
          r = (this.top + this.bottom) / 2,
          s = i - e,
          a = i + e,
          o = r + t,
          l = r - t;
        if (this.view !== null && this.view.enabled) {
          let c = (this.right - this.left) / this.view.fullWidth / this.zoom,
            u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          (s += c * this.view.offsetX),
            (a = s + c * this.view.width),
            (o -= u * this.view.offsetY),
            (l = o - u * this.view.height);
        }
        this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(e) {
        let t = super.toJSON(e);
        return (
          (t.object.zoom = this.zoom),
          (t.object.left = this.left),
          (t.object.right = this.right),
          (t.object.top = this.top),
          (t.object.bottom = this.bottom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          this.view !== null && (t.object.view = Object.assign({}, this.view)),
          t
        );
      }
    },
    Mc = 4,
    uA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
    el = 20,
    $v = new fl(),
    hA = new Bt(),
    Wv = null,
    Qo = (1 + Math.sqrt(5)) / 2,
    Ec = 1 / Qo,
    fA = [
      new le(1, 1, 1),
      new le(-1, 1, 1),
      new le(1, 1, -1),
      new le(-1, 1, -1),
      new le(0, Qo, Ec),
      new le(0, Qo, -Ec),
      new le(Ec, 0, Qo),
      new le(-Ec, 0, Qo),
      new le(Qo, Ec, 0),
      new le(-Qo, Ec, 0),
    ],
    ix = class {
      constructor(e) {
        (this._renderer = e),
          (this._pingPongRenderTarget = null),
          (this._lodMax = 0),
          (this._cubeSize = 0),
          (this._lodPlanes = []),
          (this._sizeLods = []),
          (this._sigmas = []),
          (this._blurMaterial = null),
          (this._cubemapMaterial = null),
          (this._equirectMaterial = null),
          this._compileMaterial(this._blurMaterial);
      }
      fromScene(e, t = 0, i = 0.1, r = 100) {
        (Wv = this._renderer.getRenderTarget()), this._setSize(256);
        let s = this._allocateTargets();
        return (
          (s.depthBuffer = !0),
          this._sceneToCubeUV(e, i, r, s),
          t > 0 && this._blur(s, 0, 0, t),
          this._applyPMREM(s),
          this._cleanup(s),
          s
        );
      }
      fromEquirectangular(e, t = null) {
        return this._fromTexture(e, t);
      }
      fromCubemap(e, t = null) {
        return this._fromTexture(e, t);
      }
      compileCubemapShader() {
        this._cubemapMaterial === null &&
          ((this._cubemapMaterial = mA()),
          this._compileMaterial(this._cubemapMaterial));
      }
      compileEquirectangularShader() {
        this._equirectMaterial === null &&
          ((this._equirectMaterial = pA()),
          this._compileMaterial(this._equirectMaterial));
      }
      dispose() {
        this._dispose(),
          this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
          this._equirectMaterial !== null && this._equirectMaterial.dispose();
      }
      _setSize(e) {
        (this._lodMax = Math.floor(Math.log2(e))),
          (this._cubeSize = Math.pow(2, this._lodMax));
      }
      _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
          this._pingPongRenderTarget !== null &&
            this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
          this._lodPlanes[e].dispose();
      }
      _cleanup(e) {
        this._renderer.setRenderTarget(Wv),
          (e.scissorTest = !1),
          op(e, 0, 0, e.width, e.height);
      }
      _fromTexture(e, t) {
        e.mapping === Pc || e.mapping === Dc
          ? this._setSize(
              e.image.length === 0
                ? 16
                : e.image[0].width || e.image[0].image.width
            )
          : this._setSize(e.image.width / 4),
          (Wv = this._renderer.getRenderTarget());
        let i = t || this._allocateTargets();
        return (
          this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
        );
      }
      _allocateTargets() {
        let e = 3 * Math.max(this._cubeSize, 112),
          t = 4 * this._cubeSize,
          i = {
            magFilter: Wn,
            minFilter: Wn,
            generateMipmaps: !1,
            type: fh,
            format: Wr,
            encoding: ol,
            depthBuffer: !1,
          },
          r = dA(e, t, i);
        if (
          this._pingPongRenderTarget === null ||
          this._pingPongRenderTarget.width !== e
        ) {
          this._pingPongRenderTarget !== null && this._dispose(),
            (this._pingPongRenderTarget = dA(e, t, i));
          let { _lodMax: s } = this;
          ({
            sizeLods: this._sizeLods,
            lodPlanes: this._lodPlanes,
            sigmas: this._sigmas,
          } = qV(s)),
            (this._blurMaterial = jV(s, e, t));
        }
        return r;
      }
      _compileMaterial(e) {
        let t = new ar(this._lodPlanes[0], e);
        this._renderer.compile(t, $v);
      }
      _sceneToCubeUV(e, t, i, r) {
        let o = new yn(90, 1, t, i),
          l = [1, -1, 1, 1, 1, 1],
          c = [1, 1, 1, -1, -1, -1],
          u = this._renderer,
          f = u.autoClear,
          d = u.toneMapping;
        u.getClearColor(hA), (u.toneMapping = sa), (u.autoClear = !1);
        let m = new oa({
            name: "PMREM.Background",
            side: qr,
            depthWrite: !1,
            depthTest: !1,
          }),
          x = new ar(new kc(), m),
          y = !1,
          g = e.background;
        g
          ? g.isColor && (m.color.copy(g), (e.background = null), (y = !0))
          : (m.color.copy(hA), (y = !0));
        for (let b = 0; b < 6; b++) {
          let _ = b % 3;
          _ === 0
            ? (o.up.set(0, l[b], 0), o.lookAt(c[b], 0, 0))
            : _ === 1
            ? (o.up.set(0, 0, l[b]), o.lookAt(0, c[b], 0))
            : (o.up.set(0, l[b], 0), o.lookAt(0, 0, c[b]));
          let E = this._cubeSize;
          op(r, _ * E, b > 2 ? E : 0, E, E),
            u.setRenderTarget(r),
            y && u.render(x, o),
            u.render(e, o);
        }
        x.geometry.dispose(),
          x.material.dispose(),
          (u.toneMapping = d),
          (u.autoClear = f),
          (e.background = g);
      }
      _textureToCubeUV(e, t) {
        let i = this._renderer,
          r = e.mapping === Pc || e.mapping === Dc;
        r
          ? (this._cubemapMaterial === null && (this._cubemapMaterial = mA()),
            (this._cubemapMaterial.uniforms.flipEnvMap.value =
              e.isRenderTargetTexture === !1 ? -1 : 1))
          : this._equirectMaterial === null && (this._equirectMaterial = pA());
        let s = r ? this._cubemapMaterial : this._equirectMaterial,
          a = new ar(this._lodPlanes[0], s),
          o = s.uniforms;
        o.envMap.value = e;
        let l = this._cubeSize;
        op(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(a, $v);
      }
      _applyPMREM(e) {
        let t = this._renderer,
          i = t.autoClear;
        t.autoClear = !1;
        for (let r = 1; r < this._lodPlanes.length; r++) {
          let s = Math.sqrt(
              this._sigmas[r] * this._sigmas[r] -
                this._sigmas[r - 1] * this._sigmas[r - 1]
            ),
            a = fA[(r - 1) % fA.length];
          this._blur(e, r - 1, r, s, a);
        }
        t.autoClear = i;
      }
      _blur(e, t, i, r, s) {
        let a = this._pingPongRenderTarget;
        this._halfBlur(e, a, t, i, r, "latitudinal", s),
          this._halfBlur(a, e, i, i, r, "longitudinal", s);
      }
      _halfBlur(e, t, i, r, s, a, o) {
        let l = this._renderer,
          c = this._blurMaterial;
        a !== "latitudinal" &&
          a !== "longitudinal" &&
          console.error(
            "blur direction must be either latitudinal or longitudinal!"
          );
        let u = 3,
          f = new ar(this._lodPlanes[r], c),
          d = c.uniforms,
          m = this._sizeLods[i] - 1,
          x = isFinite(s) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * el - 1),
          y = s / x,
          g = isFinite(s) ? 1 + Math.floor(u * y) : el;
        g > el &&
          console.warn(
            `sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${el}`
          );
        let b = [],
          _ = 0;
        for (let I = 0; I < el; ++I) {
          let M = I / y,
            R = Math.exp((-M * M) / 2);
          b.push(R), I === 0 ? (_ += R) : I < g && (_ += 2 * R);
        }
        for (let I = 0; I < b.length; I++) b[I] = b[I] / _;
        (d.envMap.value = e.texture),
          (d.samples.value = g),
          (d.weights.value = b),
          (d.latitudinal.value = a === "latitudinal"),
          o && (d.poleAxis.value = o);
        let { _lodMax: E } = this;
        (d.dTheta.value = x), (d.mipInt.value = E - i);
        let w = this._sizeLods[r],
          P = 3 * w * (r > E - Mc ? r - E + Mc : 0),
          L = 4 * (this._cubeSize - w);
        op(t, P, L, 3 * w, 2 * w), l.setRenderTarget(t), l.render(f, $v);
      }
    };
  function qV(n) {
    let e = [],
      t = [],
      i = [],
      r = n,
      s = n - Mc + 1 + uA.length;
    for (let a = 0; a < s; a++) {
      let o = Math.pow(2, r);
      t.push(o);
      let l = 1 / o;
      a > n - Mc ? (l = uA[a - n + Mc - 1]) : a === 0 && (l = 0), i.push(l);
      let c = 1 / (o - 2),
        u = -c,
        f = 1 + c,
        d = [u, u, f, u, f, f, u, u, f, f, u, f],
        m = 6,
        x = 6,
        y = 3,
        g = 2,
        b = 1,
        _ = new Float32Array(y * x * m),
        E = new Float32Array(g * x * m),
        w = new Float32Array(b * x * m);
      for (let L = 0; L < m; L++) {
        let I = ((L % 3) * 2) / 3 - 1,
          M = L > 2 ? 0 : -1,
          R = [
            I,
            M,
            0,
            I + 2 / 3,
            M,
            0,
            I + 2 / 3,
            M + 1,
            0,
            I,
            M,
            0,
            I + 2 / 3,
            M + 1,
            0,
            I,
            M + 1,
            0,
          ];
        _.set(R, y * x * L), E.set(d, g * x * L);
        let O = [L, L, L, L, L, L];
        w.set(O, b * x * L);
      }
      let P = new qn();
      P.setAttribute("position", new en(_, y)),
        P.setAttribute("uv", new en(E, g)),
        P.setAttribute("faceIndex", new en(w, b)),
        e.push(P),
        r > Mc && r--;
    }
    return { lodPlanes: e, sizeLods: t, sigmas: i };
  }
  function dA(n, e, t) {
    let i = new to(n, e, t);
    return (
      (i.texture.mapping = vp),
      (i.texture.name = "PMREM.cubeUv"),
      (i.scissorTest = !0),
      i
    );
  }
  function op(n, e, t, i, r) {
    n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
  }
  function jV(n, e, t) {
    let i = new Float32Array(el),
      r = new le(0, 1, 0);
    return new io({
      name: "SphericalGaussianBlur",
      defines: {
        n: el,
        CUBEUV_TEXEL_WIDTH: 1 / e,
        CUBEUV_TEXEL_HEIGHT: 1 / t,
        CUBEUV_MAX_MIP: `${n}.0`,
      },
      uniforms: {
        envMap: { value: null },
        samples: { value: 1 },
        weights: { value: i },
        latitudinal: { value: !1 },
        dTheta: { value: 0 },
        mipInt: { value: 0 },
        poleAxis: { value: r },
      },
      vertexShader: xx(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
      blending: Qa,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function pA() {
    return new io({
      name: "EquirectangularToCubeUV",
      uniforms: { envMap: { value: null } },
      vertexShader: xx(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
      blending: Qa,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function mA() {
    return new io({
      name: "CubemapToCubeUV",
      uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
      vertexShader: xx(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
      blending: Qa,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function xx() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
  }
  function XV(n) {
    let e = new WeakMap(),
      t = null;
    function i(o) {
      if (o && o.isTexture) {
        let l = o.mapping,
          c = l === Jv || l === Zv,
          u = l === Pc || l === Dc;
        if (c || u)
          if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
            o.needsPMREMUpdate = !1;
            let f = e.get(o);
            return (
              t === null && (t = new ix(n)),
              (f = c ? t.fromEquirectangular(o, f) : t.fromCubemap(o, f)),
              e.set(o, f),
              f.texture
            );
          } else {
            if (e.has(o)) return e.get(o).texture;
            {
              let f = o.image;
              if ((c && f && f.height > 0) || (u && f && r(f))) {
                t === null && (t = new ix(n));
                let d = c ? t.fromEquirectangular(o) : t.fromCubemap(o);
                return e.set(o, d), o.addEventListener("dispose", s), d.texture;
              } else return null;
            }
          }
      }
      return o;
    }
    function r(o) {
      let l = 0,
        c = 6;
      for (let u = 0; u < c; u++) o[u] !== void 0 && l++;
      return l === c;
    }
    function s(o) {
      let l = o.target;
      l.removeEventListener("dispose", s);
      let c = e.get(l);
      c !== void 0 && (e.delete(l), c.dispose());
    }
    function a() {
      (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
    }
    return { get: i, dispose: a };
  }
  function YV(n) {
    let e = {};
    function t(i) {
      if (e[i] !== void 0) return e[i];
      let r;
      switch (i) {
        case "WEBGL_depth_texture":
          r =
            n.getExtension("WEBGL_depth_texture") ||
            n.getExtension("MOZ_WEBGL_depth_texture") ||
            n.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          r =
            n.getExtension("EXT_texture_filter_anisotropic") ||
            n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
            n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          r =
            n.getExtension("WEBGL_compressed_texture_s3tc") ||
            n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
            n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          r =
            n.getExtension("WEBGL_compressed_texture_pvrtc") ||
            n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          r = n.getExtension(i);
      }
      return (e[i] = r), r;
    }
    return {
      has: function (i) {
        return t(i) !== null;
      },
      init: function (i) {
        i.isWebGL2
          ? t("EXT_color_buffer_float")
          : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
          t("OES_texture_float_linear"),
          t("EXT_color_buffer_half_float"),
          t("WEBGL_multisampled_render_to_texture");
      },
      get: function (i) {
        let r = t(i);
        return (
          r === null &&
            console.warn(
              "THREE.WebGLRenderer: " + i + " extension not supported."
            ),
          r
        );
      },
    };
  }
  function KV(n, e, t, i) {
    let r = {},
      s = new WeakMap();
    function a(f) {
      let d = f.target;
      d.index !== null && e.remove(d.index);
      for (let x in d.attributes) e.remove(d.attributes[x]);
      d.removeEventListener("dispose", a), delete r[d.id];
      let m = s.get(d);
      m && (e.remove(m), s.delete(d)),
        i.releaseStatesOfGeometry(d),
        d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
        t.memory.geometries--;
    }
    function o(f, d) {
      return (
        r[d.id] === !0 ||
          (d.addEventListener("dispose", a),
          (r[d.id] = !0),
          t.memory.geometries++),
        d
      );
    }
    function l(f) {
      let d = f.attributes;
      for (let x in d) e.update(d[x], 34962);
      let m = f.morphAttributes;
      for (let x in m) {
        let y = m[x];
        for (let g = 0, b = y.length; g < b; g++) e.update(y[g], 34962);
      }
    }
    function c(f) {
      let d = [],
        m = f.index,
        x = f.attributes.position,
        y = 0;
      if (m !== null) {
        let _ = m.array;
        y = m.version;
        for (let E = 0, w = _.length; E < w; E += 3) {
          let P = _[E + 0],
            L = _[E + 1],
            I = _[E + 2];
          d.push(P, L, L, I, I, P);
        }
      } else {
        let _ = x.array;
        y = x.version;
        for (let E = 0, w = _.length / 3 - 1; E < w; E += 3) {
          let P = E + 0,
            L = E + 1,
            I = E + 2;
          d.push(P, L, L, I, I, P);
        }
      }
      let g = new (aC(d) ? gx : mx)(d, 1);
      g.version = y;
      let b = s.get(f);
      b && e.remove(b), s.set(f, g);
    }
    function u(f) {
      let d = s.get(f);
      if (d) {
        let m = f.index;
        m !== null && d.version < m.version && c(f);
      } else c(f);
      return s.get(f);
    }
    return { get: o, update: l, getWireframeAttribute: u };
  }
  function JV(n, e, t, i) {
    let r = i.isWebGL2,
      s;
    function a(d) {
      s = d;
    }
    let o, l;
    function c(d) {
      (o = d.type), (l = d.bytesPerElement);
    }
    function u(d, m) {
      n.drawElements(s, m, o, d * l), t.update(m, s, 1);
    }
    function f(d, m, x) {
      if (x === 0) return;
      let y, g;
      if (r) (y = n), (g = "drawElementsInstanced");
      else if (
        ((y = e.get("ANGLE_instanced_arrays")),
        (g = "drawElementsInstancedANGLE"),
        y === null)
      ) {
        console.error(
          "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
        return;
      }
      y[g](s, m, o, d * l, x), t.update(m, s, x);
    }
    (this.setMode = a),
      (this.setIndex = c),
      (this.render = u),
      (this.renderInstances = f);
  }
  function ZV(n) {
    let e = { geometries: 0, textures: 0 },
      t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    function i(s, a, o) {
      switch ((t.calls++, a)) {
        case 4:
          t.triangles += o * (s / 3);
          break;
        case 1:
          t.lines += o * (s / 2);
          break;
        case 3:
          t.lines += o * (s - 1);
          break;
        case 2:
          t.lines += o * s;
          break;
        case 0:
          t.points += o * s;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", a);
          break;
      }
    }
    function r() {
      t.frame++,
        (t.calls = 0),
        (t.triangles = 0),
        (t.points = 0),
        (t.lines = 0);
    }
    return {
      memory: e,
      render: t,
      programs: null,
      autoReset: !0,
      reset: r,
      update: i,
    };
  }
  function QV(n, e) {
    return n[0] - e[0];
  }
  function e8(n, e) {
    return Math.abs(e[1]) - Math.abs(n[1]);
  }
  function t8(n, e, t) {
    let i = {},
      r = new Float32Array(8),
      s = new WeakMap(),
      a = new Ti(),
      o = [];
    for (let c = 0; c < 8; c++) o[c] = [c, 0];
    function l(c, u, f, d) {
      let m = c.morphTargetInfluences;
      if (e.isWebGL2 === !0) {
        let x =
            u.morphAttributes.position ||
            u.morphAttributes.normal ||
            u.morphAttributes.color,
          y = x !== void 0 ? x.length : 0,
          g = s.get(u);
        if (g === void 0 || g.count !== y) {
          let ue = function () {
            $.dispose(), s.delete(u), u.removeEventListener("dispose", ue);
          };
          g !== void 0 && g.texture.dispose();
          let E = u.morphAttributes.position !== void 0,
            w = u.morphAttributes.normal !== void 0,
            P = u.morphAttributes.color !== void 0,
            L = u.morphAttributes.position || [],
            I = u.morphAttributes.normal || [],
            M = u.morphAttributes.color || [],
            R = 0;
          E === !0 && (R = 1), w === !0 && (R = 2), P === !0 && (R = 3);
          let O = u.attributes.position.count * R,
            U = 1;
          O > e.maxTextureSize &&
            ((U = Math.ceil(O / e.maxTextureSize)), (O = e.maxTextureSize));
          let X = new Float32Array(O * U * 4 * y),
            $ = new dx(X, O, U, y);
          ($.type = Za), ($.needsUpdate = !0);
          let W = R * 4;
          for (let ae = 0; ae < y; ae++) {
            let he = L[ae],
              ce = I[ae],
              te = M[ae],
              Me = O * U * 4 * ae;
            for (let ge = 0; ge < he.count; ge++) {
              let pe = ge * W;
              E === !0 &&
                (a.fromBufferAttribute(he, ge),
                (X[Me + pe + 0] = a.x),
                (X[Me + pe + 1] = a.y),
                (X[Me + pe + 2] = a.z),
                (X[Me + pe + 3] = 0)),
                w === !0 &&
                  (a.fromBufferAttribute(ce, ge),
                  (X[Me + pe + 4] = a.x),
                  (X[Me + pe + 5] = a.y),
                  (X[Me + pe + 6] = a.z),
                  (X[Me + pe + 7] = 0)),
                P === !0 &&
                  (a.fromBufferAttribute(te, ge),
                  (X[Me + pe + 8] = a.x),
                  (X[Me + pe + 9] = a.y),
                  (X[Me + pe + 10] = a.z),
                  (X[Me + pe + 11] = te.itemSize === 4 ? a.w : 1));
            }
          }
          (g = { count: y, texture: $, size: new It(O, U) }),
            s.set(u, g),
            u.addEventListener("dispose", ue);
        }
        let b = 0;
        for (let E = 0; E < m.length; E++) b += m[E];
        let _ = u.morphTargetsRelative ? 1 : 1 - b;
        d.getUniforms().setValue(n, "morphTargetBaseInfluence", _),
          d.getUniforms().setValue(n, "morphTargetInfluences", m),
          d.getUniforms().setValue(n, "morphTargetsTexture", g.texture, t),
          d.getUniforms().setValue(n, "morphTargetsTextureSize", g.size);
      } else {
        let x = m === void 0 ? 0 : m.length,
          y = i[u.id];
        if (y === void 0 || y.length !== x) {
          y = [];
          for (let w = 0; w < x; w++) y[w] = [w, 0];
          i[u.id] = y;
        }
        for (let w = 0; w < x; w++) {
          let P = y[w];
          (P[0] = w), (P[1] = m[w]);
        }
        y.sort(e8);
        for (let w = 0; w < 8; w++)
          w < x && y[w][1]
            ? ((o[w][0] = y[w][0]), (o[w][1] = y[w][1]))
            : ((o[w][0] = Number.MAX_SAFE_INTEGER), (o[w][1] = 0));
        o.sort(QV);
        let g = u.morphAttributes.position,
          b = u.morphAttributes.normal,
          _ = 0;
        for (let w = 0; w < 8; w++) {
          let P = o[w],
            L = P[0],
            I = P[1];
          L !== Number.MAX_SAFE_INTEGER && I
            ? (g &&
                u.getAttribute("morphTarget" + w) !== g[L] &&
                u.setAttribute("morphTarget" + w, g[L]),
              b &&
                u.getAttribute("morphNormal" + w) !== b[L] &&
                u.setAttribute("morphNormal" + w, b[L]),
              (r[w] = I),
              (_ += I))
            : (g &&
                u.hasAttribute("morphTarget" + w) === !0 &&
                u.deleteAttribute("morphTarget" + w),
              b &&
                u.hasAttribute("morphNormal" + w) === !0 &&
                u.deleteAttribute("morphNormal" + w),
              (r[w] = 0));
        }
        let E = u.morphTargetsRelative ? 1 : 1 - _;
        d.getUniforms().setValue(n, "morphTargetBaseInfluence", E),
          d.getUniforms().setValue(n, "morphTargetInfluences", r);
      }
    }
    return { update: l };
  }
  function i8(n, e, t, i) {
    let r = new WeakMap();
    function s(l) {
      let c = i.render.frame,
        u = l.geometry,
        f = e.get(l, u);
      return (
        r.get(f) !== c && (e.update(f), r.set(f, c)),
        l.isInstancedMesh &&
          (l.hasEventListener("dispose", o) === !1 &&
            l.addEventListener("dispose", o),
          t.update(l.instanceMatrix, 34962),
          l.instanceColor !== null && t.update(l.instanceColor, 34962)),
        f
      );
    }
    function a() {
      r = new WeakMap();
    }
    function o(l) {
      let c = l.target;
      c.removeEventListener("dispose", o),
        t.remove(c.instanceMatrix),
        c.instanceColor !== null && t.remove(c.instanceColor);
    }
    return { update: s, dispose: a };
  }
  var dC = new hn(),
    pC = new dx(),
    mC = new lC(),
    gC = new vx(),
    gA = [],
    yA = [],
    vA = new Float32Array(16),
    xA = new Float32Array(9),
    bA = new Float32Array(4);
  function Fc(n, e, t) {
    let i = n[0];
    if (i <= 0 || i > 0) return n;
    let r = e * t,
      s = gA[r];
    if ((s === void 0 && ((s = new Float32Array(r)), (gA[r] = s)), e !== 0)) {
      i.toArray(s, 0);
      for (let a = 1, o = 0; a !== e; ++a) (o += t), n[a].toArray(s, o);
    }
    return s;
  }
  function fn(n, e) {
    if (n.length !== e.length) return !1;
    for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
    return !0;
  }
  function dn(n, e) {
    for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
  }
  function Ep(n, e) {
    let t = yA[e];
    t === void 0 && ((t = new Int32Array(e)), (yA[e] = t));
    for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
    return t;
  }
  function n8(n, e) {
    let t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
  }
  function r8(n, e) {
    let t = this.cache;
    if (e.x !== void 0)
      (t[0] !== e.x || t[1] !== e.y) &&
        (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
    else {
      if (fn(t, e)) return;
      n.uniform2fv(this.addr, e), dn(t, e);
    }
  }
  function s8(n, e) {
    let t = this.cache;
    if (e.x !== void 0)
      (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
        (n.uniform3f(this.addr, e.x, e.y, e.z),
        (t[0] = e.x),
        (t[1] = e.y),
        (t[2] = e.z));
    else if (e.r !== void 0)
      (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
        (n.uniform3f(this.addr, e.r, e.g, e.b),
        (t[0] = e.r),
        (t[1] = e.g),
        (t[2] = e.b));
    else {
      if (fn(t, e)) return;
      n.uniform3fv(this.addr, e), dn(t, e);
    }
  }
  function a8(n, e) {
    let t = this.cache;
    if (e.x !== void 0)
      (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
        (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        (t[0] = e.x),
        (t[1] = e.y),
        (t[2] = e.z),
        (t[3] = e.w));
    else {
      if (fn(t, e)) return;
      n.uniform4fv(this.addr, e), dn(t, e);
    }
  }
  function o8(n, e) {
    let t = this.cache,
      i = e.elements;
    if (i === void 0) {
      if (fn(t, e)) return;
      n.uniformMatrix2fv(this.addr, !1, e), dn(t, e);
    } else {
      if (fn(t, i)) return;
      bA.set(i), n.uniformMatrix2fv(this.addr, !1, bA), dn(t, i);
    }
  }
  function l8(n, e) {
    let t = this.cache,
      i = e.elements;
    if (i === void 0) {
      if (fn(t, e)) return;
      n.uniformMatrix3fv(this.addr, !1, e), dn(t, e);
    } else {
      if (fn(t, i)) return;
      xA.set(i), n.uniformMatrix3fv(this.addr, !1, xA), dn(t, i);
    }
  }
  function c8(n, e) {
    let t = this.cache,
      i = e.elements;
    if (i === void 0) {
      if (fn(t, e)) return;
      n.uniformMatrix4fv(this.addr, !1, e), dn(t, e);
    } else {
      if (fn(t, i)) return;
      vA.set(i), n.uniformMatrix4fv(this.addr, !1, vA), dn(t, i);
    }
  }
  function u8(n, e) {
    let t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
  }
  function h8(n, e) {
    let t = this.cache;
    if (e.x !== void 0)
      (t[0] !== e.x || t[1] !== e.y) &&
        (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
    else {
      if (fn(t, e)) return;
      n.uniform2iv(this.addr, e), dn(t, e);
    }
  }
  function f8(n, e) {
    let t = this.cache;
    if (e.x !== void 0)
      (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
        (n.uniform3i(this.addr, e.x, e.y, e.z),
        (t[0] = e.x),
        (t[1] = e.y),
        (t[2] = e.z));
    else {
      if (fn(t, e)) return;
      n.uniform3iv(this.addr, e), dn(t, e);
    }
  }
  function d8(n, e) {
    let t = this.cache;
    if (e.x !== void 0)
      (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
        (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        (t[0] = e.x),
        (t[1] = e.y),
        (t[2] = e.z),
        (t[3] = e.w));
    else {
      if (fn(t, e)) return;
      n.uniform4iv(this.addr, e), dn(t, e);
    }
  }
  function p8(n, e) {
    let t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
  }
  function m8(n, e) {
    let t = this.cache;
    if (e.x !== void 0)
      (t[0] !== e.x || t[1] !== e.y) &&
        (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
    else {
      if (fn(t, e)) return;
      n.uniform2uiv(this.addr, e), dn(t, e);
    }
  }
  function g8(n, e) {
    let t = this.cache;
    if (e.x !== void 0)
      (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
        (n.uniform3ui(this.addr, e.x, e.y, e.z),
        (t[0] = e.x),
        (t[1] = e.y),
        (t[2] = e.z));
    else {
      if (fn(t, e)) return;
      n.uniform3uiv(this.addr, e), dn(t, e);
    }
  }
  function y8(n, e) {
    let t = this.cache;
    if (e.x !== void 0)
      (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
        (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        (t[0] = e.x),
        (t[1] = e.y),
        (t[2] = e.z),
        (t[3] = e.w));
    else {
      if (fn(t, e)) return;
      n.uniform4uiv(this.addr, e), dn(t, e);
    }
  }
  function v8(n, e, t) {
    let i = this.cache,
      r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
      t.setTexture2D(e || dC, r);
  }
  function x8(n, e, t) {
    let i = this.cache,
      r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
      t.setTexture3D(e || mC, r);
  }
  function b8(n, e, t) {
    let i = this.cache,
      r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
      t.setTextureCube(e || gC, r);
  }
  function _8(n, e, t) {
    let i = this.cache,
      r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
      t.setTexture2DArray(e || pC, r);
  }
  function E8(n) {
    switch (n) {
      case 5126:
        return n8;
      case 35664:
        return r8;
      case 35665:
        return s8;
      case 35666:
        return a8;
      case 35674:
        return o8;
      case 35675:
        return l8;
      case 35676:
        return c8;
      case 5124:
      case 35670:
        return u8;
      case 35667:
      case 35671:
        return h8;
      case 35668:
      case 35672:
        return f8;
      case 35669:
      case 35673:
        return d8;
      case 5125:
        return p8;
      case 36294:
        return m8;
      case 36295:
        return g8;
      case 36296:
        return y8;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return v8;
      case 35679:
      case 36299:
      case 36307:
        return x8;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return b8;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return _8;
    }
  }
  function T8(n, e) {
    n.uniform1fv(this.addr, e);
  }
  function S8(n, e) {
    let t = Fc(e, this.size, 2);
    n.uniform2fv(this.addr, t);
  }
  function w8(n, e) {
    let t = Fc(e, this.size, 3);
    n.uniform3fv(this.addr, t);
  }
  function M8(n, e) {
    let t = Fc(e, this.size, 4);
    n.uniform4fv(this.addr, t);
  }
  function A8(n, e) {
    let t = Fc(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t);
  }
  function C8(n, e) {
    let t = Fc(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t);
  }
  function P8(n, e) {
    let t = Fc(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t);
  }
  function D8(n, e) {
    n.uniform1iv(this.addr, e);
  }
  function I8(n, e) {
    n.uniform2iv(this.addr, e);
  }
  function L8(n, e) {
    n.uniform3iv(this.addr, e);
  }
  function R8(n, e) {
    n.uniform4iv(this.addr, e);
  }
  function O8(n, e) {
    n.uniform1uiv(this.addr, e);
  }
  function N8(n, e) {
    n.uniform2uiv(this.addr, e);
  }
  function k8(n, e) {
    n.uniform3uiv(this.addr, e);
  }
  function F8(n, e) {
    n.uniform4uiv(this.addr, e);
  }
  function B8(n, e, t) {
    let i = this.cache,
      r = e.length,
      s = Ep(t, r);
    fn(i, s) || (n.uniform1iv(this.addr, s), dn(i, s));
    for (let a = 0; a !== r; ++a) t.setTexture2D(e[a] || dC, s[a]);
  }
  function z8(n, e, t) {
    let i = this.cache,
      r = e.length,
      s = Ep(t, r);
    fn(i, s) || (n.uniform1iv(this.addr, s), dn(i, s));
    for (let a = 0; a !== r; ++a) t.setTexture3D(e[a] || mC, s[a]);
  }
  function U8(n, e, t) {
    let i = this.cache,
      r = e.length,
      s = Ep(t, r);
    fn(i, s) || (n.uniform1iv(this.addr, s), dn(i, s));
    for (let a = 0; a !== r; ++a) t.setTextureCube(e[a] || gC, s[a]);
  }
  function V8(n, e, t) {
    let i = this.cache,
      r = e.length,
      s = Ep(t, r);
    fn(i, s) || (n.uniform1iv(this.addr, s), dn(i, s));
    for (let a = 0; a !== r; ++a) t.setTexture2DArray(e[a] || pC, s[a]);
  }
  function G8(n) {
    switch (n) {
      case 5126:
        return T8;
      case 35664:
        return S8;
      case 35665:
        return w8;
      case 35666:
        return M8;
      case 35674:
        return A8;
      case 35675:
        return C8;
      case 35676:
        return P8;
      case 5124:
      case 35670:
        return D8;
      case 35667:
      case 35671:
        return I8;
      case 35668:
      case 35672:
        return L8;
      case 35669:
      case 35673:
        return R8;
      case 5125:
        return O8;
      case 36294:
        return N8;
      case 36295:
        return k8;
      case 36296:
        return F8;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return B8;
      case 35679:
      case 36299:
      case 36307:
        return z8;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return U8;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return V8;
    }
  }
  var yC = class {
      constructor(e, t, i) {
        (this.id = e),
          (this.addr = i),
          (this.cache = []),
          (this.setValue = E8(t.type));
      }
    },
    vC = class {
      constructor(e, t, i) {
        (this.id = e),
          (this.addr = i),
          (this.cache = []),
          (this.size = t.size),
          (this.setValue = G8(t.type));
      }
    },
    xC = class {
      constructor(e) {
        (this.id = e), (this.seq = []), (this.map = {});
      }
      setValue(e, t, i) {
        let r = this.seq;
        for (let s = 0, a = r.length; s !== a; ++s) {
          let o = r[s];
          o.setValue(e, t[o.id], i);
        }
      }
    },
    qv = /(\w+)(\])?(\[|\.)?/g;
  function _A(n, e) {
    n.seq.push(e), (n.map[e.id] = e);
  }
  function H8(n, e, t) {
    let i = n.name,
      r = i.length;
    for (qv.lastIndex = 0; ; ) {
      let s = qv.exec(i),
        a = qv.lastIndex,
        o = s[1],
        l = s[2] === "]",
        c = s[3];
      if ((l && (o = o | 0), c === void 0 || (c === "[" && a + 2 === r))) {
        _A(t, c === void 0 ? new yC(o, n, e) : new vC(o, n, e));
        break;
      } else {
        let f = t.map[o];
        f === void 0 && ((f = new xC(o)), _A(t, f)), (t = f);
      }
    }
  }
  var uh = class {
    constructor(e, t) {
      (this.seq = []), (this.map = {});
      let i = e.getProgramParameter(t, 35718);
      for (let r = 0; r < i; ++r) {
        let s = e.getActiveUniform(t, r),
          a = e.getUniformLocation(t, s.name);
        H8(s, a, this);
      }
    }
    setValue(e, t, i, r) {
      let s = this.map[t];
      s !== void 0 && s.setValue(e, i, r);
    }
    setOptional(e, t, i) {
      let r = t[i];
      r !== void 0 && this.setValue(e, i, r);
    }
    static upload(e, t, i, r) {
      for (let s = 0, a = t.length; s !== a; ++s) {
        let o = t[s],
          l = i[o.id];
        l.needsUpdate !== !1 && o.setValue(e, l.value, r);
      }
    }
    static seqWithValue(e, t) {
      let i = [];
      for (let r = 0, s = e.length; r !== s; ++r) {
        let a = e[r];
        a.id in t && i.push(a);
      }
      return i;
    }
  };
  function EA(n, e, t) {
    let i = n.createShader(e);
    return n.shaderSource(i, t), n.compileShader(i), i;
  }
  var $8 = 0;
  function W8(n, e) {
    let t = n.split(`
`),
      i = [],
      r = Math.max(e - 6, 0),
      s = Math.min(e + 6, t.length);
    for (let a = r; a < s; a++) {
      let o = a + 1;
      i.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
    }
    return i.join(`
`);
  }
  function q8(n) {
    switch (n) {
      case ol:
        return ["Linear", "( value )"];
      case oi:
        return ["sRGB", "( value )"];
      default:
        return (
          console.warn("THREE.WebGLProgram: Unsupported encoding:", n),
          ["Linear", "( value )"]
        );
    }
  }
  function TA(n, e, t) {
    let i = n.getShaderParameter(e, 35713),
      r = n.getShaderInfoLog(e).trim();
    if (i && r === "") return "";
    let s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
      let a = parseInt(s[1]);
      return (
        t.toUpperCase() +
        `

` +
        r +
        `

` +
        W8(n.getShaderSource(e), a)
      );
    } else return r;
  }
  function j8(n, e) {
    let t = q8(e);
    return (
      "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
    );
  }
  function X8(n, e) {
    let t;
    switch (e) {
      case nz:
        t = "Linear";
        break;
      case rz:
        t = "Reinhard";
        break;
      case sz:
        t = "OptimizedCineon";
        break;
      case az:
        t = "ACESFilmic";
        break;
      case oz:
        t = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
          (t = "Linear");
    }
    return (
      "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
    );
  }
  function Y8(n) {
    return [
      n.extensionDerivatives ||
      !!n.envMapCubeUVHeight ||
      n.bumpMap ||
      n.tangentSpaceNormalMap ||
      n.clearcoatNormalMap ||
      n.flatShading ||
      n.shaderID === "physical"
        ? "#extension GL_OES_standard_derivatives : enable"
        : "",
      (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
      n.rendererExtensionFragDepth
        ? "#extension GL_EXT_frag_depth : enable"
        : "",
      n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
        ? "#extension GL_EXT_draw_buffers : require"
        : "",
      (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
      n.rendererExtensionShaderTextureLod
        ? "#extension GL_EXT_shader_texture_lod : enable"
        : "",
    ].filter(ah).join(`
`);
  }
  function K8(n) {
    let e = [];
    for (let t in n) {
      let i = n[t];
      i !== !1 && e.push("#define " + t + " " + i);
    }
    return e.join(`
`);
  }
  function J8(n, e) {
    let t = {},
      i = n.getProgramParameter(e, 35721);
    for (let r = 0; r < i; r++) {
      let s = n.getActiveAttrib(e, r),
        a = s.name,
        o = 1;
      s.type === 35674 && (o = 2),
        s.type === 35675 && (o = 3),
        s.type === 35676 && (o = 4),
        (t[a] = {
          type: s.type,
          location: n.getAttribLocation(e, a),
          locationSize: o,
        });
    }
    return t;
  }
  function ah(n) {
    return n !== "";
  }
  function SA(n, e) {
    let t =
      e.numSpotLightShadows +
      e.numSpotLightMaps -
      e.numSpotLightShadowsWithMaps;
    return n
      .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
      .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
      .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
      .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
      .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
      .replace(
        /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
        e.numSpotLightShadowsWithMaps
      )
      .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
      .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
  }
  function wA(n, e) {
    return n
      .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
      .replace(
        /UNION_CLIPPING_PLANES/g,
        e.numClippingPlanes - e.numClipIntersection
      );
  }
  var Z8 = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function nx(n) {
    return n.replace(Z8, Q8);
  }
  function Q8(n, e) {
    let t = $t[e];
    if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
    return nx(t);
  }
  var eG =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function MA(n) {
    return n.replace(eG, tG);
  }
  function tG(n, e, t, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
      r += i
        .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
        .replace(/UNROLLED_LOOP_INDEX/g, s);
    return r;
  }
  function AA(n) {
    let e =
      "precision " +
      n.precision +
      ` float;
precision ` +
      n.precision +
      " int;";
    return (
      n.precision === "highp"
        ? (e += `
#define HIGH_PRECISION`)
        : n.precision === "mediump"
        ? (e += `
#define MEDIUM_PRECISION`)
        : n.precision === "lowp" &&
          (e += `
#define LOW_PRECISION`),
      e
    );
  }
  function iG(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return (
      n.shadowMapType === KA
        ? (e = "SHADOWMAP_TYPE_PCF")
        : n.shadowMapType === yh
        ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
        : n.shadowMapType === sh && (e = "SHADOWMAP_TYPE_VSM"),
      e
    );
  }
  function nG(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap)
      switch (n.envMapMode) {
        case Pc:
        case Dc:
          e = "ENVMAP_TYPE_CUBE";
          break;
        case vp:
          e = "ENVMAP_TYPE_CUBE_UV";
          break;
      }
    return e;
  }
  function rG(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap)
      switch (n.envMapMode) {
        case Dc:
          e = "ENVMAP_MODE_REFRACTION";
          break;
      }
    return e;
  }
  function sG(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap)
      switch (n.combine) {
        case QA:
          e = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case tz:
          e = "ENVMAP_BLENDING_MIX";
          break;
        case iz:
          e = "ENVMAP_BLENDING_ADD";
          break;
      }
    return e;
  }
  function aG(n) {
    let e = n.envMapCubeUVHeight;
    if (e === null) return null;
    let t = Math.log2(e) - 2,
      i = 1 / e;
    return {
      texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
      texelHeight: i,
      maxMip: t,
    };
  }
  function oG(n, e, t, i) {
    let r = n.getContext(),
      s = t.defines,
      a = t.vertexShader,
      o = t.fragmentShader,
      l = iG(t),
      c = nG(t),
      u = rG(t),
      f = sG(t),
      d = aG(t),
      m = t.isWebGL2 ? "" : Y8(t),
      x = K8(s),
      y = r.createProgram(),
      g,
      b,
      _ = t.glslVersion
        ? "#version " +
          t.glslVersion +
          `
`
        : "";
    t.isRawShaderMaterial
      ? ((g = [x].filter(ah).join(`
`)),
        g.length > 0 &&
          (g += `
`),
        (b = [m, x].filter(ah).join(`
`)),
        b.length > 0 &&
          (b += `
`))
      : ((g = [
          AA(t),
          "#define SHADER_NAME " + t.shaderName,
          x,
          t.instancing ? "#define USE_INSTANCING" : "",
          t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
          t.useFog && t.fog ? "#define USE_FOG" : "",
          t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
          t.map ? "#define USE_MAP" : "",
          t.envMap ? "#define USE_ENVMAP" : "",
          t.envMap ? "#define " + u : "",
          t.lightMap ? "#define USE_LIGHTMAP" : "",
          t.aoMap ? "#define USE_AOMAP" : "",
          t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          t.bumpMap ? "#define USE_BUMPMAP" : "",
          t.normalMap ? "#define USE_NORMALMAP" : "",
          t.normalMap && t.objectSpaceNormalMap
            ? "#define OBJECTSPACE_NORMALMAP"
            : "",
          t.normalMap && t.tangentSpaceNormalMap
            ? "#define TANGENTSPACE_NORMALMAP"
            : "",
          t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          t.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          t.displacementMap && t.supportsVertexTextures
            ? "#define USE_DISPLACEMENTMAP"
            : "",
          t.specularMap ? "#define USE_SPECULARMAP" : "",
          t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
          t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
          t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          t.metalnessMap ? "#define USE_METALNESSMAP" : "",
          t.alphaMap ? "#define USE_ALPHAMAP" : "",
          t.transmission ? "#define USE_TRANSMISSION" : "",
          t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
          t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
          t.vertexTangents ? "#define USE_TANGENT" : "",
          t.vertexColors ? "#define USE_COLOR" : "",
          t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          t.vertexUvs ? "#define USE_UV" : "",
          t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          t.flatShading ? "#define FLAT_SHADED" : "",
          t.skinning ? "#define USE_SKINNING" : "",
          t.morphTargets ? "#define USE_MORPHTARGETS" : "",
          t.morphNormals && t.flatShading === !1
            ? "#define USE_MORPHNORMALS"
            : "",
          t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
          t.morphTargetsCount > 0 && t.isWebGL2
            ? "#define MORPHTARGETS_TEXTURE"
            : "",
          t.morphTargetsCount > 0 && t.isWebGL2
            ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
            : "",
          t.morphTargetsCount > 0 && t.isWebGL2
            ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
            : "",
          t.doubleSided ? "#define DOUBLE_SIDED" : "",
          t.flipSided ? "#define FLIP_SIDED" : "",
          t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          t.shadowMapEnabled ? "#define " + l : "",
          t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "	attribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "	attribute vec3 instanceColor;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_TANGENT",
          "	attribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "	attribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "	attribute vec3 color;",
          "#endif",
          "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
          "	attribute vec3 morphTarget0;",
          "	attribute vec3 morphTarget1;",
          "	attribute vec3 morphTarget2;",
          "	attribute vec3 morphTarget3;",
          "	#ifdef USE_MORPHNORMALS",
          "		attribute vec3 morphNormal0;",
          "		attribute vec3 morphNormal1;",
          "		attribute vec3 morphNormal2;",
          "		attribute vec3 morphNormal3;",
          "	#else",
          "		attribute vec3 morphTarget4;",
          "		attribute vec3 morphTarget5;",
          "		attribute vec3 morphTarget6;",
          "		attribute vec3 morphTarget7;",
          "	#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "	attribute vec4 skinIndex;",
          "	attribute vec4 skinWeight;",
          "#endif",
          `
`,
        ].filter(ah).join(`
`)),
        (b = [
          m,
          AA(t),
          "#define SHADER_NAME " + t.shaderName,
          x,
          t.useFog && t.fog ? "#define USE_FOG" : "",
          t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
          t.map ? "#define USE_MAP" : "",
          t.matcap ? "#define USE_MATCAP" : "",
          t.envMap ? "#define USE_ENVMAP" : "",
          t.envMap ? "#define " + c : "",
          t.envMap ? "#define " + u : "",
          t.envMap ? "#define " + f : "",
          d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
          d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
          d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
          t.lightMap ? "#define USE_LIGHTMAP" : "",
          t.aoMap ? "#define USE_AOMAP" : "",
          t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          t.bumpMap ? "#define USE_BUMPMAP" : "",
          t.normalMap ? "#define USE_NORMALMAP" : "",
          t.normalMap && t.objectSpaceNormalMap
            ? "#define OBJECTSPACE_NORMALMAP"
            : "",
          t.normalMap && t.tangentSpaceNormalMap
            ? "#define TANGENTSPACE_NORMALMAP"
            : "",
          t.clearcoat ? "#define USE_CLEARCOAT" : "",
          t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          t.iridescence ? "#define USE_IRIDESCENCE" : "",
          t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          t.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          t.specularMap ? "#define USE_SPECULARMAP" : "",
          t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
          t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
          t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          t.metalnessMap ? "#define USE_METALNESSMAP" : "",
          t.alphaMap ? "#define USE_ALPHAMAP" : "",
          t.alphaTest ? "#define USE_ALPHATEST" : "",
          t.sheen ? "#define USE_SHEEN" : "",
          t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
          t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
          t.transmission ? "#define USE_TRANSMISSION" : "",
          t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
          t.vertexTangents ? "#define USE_TANGENT" : "",
          t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
          t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          t.vertexUvs ? "#define USE_UV" : "",
          t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          t.gradientMap ? "#define USE_GRADIENTMAP" : "",
          t.flatShading ? "#define FLAT_SHADED" : "",
          t.doubleSided ? "#define DOUBLE_SIDED" : "",
          t.flipSided ? "#define FLIP_SIDED" : "",
          t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          t.shadowMapEnabled ? "#define " + l : "",
          t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
          t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          t.toneMapping !== sa ? "#define TONE_MAPPING" : "",
          t.toneMapping !== sa ? $t.tonemapping_pars_fragment : "",
          t.toneMapping !== sa ? X8("toneMapping", t.toneMapping) : "",
          t.dithering ? "#define DITHERING" : "",
          t.opaque ? "#define OPAQUE" : "",
          $t.encodings_pars_fragment,
          j8("linearToOutputTexel", t.outputEncoding),
          t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
          `
`,
        ].filter(ah).join(`
`))),
      (a = nx(a)),
      (a = SA(a, t)),
      (a = wA(a, t)),
      (o = nx(o)),
      (o = SA(o, t)),
      (o = wA(o, t)),
      (a = MA(a)),
      (o = MA(o)),
      t.isWebGL2 &&
        t.isRawShaderMaterial !== !0 &&
        ((_ = `#version 300 es
`),
        (g =
          [
            "precision mediump sampler2DArray;",
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture",
          ].join(`
`) +
          `
` +
          g),
        (b =
          [
            "#define varying in",
            t.glslVersion === ZM
              ? ""
              : "layout(location = 0) out highp vec4 pc_fragColor;",
            t.glslVersion === ZM ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad",
          ].join(`
`) +
          `
` +
          b));
    let E = _ + g + a,
      w = _ + b + o,
      P = EA(r, 35633, E),
      L = EA(r, 35632, w);
    if (
      (r.attachShader(y, P),
      r.attachShader(y, L),
      t.index0AttributeName !== void 0
        ? r.bindAttribLocation(y, 0, t.index0AttributeName)
        : t.morphTargets === !0 && r.bindAttribLocation(y, 0, "position"),
      r.linkProgram(y),
      n.debug.checkShaderErrors)
    ) {
      let R = r.getProgramInfoLog(y).trim(),
        O = r.getShaderInfoLog(P).trim(),
        U = r.getShaderInfoLog(L).trim(),
        X = !0,
        $ = !0;
      if (r.getProgramParameter(y, 35714) === !1) {
        X = !1;
        let W = TA(r, P, "vertex"),
          ue = TA(r, L, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            r.getError() +
            " - VALIDATE_STATUS " +
            r.getProgramParameter(y, 35715) +
            `

Program Info Log: ` +
            R +
            `
` +
            W +
            `
` +
            ue
        );
      } else
        R !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", R)
          : (O === "" || U === "") && ($ = !1);
      $ &&
        (this.diagnostics = {
          runnable: X,
          programLog: R,
          vertexShader: { log: O, prefix: g },
          fragmentShader: { log: U, prefix: b },
        });
    }
    r.deleteShader(P), r.deleteShader(L);
    let I;
    this.getUniforms = function () {
      return I === void 0 && (I = new uh(r, y)), I;
    };
    let M;
    return (
      (this.getAttributes = function () {
        return M === void 0 && (M = J8(r, y)), M;
      }),
      (this.destroy = function () {
        i.releaseStatesOfProgram(this),
          r.deleteProgram(y),
          (this.program = void 0);
      }),
      (this.name = t.shaderName),
      (this.id = $8++),
      (this.cacheKey = e),
      (this.usedTimes = 1),
      (this.program = y),
      (this.vertexShader = P),
      (this.fragmentShader = L),
      this
    );
  }
  var lG = 0,
    bC = class {
      constructor() {
        (this.shaderCache = new Map()), (this.materialCache = new Map());
      }
      update(e) {
        let t = e.vertexShader,
          i = e.fragmentShader,
          r = this._getShaderStage(t),
          s = this._getShaderStage(i),
          a = this._getShaderCacheForMaterial(e);
        return (
          a.has(r) === !1 && (a.add(r), r.usedTimes++),
          a.has(s) === !1 && (a.add(s), s.usedTimes++),
          this
        );
      }
      remove(e) {
        let t = this.materialCache.get(e);
        for (let i of t)
          i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e), this;
      }
      getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id;
      }
      getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id;
      }
      dispose() {
        this.shaderCache.clear(), this.materialCache.clear();
      }
      _getShaderCacheForMaterial(e) {
        let t = this.materialCache,
          i = t.get(e);
        return i === void 0 && ((i = new Set()), t.set(e, i)), i;
      }
      _getShaderStage(e) {
        let t = this.shaderCache,
          i = t.get(e);
        return i === void 0 && ((i = new _C(e)), t.set(e, i)), i;
      }
    },
    _C = class {
      constructor(e) {
        (this.id = lG++), (this.code = e), (this.usedTimes = 0);
      }
    };
  function cG(n, e, t, i, r, s, a) {
    let o = new px(),
      l = new bC(),
      c = [],
      u = r.isWebGL2,
      f = r.logarithmicDepthBuffer,
      d = r.vertexTextures,
      m = r.precision,
      x = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite",
      };
    function y(M, R, O, U, X) {
      let $ = U.fog,
        W = X.geometry,
        ue = M.isMeshStandardMaterial ? U.environment : null,
        ae = (M.isMeshStandardMaterial ? t : e).get(M.envMap || ue),
        he = !!ae && ae.mapping === vp ? ae.image.height : null,
        ce = x[M.type];
      M.precision !== null &&
        ((m = r.getMaxPrecision(M.precision)),
        m !== M.precision &&
          console.warn(
            "THREE.WebGLProgram.getParameters:",
            M.precision,
            "not supported, using",
            m,
            "instead."
          ));
      let te =
          W.morphAttributes.position ||
          W.morphAttributes.normal ||
          W.morphAttributes.color,
        Me = te !== void 0 ? te.length : 0,
        ge = 0;
      W.morphAttributes.position !== void 0 && (ge = 1),
        W.morphAttributes.normal !== void 0 && (ge = 2),
        W.morphAttributes.color !== void 0 && (ge = 3);
      let pe, We, Fe, Be;
      if (ce) {
        let kt = Cs[ce];
        (pe = kt.vertexShader), (We = kt.fragmentShader);
      } else
        (pe = M.vertexShader),
          (We = M.fragmentShader),
          l.update(M),
          (Fe = l.getVertexShaderID(M)),
          (Be = l.getFragmentShaderID(M));
      let be = n.getRenderTarget(),
        ut = M.alphaTest > 0,
        Ye = M.clearcoat > 0,
        _t = M.iridescence > 0;
      return {
        isWebGL2: u,
        shaderID: ce,
        shaderName: M.type,
        vertexShader: pe,
        fragmentShader: We,
        defines: M.defines,
        customVertexShaderID: Fe,
        customFragmentShaderID: Be,
        isRawShaderMaterial: M.isRawShaderMaterial === !0,
        glslVersion: M.glslVersion,
        precision: m,
        instancing: X.isInstancedMesh === !0,
        instancingColor: X.isInstancedMesh === !0 && X.instanceColor !== null,
        supportsVertexTextures: d,
        outputEncoding:
          be === null
            ? n.outputEncoding
            : be.isXRRenderTarget === !0
            ? be.texture.encoding
            : ol,
        map: !!M.map,
        matcap: !!M.matcap,
        envMap: !!ae,
        envMapMode: ae && ae.mapping,
        envMapCubeUVHeight: he,
        lightMap: !!M.lightMap,
        aoMap: !!M.aoMap,
        emissiveMap: !!M.emissiveMap,
        bumpMap: !!M.bumpMap,
        normalMap: !!M.normalMap,
        objectSpaceNormalMap: M.normalMapType === Pz,
        tangentSpaceNormalMap: M.normalMapType === nC,
        decodeVideoTexture:
          !!M.map && M.map.isVideoTexture === !0 && M.map.encoding === oi,
        clearcoat: Ye,
        clearcoatMap: Ye && !!M.clearcoatMap,
        clearcoatRoughnessMap: Ye && !!M.clearcoatRoughnessMap,
        clearcoatNormalMap: Ye && !!M.clearcoatNormalMap,
        iridescence: _t,
        iridescenceMap: _t && !!M.iridescenceMap,
        iridescenceThicknessMap: _t && !!M.iridescenceThicknessMap,
        displacementMap: !!M.displacementMap,
        roughnessMap: !!M.roughnessMap,
        metalnessMap: !!M.metalnessMap,
        specularMap: !!M.specularMap,
        specularIntensityMap: !!M.specularIntensityMap,
        specularColorMap: !!M.specularColorMap,
        opaque: M.transparent === !1 && M.blending === Ac,
        alphaMap: !!M.alphaMap,
        alphaTest: ut,
        gradientMap: !!M.gradientMap,
        sheen: M.sheen > 0,
        sheenColorMap: !!M.sheenColorMap,
        sheenRoughnessMap: !!M.sheenRoughnessMap,
        transmission: M.transmission > 0,
        transmissionMap: !!M.transmissionMap,
        thicknessMap: !!M.thicknessMap,
        combine: M.combine,
        vertexTangents: !!M.normalMap && !!W.attributes.tangent,
        vertexColors: M.vertexColors,
        vertexAlphas:
          M.vertexColors === !0 &&
          !!W.attributes.color &&
          W.attributes.color.itemSize === 4,
        vertexUvs:
          !!M.map ||
          !!M.bumpMap ||
          !!M.normalMap ||
          !!M.specularMap ||
          !!M.alphaMap ||
          !!M.emissiveMap ||
          !!M.roughnessMap ||
          !!M.metalnessMap ||
          !!M.clearcoatMap ||
          !!M.clearcoatRoughnessMap ||
          !!M.clearcoatNormalMap ||
          !!M.iridescenceMap ||
          !!M.iridescenceThicknessMap ||
          !!M.displacementMap ||
          !!M.transmissionMap ||
          !!M.thicknessMap ||
          !!M.specularIntensityMap ||
          !!M.specularColorMap ||
          !!M.sheenColorMap ||
          !!M.sheenRoughnessMap,
        uvsVertexOnly:
          !(
            !!M.map ||
            !!M.bumpMap ||
            !!M.normalMap ||
            !!M.specularMap ||
            !!M.alphaMap ||
            !!M.emissiveMap ||
            !!M.roughnessMap ||
            !!M.metalnessMap ||
            !!M.clearcoatNormalMap ||
            !!M.iridescenceMap ||
            !!M.iridescenceThicknessMap ||
            M.transmission > 0 ||
            !!M.transmissionMap ||
            !!M.thicknessMap ||
            !!M.specularIntensityMap ||
            !!M.specularColorMap ||
            M.sheen > 0 ||
            !!M.sheenColorMap ||
            !!M.sheenRoughnessMap
          ) && !!M.displacementMap,
        fog: !!$,
        useFog: M.fog === !0,
        fogExp2: $ && $.isFogExp2,
        flatShading: !!M.flatShading,
        sizeAttenuation: M.sizeAttenuation,
        logarithmicDepthBuffer: f,
        skinning: X.isSkinnedMesh === !0,
        morphTargets: W.morphAttributes.position !== void 0,
        morphNormals: W.morphAttributes.normal !== void 0,
        morphColors: W.morphAttributes.color !== void 0,
        morphTargetsCount: Me,
        morphTextureStride: ge,
        numDirLights: R.directional.length,
        numPointLights: R.point.length,
        numSpotLights: R.spot.length,
        numSpotLightMaps: R.spotLightMap.length,
        numRectAreaLights: R.rectArea.length,
        numHemiLights: R.hemi.length,
        numDirLightShadows: R.directionalShadowMap.length,
        numPointLightShadows: R.pointShadowMap.length,
        numSpotLightShadows: R.spotShadowMap.length,
        numSpotLightShadowsWithMaps: R.numSpotLightShadowsWithMaps,
        numClippingPlanes: a.numPlanes,
        numClipIntersection: a.numIntersection,
        dithering: M.dithering,
        shadowMapEnabled: n.shadowMap.enabled && O.length > 0,
        shadowMapType: n.shadowMap.type,
        toneMapping: M.toneMapped ? n.toneMapping : sa,
        physicallyCorrectLights: n.physicallyCorrectLights,
        premultipliedAlpha: M.premultipliedAlpha,
        doubleSided: M.side === vh,
        flipSided: M.side === qr,
        useDepthPacking: !!M.depthPacking,
        depthPacking: M.depthPacking || 0,
        index0AttributeName: M.index0AttributeName,
        extensionDerivatives: M.extensions && M.extensions.derivatives,
        extensionFragDepth: M.extensions && M.extensions.fragDepth,
        extensionDrawBuffers: M.extensions && M.extensions.drawBuffers,
        extensionShaderTextureLOD:
          M.extensions && M.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
        customProgramCacheKey: M.customProgramCacheKey(),
      };
    }
    function g(M) {
      let R = [];
      if (
        (M.shaderID
          ? R.push(M.shaderID)
          : (R.push(M.customVertexShaderID), R.push(M.customFragmentShaderID)),
        M.defines !== void 0)
      )
        for (let O in M.defines) R.push(O), R.push(M.defines[O]);
      return (
        M.isRawShaderMaterial === !1 &&
          (b(R, M), _(R, M), R.push(n.outputEncoding)),
        R.push(M.customProgramCacheKey),
        R.join()
      );
    }
    function b(M, R) {
      M.push(R.precision),
        M.push(R.outputEncoding),
        M.push(R.envMapMode),
        M.push(R.envMapCubeUVHeight),
        M.push(R.combine),
        M.push(R.vertexUvs),
        M.push(R.fogExp2),
        M.push(R.sizeAttenuation),
        M.push(R.morphTargetsCount),
        M.push(R.morphAttributeCount),
        M.push(R.numDirLights),
        M.push(R.numPointLights),
        M.push(R.numSpotLights),
        M.push(R.numSpotLightMaps),
        M.push(R.numHemiLights),
        M.push(R.numRectAreaLights),
        M.push(R.numDirLightShadows),
        M.push(R.numPointLightShadows),
        M.push(R.numSpotLightShadows),
        M.push(R.numSpotLightShadowsWithMaps),
        M.push(R.shadowMapType),
        M.push(R.toneMapping),
        M.push(R.numClippingPlanes),
        M.push(R.numClipIntersection),
        M.push(R.depthPacking);
    }
    function _(M, R) {
      o.disableAll(),
        R.isWebGL2 && o.enable(0),
        R.supportsVertexTextures && o.enable(1),
        R.instancing && o.enable(2),
        R.instancingColor && o.enable(3),
        R.map && o.enable(4),
        R.matcap && o.enable(5),
        R.envMap && o.enable(6),
        R.lightMap && o.enable(7),
        R.aoMap && o.enable(8),
        R.emissiveMap && o.enable(9),
        R.bumpMap && o.enable(10),
        R.normalMap && o.enable(11),
        R.objectSpaceNormalMap && o.enable(12),
        R.tangentSpaceNormalMap && o.enable(13),
        R.clearcoat && o.enable(14),
        R.clearcoatMap && o.enable(15),
        R.clearcoatRoughnessMap && o.enable(16),
        R.clearcoatNormalMap && o.enable(17),
        R.iridescence && o.enable(18),
        R.iridescenceMap && o.enable(19),
        R.iridescenceThicknessMap && o.enable(20),
        R.displacementMap && o.enable(21),
        R.specularMap && o.enable(22),
        R.roughnessMap && o.enable(23),
        R.metalnessMap && o.enable(24),
        R.gradientMap && o.enable(25),
        R.alphaMap && o.enable(26),
        R.alphaTest && o.enable(27),
        R.vertexColors && o.enable(28),
        R.vertexAlphas && o.enable(29),
        R.vertexUvs && o.enable(30),
        R.vertexTangents && o.enable(31),
        R.uvsVertexOnly && o.enable(32),
        M.push(o.mask),
        o.disableAll(),
        R.fog && o.enable(0),
        R.useFog && o.enable(1),
        R.flatShading && o.enable(2),
        R.logarithmicDepthBuffer && o.enable(3),
        R.skinning && o.enable(4),
        R.morphTargets && o.enable(5),
        R.morphNormals && o.enable(6),
        R.morphColors && o.enable(7),
        R.premultipliedAlpha && o.enable(8),
        R.shadowMapEnabled && o.enable(9),
        R.physicallyCorrectLights && o.enable(10),
        R.doubleSided && o.enable(11),
        R.flipSided && o.enable(12),
        R.useDepthPacking && o.enable(13),
        R.dithering && o.enable(14),
        R.specularIntensityMap && o.enable(15),
        R.specularColorMap && o.enable(16),
        R.transmission && o.enable(17),
        R.transmissionMap && o.enable(18),
        R.thicknessMap && o.enable(19),
        R.sheen && o.enable(20),
        R.sheenColorMap && o.enable(21),
        R.sheenRoughnessMap && o.enable(22),
        R.decodeVideoTexture && o.enable(23),
        R.opaque && o.enable(24),
        M.push(o.mask);
    }
    function E(M) {
      let R = x[M.type],
        O;
      if (R) {
        let U = Cs[R];
        O = iU.clone(U.uniforms);
      } else O = M.uniforms;
      return O;
    }
    function w(M, R) {
      let O;
      for (let U = 0, X = c.length; U < X; U++) {
        let $ = c[U];
        if ($.cacheKey === R) {
          (O = $), ++O.usedTimes;
          break;
        }
      }
      return O === void 0 && ((O = new oG(n, R, M, s)), c.push(O)), O;
    }
    function P(M) {
      if (--M.usedTimes === 0) {
        let R = c.indexOf(M);
        (c[R] = c[c.length - 1]), c.pop(), M.destroy();
      }
    }
    function L(M) {
      l.remove(M);
    }
    function I() {
      l.dispose();
    }
    return {
      getParameters: y,
      getProgramCacheKey: g,
      getUniforms: E,
      acquireProgram: w,
      releaseProgram: P,
      releaseShaderCache: L,
      programs: c,
      dispose: I,
    };
  }
  function uG() {
    let n = new WeakMap();
    function e(s) {
      let a = n.get(s);
      return a === void 0 && ((a = {}), n.set(s, a)), a;
    }
    function t(s) {
      n.delete(s);
    }
    function i(s, a, o) {
      n.get(s)[a] = o;
    }
    function r() {
      n = new WeakMap();
    }
    return { get: e, remove: t, update: i, dispose: r };
  }
  function hG(n, e) {
    return n.groupOrder !== e.groupOrder
      ? n.groupOrder - e.groupOrder
      : n.renderOrder !== e.renderOrder
      ? n.renderOrder - e.renderOrder
      : n.material.id !== e.material.id
      ? n.material.id - e.material.id
      : n.z !== e.z
      ? n.z - e.z
      : n.id - e.id;
  }
  function CA(n, e) {
    return n.groupOrder !== e.groupOrder
      ? n.groupOrder - e.groupOrder
      : n.renderOrder !== e.renderOrder
      ? n.renderOrder - e.renderOrder
      : n.z !== e.z
      ? e.z - n.z
      : n.id - e.id;
  }
  function PA() {
    let n = [],
      e = 0,
      t = [],
      i = [],
      r = [];
    function s() {
      (e = 0), (t.length = 0), (i.length = 0), (r.length = 0);
    }
    function a(f, d, m, x, y, g) {
      let b = n[e];
      return (
        b === void 0
          ? ((b = {
              id: f.id,
              object: f,
              geometry: d,
              material: m,
              groupOrder: x,
              renderOrder: f.renderOrder,
              z: y,
              group: g,
            }),
            (n[e] = b))
          : ((b.id = f.id),
            (b.object = f),
            (b.geometry = d),
            (b.material = m),
            (b.groupOrder = x),
            (b.renderOrder = f.renderOrder),
            (b.z = y),
            (b.group = g)),
        e++,
        b
      );
    }
    function o(f, d, m, x, y, g) {
      let b = a(f, d, m, x, y, g);
      m.transmission > 0
        ? i.push(b)
        : m.transparent === !0
        ? r.push(b)
        : t.push(b);
    }
    function l(f, d, m, x, y, g) {
      let b = a(f, d, m, x, y, g);
      m.transmission > 0
        ? i.unshift(b)
        : m.transparent === !0
        ? r.unshift(b)
        : t.unshift(b);
    }
    function c(f, d) {
      t.length > 1 && t.sort(f || hG),
        i.length > 1 && i.sort(d || CA),
        r.length > 1 && r.sort(d || CA);
    }
    function u() {
      for (let f = e, d = n.length; f < d; f++) {
        let m = n[f];
        if (m.id === null) break;
        (m.id = null),
          (m.object = null),
          (m.geometry = null),
          (m.material = null),
          (m.group = null);
      }
    }
    return {
      opaque: t,
      transmissive: i,
      transparent: r,
      init: s,
      push: o,
      unshift: l,
      finish: u,
      sort: c,
    };
  }
  function fG() {
    let n = new WeakMap();
    function e(i, r) {
      let s = n.get(i),
        a;
      return (
        s === void 0
          ? ((a = new PA()), n.set(i, [a]))
          : r >= s.length
          ? ((a = new PA()), s.push(a))
          : (a = s[r]),
        a
      );
    }
    function t() {
      n = new WeakMap();
    }
    return { get: e, dispose: t };
  }
  function dG() {
    let n = {};
    return {
      get: function (e) {
        if (n[e.id] !== void 0) return n[e.id];
        let t;
        switch (e.type) {
          case "DirectionalLight":
            t = { direction: new le(), color: new Bt() };
            break;
          case "SpotLight":
            t = {
              position: new le(),
              direction: new le(),
              color: new Bt(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
            };
            break;
          case "PointLight":
            t = { position: new le(), color: new Bt(), distance: 0, decay: 0 };
            break;
          case "HemisphereLight":
            t = {
              direction: new le(),
              skyColor: new Bt(),
              groundColor: new Bt(),
            };
            break;
          case "RectAreaLight":
            t = {
              color: new Bt(),
              position: new le(),
              halfWidth: new le(),
              halfHeight: new le(),
            };
            break;
        }
        return (n[e.id] = t), t;
      },
    };
  }
  function pG() {
    let n = {};
    return {
      get: function (e) {
        if (n[e.id] !== void 0) return n[e.id];
        let t;
        switch (e.type) {
          case "DirectionalLight":
            t = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new It(),
            };
            break;
          case "SpotLight":
            t = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new It(),
            };
            break;
          case "PointLight":
            t = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new It(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3,
            };
            break;
        }
        return (n[e.id] = t), t;
      },
    };
  }
  var mG = 0;
  function gG(n, e) {
    return (
      (e.castShadow ? 2 : 0) -
      (n.castShadow ? 2 : 0) +
      (e.map ? 1 : 0) -
      (n.map ? 1 : 0)
    );
  }
  function yG(n, e) {
    let t = new dG(),
      i = pG(),
      r = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1,
          numSpotMaps: -1,
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
      };
    for (let u = 0; u < 9; u++) r.probe.push(new le());
    let s = new le(),
      a = new Wt(),
      o = new Wt();
    function l(u, f) {
      let d = 0,
        m = 0,
        x = 0;
      for (let U = 0; U < 9; U++) r.probe[U].set(0, 0, 0);
      let y = 0,
        g = 0,
        b = 0,
        _ = 0,
        E = 0,
        w = 0,
        P = 0,
        L = 0,
        I = 0,
        M = 0;
      u.sort(gG);
      let R = f !== !0 ? Math.PI : 1;
      for (let U = 0, X = u.length; U < X; U++) {
        let $ = u[U],
          W = $.color,
          ue = $.intensity,
          ae = $.distance,
          he = $.shadow && $.shadow.map ? $.shadow.map.texture : null;
        if ($.isAmbientLight)
          (d += W.r * ue * R), (m += W.g * ue * R), (x += W.b * ue * R);
        else if ($.isLightProbe)
          for (let ce = 0; ce < 9; ce++)
            r.probe[ce].addScaledVector($.sh.coefficients[ce], ue);
        else if ($.isDirectionalLight) {
          let ce = t.get($);
          if (
            (ce.color.copy($.color).multiplyScalar($.intensity * R),
            $.castShadow)
          ) {
            let te = $.shadow,
              Me = i.get($);
            (Me.shadowBias = te.bias),
              (Me.shadowNormalBias = te.normalBias),
              (Me.shadowRadius = te.radius),
              (Me.shadowMapSize = te.mapSize),
              (r.directionalShadow[y] = Me),
              (r.directionalShadowMap[y] = he),
              (r.directionalShadowMatrix[y] = $.shadow.matrix),
              w++;
          }
          (r.directional[y] = ce), y++;
        } else if ($.isSpotLight) {
          let ce = t.get($);
          ce.position.setFromMatrixPosition($.matrixWorld),
            ce.color.copy(W).multiplyScalar(ue * R),
            (ce.distance = ae),
            (ce.coneCos = Math.cos($.angle)),
            (ce.penumbraCos = Math.cos($.angle * (1 - $.penumbra))),
            (ce.decay = $.decay),
            (r.spot[b] = ce);
          let te = $.shadow;
          if (
            ($.map &&
              ((r.spotLightMap[I] = $.map),
              I++,
              te.updateMatrices($),
              $.castShadow && M++),
            (r.spotLightMatrix[b] = te.matrix),
            $.castShadow)
          ) {
            let Me = i.get($);
            (Me.shadowBias = te.bias),
              (Me.shadowNormalBias = te.normalBias),
              (Me.shadowRadius = te.radius),
              (Me.shadowMapSize = te.mapSize),
              (r.spotShadow[b] = Me),
              (r.spotShadowMap[b] = he),
              L++;
          }
          b++;
        } else if ($.isRectAreaLight) {
          let ce = t.get($);
          ce.color.copy(W).multiplyScalar(ue),
            ce.halfWidth.set($.width * 0.5, 0, 0),
            ce.halfHeight.set(0, $.height * 0.5, 0),
            (r.rectArea[_] = ce),
            _++;
        } else if ($.isPointLight) {
          let ce = t.get($);
          if (
            (ce.color.copy($.color).multiplyScalar($.intensity * R),
            (ce.distance = $.distance),
            (ce.decay = $.decay),
            $.castShadow)
          ) {
            let te = $.shadow,
              Me = i.get($);
            (Me.shadowBias = te.bias),
              (Me.shadowNormalBias = te.normalBias),
              (Me.shadowRadius = te.radius),
              (Me.shadowMapSize = te.mapSize),
              (Me.shadowCameraNear = te.camera.near),
              (Me.shadowCameraFar = te.camera.far),
              (r.pointShadow[g] = Me),
              (r.pointShadowMap[g] = he),
              (r.pointShadowMatrix[g] = $.shadow.matrix),
              P++;
          }
          (r.point[g] = ce), g++;
        } else if ($.isHemisphereLight) {
          let ce = t.get($);
          ce.skyColor.copy($.color).multiplyScalar(ue * R),
            ce.groundColor.copy($.groundColor).multiplyScalar(ue * R),
            (r.hemi[E] = ce),
            E++;
        }
      }
      _ > 0 &&
        (e.isWebGL2 || n.has("OES_texture_float_linear") === !0
          ? ((r.rectAreaLTC1 = Je.LTC_FLOAT_1),
            (r.rectAreaLTC2 = Je.LTC_FLOAT_2))
          : n.has("OES_texture_half_float_linear") === !0
          ? ((r.rectAreaLTC1 = Je.LTC_HALF_1), (r.rectAreaLTC2 = Je.LTC_HALF_2))
          : console.error(
              "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
            )),
        (r.ambient[0] = d),
        (r.ambient[1] = m),
        (r.ambient[2] = x);
      let O = r.hash;
      (O.directionalLength !== y ||
        O.pointLength !== g ||
        O.spotLength !== b ||
        O.rectAreaLength !== _ ||
        O.hemiLength !== E ||
        O.numDirectionalShadows !== w ||
        O.numPointShadows !== P ||
        O.numSpotShadows !== L ||
        O.numSpotMaps !== I) &&
        ((r.directional.length = y),
        (r.spot.length = b),
        (r.rectArea.length = _),
        (r.point.length = g),
        (r.hemi.length = E),
        (r.directionalShadow.length = w),
        (r.directionalShadowMap.length = w),
        (r.pointShadow.length = P),
        (r.pointShadowMap.length = P),
        (r.spotShadow.length = L),
        (r.spotShadowMap.length = L),
        (r.directionalShadowMatrix.length = w),
        (r.pointShadowMatrix.length = P),
        (r.spotLightMatrix.length = L + I - M),
        (r.spotLightMap.length = I),
        (r.numSpotLightShadowsWithMaps = M),
        (O.directionalLength = y),
        (O.pointLength = g),
        (O.spotLength = b),
        (O.rectAreaLength = _),
        (O.hemiLength = E),
        (O.numDirectionalShadows = w),
        (O.numPointShadows = P),
        (O.numSpotShadows = L),
        (O.numSpotMaps = I),
        (r.version = mG++));
    }
    function c(u, f) {
      let d = 0,
        m = 0,
        x = 0,
        y = 0,
        g = 0,
        b = f.matrixWorldInverse;
      for (let _ = 0, E = u.length; _ < E; _++) {
        let w = u[_];
        if (w.isDirectionalLight) {
          let P = r.directional[d];
          P.direction.setFromMatrixPosition(w.matrixWorld),
            s.setFromMatrixPosition(w.target.matrixWorld),
            P.direction.sub(s),
            P.direction.transformDirection(b),
            d++;
        } else if (w.isSpotLight) {
          let P = r.spot[x];
          P.position.setFromMatrixPosition(w.matrixWorld),
            P.position.applyMatrix4(b),
            P.direction.setFromMatrixPosition(w.matrixWorld),
            s.setFromMatrixPosition(w.target.matrixWorld),
            P.direction.sub(s),
            P.direction.transformDirection(b),
            x++;
        } else if (w.isRectAreaLight) {
          let P = r.rectArea[y];
          P.position.setFromMatrixPosition(w.matrixWorld),
            P.position.applyMatrix4(b),
            o.identity(),
            a.copy(w.matrixWorld),
            a.premultiply(b),
            o.extractRotation(a),
            P.halfWidth.set(w.width * 0.5, 0, 0),
            P.halfHeight.set(0, w.height * 0.5, 0),
            P.halfWidth.applyMatrix4(o),
            P.halfHeight.applyMatrix4(o),
            y++;
        } else if (w.isPointLight) {
          let P = r.point[m];
          P.position.setFromMatrixPosition(w.matrixWorld),
            P.position.applyMatrix4(b),
            m++;
        } else if (w.isHemisphereLight) {
          let P = r.hemi[g];
          P.direction.setFromMatrixPosition(w.matrixWorld),
            P.direction.transformDirection(b),
            g++;
        }
      }
    }
    return { setup: l, setupView: c, state: r };
  }
  function DA(n, e) {
    let t = new yG(n, e),
      i = [],
      r = [];
    function s() {
      (i.length = 0), (r.length = 0);
    }
    function a(f) {
      i.push(f);
    }
    function o(f) {
      r.push(f);
    }
    function l(f) {
      t.setup(i, f);
    }
    function c(f) {
      t.setupView(i, f);
    }
    return {
      init: s,
      state: { lightsArray: i, shadowsArray: r, lights: t },
      setupLights: l,
      setupLightsView: c,
      pushLight: a,
      pushShadow: o,
    };
  }
  function vG(n, e) {
    let t = new WeakMap();
    function i(s, a = 0) {
      let o = t.get(s),
        l;
      return (
        o === void 0
          ? ((l = new DA(n, e)), t.set(s, [l]))
          : a >= o.length
          ? ((l = new DA(n, e)), o.push(l))
          : (l = o[a]),
        l
      );
    }
    function r() {
      t = new WeakMap();
    }
    return { get: i, dispose: r };
  }
  var EC = class extends Xr {
      constructor(e) {
        super();
        (this.isMeshDepthMaterial = !0),
          (this.type = "MeshDepthMaterial"),
          (this.depthPacking = Az),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.depthPacking = e.depthPacking),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          this
        );
      }
    },
    TC = class extends Xr {
      constructor(e) {
        super();
        (this.isMeshDistanceMaterial = !0),
          (this.type = "MeshDistanceMaterial"),
          (this.referencePosition = new le()),
          (this.nearDistance = 1),
          (this.farDistance = 1e3),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.referencePosition.copy(e.referencePosition),
          (this.nearDistance = e.nearDistance),
          (this.farDistance = e.farDistance),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          this
        );
      }
    },
    xG = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
    bG = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
  function _G(n, e, t) {
    let i = new bp(),
      r = new It(),
      s = new It(),
      a = new Ti(),
      o = new EC({ depthPacking: Cz }),
      l = new TC(),
      c = {},
      u = t.maxTextureSize,
      f = { 0: qr, 1: aa, 2: vh },
      d = new io({
        defines: { VSM_SAMPLES: 8 },
        uniforms: {
          shadow_pass: { value: null },
          resolution: { value: new It() },
          radius: { value: 4 },
        },
        vertexShader: xG,
        fragmentShader: bG,
      }),
      m = d.clone();
    m.defines.HORIZONTAL_PASS = 1;
    let x = new qn();
    x.setAttribute(
      "position",
      new en(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
    );
    let y = new ar(x, d),
      g = this;
    (this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = KA),
      (this.render = function (w, P, L) {
        if (
          g.enabled === !1 ||
          (g.autoUpdate === !1 && g.needsUpdate === !1) ||
          w.length === 0
        )
          return;
        let I = n.getRenderTarget(),
          M = n.getActiveCubeFace(),
          R = n.getActiveMipmapLevel(),
          O = n.state;
        O.setBlending(Qa),
          O.buffers.color.setClear(1, 1, 1, 1),
          O.buffers.depth.setTest(!0),
          O.setScissorTest(!1);
        for (let U = 0, X = w.length; U < X; U++) {
          let $ = w[U],
            W = $.shadow;
          if (W === void 0) {
            console.warn("THREE.WebGLShadowMap:", $, "has no shadow.");
            continue;
          }
          if (W.autoUpdate === !1 && W.needsUpdate === !1) continue;
          r.copy(W.mapSize);
          let ue = W.getFrameExtents();
          if (
            (r.multiply(ue),
            s.copy(W.mapSize),
            (r.x > u || r.y > u) &&
              (r.x > u &&
                ((s.x = Math.floor(u / ue.x)),
                (r.x = s.x * ue.x),
                (W.mapSize.x = s.x)),
              r.y > u &&
                ((s.y = Math.floor(u / ue.y)),
                (r.y = s.y * ue.y),
                (W.mapSize.y = s.y))),
            W.map === null)
          ) {
            let he = this.type !== sh ? { minFilter: un, magFilter: un } : {};
            (W.map = new to(r.x, r.y, he)),
              (W.map.texture.name = $.name + ".shadowMap"),
              W.camera.updateProjectionMatrix();
          }
          n.setRenderTarget(W.map), n.clear();
          let ae = W.getViewportCount();
          for (let he = 0; he < ae; he++) {
            let ce = W.getViewport(he);
            a.set(s.x * ce.x, s.y * ce.y, s.x * ce.z, s.y * ce.w),
              O.viewport(a),
              W.updateMatrices($, he),
              (i = W.getFrustum()),
              E(P, L, W.camera, $, this.type);
          }
          W.isPointLightShadow !== !0 && this.type === sh && b(W, L),
            (W.needsUpdate = !1);
        }
        (g.needsUpdate = !1), n.setRenderTarget(I, M, R);
      });
    function b(w, P) {
      let L = e.update(y);
      d.defines.VSM_SAMPLES !== w.blurSamples &&
        ((d.defines.VSM_SAMPLES = w.blurSamples),
        (m.defines.VSM_SAMPLES = w.blurSamples),
        (d.needsUpdate = !0),
        (m.needsUpdate = !0)),
        w.mapPass === null && (w.mapPass = new to(r.x, r.y)),
        (d.uniforms.shadow_pass.value = w.map.texture),
        (d.uniforms.resolution.value = w.mapSize),
        (d.uniforms.radius.value = w.radius),
        n.setRenderTarget(w.mapPass),
        n.clear(),
        n.renderBufferDirect(P, null, L, d, y, null),
        (m.uniforms.shadow_pass.value = w.mapPass.texture),
        (m.uniforms.resolution.value = w.mapSize),
        (m.uniforms.radius.value = w.radius),
        n.setRenderTarget(w.map),
        n.clear(),
        n.renderBufferDirect(P, null, L, m, y, null);
    }
    function _(w, P, L, I, M, R) {
      let O = null,
        U =
          L.isPointLight === !0
            ? w.customDistanceMaterial
            : w.customDepthMaterial;
      if (U !== void 0) O = U;
      else if (
        ((O = L.isPointLight === !0 ? l : o),
        (n.localClippingEnabled &&
          P.clipShadows === !0 &&
          Array.isArray(P.clippingPlanes) &&
          P.clippingPlanes.length !== 0) ||
          (P.displacementMap && P.displacementScale !== 0) ||
          (P.alphaMap && P.alphaTest > 0) ||
          (P.map && P.alphaTest > 0))
      ) {
        let X = O.uuid,
          $ = P.uuid,
          W = c[X];
        W === void 0 && ((W = {}), (c[X] = W));
        let ue = W[$];
        ue === void 0 && ((ue = O.clone()), (W[$] = ue)), (O = ue);
      }
      return (
        (O.visible = P.visible),
        (O.wireframe = P.wireframe),
        R === sh
          ? (O.side = P.shadowSide !== null ? P.shadowSide : P.side)
          : (O.side = P.shadowSide !== null ? P.shadowSide : f[P.side]),
        (O.alphaMap = P.alphaMap),
        (O.alphaTest = P.alphaTest),
        (O.map = P.map),
        (O.clipShadows = P.clipShadows),
        (O.clippingPlanes = P.clippingPlanes),
        (O.clipIntersection = P.clipIntersection),
        (O.displacementMap = P.displacementMap),
        (O.displacementScale = P.displacementScale),
        (O.displacementBias = P.displacementBias),
        (O.wireframeLinewidth = P.wireframeLinewidth),
        (O.linewidth = P.linewidth),
        L.isPointLight === !0 &&
          O.isMeshDistanceMaterial === !0 &&
          (O.referencePosition.setFromMatrixPosition(L.matrixWorld),
          (O.nearDistance = I),
          (O.farDistance = M)),
        O
      );
    }
    function E(w, P, L, I, M) {
      if (w.visible === !1) return;
      if (
        w.layers.test(P.layers) &&
        (w.isMesh || w.isLine || w.isPoints) &&
        (w.castShadow || (w.receiveShadow && M === sh)) &&
        (!w.frustumCulled || i.intersectsObject(w))
      ) {
        w.modelViewMatrix.multiplyMatrices(L.matrixWorldInverse, w.matrixWorld);
        let U = e.update(w),
          X = w.material;
        if (Array.isArray(X)) {
          let $ = U.groups;
          for (let W = 0, ue = $.length; W < ue; W++) {
            let ae = $[W],
              he = X[ae.materialIndex];
            if (he && he.visible) {
              let ce = _(w, he, I, L.near, L.far, M);
              n.renderBufferDirect(L, null, U, ce, w, ae);
            }
          }
        } else if (X.visible) {
          let $ = _(w, X, I, L.near, L.far, M);
          n.renderBufferDirect(L, null, U, $, w, null);
        }
      }
      let O = w.children;
      for (let U = 0, X = O.length; U < X; U++) E(O[U], P, L, I, M);
    }
  }
  function EG(n, e, t) {
    let i = t.isWebGL2;
    function r() {
      let Z = !1,
        fe = new Ti(),
        Le = null,
        qe = new Ti(0, 0, 0, 0);
      return {
        setMask: function (ot) {
          Le !== ot && !Z && (n.colorMask(ot, ot, ot, ot), (Le = ot));
        },
        setLocked: function (ot) {
          Z = ot;
        },
        setClear: function (ot, Ct, zt, gi, Ni) {
          Ni === !0 && ((ot *= gi), (Ct *= gi), (zt *= gi)),
            fe.set(ot, Ct, zt, gi),
            qe.equals(fe) === !1 && (n.clearColor(ot, Ct, zt, gi), qe.copy(fe));
        },
        reset: function () {
          (Z = !1), (Le = null), qe.set(-1, 0, 0, 0);
        },
      };
    }
    function s() {
      let Z = !1,
        fe = null,
        Le = null,
        qe = null;
      return {
        setTest: function (ot) {
          ot ? ut(2929) : Ye(2929);
        },
        setMask: function (ot) {
          fe !== ot && !Z && (n.depthMask(ot), (fe = ot));
        },
        setFunc: function (ot) {
          if (Le !== ot) {
            switch (ot) {
              case X4:
                n.depthFunc(512);
                break;
              case Y4:
                n.depthFunc(519);
                break;
              case K4:
                n.depthFunc(513);
                break;
              case Kv:
                n.depthFunc(515);
                break;
              case J4:
                n.depthFunc(514);
                break;
              case Z4:
                n.depthFunc(518);
                break;
              case Q4:
                n.depthFunc(516);
                break;
              case ez:
                n.depthFunc(517);
                break;
              default:
                n.depthFunc(515);
            }
            Le = ot;
          }
        },
        setLocked: function (ot) {
          Z = ot;
        },
        setClear: function (ot) {
          qe !== ot && (n.clearDepth(ot), (qe = ot));
        },
        reset: function () {
          (Z = !1), (fe = null), (Le = null), (qe = null);
        },
      };
    }
    function a() {
      let Z = !1,
        fe = null,
        Le = null,
        qe = null,
        ot = null,
        Ct = null,
        zt = null,
        gi = null,
        Ni = null;
      return {
        setTest: function (Pt) {
          Z || (Pt ? ut(2960) : Ye(2960));
        },
        setMask: function (Pt) {
          fe !== Pt && !Z && (n.stencilMask(Pt), (fe = Pt));
        },
        setFunc: function (Pt, Xi, xn) {
          (Le !== Pt || qe !== Xi || ot !== xn) &&
            (n.stencilFunc(Pt, Xi, xn), (Le = Pt), (qe = Xi), (ot = xn));
        },
        setOp: function (Pt, Xi, xn) {
          (Ct !== Pt || zt !== Xi || gi !== xn) &&
            (n.stencilOp(Pt, Xi, xn), (Ct = Pt), (zt = Xi), (gi = xn));
        },
        setLocked: function (Pt) {
          Z = Pt;
        },
        setClear: function (Pt) {
          Ni !== Pt && (n.clearStencil(Pt), (Ni = Pt));
        },
        reset: function () {
          (Z = !1),
            (fe = null),
            (Le = null),
            (qe = null),
            (ot = null),
            (Ct = null),
            (zt = null),
            (gi = null),
            (Ni = null);
        },
      };
    }
    let o = new r(),
      l = new s(),
      c = new a(),
      u = new WeakMap(),
      f = new WeakMap(),
      d = {},
      m = {},
      x = new WeakMap(),
      y = [],
      g = null,
      b = !1,
      _ = null,
      E = null,
      w = null,
      P = null,
      L = null,
      I = null,
      M = null,
      R = !1,
      O = null,
      U = null,
      X = null,
      $ = null,
      W = null,
      ue = n.getParameter(35661),
      ae = !1,
      he = 0,
      ce = n.getParameter(7938);
    ce.indexOf("WebGL") !== -1
      ? ((he = parseFloat(/^WebGL (\d)/.exec(ce)[1])), (ae = he >= 1))
      : ce.indexOf("OpenGL ES") !== -1 &&
        ((he = parseFloat(/^OpenGL ES (\d)/.exec(ce)[1])), (ae = he >= 2));
    let te = null,
      Me = {},
      ge = n.getParameter(3088),
      pe = n.getParameter(2978),
      We = new Ti().fromArray(ge),
      Fe = new Ti().fromArray(pe);
    function Be(Z, fe, Le) {
      let qe = new Uint8Array(4),
        ot = n.createTexture();
      n.bindTexture(Z, ot),
        n.texParameteri(Z, 10241, 9728),
        n.texParameteri(Z, 10240, 9728);
      for (let Ct = 0; Ct < Le; Ct++)
        n.texImage2D(fe + Ct, 0, 6408, 1, 1, 0, 6408, 5121, qe);
      return ot;
    }
    let be = {};
    (be[3553] = Be(3553, 3553, 1)),
      (be[34067] = Be(34067, 34069, 6)),
      o.setClear(0, 0, 0, 1),
      l.setClear(1),
      c.setClear(0),
      ut(2929),
      l.setFunc(Kv),
      Pe(!1),
      De(wM),
      ut(2884),
      ie(Qa);
    function ut(Z) {
      d[Z] !== !0 && (n.enable(Z), (d[Z] = !0));
    }
    function Ye(Z) {
      d[Z] !== !1 && (n.disable(Z), (d[Z] = !1));
    }
    function _t(Z, fe) {
      return m[Z] !== fe
        ? (n.bindFramebuffer(Z, fe),
          (m[Z] = fe),
          i && (Z === 36009 && (m[36160] = fe), Z === 36160 && (m[36009] = fe)),
          !0)
        : !1;
    }
    function Ze(Z, fe) {
      let Le = y,
        qe = !1;
      if (Z)
        if (
          ((Le = x.get(fe)),
          Le === void 0 && ((Le = []), x.set(fe, Le)),
          Z.isWebGLMultipleRenderTargets)
        ) {
          let ot = Z.texture;
          if (Le.length !== ot.length || Le[0] !== 36064) {
            for (let Ct = 0, zt = ot.length; Ct < zt; Ct++) Le[Ct] = 36064 + Ct;
            (Le.length = ot.length), (qe = !0);
          }
        } else Le[0] !== 36064 && ((Le[0] = 36064), (qe = !0));
      else Le[0] !== 1029 && ((Le[0] = 1029), (qe = !0));
      qe &&
        (t.isWebGL2
          ? n.drawBuffers(Le)
          : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Le));
    }
    function kt(Z) {
      return g !== Z ? (n.useProgram(Z), (g = Z), !0) : !1;
    }
    let Et = { [Tc]: 32774, [F4]: 32778, [B4]: 32779 };
    if (i) (Et[PM] = 32775), (Et[DM] = 32776);
    else {
      let Z = e.get("EXT_blend_minmax");
      Z !== null && ((Et[PM] = Z.MIN_EXT), (Et[DM] = Z.MAX_EXT));
    }
    let Y = {
      [z4]: 0,
      [U4]: 1,
      [V4]: 768,
      [JA]: 770,
      [j4]: 776,
      [W4]: 774,
      [H4]: 772,
      [G4]: 769,
      [ZA]: 771,
      [q4]: 775,
      [$4]: 773,
    };
    function ie(Z, fe, Le, qe, ot, Ct, zt, gi) {
      if (Z === Qa) {
        b === !0 && (Ye(3042), (b = !1));
        return;
      }
      if ((b === !1 && (ut(3042), (b = !0)), Z !== k4)) {
        if (Z !== _ || gi !== R) {
          if (
            ((E !== Tc || L !== Tc) &&
              (n.blendEquation(32774), (E = Tc), (L = Tc)),
            gi)
          )
            switch (Z) {
              case Ac:
                n.blendFuncSeparate(1, 771, 1, 771);
                break;
              case MM:
                n.blendFunc(1, 1);
                break;
              case AM:
                n.blendFuncSeparate(0, 769, 0, 1);
                break;
              case CM:
                n.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", Z);
                break;
            }
          else
            switch (Z) {
              case Ac:
                n.blendFuncSeparate(770, 771, 1, 771);
                break;
              case MM:
                n.blendFunc(770, 1);
                break;
              case AM:
                n.blendFuncSeparate(0, 769, 0, 1);
                break;
              case CM:
                n.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", Z);
                break;
            }
          (w = null), (P = null), (I = null), (M = null), (_ = Z), (R = gi);
        }
        return;
      }
      (ot = ot || fe),
        (Ct = Ct || Le),
        (zt = zt || qe),
        (fe !== E || ot !== L) &&
          (n.blendEquationSeparate(Et[fe], Et[ot]), (E = fe), (L = ot)),
        (Le !== w || qe !== P || Ct !== I || zt !== M) &&
          (n.blendFuncSeparate(Y[Le], Y[qe], Y[Ct], Y[zt]),
          (w = Le),
          (P = qe),
          (I = Ct),
          (M = zt)),
        (_ = Z),
        (R = !1);
    }
    function ye(Z, fe) {
      Z.side === vh ? Ye(2884) : ut(2884);
      let Le = Z.side === qr;
      fe && (Le = !Le),
        Pe(Le),
        Z.blending === Ac && Z.transparent === !1
          ? ie(Qa)
          : ie(
              Z.blending,
              Z.blendEquation,
              Z.blendSrc,
              Z.blendDst,
              Z.blendEquationAlpha,
              Z.blendSrcAlpha,
              Z.blendDstAlpha,
              Z.premultipliedAlpha
            ),
        l.setFunc(Z.depthFunc),
        l.setTest(Z.depthTest),
        l.setMask(Z.depthWrite),
        o.setMask(Z.colorWrite);
      let qe = Z.stencilWrite;
      c.setTest(qe),
        qe &&
          (c.setMask(Z.stencilWriteMask),
          c.setFunc(Z.stencilFunc, Z.stencilRef, Z.stencilFuncMask),
          c.setOp(Z.stencilFail, Z.stencilZFail, Z.stencilZPass)),
        Ue(Z.polygonOffset, Z.polygonOffsetFactor, Z.polygonOffsetUnits),
        Z.alphaToCoverage === !0 ? ut(32926) : Ye(32926);
    }
    function Pe(Z) {
      O !== Z && (Z ? n.frontFace(2304) : n.frontFace(2305), (O = Z));
    }
    function De(Z) {
      Z !== O4
        ? (ut(2884),
          Z !== U &&
            (Z === wM
              ? n.cullFace(1029)
              : Z === N4
              ? n.cullFace(1028)
              : n.cullFace(1032)))
        : Ye(2884),
        (U = Z);
    }
    function Ie(Z) {
      Z !== X && (ae && n.lineWidth(Z), (X = Z));
    }
    function Ue(Z, fe, Le) {
      Z
        ? (ut(32823),
          ($ !== fe || W !== Le) &&
            (n.polygonOffset(fe, Le), ($ = fe), (W = Le)))
        : Ye(32823);
    }
    function Ve(Z) {
      Z ? ut(3089) : Ye(3089);
    }
    function He(Z) {
      Z === void 0 && (Z = 33984 + ue - 1),
        te !== Z && (n.activeTexture(Z), (te = Z));
    }
    function B(Z, fe, Le) {
      Le === void 0 && (te === null ? (Le = 33984 + ue - 1) : (Le = te));
      let qe = Me[Le];
      qe === void 0 &&
        ((qe = { type: void 0, texture: void 0 }), (Me[Le] = qe)),
        (qe.type !== Z || qe.texture !== fe) &&
          (te !== Le && (n.activeTexture(Le), (te = Le)),
          n.bindTexture(Z, fe || be[Z]),
          (qe.type = Z),
          (qe.texture = fe));
    }
    function F() {
      let Z = Me[te];
      Z !== void 0 &&
        Z.type !== void 0 &&
        (n.bindTexture(Z.type, null), (Z.type = void 0), (Z.texture = void 0));
    }
    function re() {
      try {
        n.compressedTexImage2D.apply(n, arguments);
      } catch (Z) {
        console.error("THREE.WebGLState:", Z);
      }
    }
    function ve() {
      try {
        n.compressedTexImage3D.apply(n, arguments);
      } catch (Z) {
        console.error("THREE.WebGLState:", Z);
      }
    }
    function Te() {
      try {
        n.texSubImage2D.apply(n, arguments);
      } catch (Z) {
        console.error("THREE.WebGLState:", Z);
      }
    }
    function q() {
      try {
        n.texSubImage3D.apply(n, arguments);
      } catch (Z) {
        console.error("THREE.WebGLState:", Z);
      }
    }
    function j() {
      try {
        n.compressedTexSubImage2D.apply(n, arguments);
      } catch (Z) {
        console.error("THREE.WebGLState:", Z);
      }
    }
    function A() {
      try {
        n.compressedTexSubImage3D.apply(n, arguments);
      } catch (Z) {
        console.error("THREE.WebGLState:", Z);
      }
    }
    function D() {
      try {
        n.texStorage2D.apply(n, arguments);
      } catch (Z) {
        console.error("THREE.WebGLState:", Z);
      }
    }
    function V() {
      try {
        n.texStorage3D.apply(n, arguments);
      } catch (Z) {
        console.error("THREE.WebGLState:", Z);
      }
    }
    function Q() {
      try {
        n.texImage2D.apply(n, arguments);
      } catch (Z) {
        console.error("THREE.WebGLState:", Z);
      }
    }
    function ee() {
      try {
        n.texImage3D.apply(n, arguments);
      } catch (Z) {
        console.error("THREE.WebGLState:", Z);
      }
    }
    function _e(Z) {
      We.equals(Z) === !1 && (n.scissor(Z.x, Z.y, Z.z, Z.w), We.copy(Z));
    }
    function Re(Z) {
      Fe.equals(Z) === !1 && (n.viewport(Z.x, Z.y, Z.z, Z.w), Fe.copy(Z));
    }
    function Ee(Z, fe) {
      let Le = f.get(fe);
      Le === void 0 && ((Le = new WeakMap()), f.set(fe, Le));
      let qe = Le.get(Z);
      qe === void 0 &&
        ((qe = n.getUniformBlockIndex(fe, Z.name)), Le.set(Z, qe));
    }
    function Se(Z, fe) {
      let qe = f.get(fe).get(Z);
      u.get(fe) !== qe &&
        (n.uniformBlockBinding(fe, qe, Z.__bindingPointIndex), u.set(fe, qe));
    }
    function st() {
      n.disable(3042),
        n.disable(2884),
        n.disable(2929),
        n.disable(32823),
        n.disable(3089),
        n.disable(2960),
        n.disable(32926),
        n.blendEquation(32774),
        n.blendFunc(1, 0),
        n.blendFuncSeparate(1, 0, 1, 0),
        n.colorMask(!0, !0, !0, !0),
        n.clearColor(0, 0, 0, 0),
        n.depthMask(!0),
        n.depthFunc(513),
        n.clearDepth(1),
        n.stencilMask(4294967295),
        n.stencilFunc(519, 0, 4294967295),
        n.stencilOp(7680, 7680, 7680),
        n.clearStencil(0),
        n.cullFace(1029),
        n.frontFace(2305),
        n.polygonOffset(0, 0),
        n.activeTexture(33984),
        n.bindFramebuffer(36160, null),
        i === !0 &&
          (n.bindFramebuffer(36009, null), n.bindFramebuffer(36008, null)),
        n.useProgram(null),
        n.lineWidth(1),
        n.scissor(0, 0, n.canvas.width, n.canvas.height),
        n.viewport(0, 0, n.canvas.width, n.canvas.height),
        (d = {}),
        (te = null),
        (Me = {}),
        (m = {}),
        (x = new WeakMap()),
        (y = []),
        (g = null),
        (b = !1),
        (_ = null),
        (E = null),
        (w = null),
        (P = null),
        (L = null),
        (I = null),
        (M = null),
        (R = !1),
        (O = null),
        (U = null),
        (X = null),
        ($ = null),
        (W = null),
        We.set(0, 0, n.canvas.width, n.canvas.height),
        Fe.set(0, 0, n.canvas.width, n.canvas.height),
        o.reset(),
        l.reset(),
        c.reset();
    }
    return {
      buffers: { color: o, depth: l, stencil: c },
      enable: ut,
      disable: Ye,
      bindFramebuffer: _t,
      drawBuffers: Ze,
      useProgram: kt,
      setBlending: ie,
      setMaterial: ye,
      setFlipSided: Pe,
      setCullFace: De,
      setLineWidth: Ie,
      setPolygonOffset: Ue,
      setScissorTest: Ve,
      activeTexture: He,
      bindTexture: B,
      unbindTexture: F,
      compressedTexImage2D: re,
      compressedTexImage3D: ve,
      texImage2D: Q,
      texImage3D: ee,
      updateUBOMapping: Ee,
      uniformBlockBinding: Se,
      texStorage2D: D,
      texStorage3D: V,
      texSubImage2D: Te,
      texSubImage3D: q,
      compressedTexSubImage2D: j,
      compressedTexSubImage3D: A,
      scissor: _e,
      viewport: Re,
      reset: st,
    };
  }
  function TG(n, e, t, i, r, s, a) {
    let o = r.isWebGL2,
      l = r.maxTextures,
      c = r.maxCubemapSize,
      u = r.maxTextureSize,
      f = r.maxSamples,
      d = e.has("WEBGL_multisampled_render_to_texture")
        ? e.get("WEBGL_multisampled_render_to_texture")
        : null,
      m =
        typeof navigator == "undefined"
          ? !1
          : /OculusBrowser/g.test(navigator.userAgent),
      x = new WeakMap(),
      y,
      g = new WeakMap(),
      b = !1;
    try {
      b =
        typeof OffscreenCanvas != "undefined" &&
        new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (B) {}
    function _(B, F) {
      return b ? new OffscreenCanvas(B, F) : mh("canvas");
    }
    function E(B, F, re, ve) {
      let Te = 1;
      if (
        ((B.width > ve || B.height > ve) &&
          (Te = ve / Math.max(B.width, B.height)),
        Te < 1 || F === !0)
      )
        if (
          (typeof HTMLImageElement != "undefined" &&
            B instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement != "undefined" &&
            B instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap != "undefined" && B instanceof ImageBitmap)
        ) {
          let q = F ? yp : Math.floor,
            j = q(Te * B.width),
            A = q(Te * B.height);
          y === void 0 && (y = _(j, A));
          let D = re ? _(j, A) : y;
          return (
            (D.width = j),
            (D.height = A),
            D.getContext("2d").drawImage(B, 0, 0, j, A),
            console.warn(
              "THREE.WebGLRenderer: Texture has been resized from (" +
                B.width +
                "x" +
                B.height +
                ") to (" +
                j +
                "x" +
                A +
                ")."
            ),
            D
          );
        } else
          return (
            "data" in B &&
              console.warn(
                "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                  B.width +
                  "x" +
                  B.height +
                  ")."
              ),
            B
          );
      return B;
    }
    function w(B) {
      return tx(B.width) && tx(B.height);
    }
    function P(B) {
      return o
        ? !1
        : B.wrapS !== xr ||
            B.wrapT !== xr ||
            (B.minFilter !== un && B.minFilter !== Wn);
    }
    function L(B, F) {
      return B.generateMipmaps && F && B.minFilter !== un && B.minFilter !== Wn;
    }
    function I(B) {
      n.generateMipmap(B);
    }
    function M(B, F, re, ve, Te = !1) {
      if (o === !1) return F;
      if (B !== null) {
        if (n[B] !== void 0) return n[B];
        console.warn(
          "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
            B +
            "'"
        );
      }
      let q = F;
      return (
        F === 6403 &&
          (re === 5126 && (q = 33326),
          re === 5131 && (q = 33325),
          re === 5121 && (q = 33321)),
        F === 33319 &&
          (re === 5126 && (q = 33328),
          re === 5131 && (q = 33327),
          re === 5121 && (q = 33323)),
        F === 6408 &&
          (re === 5126 && (q = 34836),
          re === 5131 && (q = 34842),
          re === 5121 && (q = ve === oi && Te === !1 ? 35907 : 32856),
          re === 32819 && (q = 32854),
          re === 32820 && (q = 32855)),
        (q === 33325 ||
          q === 33326 ||
          q === 33327 ||
          q === 33328 ||
          q === 34842 ||
          q === 34836) &&
          e.get("EXT_color_buffer_float"),
        q
      );
    }
    function R(B, F, re) {
      return L(B, re) === !0 ||
        (B.isFramebufferTexture && B.minFilter !== un && B.minFilter !== Wn)
        ? Math.log2(Math.max(F.width, F.height)) + 1
        : B.mipmaps !== void 0 && B.mipmaps.length > 0
        ? B.mipmaps.length
        : B.isCompressedTexture && Array.isArray(B.image)
        ? F.mipmaps.length
        : 1;
    }
    function O(B) {
      return B === un || B === mp || B === oh ? 9728 : 9729;
    }
    function U(B) {
      let F = B.target;
      F.removeEventListener("dispose", U),
        $(F),
        F.isVideoTexture && x.delete(F);
    }
    function X(B) {
      let F = B.target;
      F.removeEventListener("dispose", X), ue(F);
    }
    function $(B) {
      let F = i.get(B);
      if (F.__webglInit === void 0) return;
      let re = B.source,
        ve = g.get(re);
      if (ve) {
        let Te = ve[F.__cacheKey];
        Te.usedTimes--,
          Te.usedTimes === 0 && W(B),
          Object.keys(ve).length === 0 && g.delete(re);
      }
      i.remove(B);
    }
    function W(B) {
      let F = i.get(B);
      n.deleteTexture(F.__webglTexture);
      let re = B.source,
        ve = g.get(re);
      delete ve[F.__cacheKey], a.memory.textures--;
    }
    function ue(B) {
      let F = B.texture,
        re = i.get(B),
        ve = i.get(F);
      if (
        (ve.__webglTexture !== void 0 &&
          (n.deleteTexture(ve.__webglTexture), a.memory.textures--),
        B.depthTexture && B.depthTexture.dispose(),
        B.isWebGLCubeRenderTarget)
      )
        for (let Te = 0; Te < 6; Te++)
          n.deleteFramebuffer(re.__webglFramebuffer[Te]),
            re.__webglDepthbuffer &&
              n.deleteRenderbuffer(re.__webglDepthbuffer[Te]);
      else {
        if (
          (n.deleteFramebuffer(re.__webglFramebuffer),
          re.__webglDepthbuffer && n.deleteRenderbuffer(re.__webglDepthbuffer),
          re.__webglMultisampledFramebuffer &&
            n.deleteFramebuffer(re.__webglMultisampledFramebuffer),
          re.__webglColorRenderbuffer)
        )
          for (let Te = 0; Te < re.__webglColorRenderbuffer.length; Te++)
            re.__webglColorRenderbuffer[Te] &&
              n.deleteRenderbuffer(re.__webglColorRenderbuffer[Te]);
        re.__webglDepthRenderbuffer &&
          n.deleteRenderbuffer(re.__webglDepthRenderbuffer);
      }
      if (B.isWebGLMultipleRenderTargets)
        for (let Te = 0, q = F.length; Te < q; Te++) {
          let j = i.get(F[Te]);
          j.__webglTexture &&
            (n.deleteTexture(j.__webglTexture), a.memory.textures--),
            i.remove(F[Te]);
        }
      i.remove(F), i.remove(B);
    }
    let ae = 0;
    function he() {
      ae = 0;
    }
    function ce() {
      let B = ae;
      return (
        B >= l &&
          console.warn(
            "THREE.WebGLTextures: Trying to use " +
              B +
              " texture units while this GPU supports only " +
              l
          ),
        (ae += 1),
        B
      );
    }
    function te(B) {
      let F = [];
      return (
        F.push(B.wrapS),
        F.push(B.wrapT),
        F.push(B.wrapR || 0),
        F.push(B.magFilter),
        F.push(B.minFilter),
        F.push(B.anisotropy),
        F.push(B.internalFormat),
        F.push(B.format),
        F.push(B.type),
        F.push(B.generateMipmaps),
        F.push(B.premultiplyAlpha),
        F.push(B.flipY),
        F.push(B.unpackAlignment),
        F.push(B.encoding),
        F.join()
      );
    }
    function Me(B, F) {
      let re = i.get(B);
      if (
        (B.isVideoTexture && Ve(B),
        B.isRenderTargetTexture === !1 &&
          B.version > 0 &&
          re.__version !== B.version)
      ) {
        let ve = B.image;
        if (ve === null)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but no image data found."
          );
        else if (ve.complete === !1)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
          );
        else {
          Ye(re, B, F);
          return;
        }
      }
      t.bindTexture(3553, re.__webglTexture, 33984 + F);
    }
    function ge(B, F) {
      let re = i.get(B);
      if (B.version > 0 && re.__version !== B.version) {
        Ye(re, B, F);
        return;
      }
      t.bindTexture(35866, re.__webglTexture, 33984 + F);
    }
    function pe(B, F) {
      let re = i.get(B);
      if (B.version > 0 && re.__version !== B.version) {
        Ye(re, B, F);
        return;
      }
      t.bindTexture(32879, re.__webglTexture, 33984 + F);
    }
    function We(B, F) {
      let re = i.get(B);
      if (B.version > 0 && re.__version !== B.version) {
        _t(re, B, F);
        return;
      }
      t.bindTexture(34067, re.__webglTexture, 33984 + F);
    }
    let Fe = { [rl]: 10497, [xr]: 33071, [hh]: 33648 },
      Be = {
        [un]: 9728,
        [mp]: 9984,
        [oh]: 9986,
        [Wn]: 9729,
        [ox]: 9985,
        [eo]: 9987,
      };
    function be(B, F, re) {
      if (
        (re
          ? (n.texParameteri(B, 10242, Fe[F.wrapS]),
            n.texParameteri(B, 10243, Fe[F.wrapT]),
            (B === 32879 || B === 35866) &&
              n.texParameteri(B, 32882, Fe[F.wrapR]),
            n.texParameteri(B, 10240, Be[F.magFilter]),
            n.texParameteri(B, 10241, Be[F.minFilter]))
          : (n.texParameteri(B, 10242, 33071),
            n.texParameteri(B, 10243, 33071),
            (B === 32879 || B === 35866) && n.texParameteri(B, 32882, 33071),
            (F.wrapS !== xr || F.wrapT !== xr) &&
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
              ),
            n.texParameteri(B, 10240, O(F.magFilter)),
            n.texParameteri(B, 10241, O(F.minFilter)),
            F.minFilter !== un &&
              F.minFilter !== Wn &&
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
              )),
        e.has("EXT_texture_filter_anisotropic") === !0)
      ) {
        let ve = e.get("EXT_texture_filter_anisotropic");
        if (
          F.magFilter === un ||
          (F.minFilter !== oh && F.minFilter !== eo) ||
          (F.type === Za && e.has("OES_texture_float_linear") === !1) ||
          (o === !1 &&
            F.type === fh &&
            e.has("OES_texture_half_float_linear") === !1)
        )
          return;
        (F.anisotropy > 1 || i.get(F).__currentAnisotropy) &&
          (n.texParameterf(
            B,
            ve.TEXTURE_MAX_ANISOTROPY_EXT,
            Math.min(F.anisotropy, r.getMaxAnisotropy())
          ),
          (i.get(F).__currentAnisotropy = F.anisotropy));
      }
    }
    function ut(B, F) {
      let re = !1;
      B.__webglInit === void 0 &&
        ((B.__webglInit = !0), F.addEventListener("dispose", U));
      let ve = F.source,
        Te = g.get(ve);
      Te === void 0 && ((Te = {}), g.set(ve, Te));
      let q = te(F);
      if (q !== B.__cacheKey) {
        Te[q] === void 0 &&
          ((Te[q] = { texture: n.createTexture(), usedTimes: 0 }),
          a.memory.textures++,
          (re = !0)),
          Te[q].usedTimes++;
        let j = Te[B.__cacheKey];
        j !== void 0 &&
          (Te[B.__cacheKey].usedTimes--, j.usedTimes === 0 && W(F)),
          (B.__cacheKey = q),
          (B.__webglTexture = Te[q].texture);
      }
      return re;
    }
    function Ye(B, F, re) {
      let ve = 3553;
      (F.isDataArrayTexture || F.isCompressedArrayTexture) && (ve = 35866),
        F.isData3DTexture && (ve = 32879);
      let Te = ut(B, F),
        q = F.source;
      t.bindTexture(ve, B.__webglTexture, 33984 + re);
      let j = i.get(q);
      if (q.version !== j.__version || Te === !0) {
        t.activeTexture(33984 + re),
          n.pixelStorei(37440, F.flipY),
          n.pixelStorei(37441, F.premultiplyAlpha),
          n.pixelStorei(3317, F.unpackAlignment),
          n.pixelStorei(37443, 0);
        let A = P(F) && w(F.image) === !1,
          D = E(F.image, A, !1, u);
        D = He(F, D);
        let V = w(D) || o,
          Q = s.convert(F.format, F.encoding),
          ee = s.convert(F.type),
          _e = M(F.internalFormat, Q, ee, F.encoding, F.isVideoTexture);
        be(ve, F, V);
        let Re,
          Ee = F.mipmaps,
          Se = o && F.isVideoTexture !== !0,
          st = j.__version === void 0 || Te === !0,
          Z = R(F, D, V);
        if (F.isDepthTexture)
          (_e = 6402),
            o
              ? F.type === Za
                ? (_e = 36012)
                : F.type === tl
                ? (_e = 33190)
                : F.type === Cc
                ? (_e = 35056)
                : (_e = 33189)
              : F.type === Za &&
                console.error(
                  "WebGLRenderer: Floating point depth texture requires WebGL2."
                ),
            F.format === il &&
              _e === 6402 &&
              F.type !== tC &&
              F.type !== tl &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
              ),
              (F.type = tl),
              (ee = s.convert(F.type))),
            F.format === Ic &&
              _e === 6402 &&
              ((_e = 34041),
              F.type !== Cc &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                ),
                (F.type = Cc),
                (ee = s.convert(F.type)))),
            st &&
              (Se
                ? t.texStorage2D(3553, 1, _e, D.width, D.height)
                : t.texImage2D(3553, 0, _e, D.width, D.height, 0, Q, ee, null));
        else if (F.isDataTexture)
          if (Ee.length > 0 && V) {
            Se && st && t.texStorage2D(3553, Z, _e, Ee[0].width, Ee[0].height);
            for (let fe = 0, Le = Ee.length; fe < Le; fe++)
              (Re = Ee[fe]),
                Se
                  ? t.texSubImage2D(
                      3553,
                      fe,
                      0,
                      0,
                      Re.width,
                      Re.height,
                      Q,
                      ee,
                      Re.data
                    )
                  : t.texImage2D(
                      3553,
                      fe,
                      _e,
                      Re.width,
                      Re.height,
                      0,
                      Q,
                      ee,
                      Re.data
                    );
            F.generateMipmaps = !1;
          } else
            Se
              ? (st && t.texStorage2D(3553, Z, _e, D.width, D.height),
                t.texSubImage2D(
                  3553,
                  0,
                  0,
                  0,
                  D.width,
                  D.height,
                  Q,
                  ee,
                  D.data
                ))
              : t.texImage2D(3553, 0, _e, D.width, D.height, 0, Q, ee, D.data);
        else if (F.isCompressedTexture)
          if (F.isCompressedArrayTexture) {
            Se &&
              st &&
              t.texStorage3D(35866, Z, _e, Ee[0].width, Ee[0].height, D.depth);
            for (let fe = 0, Le = Ee.length; fe < Le; fe++)
              (Re = Ee[fe]),
                F.format !== Wr
                  ? Q !== null
                    ? Se
                      ? t.compressedTexSubImage3D(
                          35866,
                          fe,
                          0,
                          0,
                          0,
                          Re.width,
                          Re.height,
                          D.depth,
                          Q,
                          Re.data,
                          0,
                          0
                        )
                      : t.compressedTexImage3D(
                          35866,
                          fe,
                          _e,
                          Re.width,
                          Re.height,
                          D.depth,
                          0,
                          Re.data,
                          0,
                          0
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : Se
                  ? t.texSubImage3D(
                      35866,
                      fe,
                      0,
                      0,
                      0,
                      Re.width,
                      Re.height,
                      D.depth,
                      Q,
                      ee,
                      Re.data
                    )
                  : t.texImage3D(
                      35866,
                      fe,
                      _e,
                      Re.width,
                      Re.height,
                      D.depth,
                      0,
                      Q,
                      ee,
                      Re.data
                    );
          } else {
            Se && st && t.texStorage2D(3553, Z, _e, Ee[0].width, Ee[0].height);
            for (let fe = 0, Le = Ee.length; fe < Le; fe++)
              (Re = Ee[fe]),
                F.format !== Wr
                  ? Q !== null
                    ? Se
                      ? t.compressedTexSubImage2D(
                          3553,
                          fe,
                          0,
                          0,
                          Re.width,
                          Re.height,
                          Q,
                          Re.data
                        )
                      : t.compressedTexImage2D(
                          3553,
                          fe,
                          _e,
                          Re.width,
                          Re.height,
                          0,
                          Re.data
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : Se
                  ? t.texSubImage2D(
                      3553,
                      fe,
                      0,
                      0,
                      Re.width,
                      Re.height,
                      Q,
                      ee,
                      Re.data
                    )
                  : t.texImage2D(
                      3553,
                      fe,
                      _e,
                      Re.width,
                      Re.height,
                      0,
                      Q,
                      ee,
                      Re.data
                    );
          }
        else if (F.isDataArrayTexture)
          Se
            ? (st && t.texStorage3D(35866, Z, _e, D.width, D.height, D.depth),
              t.texSubImage3D(
                35866,
                0,
                0,
                0,
                0,
                D.width,
                D.height,
                D.depth,
                Q,
                ee,
                D.data
              ))
            : t.texImage3D(
                35866,
                0,
                _e,
                D.width,
                D.height,
                D.depth,
                0,
                Q,
                ee,
                D.data
              );
        else if (F.isData3DTexture)
          Se
            ? (st && t.texStorage3D(32879, Z, _e, D.width, D.height, D.depth),
              t.texSubImage3D(
                32879,
                0,
                0,
                0,
                0,
                D.width,
                D.height,
                D.depth,
                Q,
                ee,
                D.data
              ))
            : t.texImage3D(
                32879,
                0,
                _e,
                D.width,
                D.height,
                D.depth,
                0,
                Q,
                ee,
                D.data
              );
        else if (F.isFramebufferTexture) {
          if (st)
            if (Se) t.texStorage2D(3553, Z, _e, D.width, D.height);
            else {
              let fe = D.width,
                Le = D.height;
              for (let qe = 0; qe < Z; qe++)
                t.texImage2D(3553, qe, _e, fe, Le, 0, Q, ee, null),
                  (fe >>= 1),
                  (Le >>= 1);
            }
        } else if (Ee.length > 0 && V) {
          Se && st && t.texStorage2D(3553, Z, _e, Ee[0].width, Ee[0].height);
          for (let fe = 0, Le = Ee.length; fe < Le; fe++)
            (Re = Ee[fe]),
              Se
                ? t.texSubImage2D(3553, fe, 0, 0, Q, ee, Re)
                : t.texImage2D(3553, fe, _e, Q, ee, Re);
          F.generateMipmaps = !1;
        } else
          Se
            ? (st && t.texStorage2D(3553, Z, _e, D.width, D.height),
              t.texSubImage2D(3553, 0, 0, 0, Q, ee, D))
            : t.texImage2D(3553, 0, _e, Q, ee, D);
        L(F, V) && I(ve),
          (j.__version = q.version),
          F.onUpdate && F.onUpdate(F);
      }
      B.__version = F.version;
    }
    function _t(B, F, re) {
      if (F.image.length !== 6) return;
      let ve = ut(B, F),
        Te = F.source;
      t.bindTexture(34067, B.__webglTexture, 33984 + re);
      let q = i.get(Te);
      if (Te.version !== q.__version || ve === !0) {
        t.activeTexture(33984 + re),
          n.pixelStorei(37440, F.flipY),
          n.pixelStorei(37441, F.premultiplyAlpha),
          n.pixelStorei(3317, F.unpackAlignment),
          n.pixelStorei(37443, 0);
        let j = F.isCompressedTexture || F.image[0].isCompressedTexture,
          A = F.image[0] && F.image[0].isDataTexture,
          D = [];
        for (let fe = 0; fe < 6; fe++)
          !j && !A
            ? (D[fe] = E(F.image[fe], !1, !0, c))
            : (D[fe] = A ? F.image[fe].image : F.image[fe]),
            (D[fe] = He(F, D[fe]));
        let V = D[0],
          Q = w(V) || o,
          ee = s.convert(F.format, F.encoding),
          _e = s.convert(F.type),
          Re = M(F.internalFormat, ee, _e, F.encoding),
          Ee = o && F.isVideoTexture !== !0,
          Se = q.__version === void 0 || ve === !0,
          st = R(F, V, Q);
        be(34067, F, Q);
        let Z;
        if (j) {
          Ee && Se && t.texStorage2D(34067, st, Re, V.width, V.height);
          for (let fe = 0; fe < 6; fe++) {
            Z = D[fe].mipmaps;
            for (let Le = 0; Le < Z.length; Le++) {
              let qe = Z[Le];
              F.format !== Wr
                ? ee !== null
                  ? Ee
                    ? t.compressedTexSubImage2D(
                        34069 + fe,
                        Le,
                        0,
                        0,
                        qe.width,
                        qe.height,
                        ee,
                        qe.data
                      )
                    : t.compressedTexImage2D(
                        34069 + fe,
                        Le,
                        Re,
                        qe.width,
                        qe.height,
                        0,
                        qe.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                    )
                : Ee
                ? t.texSubImage2D(
                    34069 + fe,
                    Le,
                    0,
                    0,
                    qe.width,
                    qe.height,
                    ee,
                    _e,
                    qe.data
                  )
                : t.texImage2D(
                    34069 + fe,
                    Le,
                    Re,
                    qe.width,
                    qe.height,
                    0,
                    ee,
                    _e,
                    qe.data
                  );
            }
          }
        } else {
          (Z = F.mipmaps),
            Ee &&
              Se &&
              (Z.length > 0 && st++,
              t.texStorage2D(34067, st, Re, D[0].width, D[0].height));
          for (let fe = 0; fe < 6; fe++)
            if (A) {
              Ee
                ? t.texSubImage2D(
                    34069 + fe,
                    0,
                    0,
                    0,
                    D[fe].width,
                    D[fe].height,
                    ee,
                    _e,
                    D[fe].data
                  )
                : t.texImage2D(
                    34069 + fe,
                    0,
                    Re,
                    D[fe].width,
                    D[fe].height,
                    0,
                    ee,
                    _e,
                    D[fe].data
                  );
              for (let Le = 0; Le < Z.length; Le++) {
                let ot = Z[Le].image[fe].image;
                Ee
                  ? t.texSubImage2D(
                      34069 + fe,
                      Le + 1,
                      0,
                      0,
                      ot.width,
                      ot.height,
                      ee,
                      _e,
                      ot.data
                    )
                  : t.texImage2D(
                      34069 + fe,
                      Le + 1,
                      Re,
                      ot.width,
                      ot.height,
                      0,
                      ee,
                      _e,
                      ot.data
                    );
              }
            } else {
              Ee
                ? t.texSubImage2D(34069 + fe, 0, 0, 0, ee, _e, D[fe])
                : t.texImage2D(34069 + fe, 0, Re, ee, _e, D[fe]);
              for (let Le = 0; Le < Z.length; Le++) {
                let qe = Z[Le];
                Ee
                  ? t.texSubImage2D(
                      34069 + fe,
                      Le + 1,
                      0,
                      0,
                      ee,
                      _e,
                      qe.image[fe]
                    )
                  : t.texImage2D(34069 + fe, Le + 1, Re, ee, _e, qe.image[fe]);
              }
            }
        }
        L(F, Q) && I(34067),
          (q.__version = Te.version),
          F.onUpdate && F.onUpdate(F);
      }
      B.__version = F.version;
    }
    function Ze(B, F, re, ve, Te) {
      let q = s.convert(re.format, re.encoding),
        j = s.convert(re.type),
        A = M(re.internalFormat, q, j, re.encoding);
      i.get(F).__hasExternalTextures ||
        (Te === 32879 || Te === 35866
          ? t.texImage3D(Te, 0, A, F.width, F.height, F.depth, 0, q, j, null)
          : t.texImage2D(Te, 0, A, F.width, F.height, 0, q, j, null)),
        t.bindFramebuffer(36160, B),
        Ue(F)
          ? d.framebufferTexture2DMultisampleEXT(
              36160,
              ve,
              Te,
              i.get(re).__webglTexture,
              0,
              Ie(F)
            )
          : (Te === 3553 || (Te >= 34069 && Te <= 34074)) &&
            n.framebufferTexture2D(36160, ve, Te, i.get(re).__webglTexture, 0),
        t.bindFramebuffer(36160, null);
    }
    function kt(B, F, re) {
      if ((n.bindRenderbuffer(36161, B), F.depthBuffer && !F.stencilBuffer)) {
        let ve = 33189;
        if (re || Ue(F)) {
          let Te = F.depthTexture;
          Te &&
            Te.isDepthTexture &&
            (Te.type === Za ? (ve = 36012) : Te.type === tl && (ve = 33190));
          let q = Ie(F);
          Ue(F)
            ? d.renderbufferStorageMultisampleEXT(
                36161,
                q,
                ve,
                F.width,
                F.height
              )
            : n.renderbufferStorageMultisample(36161, q, ve, F.width, F.height);
        } else n.renderbufferStorage(36161, ve, F.width, F.height);
        n.framebufferRenderbuffer(36160, 36096, 36161, B);
      } else if (F.depthBuffer && F.stencilBuffer) {
        let ve = Ie(F);
        re && Ue(F) === !1
          ? n.renderbufferStorageMultisample(
              36161,
              ve,
              35056,
              F.width,
              F.height
            )
          : Ue(F)
          ? d.renderbufferStorageMultisampleEXT(
              36161,
              ve,
              35056,
              F.width,
              F.height
            )
          : n.renderbufferStorage(36161, 34041, F.width, F.height),
          n.framebufferRenderbuffer(36160, 33306, 36161, B);
      } else {
        let ve =
          F.isWebGLMultipleRenderTargets === !0 ? F.texture : [F.texture];
        for (let Te = 0; Te < ve.length; Te++) {
          let q = ve[Te],
            j = s.convert(q.format, q.encoding),
            A = s.convert(q.type),
            D = M(q.internalFormat, j, A, q.encoding),
            V = Ie(F);
          re && Ue(F) === !1
            ? n.renderbufferStorageMultisample(36161, V, D, F.width, F.height)
            : Ue(F)
            ? d.renderbufferStorageMultisampleEXT(
                36161,
                V,
                D,
                F.width,
                F.height
              )
            : n.renderbufferStorage(36161, D, F.width, F.height);
        }
      }
      n.bindRenderbuffer(36161, null);
    }
    function Et(B, F) {
      if (F && F.isWebGLCubeRenderTarget)
        throw new Error(
          "Depth Texture with cube render targets is not supported"
        );
      if (
        (t.bindFramebuffer(36160, B),
        !(F.depthTexture && F.depthTexture.isDepthTexture))
      )
        throw new Error(
          "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
        );
      (!i.get(F.depthTexture).__webglTexture ||
        F.depthTexture.image.width !== F.width ||
        F.depthTexture.image.height !== F.height) &&
        ((F.depthTexture.image.width = F.width),
        (F.depthTexture.image.height = F.height),
        (F.depthTexture.needsUpdate = !0)),
        Me(F.depthTexture, 0);
      let ve = i.get(F.depthTexture).__webglTexture,
        Te = Ie(F);
      if (F.depthTexture.format === il)
        Ue(F)
          ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, ve, 0, Te)
          : n.framebufferTexture2D(36160, 36096, 3553, ve, 0);
      else if (F.depthTexture.format === Ic)
        Ue(F)
          ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, ve, 0, Te)
          : n.framebufferTexture2D(36160, 33306, 3553, ve, 0);
      else throw new Error("Unknown depthTexture format");
    }
    function Y(B) {
      let F = i.get(B),
        re = B.isWebGLCubeRenderTarget === !0;
      if (B.depthTexture && !F.__autoAllocateDepthBuffer) {
        if (re)
          throw new Error(
            "target.depthTexture not supported in Cube render targets"
          );
        Et(F.__webglFramebuffer, B);
      } else if (re) {
        F.__webglDepthbuffer = [];
        for (let ve = 0; ve < 6; ve++)
          t.bindFramebuffer(36160, F.__webglFramebuffer[ve]),
            (F.__webglDepthbuffer[ve] = n.createRenderbuffer()),
            kt(F.__webglDepthbuffer[ve], B, !1);
      } else
        t.bindFramebuffer(36160, F.__webglFramebuffer),
          (F.__webglDepthbuffer = n.createRenderbuffer()),
          kt(F.__webglDepthbuffer, B, !1);
      t.bindFramebuffer(36160, null);
    }
    function ie(B, F, re) {
      let ve = i.get(B);
      F !== void 0 && Ze(ve.__webglFramebuffer, B, B.texture, 36064, 3553),
        re !== void 0 && Y(B);
    }
    function ye(B) {
      let F = B.texture,
        re = i.get(B),
        ve = i.get(F);
      B.addEventListener("dispose", X),
        B.isWebGLMultipleRenderTargets !== !0 &&
          (ve.__webglTexture === void 0 &&
            (ve.__webglTexture = n.createTexture()),
          (ve.__version = F.version),
          a.memory.textures++);
      let Te = B.isWebGLCubeRenderTarget === !0,
        q = B.isWebGLMultipleRenderTargets === !0,
        j = w(B) || o;
      if (Te) {
        re.__webglFramebuffer = [];
        for (let A = 0; A < 6; A++)
          re.__webglFramebuffer[A] = n.createFramebuffer();
      } else {
        if (((re.__webglFramebuffer = n.createFramebuffer()), q))
          if (r.drawBuffers) {
            let A = B.texture;
            for (let D = 0, V = A.length; D < V; D++) {
              let Q = i.get(A[D]);
              Q.__webglTexture === void 0 &&
                ((Q.__webglTexture = n.createTexture()), a.memory.textures++);
            }
          } else
            console.warn(
              "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
            );
        if (o && B.samples > 0 && Ue(B) === !1) {
          let A = q ? F : [F];
          (re.__webglMultisampledFramebuffer = n.createFramebuffer()),
            (re.__webglColorRenderbuffer = []),
            t.bindFramebuffer(36160, re.__webglMultisampledFramebuffer);
          for (let D = 0; D < A.length; D++) {
            let V = A[D];
            (re.__webglColorRenderbuffer[D] = n.createRenderbuffer()),
              n.bindRenderbuffer(36161, re.__webglColorRenderbuffer[D]);
            let Q = s.convert(V.format, V.encoding),
              ee = s.convert(V.type),
              _e = M(
                V.internalFormat,
                Q,
                ee,
                V.encoding,
                B.isXRRenderTarget === !0
              ),
              Re = Ie(B);
            n.renderbufferStorageMultisample(36161, Re, _e, B.width, B.height),
              n.framebufferRenderbuffer(
                36160,
                36064 + D,
                36161,
                re.__webglColorRenderbuffer[D]
              );
          }
          n.bindRenderbuffer(36161, null),
            B.depthBuffer &&
              ((re.__webglDepthRenderbuffer = n.createRenderbuffer()),
              kt(re.__webglDepthRenderbuffer, B, !0)),
            t.bindFramebuffer(36160, null);
        }
      }
      if (Te) {
        t.bindTexture(34067, ve.__webglTexture), be(34067, F, j);
        for (let A = 0; A < 6; A++)
          Ze(re.__webglFramebuffer[A], B, F, 36064, 34069 + A);
        L(F, j) && I(34067), t.unbindTexture();
      } else if (q) {
        let A = B.texture;
        for (let D = 0, V = A.length; D < V; D++) {
          let Q = A[D],
            ee = i.get(Q);
          t.bindTexture(3553, ee.__webglTexture),
            be(3553, Q, j),
            Ze(re.__webglFramebuffer, B, Q, 36064 + D, 3553),
            L(Q, j) && I(3553);
        }
        t.unbindTexture();
      } else {
        let A = 3553;
        (B.isWebGL3DRenderTarget || B.isWebGLArrayRenderTarget) &&
          (o
            ? (A = B.isWebGL3DRenderTarget ? 32879 : 35866)
            : console.error(
                "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
              )),
          t.bindTexture(A, ve.__webglTexture),
          be(A, F, j),
          Ze(re.__webglFramebuffer, B, F, 36064, A),
          L(F, j) && I(A),
          t.unbindTexture();
      }
      B.depthBuffer && Y(B);
    }
    function Pe(B) {
      let F = w(B) || o,
        re = B.isWebGLMultipleRenderTargets === !0 ? B.texture : [B.texture];
      for (let ve = 0, Te = re.length; ve < Te; ve++) {
        let q = re[ve];
        if (L(q, F)) {
          let j = B.isWebGLCubeRenderTarget ? 34067 : 3553,
            A = i.get(q).__webglTexture;
          t.bindTexture(j, A), I(j), t.unbindTexture();
        }
      }
    }
    function De(B) {
      if (o && B.samples > 0 && Ue(B) === !1) {
        let F = B.isWebGLMultipleRenderTargets ? B.texture : [B.texture],
          re = B.width,
          ve = B.height,
          Te = 16384,
          q = [],
          j = B.stencilBuffer ? 33306 : 36096,
          A = i.get(B),
          D = B.isWebGLMultipleRenderTargets === !0;
        if (D)
          for (let V = 0; V < F.length; V++)
            t.bindFramebuffer(36160, A.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(36160, 36064 + V, 36161, null),
              t.bindFramebuffer(36160, A.__webglFramebuffer),
              n.framebufferTexture2D(36009, 36064 + V, 3553, null, 0);
        t.bindFramebuffer(36008, A.__webglMultisampledFramebuffer),
          t.bindFramebuffer(36009, A.__webglFramebuffer);
        for (let V = 0; V < F.length; V++) {
          q.push(36064 + V), B.depthBuffer && q.push(j);
          let Q = A.__ignoreDepthValues !== void 0 ? A.__ignoreDepthValues : !1;
          if (
            (Q === !1 &&
              (B.depthBuffer && (Te |= 256), B.stencilBuffer && (Te |= 1024)),
            D &&
              n.framebufferRenderbuffer(
                36008,
                36064,
                36161,
                A.__webglColorRenderbuffer[V]
              ),
            Q === !0 &&
              (n.invalidateFramebuffer(36008, [j]),
              n.invalidateFramebuffer(36009, [j])),
            D)
          ) {
            let ee = i.get(F[V]).__webglTexture;
            n.framebufferTexture2D(36009, 36064, 3553, ee, 0);
          }
          n.blitFramebuffer(0, 0, re, ve, 0, 0, re, ve, Te, 9728),
            m && n.invalidateFramebuffer(36008, q);
        }
        if ((t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), D))
          for (let V = 0; V < F.length; V++) {
            t.bindFramebuffer(36160, A.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                36160,
                36064 + V,
                36161,
                A.__webglColorRenderbuffer[V]
              );
            let Q = i.get(F[V]).__webglTexture;
            t.bindFramebuffer(36160, A.__webglFramebuffer),
              n.framebufferTexture2D(36009, 36064 + V, 3553, Q, 0);
          }
        t.bindFramebuffer(36009, A.__webglMultisampledFramebuffer);
      }
    }
    function Ie(B) {
      return Math.min(f, B.samples);
    }
    function Ue(B) {
      let F = i.get(B);
      return (
        o &&
        B.samples > 0 &&
        e.has("WEBGL_multisampled_render_to_texture") === !0 &&
        F.__useRenderToTexture !== !1
      );
    }
    function Ve(B) {
      let F = a.render.frame;
      x.get(B) !== F && (x.set(B, F), B.update());
    }
    function He(B, F) {
      let re = B.encoding,
        ve = B.format,
        Te = B.type;
      return (
        B.isCompressedTexture === !0 ||
          B.isVideoTexture === !0 ||
          B.format === ex ||
          (re !== ol &&
            (re === oi
              ? o === !1
                ? e.has("EXT_sRGB") === !0 && ve === Wr
                  ? ((B.format = ex),
                    (B.minFilter = Wn),
                    (B.generateMipmaps = !1))
                  : (F = hx.sRGBToLinear(F))
                : (ve !== Wr || Te !== sl) &&
                  console.warn(
                    "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                  )
              : console.error(
                  "THREE.WebGLTextures: Unsupported texture encoding:",
                  re
                ))),
        F
      );
    }
    (this.allocateTextureUnit = ce),
      (this.resetTextureUnits = he),
      (this.setTexture2D = Me),
      (this.setTexture2DArray = ge),
      (this.setTexture3D = pe),
      (this.setTextureCube = We),
      (this.rebindTextures = ie),
      (this.setupRenderTarget = ye),
      (this.updateRenderTargetMipmap = Pe),
      (this.updateMultisampleRenderTarget = De),
      (this.setupDepthRenderbuffer = Y),
      (this.setupFrameBufferTexture = Ze),
      (this.useMultisampledRTT = Ue);
  }
  function SG(n, e, t) {
    let i = t.isWebGL2;
    function r(s, a = null) {
      let o;
      if (s === sl) return 5121;
      if (s === hz) return 32819;
      if (s === fz) return 32820;
      if (s === lz) return 5120;
      if (s === cz) return 5122;
      if (s === tC) return 5123;
      if (s === uz) return 5124;
      if (s === tl) return 5125;
      if (s === Za) return 5126;
      if (s === fh)
        return i
          ? 5131
          : ((o = e.get("OES_texture_half_float")),
            o !== null ? o.HALF_FLOAT_OES : null);
      if (s === dz) return 6406;
      if (s === Wr) return 6408;
      if (s === mz) return 6409;
      if (s === gz) return 6410;
      if (s === il) return 6402;
      if (s === Ic) return 34041;
      if (s === pz)
        return (
          console.warn(
            "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
          ),
          6408
        );
      if (s === ex)
        return (o = e.get("EXT_sRGB")), o !== null ? o.SRGB_ALPHA_EXT : null;
      if (s === yz) return 6403;
      if (s === vz) return 36244;
      if (s === xz) return 33319;
      if (s === bz) return 33320;
      if (s === _z) return 36249;
      if (s === vv || s === xv || s === bv || s === _v)
        if (a === oi)
          if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
            if (s === vv) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (s === xv) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (s === bv) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (s === _v) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else return null;
        else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
          if (s === vv) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (s === xv) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (s === bv) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (s === _v) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else return null;
      if (s === IM || s === LM || s === RM || s === OM)
        if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
          if (s === IM) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (s === LM) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (s === RM) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (s === OM) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else return null;
      if (s === Ez)
        return (
          (o = e.get("WEBGL_compressed_texture_etc1")),
          o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
        );
      if (s === NM || s === kM)
        if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
          if (s === NM)
            return a === oi ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
          if (s === kM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
              : o.COMPRESSED_RGBA8_ETC2_EAC;
        } else return null;
      if (
        s === FM ||
        s === BM ||
        s === zM ||
        s === UM ||
        s === VM ||
        s === GM ||
        s === HM ||
        s === $M ||
        s === WM ||
        s === qM ||
        s === jM ||
        s === XM ||
        s === YM ||
        s === KM
      )
        if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
          if (s === FM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
              : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (s === BM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
              : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (s === zM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
              : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (s === UM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
              : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (s === VM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
              : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (s === GM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
              : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (s === HM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
              : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (s === $M)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
              : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (s === WM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
              : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (s === qM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
              : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (s === jM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
              : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (s === XM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
              : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (s === YM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
              : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (s === KM)
            return a === oi
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
              : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
        } else return null;
      if (s === JM)
        if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
          if (s === JM)
            return a === oi
              ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
              : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        } else return null;
      return s === Cc
        ? i
          ? 34042
          : ((o = e.get("WEBGL_depth_texture")),
            o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null)
        : n[s] !== void 0
        ? n[s]
        : null;
    }
    return { convert: r };
  }
  var SC = class extends yn {
      constructor(e = []) {
        super();
        (this.isArrayCamera = !0), (this.cameras = e);
      }
    },
    br = class extends Ai {
      constructor() {
        super();
        (this.isGroup = !0), (this.type = "Group");
      }
    },
    wG = { type: "move" },
    pp = class {
      constructor() {
        (this._targetRay = null), (this._grip = null), (this._hand = null);
      }
      getHandSpace() {
        return (
          this._hand === null &&
            ((this._hand = new br()),
            (this._hand.matrixAutoUpdate = !1),
            (this._hand.visible = !1),
            (this._hand.joints = {}),
            (this._hand.inputState = { pinching: !1 })),
          this._hand
        );
      }
      getTargetRaySpace() {
        return (
          this._targetRay === null &&
            ((this._targetRay = new br()),
            (this._targetRay.matrixAutoUpdate = !1),
            (this._targetRay.visible = !1),
            (this._targetRay.hasLinearVelocity = !1),
            (this._targetRay.linearVelocity = new le()),
            (this._targetRay.hasAngularVelocity = !1),
            (this._targetRay.angularVelocity = new le())),
          this._targetRay
        );
      }
      getGripSpace() {
        return (
          this._grip === null &&
            ((this._grip = new br()),
            (this._grip.matrixAutoUpdate = !1),
            (this._grip.visible = !1),
            (this._grip.hasLinearVelocity = !1),
            (this._grip.linearVelocity = new le()),
            (this._grip.hasAngularVelocity = !1),
            (this._grip.angularVelocity = new le())),
          this._grip
        );
      }
      dispatchEvent(e) {
        return (
          this._targetRay !== null && this._targetRay.dispatchEvent(e),
          this._grip !== null && this._grip.dispatchEvent(e),
          this._hand !== null && this._hand.dispatchEvent(e),
          this
        );
      }
      connect(e) {
        if (e && e.hand) {
          let t = this._hand;
          if (t) for (let i of e.hand.values()) this._getHandJoint(t, i);
        }
        return this.dispatchEvent({ type: "connected", data: e }), this;
      }
      disconnect(e) {
        return (
          this.dispatchEvent({ type: "disconnected", data: e }),
          this._targetRay !== null && (this._targetRay.visible = !1),
          this._grip !== null && (this._grip.visible = !1),
          this._hand !== null && (this._hand.visible = !1),
          this
        );
      }
      update(e, t, i) {
        let r = null,
          s = null,
          a = null,
          o = this._targetRay,
          l = this._grip,
          c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
          if (c && e.hand) {
            a = !0;
            for (let y of e.hand.values()) {
              let g = t.getJointPose(y, i),
                b = this._getHandJoint(c, y);
              g !== null &&
                (b.matrix.fromArray(g.transform.matrix),
                b.matrix.decompose(b.position, b.rotation, b.scale),
                (b.jointRadius = g.radius)),
                (b.visible = g !== null);
            }
            let u = c.joints["index-finger-tip"],
              f = c.joints["thumb-tip"],
              d = u.position.distanceTo(f.position),
              m = 0.02,
              x = 0.005;
            c.inputState.pinching && d > m + x
              ? ((c.inputState.pinching = !1),
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: e.handedness,
                  target: this,
                }))
              : !c.inputState.pinching &&
                d <= m - x &&
                ((c.inputState.pinching = !0),
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: e.handedness,
                  target: this,
                }));
          } else
            l !== null &&
              e.gripSpace &&
              ((s = t.getPose(e.gripSpace, i)),
              s !== null &&
                (l.matrix.fromArray(s.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                s.linearVelocity
                  ? ((l.hasLinearVelocity = !0),
                    l.linearVelocity.copy(s.linearVelocity))
                  : (l.hasLinearVelocity = !1),
                s.angularVelocity
                  ? ((l.hasAngularVelocity = !0),
                    l.angularVelocity.copy(s.angularVelocity))
                  : (l.hasAngularVelocity = !1)));
          o !== null &&
            ((r = t.getPose(e.targetRaySpace, i)),
            r === null && s !== null && (r = s),
            r !== null &&
              (o.matrix.fromArray(r.transform.matrix),
              o.matrix.decompose(o.position, o.rotation, o.scale),
              r.linearVelocity
                ? ((o.hasLinearVelocity = !0),
                  o.linearVelocity.copy(r.linearVelocity))
                : (o.hasLinearVelocity = !1),
              r.angularVelocity
                ? ((o.hasAngularVelocity = !0),
                  o.angularVelocity.copy(r.angularVelocity))
                : (o.hasAngularVelocity = !1),
              this.dispatchEvent(wG)));
        }
        return (
          o !== null && (o.visible = r !== null),
          l !== null && (l.visible = s !== null),
          c !== null && (c.visible = a !== null),
          this
        );
      }
      _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
          let i = new br();
          (i.matrixAutoUpdate = !1),
            (i.visible = !1),
            (e.joints[t.jointName] = i),
            e.add(i);
        }
        return e.joints[t.jointName];
      }
    },
    wC = class extends hn {
      constructor(e, t, i, r, s, a, o, l, c, u) {
        if (((u = u !== void 0 ? u : il), u !== il && u !== Ic))
          throw new Error(
            "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
          );
        i === void 0 && u === il && (i = tl),
          i === void 0 && u === Ic && (i = Cc);
        super(null, r, s, a, o, l, u, i, c);
        (this.isDepthTexture = !0),
          (this.image = { width: e, height: t }),
          (this.magFilter = o !== void 0 ? o : un),
          (this.minFilter = l !== void 0 ? l : un),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
    },
    MC = class extends Ds {
      constructor(e, t) {
        super();
        let i = this,
          r = null,
          s = 1,
          a = null,
          o = "local-floor",
          l = null,
          c = null,
          u = null,
          f = null,
          d = null,
          m = null,
          x = t.getContextAttributes(),
          y = null,
          g = null,
          b = [],
          _ = [],
          E = new Set(),
          w = new Map(),
          P = new yn();
        P.layers.enable(1), (P.viewport = new Ti());
        let L = new yn();
        L.layers.enable(2), (L.viewport = new Ti());
        let I = [P, L],
          M = new SC();
        M.layers.enable(1), M.layers.enable(2);
        let R = null,
          O = null;
        (this.cameraAutoUpdate = !0),
          (this.enabled = !1),
          (this.isPresenting = !1),
          (this.getController = function (ge) {
            let pe = b[ge];
            return (
              pe === void 0 && ((pe = new pp()), (b[ge] = pe)),
              pe.getTargetRaySpace()
            );
          }),
          (this.getControllerGrip = function (ge) {
            let pe = b[ge];
            return (
              pe === void 0 && ((pe = new pp()), (b[ge] = pe)),
              pe.getGripSpace()
            );
          }),
          (this.getHand = function (ge) {
            let pe = b[ge];
            return (
              pe === void 0 && ((pe = new pp()), (b[ge] = pe)),
              pe.getHandSpace()
            );
          });
        function U(ge) {
          let pe = _.indexOf(ge.inputSource);
          if (pe === -1) return;
          let We = b[pe];
          We !== void 0 &&
            We.dispatchEvent({ type: ge.type, data: ge.inputSource });
        }
        function X() {
          r.removeEventListener("select", U),
            r.removeEventListener("selectstart", U),
            r.removeEventListener("selectend", U),
            r.removeEventListener("squeeze", U),
            r.removeEventListener("squeezestart", U),
            r.removeEventListener("squeezeend", U),
            r.removeEventListener("end", X),
            r.removeEventListener("inputsourceschange", $);
          for (let ge = 0; ge < b.length; ge++) {
            let pe = _[ge];
            pe !== null && ((_[ge] = null), b[ge].disconnect(pe));
          }
          (R = null),
            (O = null),
            e.setRenderTarget(y),
            (d = null),
            (f = null),
            (u = null),
            (r = null),
            (g = null),
            Me.stop(),
            (i.isPresenting = !1),
            i.dispatchEvent({ type: "sessionend" });
        }
        (this.setFramebufferScaleFactor = function (ge) {
          (s = ge),
            i.isPresenting === !0 &&
              console.warn(
                "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
              );
        }),
          (this.setReferenceSpaceType = function (ge) {
            (o = ge),
              i.isPresenting === !0 &&
                console.warn(
                  "THREE.WebXRManager: Cannot change reference space type while presenting."
                );
          }),
          (this.getReferenceSpace = function () {
            return l || a;
          }),
          (this.setReferenceSpace = function (ge) {
            l = ge;
          }),
          (this.getBaseLayer = function () {
            return f !== null ? f : d;
          }),
          (this.getBinding = function () {
            return u;
          }),
          (this.getFrame = function () {
            return m;
          }),
          (this.getSession = function () {
            return r;
          }),
          (this.setSession = function (ge) {
            return Fr(this, null, function* () {
              if (((r = ge), r !== null)) {
                if (
                  ((y = e.getRenderTarget()),
                  r.addEventListener("select", U),
                  r.addEventListener("selectstart", U),
                  r.addEventListener("selectend", U),
                  r.addEventListener("squeeze", U),
                  r.addEventListener("squeezestart", U),
                  r.addEventListener("squeezeend", U),
                  r.addEventListener("end", X),
                  r.addEventListener("inputsourceschange", $),
                  x.xrCompatible !== !0 && (yield t.makeXRCompatible()),
                  r.renderState.layers === void 0 ||
                    e.capabilities.isWebGL2 === !1)
                ) {
                  let pe = {
                    antialias:
                      r.renderState.layers === void 0 ? x.antialias : !0,
                    alpha: x.alpha,
                    depth: x.depth,
                    stencil: x.stencil,
                    framebufferScaleFactor: s,
                  };
                  (d = new XRWebGLLayer(r, t, pe)),
                    r.updateRenderState({ baseLayer: d }),
                    (g = new to(d.framebufferWidth, d.framebufferHeight, {
                      format: Wr,
                      type: sl,
                      encoding: e.outputEncoding,
                      stencilBuffer: x.stencil,
                    }));
                } else {
                  let pe = null,
                    We = null,
                    Fe = null;
                  x.depth &&
                    ((Fe = x.stencil ? 35056 : 33190),
                    (pe = x.stencil ? Ic : il),
                    (We = x.stencil ? Cc : tl));
                  let Be = {
                    colorFormat: 32856,
                    depthFormat: Fe,
                    scaleFactor: s,
                  };
                  (u = new XRWebGLBinding(r, t)),
                    (f = u.createProjectionLayer(Be)),
                    r.updateRenderState({ layers: [f] }),
                    (g = new to(f.textureWidth, f.textureHeight, {
                      format: Wr,
                      type: sl,
                      depthTexture: new wC(
                        f.textureWidth,
                        f.textureHeight,
                        We,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        pe
                      ),
                      stencilBuffer: x.stencil,
                      encoding: e.outputEncoding,
                      samples: x.antialias ? 4 : 0,
                    }));
                  let be = e.properties.get(g);
                  be.__ignoreDepthValues = f.ignoreDepthValues;
                }
                (g.isXRRenderTarget = !0),
                  this.setFoveation(1),
                  (l = null),
                  (a = yield r.requestReferenceSpace(o)),
                  Me.setContext(r),
                  Me.start(),
                  (i.isPresenting = !0),
                  i.dispatchEvent({ type: "sessionstart" });
              }
            });
          });
        function $(ge) {
          for (let pe = 0; pe < ge.removed.length; pe++) {
            let We = ge.removed[pe],
              Fe = _.indexOf(We);
            Fe >= 0 && ((_[Fe] = null), b[Fe].disconnect(We));
          }
          for (let pe = 0; pe < ge.added.length; pe++) {
            let We = ge.added[pe],
              Fe = _.indexOf(We);
            if (Fe === -1) {
              for (let be = 0; be < b.length; be++)
                if (be >= _.length) {
                  _.push(We), (Fe = be);
                  break;
                } else if (_[be] === null) {
                  (_[be] = We), (Fe = be);
                  break;
                }
              if (Fe === -1) break;
            }
            let Be = b[Fe];
            Be && Be.connect(We);
          }
        }
        let W = new le(),
          ue = new le();
        function ae(ge, pe, We) {
          W.setFromMatrixPosition(pe.matrixWorld),
            ue.setFromMatrixPosition(We.matrixWorld);
          let Fe = W.distanceTo(ue),
            Be = pe.projectionMatrix.elements,
            be = We.projectionMatrix.elements,
            ut = Be[14] / (Be[10] - 1),
            Ye = Be[14] / (Be[10] + 1),
            _t = (Be[9] + 1) / Be[5],
            Ze = (Be[9] - 1) / Be[5],
            kt = (Be[8] - 1) / Be[0],
            Et = (be[8] + 1) / be[0],
            Y = ut * kt,
            ie = ut * Et,
            ye = Fe / (-kt + Et),
            Pe = ye * -kt;
          pe.matrixWorld.decompose(ge.position, ge.quaternion, ge.scale),
            ge.translateX(Pe),
            ge.translateZ(ye),
            ge.matrixWorld.compose(ge.position, ge.quaternion, ge.scale),
            ge.matrixWorldInverse.copy(ge.matrixWorld).invert();
          let De = ut + ye,
            Ie = Ye + ye,
            Ue = Y - Pe,
            Ve = ie + (Fe - Pe),
            He = ((_t * Ye) / Ie) * De,
            B = ((Ze * Ye) / Ie) * De;
          ge.projectionMatrix.makePerspective(Ue, Ve, He, B, De, Ie);
        }
        function he(ge, pe) {
          pe === null
            ? ge.matrixWorld.copy(ge.matrix)
            : ge.matrixWorld.multiplyMatrices(pe.matrixWorld, ge.matrix),
            ge.matrixWorldInverse.copy(ge.matrixWorld).invert();
        }
        (this.updateCamera = function (ge) {
          if (r === null) return;
          (M.near = L.near = P.near = ge.near),
            (M.far = L.far = P.far = ge.far),
            (R !== M.near || O !== M.far) &&
              (r.updateRenderState({ depthNear: M.near, depthFar: M.far }),
              (R = M.near),
              (O = M.far));
          let pe = ge.parent,
            We = M.cameras;
          he(M, pe);
          for (let Be = 0; Be < We.length; Be++) he(We[Be], pe);
          M.matrixWorld.decompose(M.position, M.quaternion, M.scale),
            ge.matrix.copy(M.matrix),
            ge.matrix.decompose(ge.position, ge.quaternion, ge.scale);
          let Fe = ge.children;
          for (let Be = 0, be = Fe.length; Be < be; Be++)
            Fe[Be].updateMatrixWorld(!0);
          We.length === 2
            ? ae(M, P, L)
            : M.projectionMatrix.copy(P.projectionMatrix);
        }),
          (this.getCamera = function () {
            return M;
          }),
          (this.getFoveation = function () {
            if (f !== null) return f.fixedFoveation;
            if (d !== null) return d.fixedFoveation;
          }),
          (this.setFoveation = function (ge) {
            f !== null && (f.fixedFoveation = ge),
              d !== null &&
                d.fixedFoveation !== void 0 &&
                (d.fixedFoveation = ge);
          }),
          (this.getPlanes = function () {
            return E;
          });
        let ce = null;
        function te(ge, pe) {
          if (((c = pe.getViewerPose(l || a)), (m = pe), c !== null)) {
            let We = c.views;
            d !== null &&
              (e.setRenderTargetFramebuffer(g, d.framebuffer),
              e.setRenderTarget(g));
            let Fe = !1;
            We.length !== M.cameras.length &&
              ((M.cameras.length = 0), (Fe = !0));
            for (let Be = 0; Be < We.length; Be++) {
              let be = We[Be],
                ut = null;
              if (d !== null) ut = d.getViewport(be);
              else {
                let _t = u.getViewSubImage(f, be);
                (ut = _t.viewport),
                  Be === 0 &&
                    (e.setRenderTargetTextures(
                      g,
                      _t.colorTexture,
                      f.ignoreDepthValues ? void 0 : _t.depthStencilTexture
                    ),
                    e.setRenderTarget(g));
              }
              let Ye = I[Be];
              Ye === void 0 &&
                ((Ye = new yn()),
                Ye.layers.enable(Be),
                (Ye.viewport = new Ti()),
                (I[Be] = Ye)),
                Ye.matrix.fromArray(be.transform.matrix),
                Ye.projectionMatrix.fromArray(be.projectionMatrix),
                Ye.viewport.set(ut.x, ut.y, ut.width, ut.height),
                Be === 0 && M.matrix.copy(Ye.matrix),
                Fe === !0 && M.cameras.push(Ye);
            }
          }
          for (let We = 0; We < b.length; We++) {
            let Fe = _[We],
              Be = b[We];
            Fe !== null && Be !== void 0 && Be.update(Fe, pe, l || a);
          }
          if ((ce && ce(ge, pe), pe.detectedPlanes)) {
            i.dispatchEvent({
              type: "planesdetected",
              data: pe.detectedPlanes,
            });
            let We = null;
            for (let Fe of E)
              pe.detectedPlanes.has(Fe) ||
                (We === null && (We = []), We.push(Fe));
            if (We !== null)
              for (let Fe of We)
                E.delete(Fe),
                  w.delete(Fe),
                  i.dispatchEvent({ type: "planeremoved", data: Fe });
            for (let Fe of pe.detectedPlanes)
              if (!E.has(Fe))
                E.add(Fe),
                  w.set(Fe, pe.lastChangedTime),
                  i.dispatchEvent({ type: "planeadded", data: Fe });
              else {
                let Be = w.get(Fe);
                Fe.lastChangedTime > Be &&
                  (w.set(Fe, Fe.lastChangedTime),
                  i.dispatchEvent({ type: "planechanged", data: Fe }));
              }
          }
          m = null;
        }
        let Me = new fC();
        Me.setAnimationLoop(te),
          (this.setAnimationLoop = function (ge) {
            ce = ge;
          }),
          (this.dispose = function () {});
      }
    };
  function MG(n, e) {
    function t(y, g) {
      g.color.getRGB(y.fogColor.value, cC(n)),
        g.isFog
          ? ((y.fogNear.value = g.near), (y.fogFar.value = g.far))
          : g.isFogExp2 && (y.fogDensity.value = g.density);
    }
    function i(y, g, b, _, E) {
      g.isMeshBasicMaterial || g.isMeshLambertMaterial
        ? r(y, g)
        : g.isMeshToonMaterial
        ? (r(y, g), u(y, g))
        : g.isMeshPhongMaterial
        ? (r(y, g), c(y, g))
        : g.isMeshStandardMaterial
        ? (r(y, g), f(y, g), g.isMeshPhysicalMaterial && d(y, g, E))
        : g.isMeshMatcapMaterial
        ? (r(y, g), m(y, g))
        : g.isMeshDepthMaterial
        ? r(y, g)
        : g.isMeshDistanceMaterial
        ? (r(y, g), x(y, g))
        : g.isMeshNormalMaterial
        ? r(y, g)
        : g.isLineBasicMaterial
        ? (s(y, g), g.isLineDashedMaterial && a(y, g))
        : g.isPointsMaterial
        ? o(y, g, b, _)
        : g.isSpriteMaterial
        ? l(y, g)
        : g.isShadowMaterial
        ? (y.color.value.copy(g.color), (y.opacity.value = g.opacity))
        : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
    }
    function r(y, g) {
      (y.opacity.value = g.opacity),
        g.color && y.diffuse.value.copy(g.color),
        g.emissive &&
          y.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
        g.map && (y.map.value = g.map),
        g.alphaMap && (y.alphaMap.value = g.alphaMap),
        g.bumpMap &&
          ((y.bumpMap.value = g.bumpMap),
          (y.bumpScale.value = g.bumpScale),
          g.side === qr && (y.bumpScale.value *= -1)),
        g.displacementMap &&
          ((y.displacementMap.value = g.displacementMap),
          (y.displacementScale.value = g.displacementScale),
          (y.displacementBias.value = g.displacementBias)),
        g.emissiveMap && (y.emissiveMap.value = g.emissiveMap),
        g.normalMap &&
          ((y.normalMap.value = g.normalMap),
          y.normalScale.value.copy(g.normalScale),
          g.side === qr && y.normalScale.value.negate()),
        g.specularMap && (y.specularMap.value = g.specularMap),
        g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
      let b = e.get(g).envMap;
      if (
        (b &&
          ((y.envMap.value = b),
          (y.flipEnvMap.value =
            b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1),
          (y.reflectivity.value = g.reflectivity),
          (y.ior.value = g.ior),
          (y.refractionRatio.value = g.refractionRatio)),
        g.lightMap)
      ) {
        y.lightMap.value = g.lightMap;
        let w = n.physicallyCorrectLights !== !0 ? Math.PI : 1;
        y.lightMapIntensity.value = g.lightMapIntensity * w;
      }
      g.aoMap &&
        ((y.aoMap.value = g.aoMap),
        (y.aoMapIntensity.value = g.aoMapIntensity));
      let _;
      g.map
        ? (_ = g.map)
        : g.specularMap
        ? (_ = g.specularMap)
        : g.displacementMap
        ? (_ = g.displacementMap)
        : g.normalMap
        ? (_ = g.normalMap)
        : g.bumpMap
        ? (_ = g.bumpMap)
        : g.roughnessMap
        ? (_ = g.roughnessMap)
        : g.metalnessMap
        ? (_ = g.metalnessMap)
        : g.alphaMap
        ? (_ = g.alphaMap)
        : g.emissiveMap
        ? (_ = g.emissiveMap)
        : g.clearcoatMap
        ? (_ = g.clearcoatMap)
        : g.clearcoatNormalMap
        ? (_ = g.clearcoatNormalMap)
        : g.clearcoatRoughnessMap
        ? (_ = g.clearcoatRoughnessMap)
        : g.iridescenceMap
        ? (_ = g.iridescenceMap)
        : g.iridescenceThicknessMap
        ? (_ = g.iridescenceThicknessMap)
        : g.specularIntensityMap
        ? (_ = g.specularIntensityMap)
        : g.specularColorMap
        ? (_ = g.specularColorMap)
        : g.transmissionMap
        ? (_ = g.transmissionMap)
        : g.thicknessMap
        ? (_ = g.thicknessMap)
        : g.sheenColorMap
        ? (_ = g.sheenColorMap)
        : g.sheenRoughnessMap && (_ = g.sheenRoughnessMap),
        _ !== void 0 &&
          (_.isWebGLRenderTarget && (_ = _.texture),
          _.matrixAutoUpdate === !0 && _.updateMatrix(),
          y.uvTransform.value.copy(_.matrix));
      let E;
      g.aoMap ? (E = g.aoMap) : g.lightMap && (E = g.lightMap),
        E !== void 0 &&
          (E.isWebGLRenderTarget && (E = E.texture),
          E.matrixAutoUpdate === !0 && E.updateMatrix(),
          y.uv2Transform.value.copy(E.matrix));
    }
    function s(y, g) {
      y.diffuse.value.copy(g.color), (y.opacity.value = g.opacity);
    }
    function a(y, g) {
      (y.dashSize.value = g.dashSize),
        (y.totalSize.value = g.dashSize + g.gapSize),
        (y.scale.value = g.scale);
    }
    function o(y, g, b, _) {
      y.diffuse.value.copy(g.color),
        (y.opacity.value = g.opacity),
        (y.size.value = g.size * b),
        (y.scale.value = _ * 0.5),
        g.map && (y.map.value = g.map),
        g.alphaMap && (y.alphaMap.value = g.alphaMap),
        g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
      let E;
      g.map ? (E = g.map) : g.alphaMap && (E = g.alphaMap),
        E !== void 0 &&
          (E.matrixAutoUpdate === !0 && E.updateMatrix(),
          y.uvTransform.value.copy(E.matrix));
    }
    function l(y, g) {
      y.diffuse.value.copy(g.color),
        (y.opacity.value = g.opacity),
        (y.rotation.value = g.rotation),
        g.map && (y.map.value = g.map),
        g.alphaMap && (y.alphaMap.value = g.alphaMap),
        g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
      let b;
      g.map ? (b = g.map) : g.alphaMap && (b = g.alphaMap),
        b !== void 0 &&
          (b.matrixAutoUpdate === !0 && b.updateMatrix(),
          y.uvTransform.value.copy(b.matrix));
    }
    function c(y, g) {
      y.specular.value.copy(g.specular),
        (y.shininess.value = Math.max(g.shininess, 1e-4));
    }
    function u(y, g) {
      g.gradientMap && (y.gradientMap.value = g.gradientMap);
    }
    function f(y, g) {
      (y.roughness.value = g.roughness),
        (y.metalness.value = g.metalness),
        g.roughnessMap && (y.roughnessMap.value = g.roughnessMap),
        g.metalnessMap && (y.metalnessMap.value = g.metalnessMap),
        e.get(g).envMap && (y.envMapIntensity.value = g.envMapIntensity);
    }
    function d(y, g, b) {
      (y.ior.value = g.ior),
        g.sheen > 0 &&
          (y.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
          (y.sheenRoughness.value = g.sheenRoughness),
          g.sheenColorMap && (y.sheenColorMap.value = g.sheenColorMap),
          g.sheenRoughnessMap &&
            (y.sheenRoughnessMap.value = g.sheenRoughnessMap)),
        g.clearcoat > 0 &&
          ((y.clearcoat.value = g.clearcoat),
          (y.clearcoatRoughness.value = g.clearcoatRoughness),
          g.clearcoatMap && (y.clearcoatMap.value = g.clearcoatMap),
          g.clearcoatRoughnessMap &&
            (y.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
          g.clearcoatNormalMap &&
            (y.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
            (y.clearcoatNormalMap.value = g.clearcoatNormalMap),
            g.side === qr && y.clearcoatNormalScale.value.negate())),
        g.iridescence > 0 &&
          ((y.iridescence.value = g.iridescence),
          (y.iridescenceIOR.value = g.iridescenceIOR),
          (y.iridescenceThicknessMinimum.value =
            g.iridescenceThicknessRange[0]),
          (y.iridescenceThicknessMaximum.value =
            g.iridescenceThicknessRange[1]),
          g.iridescenceMap && (y.iridescenceMap.value = g.iridescenceMap),
          g.iridescenceThicknessMap &&
            (y.iridescenceThicknessMap.value = g.iridescenceThicknessMap)),
        g.transmission > 0 &&
          ((y.transmission.value = g.transmission),
          (y.transmissionSamplerMap.value = b.texture),
          y.transmissionSamplerSize.value.set(b.width, b.height),
          g.transmissionMap && (y.transmissionMap.value = g.transmissionMap),
          (y.thickness.value = g.thickness),
          g.thicknessMap && (y.thicknessMap.value = g.thicknessMap),
          (y.attenuationDistance.value = g.attenuationDistance),
          y.attenuationColor.value.copy(g.attenuationColor)),
        (y.specularIntensity.value = g.specularIntensity),
        y.specularColor.value.copy(g.specularColor),
        g.specularIntensityMap &&
          (y.specularIntensityMap.value = g.specularIntensityMap),
        g.specularColorMap && (y.specularColorMap.value = g.specularColorMap);
    }
    function m(y, g) {
      g.matcap && (y.matcap.value = g.matcap);
    }
    function x(y, g) {
      y.referencePosition.value.copy(g.referencePosition),
        (y.nearDistance.value = g.nearDistance),
        (y.farDistance.value = g.farDistance);
    }
    return { refreshFogUniforms: t, refreshMaterialUniforms: i };
  }
  function AG(n, e, t, i) {
    let r = {},
      s = {},
      a = [],
      o = t.isWebGL2 ? n.getParameter(35375) : 0;
    function l(_, E) {
      let w = E.program;
      i.uniformBlockBinding(_, w);
    }
    function c(_, E) {
      let w = r[_.id];
      w === void 0 &&
        (x(_), (w = u(_)), (r[_.id] = w), _.addEventListener("dispose", g));
      let P = E.program;
      i.updateUBOMapping(_, P);
      let L = e.render.frame;
      s[_.id] !== L && (d(_), (s[_.id] = L));
    }
    function u(_) {
      let E = f();
      _.__bindingPointIndex = E;
      let w = n.createBuffer(),
        P = _.__size,
        L = _.usage;
      return (
        n.bindBuffer(35345, w),
        n.bufferData(35345, P, L),
        n.bindBuffer(35345, null),
        n.bindBufferBase(35345, E, w),
        w
      );
    }
    function f() {
      for (let _ = 0; _ < o; _++) if (a.indexOf(_) === -1) return a.push(_), _;
      return (
        console.error(
          "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
        ),
        0
      );
    }
    function d(_) {
      let E = r[_.id],
        w = _.uniforms,
        P = _.__cache;
      n.bindBuffer(35345, E);
      for (let L = 0, I = w.length; L < I; L++) {
        let M = w[L];
        if (m(M, L, P) === !0) {
          let R = M.__offset,
            O = Array.isArray(M.value) ? M.value : [M.value],
            U = 0;
          for (let X = 0; X < O.length; X++) {
            let $ = O[X],
              W = y($);
            typeof $ == "number"
              ? ((M.__data[0] = $), n.bufferSubData(35345, R + U, M.__data))
              : $.isMatrix3
              ? ((M.__data[0] = $.elements[0]),
                (M.__data[1] = $.elements[1]),
                (M.__data[2] = $.elements[2]),
                (M.__data[3] = $.elements[0]),
                (M.__data[4] = $.elements[3]),
                (M.__data[5] = $.elements[4]),
                (M.__data[6] = $.elements[5]),
                (M.__data[7] = $.elements[0]),
                (M.__data[8] = $.elements[6]),
                (M.__data[9] = $.elements[7]),
                (M.__data[10] = $.elements[8]),
                (M.__data[11] = $.elements[0]))
              : ($.toArray(M.__data, U),
                (U += W.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          n.bufferSubData(35345, R, M.__data);
        }
      }
      n.bindBuffer(35345, null);
    }
    function m(_, E, w) {
      let P = _.value;
      if (w[E] === void 0) {
        if (typeof P == "number") w[E] = P;
        else {
          let L = Array.isArray(P) ? P : [P],
            I = [];
          for (let M = 0; M < L.length; M++) I.push(L[M].clone());
          w[E] = I;
        }
        return !0;
      } else if (typeof P == "number") {
        if (w[E] !== P) return (w[E] = P), !0;
      } else {
        let L = Array.isArray(w[E]) ? w[E] : [w[E]],
          I = Array.isArray(P) ? P : [P];
        for (let M = 0; M < L.length; M++) {
          let R = L[M];
          if (R.equals(I[M]) === !1) return R.copy(I[M]), !0;
        }
      }
      return !1;
    }
    function x(_) {
      let E = _.uniforms,
        w = 0,
        P = 16,
        L = 0;
      for (let I = 0, M = E.length; I < M; I++) {
        let R = E[I],
          O = { boundary: 0, storage: 0 },
          U = Array.isArray(R.value) ? R.value : [R.value];
        for (let X = 0, $ = U.length; X < $; X++) {
          let W = U[X],
            ue = y(W);
          (O.boundary += ue.boundary), (O.storage += ue.storage);
        }
        if (
          ((R.__data = new Float32Array(
            O.storage / Float32Array.BYTES_PER_ELEMENT
          )),
          (R.__offset = w),
          I > 0)
        ) {
          L = w % P;
          let X = P - L;
          L !== 0 && X - O.boundary < 0 && ((w += P - L), (R.__offset = w));
        }
        w += O.storage;
      }
      return (
        (L = w % P),
        L > 0 && (w += P - L),
        (_.__size = w),
        (_.__cache = {}),
        this
      );
    }
    function y(_) {
      let E = { boundary: 0, storage: 0 };
      return (
        typeof _ == "number"
          ? ((E.boundary = 4), (E.storage = 4))
          : _.isVector2
          ? ((E.boundary = 8), (E.storage = 8))
          : _.isVector3 || _.isColor
          ? ((E.boundary = 16), (E.storage = 12))
          : _.isVector4
          ? ((E.boundary = 16), (E.storage = 16))
          : _.isMatrix3
          ? ((E.boundary = 48), (E.storage = 48))
          : _.isMatrix4
          ? ((E.boundary = 64), (E.storage = 64))
          : _.isTexture
          ? console.warn(
              "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
            )
          : console.warn(
              "THREE.WebGLRenderer: Unsupported uniform value type.",
              _
            ),
        E
      );
    }
    function g(_) {
      let E = _.target;
      E.removeEventListener("dispose", g);
      let w = a.indexOf(E.__bindingPointIndex);
      a.splice(w, 1), n.deleteBuffer(r[E.id]), delete r[E.id], delete s[E.id];
    }
    function b() {
      for (let _ in r) n.deleteBuffer(r[_]);
      (a = []), (r = {}), (s = {});
    }
    return { bind: l, update: c, dispose: b };
  }
  function CG() {
    let n = mh("canvas");
    return (n.style.display = "block"), n;
  }
  function xh(n = {}) {
    this.isWebGLRenderer = !0;
    let e = n.canvas !== void 0 ? n.canvas : CG(),
      t = n.context !== void 0 ? n.context : null,
      i = n.depth !== void 0 ? n.depth : !0,
      r = n.stencil !== void 0 ? n.stencil : !0,
      s = n.antialias !== void 0 ? n.antialias : !1,
      a = n.premultipliedAlpha !== void 0 ? n.premultipliedAlpha : !0,
      o = n.preserveDrawingBuffer !== void 0 ? n.preserveDrawingBuffer : !1,
      l = n.powerPreference !== void 0 ? n.powerPreference : "default",
      c =
        n.failIfMajorPerformanceCaveat !== void 0
          ? n.failIfMajorPerformanceCaveat
          : !1,
      u;
    t !== null
      ? (u = t.getContextAttributes().alpha)
      : (u = n.alpha !== void 0 ? n.alpha : !1);
    let f = null,
      d = null,
      m = [],
      x = [];
    (this.domElement = e),
      (this.debug = { checkShaderErrors: !0 }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputEncoding = ol),
      (this.physicallyCorrectLights = !1),
      (this.toneMapping = sa),
      (this.toneMappingExposure = 1);
    let y = this,
      g = !1,
      b = 0,
      _ = 0,
      E = null,
      w = -1,
      P = null,
      L = new Ti(),
      I = new Ti(),
      M = null,
      R = e.width,
      O = e.height,
      U = 1,
      X = null,
      $ = null,
      W = new Ti(0, 0, R, O),
      ue = new Ti(0, 0, R, O),
      ae = !1,
      he = new bp(),
      ce = !1,
      te = !1,
      Me = null,
      ge = new Wt(),
      pe = new It(),
      We = new le(),
      Fe = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Be() {
      return E === null ? U : 1;
    }
    let be = t;
    function ut(K, me) {
      for (let Oe = 0; Oe < K.length; Oe++) {
        let de = K[Oe],
          Ne = e.getContext(de, me);
        if (Ne !== null) return Ne;
      }
      return null;
    }
    try {
      let K = {
        alpha: !0,
        depth: i,
        stencil: r,
        antialias: s,
        premultipliedAlpha: a,
        preserveDrawingBuffer: o,
        powerPreference: l,
        failIfMajorPerformanceCaveat: c,
      };
      if (
        ("setAttribute" in e &&
          e.setAttribute("data-engine", `three.js r${ax}`),
        e.addEventListener("webglcontextlost", _e, !1),
        e.addEventListener("webglcontextrestored", Re, !1),
        e.addEventListener("webglcontextcreationerror", Ee, !1),
        be === null)
      ) {
        let me = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (y.isWebGL1Renderer === !0 && me.shift(),
          (be = ut(me, K)),
          be === null)
        )
          throw ut(me)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      be.getShaderPrecisionFormat === void 0 &&
        (be.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
    } catch (K) {
      throw (console.error("THREE.WebGLRenderer: " + K.message), K);
    }
    let Ye,
      _t,
      Ze,
      kt,
      Et,
      Y,
      ie,
      ye,
      Pe,
      De,
      Ie,
      Ue,
      Ve,
      He,
      B,
      F,
      re,
      ve,
      Te,
      q,
      j,
      A,
      D,
      V;
    function Q() {
      (Ye = new YV(be)),
        (_t = new HV(be, Ye, n)),
        Ye.init(_t),
        (A = new SG(be, Ye, _t)),
        (Ze = new EG(be, Ye, _t)),
        (kt = new ZV()),
        (Et = new uG()),
        (Y = new TG(be, Ye, Ze, Et, _t, A, kt)),
        (ie = new WV(y)),
        (ye = new XV(y)),
        (Pe = new oU(be, _t)),
        (D = new VV(be, Ye, Pe, _t)),
        (De = new KV(be, Pe, kt, D)),
        (Ie = new i8(be, De, Pe, kt)),
        (Te = new t8(be, _t, Y)),
        (F = new $V(Et)),
        (Ue = new cG(y, ie, ye, Ye, _t, D, F)),
        (Ve = new MG(y, Et)),
        (He = new fG()),
        (B = new vG(Ye, _t)),
        (ve = new UV(y, ie, ye, Ze, Ie, u, a)),
        (re = new _G(y, Ie, _t)),
        (V = new AG(be, kt, _t, Ze)),
        (q = new GV(be, Ye, kt, _t)),
        (j = new JV(be, Ye, kt, _t)),
        (kt.programs = Ue.programs),
        (y.capabilities = _t),
        (y.extensions = Ye),
        (y.properties = Et),
        (y.renderLists = He),
        (y.shadowMap = re),
        (y.state = Ze),
        (y.info = kt);
    }
    Q();
    let ee = new MC(y, be);
    (this.xr = ee),
      (this.getContext = function () {
        return be;
      }),
      (this.getContextAttributes = function () {
        return be.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        let K = Ye.get("WEBGL_lose_context");
        K && K.loseContext();
      }),
      (this.forceContextRestore = function () {
        let K = Ye.get("WEBGL_lose_context");
        K && K.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return U;
      }),
      (this.setPixelRatio = function (K) {
        K !== void 0 && ((U = K), this.setSize(R, O, !1));
      }),
      (this.getSize = function (K) {
        return K.set(R, O);
      }),
      (this.setSize = function (K, me, Oe) {
        if (ee.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (R = K),
          (O = me),
          (e.width = Math.floor(K * U)),
          (e.height = Math.floor(me * U)),
          Oe !== !1 &&
            ((e.style.width = K + "px"), (e.style.height = me + "px")),
          this.setViewport(0, 0, K, me);
      }),
      (this.getDrawingBufferSize = function (K) {
        return K.set(R * U, O * U).floor();
      }),
      (this.setDrawingBufferSize = function (K, me, Oe) {
        (R = K),
          (O = me),
          (U = Oe),
          (e.width = Math.floor(K * Oe)),
          (e.height = Math.floor(me * Oe)),
          this.setViewport(0, 0, K, me);
      }),
      (this.getCurrentViewport = function (K) {
        return K.copy(L);
      }),
      (this.getViewport = function (K) {
        return K.copy(W);
      }),
      (this.setViewport = function (K, me, Oe, de) {
        K.isVector4 ? W.set(K.x, K.y, K.z, K.w) : W.set(K, me, Oe, de),
          Ze.viewport(L.copy(W).multiplyScalar(U).floor());
      }),
      (this.getScissor = function (K) {
        return K.copy(ue);
      }),
      (this.setScissor = function (K, me, Oe, de) {
        K.isVector4 ? ue.set(K.x, K.y, K.z, K.w) : ue.set(K, me, Oe, de),
          Ze.scissor(I.copy(ue).multiplyScalar(U).floor());
      }),
      (this.getScissorTest = function () {
        return ae;
      }),
      (this.setScissorTest = function (K) {
        Ze.setScissorTest((ae = K));
      }),
      (this.setOpaqueSort = function (K) {
        X = K;
      }),
      (this.setTransparentSort = function (K) {
        $ = K;
      }),
      (this.getClearColor = function (K) {
        return K.copy(ve.getClearColor());
      }),
      (this.setClearColor = function () {
        ve.setClearColor.apply(ve, arguments);
      }),
      (this.getClearAlpha = function () {
        return ve.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        ve.setClearAlpha.apply(ve, arguments);
      }),
      (this.clear = function (K = !0, me = !0, Oe = !0) {
        let de = 0;
        K && (de |= 16384), me && (de |= 256), Oe && (de |= 1024), be.clear(de);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        e.removeEventListener("webglcontextlost", _e, !1),
          e.removeEventListener("webglcontextrestored", Re, !1),
          e.removeEventListener("webglcontextcreationerror", Ee, !1),
          He.dispose(),
          B.dispose(),
          Et.dispose(),
          ie.dispose(),
          ye.dispose(),
          Ie.dispose(),
          D.dispose(),
          V.dispose(),
          Ue.dispose(),
          ee.dispose(),
          ee.removeEventListener("sessionstart", qe),
          ee.removeEventListener("sessionend", ot),
          Me && (Me.dispose(), (Me = null)),
          Ct.stop();
      });
    function _e(K) {
      K.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (g = !0);
    }
    function Re() {
      console.log("THREE.WebGLRenderer: Context Restored."), (g = !1);
      let K = kt.autoReset,
        me = re.enabled,
        Oe = re.autoUpdate,
        de = re.needsUpdate,
        Ne = re.type;
      Q(),
        (kt.autoReset = K),
        (re.enabled = me),
        (re.autoUpdate = Oe),
        (re.needsUpdate = de),
        (re.type = Ne);
    }
    function Ee(K) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        K.statusMessage
      );
    }
    function Se(K) {
      let me = K.target;
      me.removeEventListener("dispose", Se), st(me);
    }
    function st(K) {
      Z(K), Et.remove(K);
    }
    function Z(K) {
      let me = Et.get(K).programs;
      me !== void 0 &&
        (me.forEach(function (Oe) {
          Ue.releaseProgram(Oe);
        }),
        K.isShaderMaterial && Ue.releaseShaderCache(K));
    }
    (this.renderBufferDirect = function (K, me, Oe, de, Ne, At) {
      me === null && (me = Fe);
      let Rt = Ne.isMesh && Ne.matrixWorld.determinant() < 0,
        Ht = fr(K, me, Oe, de, Ne);
      Ze.setMaterial(de, Rt);
      let Ut = Oe.index,
        ti = 1;
      de.wireframe === !0 && ((Ut = De.getWireframeAttribute(Oe)), (ti = 2));
      let ii = Oe.drawRange,
        Jt = Oe.attributes.position,
        Hi = ii.start * ti,
        Fn = (ii.start + ii.count) * ti;
      At !== null &&
        ((Hi = Math.max(Hi, At.start * ti)),
        (Fn = Math.min(Fn, (At.start + At.count) * ti))),
        Ut !== null
          ? ((Hi = Math.max(Hi, 0)), (Fn = Math.min(Fn, Ut.count)))
          : Jt != null &&
            ((Hi = Math.max(Hi, 0)), (Fn = Math.min(Fn, Jt.count)));
      let vs = Fn - Hi;
      if (vs < 0 || vs === 1 / 0) return;
      D.setup(Ne, de, Ht, Oe, Ut);
      let Or,
        Ci = q;
      if (
        (Ut !== null && ((Or = Pe.get(Ut)), (Ci = j), Ci.setIndex(Or)),
        Ne.isMesh)
      )
        de.wireframe === !0
          ? (Ze.setLineWidth(de.wireframeLinewidth * Be()), Ci.setMode(1))
          : Ci.setMode(4);
      else if (Ne.isLine) {
        let Qt = de.linewidth;
        Qt === void 0 && (Qt = 1),
          Ze.setLineWidth(Qt * Be()),
          Ne.isLineSegments
            ? Ci.setMode(1)
            : Ne.isLineLoop
            ? Ci.setMode(2)
            : Ci.setMode(3);
      } else Ne.isPoints ? Ci.setMode(0) : Ne.isSprite && Ci.setMode(4);
      if (Ne.isInstancedMesh) Ci.renderInstances(Hi, vs, Ne.count);
      else if (Oe.isInstancedBufferGeometry) {
        let Qt = Oe._maxInstanceCount !== void 0 ? Oe._maxInstanceCount : 1 / 0,
          Ra = Math.min(Oe.instanceCount, Qt);
        Ci.renderInstances(Hi, vs, Ra);
      } else Ci.render(Hi, vs);
    }),
      (this.compile = function (K, me) {
        function Oe(de, Ne, At) {
          de.transparent === !0 && de.side === Hd
            ? ((de.side = qr),
              (de.needsUpdate = !0),
              xn(de, Ne, At),
              (de.side = aa),
              (de.needsUpdate = !0),
              xn(de, Ne, At),
              (de.side = Hd))
            : xn(de, Ne, At);
        }
        (d = B.get(K)),
          d.init(),
          x.push(d),
          K.traverseVisible(function (de) {
            de.isLight &&
              de.layers.test(me.layers) &&
              (d.pushLight(de), de.castShadow && d.pushShadow(de));
          }),
          d.setupLights(y.physicallyCorrectLights),
          K.traverse(function (de) {
            let Ne = de.material;
            if (Ne)
              if (Array.isArray(Ne))
                for (let At = 0; At < Ne.length; At++) {
                  let Rt = Ne[At];
                  Oe(Rt, K, de);
                }
              else Oe(Ne, K, de);
          }),
          x.pop(),
          (d = null);
      });
    let fe = null;
    function Le(K) {
      fe && fe(K);
    }
    function qe() {
      Ct.stop();
    }
    function ot() {
      Ct.start();
    }
    let Ct = new fC();
    Ct.setAnimationLoop(Le),
      typeof self != "undefined" && Ct.setContext(self),
      (this.setAnimationLoop = function (K) {
        (fe = K), ee.setAnimationLoop(K), K === null ? Ct.stop() : Ct.start();
      }),
      ee.addEventListener("sessionstart", qe),
      ee.addEventListener("sessionend", ot),
      (this.render = function (K, me) {
        if (me !== void 0 && me.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (g === !0) return;
        K.matrixWorldAutoUpdate === !0 && K.updateMatrixWorld(),
          me.parent === null &&
            me.matrixWorldAutoUpdate === !0 &&
            me.updateMatrixWorld(),
          ee.enabled === !0 &&
            ee.isPresenting === !0 &&
            (ee.cameraAutoUpdate === !0 && ee.updateCamera(me),
            (me = ee.getCamera())),
          K.isScene === !0 && K.onBeforeRender(y, K, me, E),
          (d = B.get(K, x.length)),
          d.init(),
          x.push(d),
          ge.multiplyMatrices(me.projectionMatrix, me.matrixWorldInverse),
          he.setFromProjectionMatrix(ge),
          (te = this.localClippingEnabled),
          (ce = F.init(this.clippingPlanes, te, me)),
          (f = He.get(K, m.length)),
          f.init(),
          m.push(f),
          zt(K, me, 0, y.sortObjects),
          f.finish(),
          y.sortObjects === !0 && f.sort(X, $),
          ce === !0 && F.beginShadows();
        let Oe = d.state.shadowsArray;
        if (
          (re.render(Oe, K, me),
          ce === !0 && F.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          ve.render(f, K),
          d.setupLights(y.physicallyCorrectLights),
          me.isArrayCamera)
        ) {
          let de = me.cameras;
          for (let Ne = 0, At = de.length; Ne < At; Ne++) {
            let Rt = de[Ne];
            gi(f, K, Rt, Rt.viewport);
          }
        } else gi(f, K, me);
        E !== null &&
          (Y.updateMultisampleRenderTarget(E), Y.updateRenderTargetMipmap(E)),
          K.isScene === !0 && K.onAfterRender(y, K, me),
          D.resetDefaultState(),
          (w = -1),
          (P = null),
          x.pop(),
          x.length > 0 ? (d = x[x.length - 1]) : (d = null),
          m.pop(),
          m.length > 0 ? (f = m[m.length - 1]) : (f = null);
      });
    function zt(K, me, Oe, de) {
      if (K.visible === !1) return;
      if (K.layers.test(me.layers)) {
        if (K.isGroup) Oe = K.renderOrder;
        else if (K.isLOD) K.autoUpdate === !0 && K.update(me);
        else if (K.isLight) d.pushLight(K), K.castShadow && d.pushShadow(K);
        else if (K.isSprite) {
          if (!K.frustumCulled || he.intersectsSprite(K)) {
            de && We.setFromMatrixPosition(K.matrixWorld).applyMatrix4(ge);
            let Rt = Ie.update(K),
              Ht = K.material;
            Ht.visible && f.push(K, Rt, Ht, Oe, We.z, null);
          }
        } else if (
          (K.isMesh || K.isLine || K.isPoints) &&
          (K.isSkinnedMesh &&
            K.skeleton.frame !== kt.render.frame &&
            (K.skeleton.update(), (K.skeleton.frame = kt.render.frame)),
          !K.frustumCulled || he.intersectsObject(K))
        ) {
          de && We.setFromMatrixPosition(K.matrixWorld).applyMatrix4(ge);
          let Rt = Ie.update(K),
            Ht = K.material;
          if (Array.isArray(Ht)) {
            let Ut = Rt.groups;
            for (let ti = 0, ii = Ut.length; ti < ii; ti++) {
              let Jt = Ut[ti],
                Hi = Ht[Jt.materialIndex];
              Hi && Hi.visible && f.push(K, Rt, Hi, Oe, We.z, Jt);
            }
          } else Ht.visible && f.push(K, Rt, Ht, Oe, We.z, null);
        }
      }
      let At = K.children;
      for (let Rt = 0, Ht = At.length; Rt < Ht; Rt++) zt(At[Rt], me, Oe, de);
    }
    function gi(K, me, Oe, de) {
      let Ne = K.opaque,
        At = K.transmissive,
        Rt = K.transparent;
      d.setupLightsView(Oe),
        At.length > 0 && Ni(Ne, me, Oe),
        de && Ze.viewport(L.copy(de)),
        Ne.length > 0 && Pt(Ne, me, Oe),
        At.length > 0 && Pt(At, me, Oe),
        Rt.length > 0 && Pt(Rt, me, Oe),
        Ze.buffers.depth.setTest(!0),
        Ze.buffers.depth.setMask(!0),
        Ze.buffers.color.setMask(!0),
        Ze.setPolygonOffset(!1);
    }
    function Ni(K, me, Oe) {
      let de = _t.isWebGL2;
      Me === null &&
        (Me = new to(1, 1, {
          generateMipmaps: !0,
          type: Ye.has("EXT_color_buffer_half_float") ? fh : sl,
          minFilter: eo,
          samples: de && s === !0 ? 4 : 0,
        })),
        y.getDrawingBufferSize(pe),
        de ? Me.setSize(pe.x, pe.y) : Me.setSize(yp(pe.x), yp(pe.y));
      let Ne = y.getRenderTarget();
      y.setRenderTarget(Me), y.clear();
      let At = y.toneMapping;
      (y.toneMapping = sa),
        Pt(K, me, Oe),
        (y.toneMapping = At),
        Y.updateMultisampleRenderTarget(Me),
        Y.updateRenderTargetMipmap(Me),
        y.setRenderTarget(Ne);
    }
    function Pt(K, me, Oe) {
      let de = me.isScene === !0 ? me.overrideMaterial : null;
      for (let Ne = 0, At = K.length; Ne < At; Ne++) {
        let Rt = K[Ne],
          Ht = Rt.object,
          Ut = Rt.geometry,
          ti = de === null ? Rt.material : de,
          ii = Rt.group;
        Ht.layers.test(Oe.layers) && Xi(Ht, me, Oe, Ut, ti, ii);
      }
    }
    function Xi(K, me, Oe, de, Ne, At) {
      K.onBeforeRender(y, me, Oe, de, Ne, At),
        K.modelViewMatrix.multiplyMatrices(
          Oe.matrixWorldInverse,
          K.matrixWorld
        ),
        K.normalMatrix.getNormalMatrix(K.modelViewMatrix),
        Ne.onBeforeRender(y, me, Oe, de, K, At),
        Ne.transparent === !0 && Ne.side === Hd
          ? ((Ne.side = qr),
            (Ne.needsUpdate = !0),
            y.renderBufferDirect(Oe, me, de, Ne, K, At),
            (Ne.side = aa),
            (Ne.needsUpdate = !0),
            y.renderBufferDirect(Oe, me, de, Ne, K, At),
            (Ne.side = Hd))
          : y.renderBufferDirect(Oe, me, de, Ne, K, At),
        K.onAfterRender(y, me, Oe, de, Ne, At);
    }
    function xn(K, me, Oe) {
      me.isScene !== !0 && (me = Fe);
      let de = Et.get(K),
        Ne = d.state.lights,
        At = d.state.shadowsArray,
        Rt = Ne.state.version,
        Ht = Ue.getParameters(K, Ne.state, At, me, Oe),
        Ut = Ue.getProgramCacheKey(Ht),
        ti = de.programs;
      (de.environment = K.isMeshStandardMaterial ? me.environment : null),
        (de.fog = me.fog),
        (de.envMap = (K.isMeshStandardMaterial ? ye : ie).get(
          K.envMap || de.environment
        )),
        ti === void 0 &&
          (K.addEventListener("dispose", Se),
          (ti = new Map()),
          (de.programs = ti));
      let ii = ti.get(Ut);
      if (ii !== void 0) {
        if (de.currentProgram === ii && de.lightsStateVersion === Rt)
          return Rr(K, Ht), ii;
      } else
        (Ht.uniforms = Ue.getUniforms(K)),
          K.onBuild(Oe, Ht, y),
          K.onBeforeCompile(Ht, y),
          (ii = Ue.acquireProgram(Ht, Ut)),
          ti.set(Ut, ii),
          (de.uniforms = Ht.uniforms);
      let Jt = de.uniforms;
      ((!K.isShaderMaterial && !K.isRawShaderMaterial) || K.clipping === !0) &&
        (Jt.clippingPlanes = F.uniform),
        Rr(K, Ht),
        (de.needsLights = lT(K)),
        (de.lightsStateVersion = Rt),
        de.needsLights &&
          ((Jt.ambientLightColor.value = Ne.state.ambient),
          (Jt.lightProbe.value = Ne.state.probe),
          (Jt.directionalLights.value = Ne.state.directional),
          (Jt.directionalLightShadows.value = Ne.state.directionalShadow),
          (Jt.spotLights.value = Ne.state.spot),
          (Jt.spotLightShadows.value = Ne.state.spotShadow),
          (Jt.rectAreaLights.value = Ne.state.rectArea),
          (Jt.ltc_1.value = Ne.state.rectAreaLTC1),
          (Jt.ltc_2.value = Ne.state.rectAreaLTC2),
          (Jt.pointLights.value = Ne.state.point),
          (Jt.pointLightShadows.value = Ne.state.pointShadow),
          (Jt.hemisphereLights.value = Ne.state.hemi),
          (Jt.directionalShadowMap.value = Ne.state.directionalShadowMap),
          (Jt.directionalShadowMatrix.value = Ne.state.directionalShadowMatrix),
          (Jt.spotShadowMap.value = Ne.state.spotShadowMap),
          (Jt.spotLightMatrix.value = Ne.state.spotLightMatrix),
          (Jt.spotLightMap.value = Ne.state.spotLightMap),
          (Jt.pointShadowMap.value = Ne.state.pointShadowMap),
          (Jt.pointShadowMatrix.value = Ne.state.pointShadowMatrix));
      let Hi = ii.getUniforms(),
        Fn = uh.seqWithValue(Hi.seq, Jt);
      return (de.currentProgram = ii), (de.uniformsList = Fn), ii;
    }
    function Rr(K, me) {
      let Oe = Et.get(K);
      (Oe.outputEncoding = me.outputEncoding),
        (Oe.instancing = me.instancing),
        (Oe.skinning = me.skinning),
        (Oe.morphTargets = me.morphTargets),
        (Oe.morphNormals = me.morphNormals),
        (Oe.morphColors = me.morphColors),
        (Oe.morphTargetsCount = me.morphTargetsCount),
        (Oe.numClippingPlanes = me.numClippingPlanes),
        (Oe.numIntersection = me.numClipIntersection),
        (Oe.vertexAlphas = me.vertexAlphas),
        (Oe.vertexTangents = me.vertexTangents),
        (Oe.toneMapping = me.toneMapping);
    }
    function fr(K, me, Oe, de, Ne) {
      me.isScene !== !0 && (me = Fe), Y.resetTextureUnits();
      let At = me.fog,
        Rt = de.isMeshStandardMaterial ? me.environment : null,
        Ht =
          E === null
            ? y.outputEncoding
            : E.isXRRenderTarget === !0
            ? E.texture.encoding
            : ol,
        Ut = (de.isMeshStandardMaterial ? ye : ie).get(de.envMap || Rt),
        ti =
          de.vertexColors === !0 &&
          !!Oe.attributes.color &&
          Oe.attributes.color.itemSize === 4,
        ii = !!de.normalMap && !!Oe.attributes.tangent,
        Jt = !!Oe.morphAttributes.position,
        Hi = !!Oe.morphAttributes.normal,
        Fn = !!Oe.morphAttributes.color,
        vs = de.toneMapped ? y.toneMapping : sa,
        Or =
          Oe.morphAttributes.position ||
          Oe.morphAttributes.normal ||
          Oe.morphAttributes.color,
        Ci = Or !== void 0 ? Or.length : 0,
        Qt = Et.get(de),
        Ra = d.state.lights;
      if (ce === !0 && (te === !0 || K !== P)) {
        let Bn = K === P && de.id === w;
        F.setState(de, K, Bn);
      }
      let Yi = !1;
      de.version === Qt.__version
        ? ((Qt.needsLights && Qt.lightsStateVersion !== Ra.state.version) ||
            Qt.outputEncoding !== Ht ||
            (Ne.isInstancedMesh && Qt.instancing === !1) ||
            (!Ne.isInstancedMesh && Qt.instancing === !0) ||
            (Ne.isSkinnedMesh && Qt.skinning === !1) ||
            (!Ne.isSkinnedMesh && Qt.skinning === !0) ||
            Qt.envMap !== Ut ||
            (de.fog === !0 && Qt.fog !== At) ||
            (Qt.numClippingPlanes !== void 0 &&
              (Qt.numClippingPlanes !== F.numPlanes ||
                Qt.numIntersection !== F.numIntersection)) ||
            Qt.vertexAlphas !== ti ||
            Qt.vertexTangents !== ii ||
            Qt.morphTargets !== Jt ||
            Qt.morphNormals !== Hi ||
            Qt.morphColors !== Fn ||
            Qt.toneMapping !== vs ||
            (_t.isWebGL2 === !0 && Qt.morphTargetsCount !== Ci)) &&
          (Yi = !0)
        : ((Yi = !0), (Qt.__version = de.version));
      let ns = Qt.currentProgram;
      Yi === !0 && (ns = xn(de, me, Ne));
      let Pg = !1,
        Bl = !1,
        Wf = !1,
        wn = ns.getUniforms(),
        Oa = Qt.uniforms;
      if (
        (Ze.useProgram(ns.program) && ((Pg = !0), (Bl = !0), (Wf = !0)),
        de.id !== w && ((w = de.id), (Bl = !0)),
        Pg || P !== K)
      ) {
        if (
          (wn.setValue(be, "projectionMatrix", K.projectionMatrix),
          _t.logarithmicDepthBuffer &&
            wn.setValue(
              be,
              "logDepthBufFC",
              2 / (Math.log(K.far + 1) / Math.LN2)
            ),
          P !== K && ((P = K), (Bl = !0), (Wf = !0)),
          de.isShaderMaterial ||
            de.isMeshPhongMaterial ||
            de.isMeshToonMaterial ||
            de.isMeshStandardMaterial ||
            de.envMap)
        ) {
          let Bn = wn.map.cameraPosition;
          Bn !== void 0 &&
            Bn.setValue(be, We.setFromMatrixPosition(K.matrixWorld));
        }
        (de.isMeshPhongMaterial ||
          de.isMeshToonMaterial ||
          de.isMeshLambertMaterial ||
          de.isMeshBasicMaterial ||
          de.isMeshStandardMaterial ||
          de.isShaderMaterial) &&
          wn.setValue(be, "isOrthographic", K.isOrthographicCamera === !0),
          (de.isMeshPhongMaterial ||
            de.isMeshToonMaterial ||
            de.isMeshLambertMaterial ||
            de.isMeshBasicMaterial ||
            de.isMeshStandardMaterial ||
            de.isShaderMaterial ||
            de.isShadowMaterial ||
            Ne.isSkinnedMesh) &&
            wn.setValue(be, "viewMatrix", K.matrixWorldInverse);
      }
      if (Ne.isSkinnedMesh) {
        wn.setOptional(be, Ne, "bindMatrix"),
          wn.setOptional(be, Ne, "bindMatrixInverse");
        let Bn = Ne.skeleton;
        Bn &&
          (_t.floatVertexTextures
            ? (Bn.boneTexture === null && Bn.computeBoneTexture(),
              wn.setValue(be, "boneTexture", Bn.boneTexture, Y),
              wn.setValue(be, "boneTextureSize", Bn.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      let bu = Oe.morphAttributes;
      if (
        ((bu.position !== void 0 ||
          bu.normal !== void 0 ||
          (bu.color !== void 0 && _t.isWebGL2 === !0)) &&
          Te.update(Ne, Oe, de, ns),
        (Bl || Qt.receiveShadow !== Ne.receiveShadow) &&
          ((Qt.receiveShadow = Ne.receiveShadow),
          wn.setValue(be, "receiveShadow", Ne.receiveShadow)),
        de.isMeshGouraudMaterial &&
          de.envMap !== null &&
          ((Oa.envMap.value = Ut),
          (Oa.flipEnvMap.value =
            Ut.isCubeTexture && Ut.isRenderTargetTexture === !1 ? -1 : 1)),
        Bl &&
          (wn.setValue(be, "toneMappingExposure", y.toneMappingExposure),
          Qt.needsLights && oT(Oa, Wf),
          At && de.fog === !0 && Ve.refreshFogUniforms(Oa, At),
          Ve.refreshMaterialUniforms(Oa, de, U, O, Me),
          uh.upload(be, Qt.uniformsList, Oa, Y)),
        de.isShaderMaterial &&
          de.uniformsNeedUpdate === !0 &&
          (uh.upload(be, Qt.uniformsList, Oa, Y), (de.uniformsNeedUpdate = !1)),
        de.isSpriteMaterial && wn.setValue(be, "center", Ne.center),
        wn.setValue(be, "modelViewMatrix", Ne.modelViewMatrix),
        wn.setValue(be, "normalMatrix", Ne.normalMatrix),
        wn.setValue(be, "modelMatrix", Ne.matrixWorld),
        de.isShaderMaterial || de.isRawShaderMaterial)
      ) {
        let Bn = de.uniformsGroups;
        for (let _u = 0, cT = Bn.length; _u < cT; _u++)
          if (_t.isWebGL2) {
            let Eu = Bn[_u];
            V.update(Eu, ns), V.bind(Eu, ns);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return ns;
    }
    function oT(K, me) {
      (K.ambientLightColor.needsUpdate = me),
        (K.lightProbe.needsUpdate = me),
        (K.directionalLights.needsUpdate = me),
        (K.directionalLightShadows.needsUpdate = me),
        (K.pointLights.needsUpdate = me),
        (K.pointLightShadows.needsUpdate = me),
        (K.spotLights.needsUpdate = me),
        (K.spotLightShadows.needsUpdate = me),
        (K.rectAreaLights.needsUpdate = me),
        (K.hemisphereLights.needsUpdate = me);
    }
    function lT(K) {
      return (
        K.isMeshLambertMaterial ||
        K.isMeshToonMaterial ||
        K.isMeshPhongMaterial ||
        K.isMeshStandardMaterial ||
        K.isShadowMaterial ||
        (K.isShaderMaterial && K.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return b;
    }),
      (this.getActiveMipmapLevel = function () {
        return _;
      }),
      (this.getRenderTarget = function () {
        return E;
      }),
      (this.setRenderTargetTextures = function (K, me, Oe) {
        (Et.get(K.texture).__webglTexture = me),
          (Et.get(K.depthTexture).__webglTexture = Oe);
        let de = Et.get(K);
        (de.__hasExternalTextures = !0),
          de.__hasExternalTextures &&
            ((de.__autoAllocateDepthBuffer = Oe === void 0),
            de.__autoAllocateDepthBuffer ||
              (Ye.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (de.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (K, me) {
        let Oe = Et.get(K);
        (Oe.__webglFramebuffer = me),
          (Oe.__useDefaultFramebuffer = me === void 0);
      }),
      (this.setRenderTarget = function (K, me = 0, Oe = 0) {
        (E = K), (b = me), (_ = Oe);
        let de = !0,
          Ne = null,
          At = !1,
          Rt = !1;
        if (K) {
          let Ut = Et.get(K);
          Ut.__useDefaultFramebuffer !== void 0
            ? (Ze.bindFramebuffer(36160, null), (de = !1))
            : Ut.__webglFramebuffer === void 0
            ? Y.setupRenderTarget(K)
            : Ut.__hasExternalTextures &&
              Y.rebindTextures(
                K,
                Et.get(K.texture).__webglTexture,
                Et.get(K.depthTexture).__webglTexture
              );
          let ti = K.texture;
          (ti.isData3DTexture ||
            ti.isDataArrayTexture ||
            ti.isCompressedArrayTexture) &&
            (Rt = !0);
          let ii = Et.get(K).__webglFramebuffer;
          K.isWebGLCubeRenderTarget
            ? ((Ne = ii[me]), (At = !0))
            : _t.isWebGL2 && K.samples > 0 && Y.useMultisampledRTT(K) === !1
            ? (Ne = Et.get(K).__webglMultisampledFramebuffer)
            : (Ne = ii),
            L.copy(K.viewport),
            I.copy(K.scissor),
            (M = K.scissorTest);
        } else
          L.copy(W).multiplyScalar(U).floor(),
            I.copy(ue).multiplyScalar(U).floor(),
            (M = ae);
        if (
          (Ze.bindFramebuffer(36160, Ne) &&
            _t.drawBuffers &&
            de &&
            Ze.drawBuffers(K, Ne),
          Ze.viewport(L),
          Ze.scissor(I),
          Ze.setScissorTest(M),
          At)
        ) {
          let Ut = Et.get(K.texture);
          be.framebufferTexture2D(
            36160,
            36064,
            34069 + me,
            Ut.__webglTexture,
            Oe
          );
        } else if (Rt) {
          let Ut = Et.get(K.texture),
            ti = me || 0;
          be.framebufferTextureLayer(
            36160,
            36064,
            Ut.__webglTexture,
            Oe || 0,
            ti
          );
        }
        w = -1;
      }),
      (this.readRenderTargetPixels = function (K, me, Oe, de, Ne, At, Rt) {
        if (!(K && K.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let Ht = Et.get(K).__webglFramebuffer;
        if ((K.isWebGLCubeRenderTarget && Rt !== void 0 && (Ht = Ht[Rt]), Ht)) {
          Ze.bindFramebuffer(36160, Ht);
          try {
            let Ut = K.texture,
              ti = Ut.format,
              ii = Ut.type;
            if (ti !== Wr && A.convert(ti) !== be.getParameter(35739)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            let Jt =
              ii === fh &&
              (Ye.has("EXT_color_buffer_half_float") ||
                (_t.isWebGL2 && Ye.has("EXT_color_buffer_float")));
            if (
              ii !== sl &&
              A.convert(ii) !== be.getParameter(35738) &&
              !(
                ii === Za &&
                (_t.isWebGL2 ||
                  Ye.has("OES_texture_float") ||
                  Ye.has("WEBGL_color_buffer_float"))
              ) &&
              !Jt
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            me >= 0 &&
              me <= K.width - de &&
              Oe >= 0 &&
              Oe <= K.height - Ne &&
              be.readPixels(me, Oe, de, Ne, A.convert(ti), A.convert(ii), At);
          } finally {
            let Ut = E !== null ? Et.get(E).__webglFramebuffer : null;
            Ze.bindFramebuffer(36160, Ut);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (K, me, Oe = 0) {
        let de = Math.pow(2, -Oe),
          Ne = Math.floor(me.image.width * de),
          At = Math.floor(me.image.height * de);
        Y.setTexture2D(me, 0),
          be.copyTexSubImage2D(3553, Oe, 0, 0, K.x, K.y, Ne, At),
          Ze.unbindTexture();
      }),
      (this.copyTextureToTexture = function (K, me, Oe, de = 0) {
        let Ne = me.image.width,
          At = me.image.height,
          Rt = A.convert(Oe.format),
          Ht = A.convert(Oe.type);
        Y.setTexture2D(Oe, 0),
          be.pixelStorei(37440, Oe.flipY),
          be.pixelStorei(37441, Oe.premultiplyAlpha),
          be.pixelStorei(3317, Oe.unpackAlignment),
          me.isDataTexture
            ? be.texSubImage2D(
                3553,
                de,
                K.x,
                K.y,
                Ne,
                At,
                Rt,
                Ht,
                me.image.data
              )
            : me.isCompressedTexture
            ? be.compressedTexSubImage2D(
                3553,
                de,
                K.x,
                K.y,
                me.mipmaps[0].width,
                me.mipmaps[0].height,
                Rt,
                me.mipmaps[0].data
              )
            : be.texSubImage2D(3553, de, K.x, K.y, Rt, Ht, me.image),
          de === 0 && Oe.generateMipmaps && be.generateMipmap(3553),
          Ze.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (K, me, Oe, de, Ne = 0) {
        if (y.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        let At = K.max.x - K.min.x + 1,
          Rt = K.max.y - K.min.y + 1,
          Ht = K.max.z - K.min.z + 1,
          Ut = A.convert(de.format),
          ti = A.convert(de.type),
          ii;
        if (de.isData3DTexture) Y.setTexture3D(de, 0), (ii = 32879);
        else if (de.isDataArrayTexture)
          Y.setTexture2DArray(de, 0), (ii = 35866);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        be.pixelStorei(37440, de.flipY),
          be.pixelStorei(37441, de.premultiplyAlpha),
          be.pixelStorei(3317, de.unpackAlignment);
        let Jt = be.getParameter(3314),
          Hi = be.getParameter(32878),
          Fn = be.getParameter(3316),
          vs = be.getParameter(3315),
          Or = be.getParameter(32877),
          Ci = Oe.isCompressedTexture ? Oe.mipmaps[0] : Oe.image;
        be.pixelStorei(3314, Ci.width),
          be.pixelStorei(32878, Ci.height),
          be.pixelStorei(3316, K.min.x),
          be.pixelStorei(3315, K.min.y),
          be.pixelStorei(32877, K.min.z),
          Oe.isDataTexture || Oe.isData3DTexture
            ? be.texSubImage3D(
                ii,
                Ne,
                me.x,
                me.y,
                me.z,
                At,
                Rt,
                Ht,
                Ut,
                ti,
                Ci.data
              )
            : Oe.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              be.compressedTexSubImage3D(
                ii,
                Ne,
                me.x,
                me.y,
                me.z,
                At,
                Rt,
                Ht,
                Ut,
                Ci.data
              ))
            : be.texSubImage3D(
                ii,
                Ne,
                me.x,
                me.y,
                me.z,
                At,
                Rt,
                Ht,
                Ut,
                ti,
                Ci
              ),
          be.pixelStorei(3314, Jt),
          be.pixelStorei(32878, Hi),
          be.pixelStorei(3316, Fn),
          be.pixelStorei(3315, vs),
          be.pixelStorei(32877, Or),
          Ne === 0 && de.generateMipmaps && be.generateMipmap(ii),
          Ze.unbindTexture();
      }),
      (this.initTexture = function (K) {
        K.isCubeTexture
          ? Y.setTextureCube(K, 0)
          : K.isData3DTexture
          ? Y.setTexture3D(K, 0)
          : K.isDataArrayTexture || K.isCompressedArrayTexture
          ? Y.setTexture2DArray(K, 0)
          : Y.setTexture2D(K, 0),
          Ze.unbindTexture();
      }),
      (this.resetState = function () {
        (b = 0), (_ = 0), (E = null), Ze.reset(), D.reset();
      }),
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  var AC = class extends xh {};
  AC.prototype.isWebGL1Renderer = !0;
  var bh = class extends Ai {
      constructor() {
        super();
        (this.isScene = !0),
          (this.type = "Scene"),
          (this.background = null),
          (this.environment = null),
          (this.fog = null),
          (this.backgroundBlurriness = 0),
          (this.backgroundIntensity = 1),
          (this.overrideMaterial = null),
          typeof __THREE_DEVTOOLS__ != "undefined" &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          e.background !== null && (this.background = e.background.clone()),
          e.environment !== null && (this.environment = e.environment.clone()),
          e.fog !== null && (this.fog = e.fog.clone()),
          (this.backgroundBlurriness = e.backgroundBlurriness),
          (this.backgroundIntensity = e.backgroundIntensity),
          e.overrideMaterial !== null &&
            (this.overrideMaterial = e.overrideMaterial.clone()),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          this
        );
      }
      toJSON(e) {
        let t = super.toJSON(e);
        return (
          this.fog !== null && (t.object.fog = this.fog.toJSON()),
          this.backgroundBlurriness > 0 &&
            (t.backgroundBlurriness = this.backgroundBlurriness),
          this.backgroundIntensity !== 1 &&
            (t.backgroundIntensity = this.backgroundIntensity),
          t
        );
      }
      get autoUpdate() {
        return (
          console.warn(
            "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
          ),
          this.matrixWorldAutoUpdate
        );
      }
      set autoUpdate(e) {
        console.warn(
          "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
        ),
          (this.matrixWorldAutoUpdate = e);
      }
    },
    bx = class {
      constructor(e, t) {
        (this.isInterleavedBuffer = !0),
          (this.array = e),
          (this.stride = t),
          (this.count = e !== void 0 ? e.length / t : 0),
          (this.usage = Qv),
          (this.updateRange = { offset: 0, count: -1 }),
          (this.version = 0),
          (this.uuid = ds());
      }
      onUploadCallback() {}
      set needsUpdate(e) {
        e === !0 && this.version++;
      }
      setUsage(e) {
        return (this.usage = e), this;
      }
      copy(e) {
        return (
          (this.array = new e.array.constructor(e.array)),
          (this.count = e.count),
          (this.stride = e.stride),
          (this.usage = e.usage),
          this
        );
      }
      copyAt(e, t, i) {
        (e *= this.stride), (i *= t.stride);
        for (let r = 0, s = this.stride; r < s; r++)
          this.array[e + r] = t.array[i + r];
        return this;
      }
      set(e, t = 0) {
        return this.array.set(e, t), this;
      }
      clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
          this.array.buffer._uuid === void 0 &&
            (this.array.buffer._uuid = ds()),
          e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
            (e.arrayBuffers[this.array.buffer._uuid] =
              this.array.slice(0).buffer);
        let t = new this.array.constructor(
            e.arrayBuffers[this.array.buffer._uuid]
          ),
          i = new this.constructor(t, this.stride);
        return i.setUsage(this.usage), i;
      }
      onUpload(e) {
        return (this.onUploadCallback = e), this;
      }
      toJSON(e) {
        return (
          e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
          this.array.buffer._uuid === void 0 &&
            (this.array.buffer._uuid = ds()),
          e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
            (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
              new Uint32Array(this.array.buffer)
            )),
          {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride,
          }
        );
      }
    },
    Hn = new le(),
    _h = class {
      constructor(e, t, i, r = !1) {
        (this.isInterleavedBufferAttribute = !0),
          (this.name = ""),
          (this.data = e),
          (this.itemSize = t),
          (this.offset = i),
          (this.normalized = r);
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate(e) {
        this.data.needsUpdate = e;
      }
      applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++)
          Hn.fromBufferAttribute(this, t),
            Hn.applyMatrix4(e),
            this.setXYZ(t, Hn.x, Hn.y, Hn.z);
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
          Hn.fromBufferAttribute(this, t),
            Hn.applyNormalMatrix(e),
            this.setXYZ(t, Hn.x, Hn.y, Hn.z);
        return this;
      }
      transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
          Hn.fromBufferAttribute(this, t),
            Hn.transformDirection(e),
            this.setXYZ(t, Hn.x, Hn.y, Hn.z);
        return this;
      }
      setX(e, t) {
        return (
          this.normalized && (t = Mi(t, this.array)),
          (this.data.array[e * this.data.stride + this.offset] = t),
          this
        );
      }
      setY(e, t) {
        return (
          this.normalized && (t = Mi(t, this.array)),
          (this.data.array[e * this.data.stride + this.offset + 1] = t),
          this
        );
      }
      setZ(e, t) {
        return (
          this.normalized && (t = Mi(t, this.array)),
          (this.data.array[e * this.data.stride + this.offset + 2] = t),
          this
        );
      }
      setW(e, t) {
        return (
          this.normalized && (t = Mi(t, this.array)),
          (this.data.array[e * this.data.stride + this.offset + 3] = t),
          this
        );
      }
      getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = ra(t, this.array)), t;
      }
      getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = ra(t, this.array)), t;
      }
      getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = ra(t, this.array)), t;
      }
      getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = ra(t, this.array)), t;
      }
      setXY(e, t, i) {
        return (
          (e = e * this.data.stride + this.offset),
          this.normalized && ((t = Mi(t, this.array)), (i = Mi(i, this.array))),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = i),
          this
        );
      }
      setXYZ(e, t, i, r) {
        return (
          (e = e * this.data.stride + this.offset),
          this.normalized &&
            ((t = Mi(t, this.array)),
            (i = Mi(i, this.array)),
            (r = Mi(r, this.array))),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = i),
          (this.data.array[e + 2] = r),
          this
        );
      }
      setXYZW(e, t, i, r, s) {
        return (
          (e = e * this.data.stride + this.offset),
          this.normalized &&
            ((t = Mi(t, this.array)),
            (i = Mi(i, this.array)),
            (r = Mi(r, this.array)),
            (s = Mi(s, this.array))),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = i),
          (this.data.array[e + 2] = r),
          (this.data.array[e + 3] = s),
          this
        );
      }
      clone(e) {
        if (e === void 0) {
          console.log(
            "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
          );
          let t = [];
          for (let i = 0; i < this.count; i++) {
            let r = i * this.data.stride + this.offset;
            for (let s = 0; s < this.itemSize; s++)
              t.push(this.data.array[r + s]);
          }
          return new en(
            new this.array.constructor(t),
            this.itemSize,
            this.normalized
          );
        } else
          return (
            e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 &&
              (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new _h(
              e.interleavedBuffers[this.data.uuid],
              this.itemSize,
              this.offset,
              this.normalized
            )
          );
      }
      toJSON(e) {
        if (e === void 0) {
          console.log(
            "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
          );
          let t = [];
          for (let i = 0; i < this.count; i++) {
            let r = i * this.data.stride + this.offset;
            for (let s = 0; s < this.itemSize; s++)
              t.push(this.data.array[r + s]);
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: t,
            normalized: this.normalized,
          };
        } else
          return (
            e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 &&
              (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
              isInterleavedBufferAttribute: !0,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized,
            }
          );
      }
    };
  var IA = new le(),
    LA = new Ti(),
    RA = new Ti(),
    PG = new le(),
    OA = new Wt(),
    _x = class extends ar {
      constructor(e, t) {
        super(e, t);
        (this.isSkinnedMesh = !0),
          (this.type = "SkinnedMesh"),
          (this.bindMode = "attached"),
          (this.bindMatrix = new Wt()),
          (this.bindMatrixInverse = new Wt());
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.bindMode = e.bindMode),
          this.bindMatrix.copy(e.bindMatrix),
          this.bindMatrixInverse.copy(e.bindMatrixInverse),
          (this.skeleton = e.skeleton),
          this
        );
      }
      bind(e, t) {
        (this.skeleton = e),
          t === void 0 &&
            (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            (t = this.matrixWorld)),
          this.bindMatrix.copy(t),
          this.bindMatrixInverse.copy(t).invert();
      }
      pose() {
        this.skeleton.pose();
      }
      normalizeSkinWeights() {
        let e = new Ti(),
          t = this.geometry.attributes.skinWeight;
        for (let i = 0, r = t.count; i < r; i++) {
          e.fromBufferAttribute(t, i);
          let s = 1 / e.manhattanLength();
          s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
            t.setXYZW(i, e.x, e.y, e.z, e.w);
        }
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
          this.bindMode === "attached"
            ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
            : this.bindMode === "detached"
            ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
            : console.warn(
                "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
              );
      }
      boneTransform(e, t) {
        let i = this.skeleton,
          r = this.geometry;
        LA.fromBufferAttribute(r.attributes.skinIndex, e),
          RA.fromBufferAttribute(r.attributes.skinWeight, e),
          IA.copy(t).applyMatrix4(this.bindMatrix),
          t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
          let a = RA.getComponent(s);
          if (a !== 0) {
            let o = LA.getComponent(s);
            OA.multiplyMatrices(i.bones[o].matrixWorld, i.boneInverses[o]),
              t.addScaledVector(PG.copy(IA).applyMatrix4(OA), a);
          }
        }
        return t.applyMatrix4(this.bindMatrixInverse);
      }
    },
    Tp = class extends Ai {
      constructor() {
        super();
        (this.isBone = !0), (this.type = "Bone");
      }
    },
    CC = class extends hn {
      constructor(e = null, t = 1, i = 1, r, s, a, o, l, c = un, u = un, f, d) {
        super(null, a, o, l, c, u, r, s, f, d);
        (this.isDataTexture = !0),
          (this.image = { data: e, width: t, height: i }),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1);
      }
    },
    NA = new Wt(),
    DG = new Wt(),
    Eh = class {
      constructor(e = [], t = []) {
        (this.uuid = ds()),
          (this.bones = e.slice(0)),
          (this.boneInverses = t),
          (this.boneMatrices = null),
          (this.boneTexture = null),
          (this.boneTextureSize = 0),
          (this.frame = -1),
          this.init();
      }
      init() {
        let e = this.bones,
          t = this.boneInverses;
        if (
          ((this.boneMatrices = new Float32Array(e.length * 16)),
          t.length === 0)
        )
          this.calculateInverses();
        else if (e.length !== t.length) {
          console.warn(
            "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
          ),
            (this.boneInverses = []);
          for (let i = 0, r = this.bones.length; i < r; i++)
            this.boneInverses.push(new Wt());
        }
      }
      calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
          let i = new Wt();
          this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(i);
        }
      }
      pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
          let i = this.bones[e];
          i && i.matrixWorld.copy(this.boneInverses[e]).invert();
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
          let i = this.bones[e];
          i &&
            (i.parent && i.parent.isBone
              ? (i.matrix.copy(i.parent.matrixWorld).invert(),
                i.matrix.multiply(i.matrixWorld))
              : i.matrix.copy(i.matrixWorld),
            i.matrix.decompose(i.position, i.quaternion, i.scale));
        }
      }
      update() {
        let e = this.bones,
          t = this.boneInverses,
          i = this.boneMatrices,
          r = this.boneTexture;
        for (let s = 0, a = e.length; s < a; s++) {
          let o = e[s] ? e[s].matrixWorld : DG;
          NA.multiplyMatrices(o, t[s]), NA.toArray(i, s * 16);
        }
        r !== null && (r.needsUpdate = !0);
      }
      clone() {
        return new Eh(this.bones, this.boneInverses);
      }
      computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        (e = rC(e)), (e = Math.max(e, 4));
        let t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        let i = new CC(t, e, e, Wr, Za);
        return (
          (i.needsUpdate = !0),
          (this.boneMatrices = t),
          (this.boneTexture = i),
          (this.boneTextureSize = e),
          this
        );
      }
      getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
          let r = this.bones[t];
          if (r.name === e) return r;
        }
      }
      dispose() {
        this.boneTexture !== null &&
          (this.boneTexture.dispose(), (this.boneTexture = null));
      }
      fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, r = e.bones.length; i < r; i++) {
          let s = e.bones[i],
            a = t[s];
          a === void 0 &&
            (console.warn("THREE.Skeleton: No bone found with UUID:", s),
            (a = new Tp())),
            this.bones.push(a),
            this.boneInverses.push(new Wt().fromArray(e.boneInverses[i]));
        }
        return this.init(), this;
      }
      toJSON() {
        let e = {
          metadata: {
            version: 4.5,
            type: "Skeleton",
            generator: "Skeleton.toJSON",
          },
          bones: [],
          boneInverses: [],
        };
        e.uuid = this.uuid;
        let t = this.bones,
          i = this.boneInverses;
        for (let r = 0, s = t.length; r < s; r++) {
          let a = t[r];
          e.bones.push(a.uuid);
          let o = i[r];
          e.boneInverses.push(o.toArray());
        }
        return e;
      }
    },
    rx = class extends en {
      constructor(e, t, i, r = 1) {
        super(e, t, i);
        (this.isInstancedBufferAttribute = !0), (this.meshPerAttribute = r);
      }
      copy(e) {
        return (
          super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
        );
      }
      toJSON() {
        let e = super.toJSON();
        return (
          (e.meshPerAttribute = this.meshPerAttribute),
          (e.isInstancedBufferAttribute = !0),
          e
        );
      }
    },
    kA = new Wt(),
    FA = new Wt(),
    lp = [],
    IG = new Wt(),
    nh = new ar(),
    Ex = class extends ar {
      constructor(e, t, i) {
        super(e, t);
        (this.isInstancedMesh = !0),
          (this.instanceMatrix = new rx(new Float32Array(i * 16), 16)),
          (this.instanceColor = null),
          (this.count = i),
          (this.frustumCulled = !1);
        for (let r = 0; r < i; r++) this.setMatrixAt(r, IG);
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          this.instanceMatrix.copy(e.instanceMatrix),
          e.instanceColor !== null &&
            (this.instanceColor = e.instanceColor.clone()),
          (this.count = e.count),
          this
        );
      }
      getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3);
      }
      getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16);
      }
      raycast(e, t) {
        let i = this.matrixWorld,
          r = this.count;
        if (
          ((nh.geometry = this.geometry),
          (nh.material = this.material),
          nh.material !== void 0)
        )
          for (let s = 0; s < r; s++) {
            this.getMatrixAt(s, kA),
              FA.multiplyMatrices(i, kA),
              (nh.matrixWorld = FA),
              nh.raycast(e, lp);
            for (let a = 0, o = lp.length; a < o; a++) {
              let l = lp[a];
              (l.instanceId = s), (l.object = this), t.push(l);
            }
            lp.length = 0;
          }
      }
      setColorAt(e, t) {
        this.instanceColor === null &&
          (this.instanceColor = new rx(
            new Float32Array(this.instanceMatrix.count * 3),
            3
          )),
          t.toArray(this.instanceColor.array, e * 3);
      }
      setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16);
      }
      updateMorphTargets() {}
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    },
    Th = class extends Xr {
      constructor(e) {
        super();
        (this.isLineBasicMaterial = !0),
          (this.type = "LineBasicMaterial"),
          (this.color = new Bt(16777215)),
          (this.linewidth = 1),
          (this.linecap = "round"),
          (this.linejoin = "round"),
          (this.fog = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.linewidth = e.linewidth),
          (this.linecap = e.linecap),
          (this.linejoin = e.linejoin),
          (this.fog = e.fog),
          this
        );
      }
    },
    BA = new le(),
    zA = new le(),
    UA = new Wt(),
    jv = new xp(),
    cp = new ro(),
    Sh = class extends Ai {
      constructor(e = new qn(), t = new Th()) {
        super();
        (this.isLine = !0),
          (this.type = "Line"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      computeLineDistances() {
        let e = this.geometry;
        if (e.index === null) {
          let t = e.attributes.position,
            i = [0];
          for (let r = 1, s = t.count; r < s; r++)
            BA.fromBufferAttribute(t, r - 1),
              zA.fromBufferAttribute(t, r),
              (i[r] = i[r - 1]),
              (i[r] += BA.distanceTo(zA));
          e.setAttribute("lineDistance", new jr(i, 1));
        } else
          console.warn(
            "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
          );
        return this;
      }
      raycast(e, t) {
        let i = this.geometry,
          r = this.matrixWorld,
          s = e.params.Line.threshold,
          a = i.drawRange;
        if (
          (i.boundingSphere === null && i.computeBoundingSphere(),
          cp.copy(i.boundingSphere),
          cp.applyMatrix4(r),
          (cp.radius += s),
          e.ray.intersectsSphere(cp) === !1)
        )
          return;
        UA.copy(r).invert(), jv.copy(e.ray).applyMatrix4(UA);
        let o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          l = o * o,
          c = new le(),
          u = new le(),
          f = new le(),
          d = new le(),
          m = this.isLineSegments ? 2 : 1,
          x = i.index,
          g = i.attributes.position;
        if (x !== null) {
          let b = Math.max(0, a.start),
            _ = Math.min(x.count, a.start + a.count);
          for (let E = b, w = _ - 1; E < w; E += m) {
            let P = x.getX(E),
              L = x.getX(E + 1);
            if (
              (c.fromBufferAttribute(g, P),
              u.fromBufferAttribute(g, L),
              jv.distanceSqToSegment(c, u, d, f) > l)
            )
              continue;
            d.applyMatrix4(this.matrixWorld);
            let M = e.ray.origin.distanceTo(d);
            M < e.near ||
              M > e.far ||
              t.push({
                distance: M,
                point: f.clone().applyMatrix4(this.matrixWorld),
                index: E,
                face: null,
                faceIndex: null,
                object: this,
              });
          }
        } else {
          let b = Math.max(0, a.start),
            _ = Math.min(g.count, a.start + a.count);
          for (let E = b, w = _ - 1; E < w; E += m) {
            if (
              (c.fromBufferAttribute(g, E),
              u.fromBufferAttribute(g, E + 1),
              jv.distanceSqToSegment(c, u, d, f) > l)
            )
              continue;
            d.applyMatrix4(this.matrixWorld);
            let L = e.ray.origin.distanceTo(d);
            L < e.near ||
              L > e.far ||
              t.push({
                distance: L,
                point: f.clone().applyMatrix4(this.matrixWorld),
                index: E,
                face: null,
                faceIndex: null,
                object: this,
              });
          }
        }
      }
      updateMorphTargets() {
        let t = this.geometry.morphAttributes,
          i = Object.keys(t);
        if (i.length > 0) {
          let r = t[i[0]];
          if (r !== void 0) {
            (this.morphTargetInfluences = []),
              (this.morphTargetDictionary = {});
            for (let s = 0, a = r.length; s < a; s++) {
              let o = r[s].name || String(s);
              this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[o] = s);
            }
          }
        }
      }
    },
    VA = new le(),
    GA = new le(),
    Sp = class extends Sh {
      constructor(e, t) {
        super(e, t);
        (this.isLineSegments = !0), (this.type = "LineSegments");
      }
      computeLineDistances() {
        let e = this.geometry;
        if (e.index === null) {
          let t = e.attributes.position,
            i = [];
          for (let r = 0, s = t.count; r < s; r += 2)
            VA.fromBufferAttribute(t, r),
              GA.fromBufferAttribute(t, r + 1),
              (i[r] = r === 0 ? 0 : i[r - 1]),
              (i[r + 1] = i[r] + VA.distanceTo(GA));
          e.setAttribute("lineDistance", new jr(i, 1));
        } else
          console.warn(
            "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
          );
        return this;
      }
    },
    Tx = class extends Sh {
      constructor(e, t) {
        super(e, t);
        (this.isLineLoop = !0), (this.type = "LineLoop");
      }
    },
    wp = class extends Xr {
      constructor(e) {
        super();
        (this.isPointsMaterial = !0),
          (this.type = "PointsMaterial"),
          (this.color = new Bt(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.size = 1),
          (this.sizeAttenuation = !0),
          (this.fog = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.size = e.size),
          (this.sizeAttenuation = e.sizeAttenuation),
          (this.fog = e.fog),
          this
        );
      }
    },
    HA = new Wt(),
    sx = new xp(),
    up = new ro(),
    hp = new le(),
    Sx = class extends Ai {
      constructor(e = new qn(), t = new wp()) {
        super();
        (this.isPoints = !0),
          (this.type = "Points"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      raycast(e, t) {
        let i = this.geometry,
          r = this.matrixWorld,
          s = e.params.Points.threshold,
          a = i.drawRange;
        if (
          (i.boundingSphere === null && i.computeBoundingSphere(),
          up.copy(i.boundingSphere),
          up.applyMatrix4(r),
          (up.radius += s),
          e.ray.intersectsSphere(up) === !1)
        )
          return;
        HA.copy(r).invert(), sx.copy(e.ray).applyMatrix4(HA);
        let o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          l = o * o,
          c = i.index,
          f = i.attributes.position;
        if (c !== null) {
          let d = Math.max(0, a.start),
            m = Math.min(c.count, a.start + a.count);
          for (let x = d, y = m; x < y; x++) {
            let g = c.getX(x);
            hp.fromBufferAttribute(f, g), $A(hp, g, l, r, e, t, this);
          }
        } else {
          let d = Math.max(0, a.start),
            m = Math.min(f.count, a.start + a.count);
          for (let x = d, y = m; x < y; x++)
            hp.fromBufferAttribute(f, x), $A(hp, x, l, r, e, t, this);
        }
      }
      updateMorphTargets() {
        let t = this.geometry.morphAttributes,
          i = Object.keys(t);
        if (i.length > 0) {
          let r = t[i[0]];
          if (r !== void 0) {
            (this.morphTargetInfluences = []),
              (this.morphTargetDictionary = {});
            for (let s = 0, a = r.length; s < a; s++) {
              let o = r[s].name || String(s);
              this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[o] = s);
            }
          }
        }
      }
    };
  function $A(n, e, t, i, r, s, a) {
    let o = sx.distanceSqToPoint(n);
    if (o < t) {
      let l = new le();
      sx.closestPointToPoint(n, l), l.applyMatrix4(i);
      let c = r.ray.origin.distanceTo(l);
      if (c < r.near || c > r.far) return;
      s.push({
        distance: c,
        distanceToRay: Math.sqrt(o),
        point: l,
        index: e,
        face: null,
        object: a,
      });
    }
  }
  var wh = class extends Xr {
      constructor(e) {
        super();
        (this.isMeshStandardMaterial = !0),
          (this.defines = { STANDARD: "" }),
          (this.type = "MeshStandardMaterial"),
          (this.color = new Bt(16777215)),
          (this.roughness = 1),
          (this.metalness = 0),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new Bt(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = nC),
          (this.normalScale = new It(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.roughnessMap = null),
          (this.metalnessMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.envMapIntensity = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.flatShading = !1),
          (this.fog = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = { STANDARD: "" }),
          this.color.copy(e.color),
          (this.roughness = e.roughness),
          (this.metalness = e.metalness),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.roughnessMap = e.roughnessMap),
          (this.metalnessMap = e.metalnessMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.envMapIntensity = e.envMapIntensity),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.flatShading = e.flatShading),
          (this.fog = e.fog),
          this
        );
      }
    },
    la = class extends wh {
      constructor(e) {
        super();
        (this.isMeshPhysicalMaterial = !0),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.type = "MeshPhysicalMaterial"),
          (this.clearcoatMap = null),
          (this.clearcoatRoughness = 0),
          (this.clearcoatRoughnessMap = null),
          (this.clearcoatNormalScale = new It(1, 1)),
          (this.clearcoatNormalMap = null),
          (this.ior = 1.5),
          Object.defineProperty(this, "reflectivity", {
            get: function () {
              return Dn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
            },
            set: function (t) {
              this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
            },
          }),
          (this.iridescenceMap = null),
          (this.iridescenceIOR = 1.3),
          (this.iridescenceThicknessRange = [100, 400]),
          (this.iridescenceThicknessMap = null),
          (this.sheenColor = new Bt(0)),
          (this.sheenColorMap = null),
          (this.sheenRoughness = 1),
          (this.sheenRoughnessMap = null),
          (this.transmissionMap = null),
          (this.thickness = 0),
          (this.thicknessMap = null),
          (this.attenuationDistance = 1 / 0),
          (this.attenuationColor = new Bt(1, 1, 1)),
          (this.specularIntensity = 1),
          (this.specularIntensityMap = null),
          (this.specularColor = new Bt(1, 1, 1)),
          (this.specularColorMap = null),
          (this._sheen = 0),
          (this._clearcoat = 0),
          (this._iridescence = 0),
          (this._transmission = 0),
          this.setValues(e);
      }
      get sheen() {
        return this._sheen;
      }
      set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
      }
      get clearcoat() {
        return this._clearcoat;
      }
      set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
      }
      get iridescence() {
        return this._iridescence;
      }
      set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
          (this._iridescence = e);
      }
      get transmission() {
        return this._transmission;
      }
      set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
          (this._transmission = e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.clearcoat = e.clearcoat),
          (this.clearcoatMap = e.clearcoatMap),
          (this.clearcoatRoughness = e.clearcoatRoughness),
          (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
          (this.clearcoatNormalMap = e.clearcoatNormalMap),
          this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
          (this.ior = e.ior),
          (this.iridescence = e.iridescence),
          (this.iridescenceMap = e.iridescenceMap),
          (this.iridescenceIOR = e.iridescenceIOR),
          (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
          (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
          (this.sheen = e.sheen),
          this.sheenColor.copy(e.sheenColor),
          (this.sheenColorMap = e.sheenColorMap),
          (this.sheenRoughness = e.sheenRoughness),
          (this.sheenRoughnessMap = e.sheenRoughnessMap),
          (this.transmission = e.transmission),
          (this.transmissionMap = e.transmissionMap),
          (this.thickness = e.thickness),
          (this.thicknessMap = e.thicknessMap),
          (this.attenuationDistance = e.attenuationDistance),
          this.attenuationColor.copy(e.attenuationColor),
          (this.specularIntensity = e.specularIntensity),
          (this.specularIntensityMap = e.specularIntensityMap),
          this.specularColor.copy(e.specularColor),
          (this.specularColorMap = e.specularColorMap),
          this
        );
      }
    };
  function Ka(n, e, t) {
    return PC(n)
      ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length))
      : n.slice(e, t);
  }
  function fp(n, e, t) {
    return !n || (!t && n.constructor === e)
      ? n
      : typeof e.BYTES_PER_ELEMENT == "number"
      ? new e(n)
      : Array.prototype.slice.call(n);
  }
  function PC(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView);
  }
  function LG(n) {
    function e(r, s) {
      return n[r] - n[s];
    }
    let t = n.length,
      i = new Array(t);
    for (let r = 0; r !== t; ++r) i[r] = r;
    return i.sort(e), i;
  }
  function WA(n, e, t) {
    let i = n.length,
      r = new n.constructor(i);
    for (let s = 0, a = 0; a !== i; ++s) {
      let o = t[s] * e;
      for (let l = 0; l !== e; ++l) r[a++] = n[o + l];
    }
    return r;
  }
  function DC(n, e, t, i) {
    let r = 1,
      s = n[0];
    for (; s !== void 0 && s[i] === void 0; ) s = n[r++];
    if (s === void 0) return;
    let a = s[i];
    if (a !== void 0)
      if (Array.isArray(a))
        do
          (a = s[i]),
            a !== void 0 && (e.push(s.time), t.push.apply(t, a)),
            (s = n[r++]);
        while (s !== void 0);
      else if (a.toArray !== void 0)
        do
          (a = s[i]),
            a !== void 0 && (e.push(s.time), a.toArray(t, t.length)),
            (s = n[r++]);
        while (s !== void 0);
      else
        do
          (a = s[i]), a !== void 0 && (e.push(s.time), t.push(a)), (s = n[r++]);
        while (s !== void 0);
  }
  var dl = class {
      constructor(e, t, i, r) {
        (this.parameterPositions = e),
          (this._cachedIndex = 0),
          (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
          (this.sampleValues = t),
          (this.valueSize = i),
          (this.settings = null),
          (this.DefaultSettings_ = {});
      }
      evaluate(e) {
        let t = this.parameterPositions,
          i = this._cachedIndex,
          r = t[i],
          s = t[i - 1];
        e: {
          t: {
            let a;
            i: {
              n: if (!(e < r)) {
                for (let o = i + 2; ; ) {
                  if (r === void 0) {
                    if (e < s) break n;
                    return (
                      (i = t.length),
                      (this._cachedIndex = i),
                      this.copySampleValue_(i - 1)
                    );
                  }
                  if (i === o) break;
                  if (((s = r), (r = t[++i]), e < r)) break t;
                }
                a = t.length;
                break i;
              }
              if (!(e >= s)) {
                let o = t[1];
                e < o && ((i = 2), (s = o));
                for (let l = i - 2; ; ) {
                  if (s === void 0)
                    return (this._cachedIndex = 0), this.copySampleValue_(0);
                  if (i === l) break;
                  if (((r = s), (s = t[--i - 1]), e >= s)) break t;
                }
                (a = i), (i = 0);
                break i;
              }
              break e;
            }
            for (; i < a; ) {
              let o = (i + a) >>> 1;
              e < t[o] ? (a = o) : (i = o + 1);
            }
            if (((r = t[i]), (s = t[i - 1]), s === void 0))
              return (this._cachedIndex = 0), this.copySampleValue_(0);
            if (r === void 0)
              return (
                (i = t.length),
                (this._cachedIndex = i),
                this.copySampleValue_(i - 1)
              );
          }
          (this._cachedIndex = i), this.intervalChanged_(i, s, r);
        }
        return this.interpolate_(i, s, e, r);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(e) {
        let t = this.resultBuffer,
          i = this.sampleValues,
          r = this.valueSize,
          s = e * r;
        for (let a = 0; a !== r; ++a) t[a] = i[s + a];
        return t;
      }
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {}
    },
    IC = class extends dl {
      constructor(e, t, i, r) {
        super(e, t, i, r);
        (this._weightPrev = -0),
          (this._offsetPrev = -0),
          (this._weightNext = -0),
          (this._offsetNext = -0),
          (this.DefaultSettings_ = { endingStart: Sc, endingEnd: Sc });
      }
      intervalChanged_(e, t, i) {
        let r = this.parameterPositions,
          s = e - 2,
          a = e + 1,
          o = r[s],
          l = r[a];
        if (o === void 0)
          switch (this.getSettings_().endingStart) {
            case wc:
              (s = e), (o = 2 * t - i);
              break;
            case gp:
              (s = r.length - 2), (o = t + r[s] - r[s + 1]);
              break;
            default:
              (s = e), (o = i);
          }
        if (l === void 0)
          switch (this.getSettings_().endingEnd) {
            case wc:
              (a = e), (l = 2 * i - t);
              break;
            case gp:
              (a = 1), (l = i + r[1] - r[0]);
              break;
            default:
              (a = e - 1), (l = t);
          }
        let c = (i - t) * 0.5,
          u = this.valueSize;
        (this._weightPrev = c / (t - o)),
          (this._weightNext = c / (l - i)),
          (this._offsetPrev = s * u),
          (this._offsetNext = a * u);
      }
      interpolate_(e, t, i, r) {
        let s = this.resultBuffer,
          a = this.sampleValues,
          o = this.valueSize,
          l = e * o,
          c = l - o,
          u = this._offsetPrev,
          f = this._offsetNext,
          d = this._weightPrev,
          m = this._weightNext,
          x = (i - t) / (r - t),
          y = x * x,
          g = y * x,
          b = -d * g + 2 * d * y - d * x,
          _ = (1 + d) * g + (-1.5 - 2 * d) * y + (-0.5 + d) * x + 1,
          E = (-1 - m) * g + (1.5 + m) * y + 0.5 * x,
          w = m * g - m * y;
        for (let P = 0; P !== o; ++P)
          s[P] = b * a[u + P] + _ * a[c + P] + E * a[l + P] + w * a[f + P];
        return s;
      }
    },
    wx = class extends dl {
      constructor(e, t, i, r) {
        super(e, t, i, r);
      }
      interpolate_(e, t, i, r) {
        let s = this.resultBuffer,
          a = this.sampleValues,
          o = this.valueSize,
          l = e * o,
          c = l - o,
          u = (i - t) / (r - t),
          f = 1 - u;
        for (let d = 0; d !== o; ++d) s[d] = a[c + d] * f + a[l + d] * u;
        return s;
      }
    },
    LC = class extends dl {
      constructor(e, t, i, r) {
        super(e, t, i, r);
      }
      interpolate_(e) {
        return this.copySampleValue_(e - 1);
      }
    },
    ps = class {
      constructor(e, t, i, r) {
        if (e === void 0)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
          throw new Error(
            "THREE.KeyframeTrack: no keyframes in track named " + e
          );
        (this.name = e),
          (this.times = fp(t, this.TimeBufferType)),
          (this.values = fp(i, this.ValueBufferType)),
          this.setInterpolation(r || this.DefaultInterpolation);
      }
      static toJSON(e) {
        let t = e.constructor,
          i;
        if (t.toJSON !== this.toJSON) i = t.toJSON(e);
        else {
          i = {
            name: e.name,
            times: fp(e.times, Array),
            values: fp(e.values, Array),
          };
          let r = e.getInterpolation();
          r !== e.DefaultInterpolation && (i.interpolation = r);
        }
        return (i.type = e.ValueTypeName), i;
      }
      InterpolantFactoryMethodDiscrete(e) {
        return new LC(this.times, this.values, this.getValueSize(), e);
      }
      InterpolantFactoryMethodLinear(e) {
        return new wx(this.times, this.values, this.getValueSize(), e);
      }
      InterpolantFactoryMethodSmooth(e) {
        return new IC(this.times, this.values, this.getValueSize(), e);
      }
      setInterpolation(e) {
        let t;
        switch (e) {
          case Lc:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
          case al:
            t = this.InterpolantFactoryMethodLinear;
            break;
          case Ev:
            t = this.InterpolantFactoryMethodSmooth;
            break;
        }
        if (t === void 0) {
          let i =
            "unsupported interpolation for " +
            this.ValueTypeName +
            " keyframe track named " +
            this.name;
          if (this.createInterpolant === void 0)
            if (e !== this.DefaultInterpolation)
              this.setInterpolation(this.DefaultInterpolation);
            else throw new Error(i);
          return console.warn("THREE.KeyframeTrack:", i), this;
        }
        return (this.createInterpolant = t), this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return Lc;
          case this.InterpolantFactoryMethodLinear:
            return al;
          case this.InterpolantFactoryMethodSmooth:
            return Ev;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(e) {
        if (e !== 0) {
          let t = this.times;
          for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
        }
        return this;
      }
      scale(e) {
        if (e !== 1) {
          let t = this.times;
          for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
        }
        return this;
      }
      trim(e, t) {
        let i = this.times,
          r = i.length,
          s = 0,
          a = r - 1;
        for (; s !== r && i[s] < e; ) ++s;
        for (; a !== -1 && i[a] > t; ) --a;
        if ((++a, s !== 0 || a !== r)) {
          s >= a && ((a = Math.max(a, 1)), (s = a - 1));
          let o = this.getValueSize();
          (this.times = Ka(i, s, a)),
            (this.values = Ka(this.values, s * o, a * o));
        }
        return this;
      }
      validate() {
        let e = !0,
          t = this.getValueSize();
        t - Math.floor(t) !== 0 &&
          (console.error(
            "THREE.KeyframeTrack: Invalid value size in track.",
            this
          ),
          (e = !1));
        let i = this.times,
          r = this.values,
          s = i.length;
        s === 0 &&
          (console.error("THREE.KeyframeTrack: Track is empty.", this),
          (e = !1));
        let a = null;
        for (let o = 0; o !== s; o++) {
          let l = i[o];
          if (typeof l == "number" && isNaN(l)) {
            console.error(
              "THREE.KeyframeTrack: Time is not a valid number.",
              this,
              o,
              l
            ),
              (e = !1);
            break;
          }
          if (a !== null && a > l) {
            console.error(
              "THREE.KeyframeTrack: Out of order keys.",
              this,
              o,
              l,
              a
            ),
              (e = !1);
            break;
          }
          a = l;
        }
        if (r !== void 0 && PC(r))
          for (let o = 0, l = r.length; o !== l; ++o) {
            let c = r[o];
            if (isNaN(c)) {
              console.error(
                "THREE.KeyframeTrack: Value is not a valid number.",
                this,
                o,
                c
              ),
                (e = !1);
              break;
            }
          }
        return e;
      }
      optimize() {
        let e = Ka(this.times),
          t = Ka(this.values),
          i = this.getValueSize(),
          r = this.getInterpolation() === Ev,
          s = e.length - 1,
          a = 1;
        for (let o = 1; o < s; ++o) {
          let l = !1,
            c = e[o],
            u = e[o + 1];
          if (c !== u && (o !== 1 || c !== e[0]))
            if (r) l = !0;
            else {
              let f = o * i,
                d = f - i,
                m = f + i;
              for (let x = 0; x !== i; ++x) {
                let y = t[f + x];
                if (y !== t[d + x] || y !== t[m + x]) {
                  l = !0;
                  break;
                }
              }
            }
          if (l) {
            if (o !== a) {
              e[a] = e[o];
              let f = o * i,
                d = a * i;
              for (let m = 0; m !== i; ++m) t[d + m] = t[f + m];
            }
            ++a;
          }
        }
        if (s > 0) {
          e[a] = e[s];
          for (let o = s * i, l = a * i, c = 0; c !== i; ++c)
            t[l + c] = t[o + c];
          ++a;
        }
        return (
          a !== e.length
            ? ((this.times = Ka(e, 0, a)), (this.values = Ka(t, 0, a * i)))
            : ((this.times = e), (this.values = t)),
          this
        );
      }
      clone() {
        let e = Ka(this.times, 0),
          t = Ka(this.values, 0),
          i = this.constructor,
          r = new i(this.name, e, t);
        return (r.createInterpolant = this.createInterpolant), r;
      }
    };
  ps.prototype.TimeBufferType = Float32Array;
  ps.prototype.ValueBufferType = Float32Array;
  ps.prototype.DefaultInterpolation = al;
  var pl = class extends ps {};
  pl.prototype.ValueTypeName = "bool";
  pl.prototype.ValueBufferType = Array;
  pl.prototype.DefaultInterpolation = Lc;
  pl.prototype.InterpolantFactoryMethodLinear = void 0;
  pl.prototype.InterpolantFactoryMethodSmooth = void 0;
  var Mx = class extends ps {};
  Mx.prototype.ValueTypeName = "color";
  var ll = class extends ps {};
  ll.prototype.ValueTypeName = "number";
  var RC = class extends dl {
      constructor(e, t, i, r) {
        super(e, t, i, r);
      }
      interpolate_(e, t, i, r) {
        let s = this.resultBuffer,
          a = this.sampleValues,
          o = this.valueSize,
          l = (i - t) / (r - t),
          c = e * o;
        for (let u = c + o; c !== u; c += 4)
          In.slerpFlat(s, 0, a, c - o, a, c, l);
        return s;
      }
    },
    ca = class extends ps {
      InterpolantFactoryMethodLinear(e) {
        return new RC(this.times, this.values, this.getValueSize(), e);
      }
    };
  ca.prototype.ValueTypeName = "quaternion";
  ca.prototype.DefaultInterpolation = al;
  ca.prototype.InterpolantFactoryMethodSmooth = void 0;
  var ml = class extends ps {};
  ml.prototype.ValueTypeName = "string";
  ml.prototype.ValueBufferType = Array;
  ml.prototype.DefaultInterpolation = Lc;
  ml.prototype.InterpolantFactoryMethodLinear = void 0;
  ml.prototype.InterpolantFactoryMethodSmooth = void 0;
  var cl = class extends ps {};
  cl.prototype.ValueTypeName = "vector";
  var gh = class {
    constructor(e, t = -1, i, r = lx) {
      (this.name = e),
        (this.tracks = i),
        (this.duration = t),
        (this.blendMode = r),
        (this.uuid = ds()),
        this.duration < 0 && this.resetDuration();
    }
    static parse(e) {
      let t = [],
        i = e.tracks,
        r = 1 / (e.fps || 1);
      for (let a = 0, o = i.length; a !== o; ++a) t.push(OG(i[a]).scale(r));
      let s = new this(e.name, e.duration, t, e.blendMode);
      return (s.uuid = e.uuid), s;
    }
    static toJSON(e) {
      let t = [],
        i = e.tracks,
        r = {
          name: e.name,
          duration: e.duration,
          tracks: t,
          uuid: e.uuid,
          blendMode: e.blendMode,
        };
      for (let s = 0, a = i.length; s !== a; ++s) t.push(ps.toJSON(i[s]));
      return r;
    }
    static CreateFromMorphTargetSequence(e, t, i, r) {
      let s = t.length,
        a = [];
      for (let o = 0; o < s; o++) {
        let l = [],
          c = [];
        l.push((o + s - 1) % s, o, (o + 1) % s), c.push(0, 1, 0);
        let u = LG(l);
        (l = WA(l, 1, u)),
          (c = WA(c, 1, u)),
          !r && l[0] === 0 && (l.push(s), c.push(c[0])),
          a.push(
            new ll(".morphTargetInfluences[" + t[o].name + "]", l, c).scale(
              1 / i
            )
          );
      }
      return new this(e, -1, a);
    }
    static findByName(e, t) {
      let i = e;
      if (!Array.isArray(e)) {
        let r = e;
        i = (r.geometry && r.geometry.animations) || r.animations;
      }
      for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(e, t, i) {
      let r = {},
        s = /^([\w-]*?)([\d]+)$/;
      for (let o = 0, l = e.length; o < l; o++) {
        let c = e[o],
          u = c.name.match(s);
        if (u && u.length > 1) {
          let f = u[1],
            d = r[f];
          d || (r[f] = d = []), d.push(c);
        }
      }
      let a = [];
      for (let o in r)
        a.push(this.CreateFromMorphTargetSequence(o, r[o], t, i));
      return a;
    }
    static parseAnimation(e, t) {
      if (!e)
        return (
          console.error(
            "THREE.AnimationClip: No animation in JSONLoader data."
          ),
          null
        );
      let i = function (f, d, m, x, y) {
          if (m.length !== 0) {
            let g = [],
              b = [];
            DC(m, g, b, x), g.length !== 0 && y.push(new f(d, g, b));
          }
        },
        r = [],
        s = e.name || "default",
        a = e.fps || 30,
        o = e.blendMode,
        l = e.length || -1,
        c = e.hierarchy || [];
      for (let f = 0; f < c.length; f++) {
        let d = c[f].keys;
        if (!(!d || d.length === 0))
          if (d[0].morphTargets) {
            let m = {},
              x;
            for (x = 0; x < d.length; x++)
              if (d[x].morphTargets)
                for (let y = 0; y < d[x].morphTargets.length; y++)
                  m[d[x].morphTargets[y]] = -1;
            for (let y in m) {
              let g = [],
                b = [];
              for (let _ = 0; _ !== d[x].morphTargets.length; ++_) {
                let E = d[x];
                g.push(E.time), b.push(E.morphTarget === y ? 1 : 0);
              }
              r.push(new ll(".morphTargetInfluence[" + y + "]", g, b));
            }
            l = m.length * a;
          } else {
            let m = ".bones[" + t[f].name + "]";
            i(cl, m + ".position", d, "pos", r),
              i(ca, m + ".quaternion", d, "rot", r),
              i(cl, m + ".scale", d, "scl", r);
          }
      }
      return r.length === 0 ? null : new this(s, l, r, o);
    }
    resetDuration() {
      let e = this.tracks,
        t = 0;
      for (let i = 0, r = e.length; i !== r; ++i) {
        let s = this.tracks[i];
        t = Math.max(t, s.times[s.times.length - 1]);
      }
      return (this.duration = t), this;
    }
    trim() {
      for (let e = 0; e < this.tracks.length; e++)
        this.tracks[e].trim(0, this.duration);
      return this;
    }
    validate() {
      let e = !0;
      for (let t = 0; t < this.tracks.length; t++)
        e = e && this.tracks[t].validate();
      return e;
    }
    optimize() {
      for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
      return this;
    }
    clone() {
      let e = [];
      for (let t = 0; t < this.tracks.length; t++)
        e.push(this.tracks[t].clone());
      return new this.constructor(this.name, this.duration, e, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  };
  function RG(n) {
    switch (n.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return ll;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return cl;
      case "color":
        return Mx;
      case "quaternion":
        return ca;
      case "bool":
      case "boolean":
        return pl;
      case "string":
        return ml;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
  }
  function OG(n) {
    if (n.type === void 0)
      throw new Error(
        "THREE.KeyframeTrack: track type undefined, can not parse"
      );
    let e = RG(n.type);
    if (n.times === void 0) {
      let t = [],
        i = [];
      DC(n.keys, t, i, "value"), (n.times = t), (n.values = i);
    }
    return e.parse !== void 0
      ? e.parse(n)
      : new e(n.name, n.times, n.values, n.interpolation);
  }
  var Oc = {
      enabled: !1,
      files: {},
      add: function (n, e) {
        this.enabled !== !1 && (this.files[n] = e);
      },
      get: function (n) {
        if (this.enabled !== !1) return this.files[n];
      },
      remove: function (n) {
        delete this.files[n];
      },
      clear: function () {
        this.files = {};
      },
    },
    OC = class {
      constructor(e, t, i) {
        let r = this,
          s = !1,
          a = 0,
          o = 0,
          l,
          c = [];
        (this.onStart = void 0),
          (this.onLoad = e),
          (this.onProgress = t),
          (this.onError = i),
          (this.itemStart = function (u) {
            o++,
              s === !1 && r.onStart !== void 0 && r.onStart(u, a, o),
              (s = !0);
          }),
          (this.itemEnd = function (u) {
            a++,
              r.onProgress !== void 0 && r.onProgress(u, a, o),
              a === o && ((s = !1), r.onLoad !== void 0 && r.onLoad());
          }),
          (this.itemError = function (u) {
            r.onError !== void 0 && r.onError(u);
          }),
          (this.resolveURL = function (u) {
            return l ? l(u) : u;
          }),
          (this.setURLModifier = function (u) {
            return (l = u), this;
          }),
          (this.addHandler = function (u, f) {
            return c.push(u, f), this;
          }),
          (this.removeHandler = function (u) {
            let f = c.indexOf(u);
            return f !== -1 && c.splice(f, 2), this;
          }),
          (this.getHandler = function (u) {
            for (let f = 0, d = c.length; f < d; f += 2) {
              let m = c[f],
                x = c[f + 1];
              if ((m.global && (m.lastIndex = 0), m.test(u))) return x;
            }
            return null;
          });
      }
    },
    NG = new OC(),
    ua = class {
      constructor(e) {
        (this.manager = e !== void 0 ? e : NG),
          (this.crossOrigin = "anonymous"),
          (this.withCredentials = !1),
          (this.path = ""),
          (this.resourcePath = ""),
          (this.requestHeader = {});
      }
      load() {}
      loadAsync(e, t) {
        let i = this;
        return new Promise(function (r, s) {
          i.load(e, r, t, s);
        });
      }
      parse() {}
      setCrossOrigin(e) {
        return (this.crossOrigin = e), this;
      }
      setWithCredentials(e) {
        return (this.withCredentials = e), this;
      }
      setPath(e) {
        return (this.path = e), this;
      }
      setResourcePath(e) {
        return (this.resourcePath = e), this;
      }
      setRequestHeader(e) {
        return (this.requestHeader = e), this;
      }
    },
    na = {},
    NC = class extends Error {
      constructor(e, t) {
        super(e);
        this.response = t;
      }
    },
    gl = class extends ua {
      constructor(e) {
        super(e);
      }
      load(e, t, i, r) {
        e === void 0 && (e = ""),
          this.path !== void 0 && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        let s = Oc.get(e);
        if (s !== void 0)
          return (
            this.manager.itemStart(e),
            setTimeout(() => {
              t && t(s), this.manager.itemEnd(e);
            }, 0),
            s
          );
        if (na[e] !== void 0) {
          na[e].push({ onLoad: t, onProgress: i, onError: r });
          return;
        }
        (na[e] = []), na[e].push({ onLoad: t, onProgress: i, onError: r });
        let a = new Request(e, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin",
          }),
          o = this.mimeType,
          l = this.responseType;
        fetch(a)
          .then((c) => {
            if (c.status === 200 || c.status === 0) {
              if (
                (c.status === 0 &&
                  console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream == "undefined" ||
                  c.body === void 0 ||
                  c.body.getReader === void 0)
              )
                return c;
              let u = na[e],
                f = c.body.getReader(),
                d =
                  c.headers.get("Content-Length") ||
                  c.headers.get("X-File-Size"),
                m = d ? parseInt(d) : 0,
                x = m !== 0,
                y = 0,
                g = new ReadableStream({
                  start(b) {
                    _();
                    function _() {
                      f.read().then(({ done: E, value: w }) => {
                        if (E) b.close();
                        else {
                          y += w.byteLength;
                          let P = new ProgressEvent("progress", {
                            lengthComputable: x,
                            loaded: y,
                            total: m,
                          });
                          for (let L = 0, I = u.length; L < I; L++) {
                            let M = u[L];
                            M.onProgress && M.onProgress(P);
                          }
                          b.enqueue(w), _();
                        }
                      });
                    }
                  },
                });
              return new Response(g);
            } else
              throw new NC(
                `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
                c
              );
          })
          .then((c) => {
            switch (l) {
              case "arraybuffer":
                return c.arrayBuffer();
              case "blob":
                return c.blob();
              case "document":
                return c
                  .text()
                  .then((u) => new DOMParser().parseFromString(u, o));
              case "json":
                return c.json();
              default:
                if (o === void 0) return c.text();
                {
                  let f = /charset="?([^;"\s]*)"?/i.exec(o),
                    d = f && f[1] ? f[1].toLowerCase() : void 0,
                    m = new TextDecoder(d);
                  return c.arrayBuffer().then((x) => m.decode(x));
                }
            }
          })
          .then((c) => {
            Oc.add(e, c);
            let u = na[e];
            delete na[e];
            for (let f = 0, d = u.length; f < d; f++) {
              let m = u[f];
              m.onLoad && m.onLoad(c);
            }
          })
          .catch((c) => {
            let u = na[e];
            if (u === void 0) throw (this.manager.itemError(e), c);
            delete na[e];
            for (let f = 0, d = u.length; f < d; f++) {
              let m = u[f];
              m.onError && m.onError(c);
            }
            this.manager.itemError(e);
          })
          .finally(() => {
            this.manager.itemEnd(e);
          }),
          this.manager.itemStart(e);
      }
      setResponseType(e) {
        return (this.responseType = e), this;
      }
      setMimeType(e) {
        return (this.mimeType = e), this;
      }
    };
  var kC = class extends ua {
    constructor(e) {
      super(e);
    }
    load(e, t, i, r) {
      this.path !== void 0 && (e = this.path + e),
        (e = this.manager.resolveURL(e));
      let s = this,
        a = Oc.get(e);
      if (a !== void 0)
        return (
          s.manager.itemStart(e),
          setTimeout(function () {
            t && t(a), s.manager.itemEnd(e);
          }, 0),
          a
        );
      let o = mh("img");
      function l() {
        u(), Oc.add(e, this), t && t(this), s.manager.itemEnd(e);
      }
      function c(f) {
        u(), r && r(f), s.manager.itemError(e), s.manager.itemEnd(e);
      }
      function u() {
        o.removeEventListener("load", l, !1),
          o.removeEventListener("error", c, !1);
      }
      return (
        o.addEventListener("load", l, !1),
        o.addEventListener("error", c, !1),
        e.slice(0, 5) !== "data:" &&
          this.crossOrigin !== void 0 &&
          (o.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        (o.src = e),
        o
      );
    }
  };
  var Ax = class extends ua {
      constructor(e) {
        super(e);
      }
      load(e, t, i, r) {
        let s = new hn(),
          a = new kC(this.manager);
        return (
          a.setCrossOrigin(this.crossOrigin),
          a.setPath(this.path),
          a.load(
            e,
            function (o) {
              (s.image = o), (s.needsUpdate = !0), t !== void 0 && t(s);
            },
            i,
            r
          ),
          s
        );
      }
    },
    Mh = class extends Ai {
      constructor(e, t = 1) {
        super();
        (this.isLight = !0),
          (this.type = "Light"),
          (this.color = new Bt(e)),
          (this.intensity = t);
      }
      dispose() {}
      copy(e, t) {
        return (
          super.copy(e, t),
          this.color.copy(e.color),
          (this.intensity = e.intensity),
          this
        );
      }
      toJSON(e) {
        let t = super.toJSON(e);
        return (
          (t.object.color = this.color.getHex()),
          (t.object.intensity = this.intensity),
          this.groundColor !== void 0 &&
            (t.object.groundColor = this.groundColor.getHex()),
          this.distance !== void 0 && (t.object.distance = this.distance),
          this.angle !== void 0 && (t.object.angle = this.angle),
          this.decay !== void 0 && (t.object.decay = this.decay),
          this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
          this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
          t
        );
      }
    };
  var Xv = new Wt(),
    qA = new le(),
    jA = new le(),
    Mp = class {
      constructor(e) {
        (this.camera = e),
          (this.bias = 0),
          (this.normalBias = 0),
          (this.radius = 1),
          (this.blurSamples = 8),
          (this.mapSize = new It(512, 512)),
          (this.map = null),
          (this.mapPass = null),
          (this.matrix = new Wt()),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this._frustum = new bp()),
          (this._frameExtents = new It(1, 1)),
          (this._viewportCount = 1),
          (this._viewports = [new Ti(0, 0, 1, 1)]);
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(e) {
        let t = this.camera,
          i = this.matrix;
        qA.setFromMatrixPosition(e.matrixWorld),
          t.position.copy(qA),
          jA.setFromMatrixPosition(e.target.matrixWorld),
          t.lookAt(jA),
          t.updateMatrixWorld(),
          Xv.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(Xv),
          i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
          i.multiply(Xv);
      }
      getViewport(e) {
        return this._viewports[e];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
      }
      copy(e) {
        return (
          (this.camera = e.camera.clone()),
          (this.bias = e.bias),
          (this.radius = e.radius),
          this.mapSize.copy(e.mapSize),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        let e = {};
        return (
          this.bias !== 0 && (e.bias = this.bias),
          this.normalBias !== 0 && (e.normalBias = this.normalBias),
          this.radius !== 1 && (e.radius = this.radius),
          (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
            (e.mapSize = this.mapSize.toArray()),
          (e.camera = this.camera.toJSON(!1).object),
          delete e.camera.matrix,
          e
        );
      }
    },
    FC = class extends Mp {
      constructor() {
        super(new yn(50, 1, 0.5, 500));
        (this.isSpotLightShadow = !0), (this.focus = 1);
      }
      updateMatrices(e) {
        let t = this.camera,
          i = ph * 2 * e.angle * this.focus,
          r = this.mapSize.width / this.mapSize.height,
          s = e.distance || t.far;
        (i !== t.fov || r !== t.aspect || s !== t.far) &&
          ((t.fov = i),
          (t.aspect = r),
          (t.far = s),
          t.updateProjectionMatrix()),
          super.updateMatrices(e);
      }
      copy(e) {
        return super.copy(e), (this.focus = e.focus), this;
      }
    },
    Cx = class extends Mh {
      constructor(e, t, i = 0, r = Math.PI / 3, s = 0, a = 2) {
        super(e, t);
        (this.isSpotLight = !0),
          (this.type = "SpotLight"),
          this.position.copy(Ai.DefaultUp),
          this.updateMatrix(),
          (this.target = new Ai()),
          (this.distance = i),
          (this.angle = r),
          (this.penumbra = s),
          (this.decay = a),
          (this.map = null),
          (this.shadow = new FC());
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power(e) {
        this.intensity = e / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.distance = e.distance),
          (this.angle = e.angle),
          (this.penumbra = e.penumbra),
          (this.decay = e.decay),
          (this.target = e.target.clone()),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    },
    XA = new Wt(),
    rh = new le(),
    Yv = new le(),
    BC = class extends Mp {
      constructor() {
        super(new yn(90, 1, 0.5, 500));
        (this.isPointLightShadow = !0),
          (this._frameExtents = new It(4, 2)),
          (this._viewportCount = 6),
          (this._viewports = [
            new Ti(2, 1, 1, 1),
            new Ti(0, 1, 1, 1),
            new Ti(3, 1, 1, 1),
            new Ti(1, 1, 1, 1),
            new Ti(3, 0, 1, 1),
            new Ti(1, 0, 1, 1),
          ]),
          (this._cubeDirections = [
            new le(1, 0, 0),
            new le(-1, 0, 0),
            new le(0, 0, 1),
            new le(0, 0, -1),
            new le(0, 1, 0),
            new le(0, -1, 0),
          ]),
          (this._cubeUps = [
            new le(0, 1, 0),
            new le(0, 1, 0),
            new le(0, 1, 0),
            new le(0, 1, 0),
            new le(0, 0, 1),
            new le(0, 0, -1),
          ]);
      }
      updateMatrices(e, t = 0) {
        let i = this.camera,
          r = this.matrix,
          s = e.distance || i.far;
        s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
          rh.setFromMatrixPosition(e.matrixWorld),
          i.position.copy(rh),
          Yv.copy(i.position),
          Yv.add(this._cubeDirections[t]),
          i.up.copy(this._cubeUps[t]),
          i.lookAt(Yv),
          i.updateMatrixWorld(),
          r.makeTranslation(-rh.x, -rh.y, -rh.z),
          XA.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(XA);
      }
    },
    Px = class extends Mh {
      constructor(e, t, i = 0, r = 2) {
        super(e, t);
        (this.isPointLight = !0),
          (this.type = "PointLight"),
          (this.distance = i),
          (this.decay = r),
          (this.shadow = new BC());
      }
      get power() {
        return this.intensity * 4 * Math.PI;
      }
      set power(e) {
        this.intensity = e / (4 * Math.PI);
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.distance = e.distance),
          (this.decay = e.decay),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    },
    zC = class extends Mp {
      constructor() {
        super(new fl(-5, 5, 5, -5, 0.5, 500));
        this.isDirectionalLightShadow = !0;
      }
    },
    Dx = class extends Mh {
      constructor(e, t) {
        super(e, t);
        (this.isDirectionalLight = !0),
          (this.type = "DirectionalLight"),
          this.position.copy(Ai.DefaultUp),
          this.updateMatrix(),
          (this.target = new Ai()),
          (this.shadow = new zC());
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.target = e.target.clone()),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    },
    Ah = class extends Mh {
      constructor(e, t) {
        super(e, t);
        (this.isAmbientLight = !0), (this.type = "AmbientLight");
      }
    };
  var ha = class {
    static decodeText(e) {
      if (typeof TextDecoder != "undefined") return new TextDecoder().decode(e);
      let t = "";
      for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
      try {
        return decodeURIComponent(escape(t));
      } catch (i) {
        return t;
      }
    }
    static extractUrlBase(e) {
      let t = e.lastIndexOf("/");
      return t === -1 ? "./" : e.slice(0, t + 1);
    }
    static resolveURL(e, t) {
      return typeof e != "string" || e === ""
        ? ""
        : (/^https?:\/\//i.test(t) &&
            /^\//.test(e) &&
            (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
          /^(https?:)?\/\//i.test(e) ||
          /^data:.*,.*$/i.test(e) ||
          /^blob:.*$/i.test(e)
            ? e
            : t + e);
    }
  };
  var Ix = class extends ua {
    constructor(e) {
      super(e);
      (this.isImageBitmapLoader = !0),
        typeof createImageBitmap == "undefined" &&
          console.warn(
            "THREE.ImageBitmapLoader: createImageBitmap() not supported."
          ),
        typeof fetch == "undefined" &&
          console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        (this.options = { premultiplyAlpha: "none" });
    }
    setOptions(e) {
      return (this.options = e), this;
    }
    load(e, t, i, r) {
      e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        (e = this.manager.resolveURL(e));
      let s = this,
        a = Oc.get(e);
      if (a !== void 0)
        return (
          s.manager.itemStart(e),
          setTimeout(function () {
            t && t(a), s.manager.itemEnd(e);
          }, 0),
          a
        );
      let o = {};
      (o.credentials =
        this.crossOrigin === "anonymous" ? "same-origin" : "include"),
        (o.headers = this.requestHeader),
        fetch(e, o)
          .then(function (l) {
            return l.blob();
          })
          .then(function (l) {
            return createImageBitmap(
              l,
              Object.assign(s.options, { colorSpaceConversion: "none" })
            );
          })
          .then(function (l) {
            Oc.add(e, l), t && t(l), s.manager.itemEnd(e);
          })
          .catch(function (l) {
            r && r(l), s.manager.itemError(e), s.manager.itemEnd(e);
          }),
        s.manager.itemStart(e);
    }
  };
  var Ch = class {
    constructor(e = !0) {
      (this.autoStart = e),
        (this.startTime = 0),
        (this.oldTime = 0),
        (this.elapsedTime = 0),
        (this.running = !1);
    }
    start() {
      (this.startTime = YA()),
        (this.oldTime = this.startTime),
        (this.elapsedTime = 0),
        (this.running = !0);
    }
    stop() {
      this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let e = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        let t = YA();
        (e = (t - this.oldTime) / 1e3),
          (this.oldTime = t),
          (this.elapsedTime += e);
      }
      return e;
    }
  };
  function YA() {
    return (typeof performance == "undefined" ? Date : performance).now();
  }
  var UC = class {
      constructor(e, t, i) {
        (this.binding = e), (this.valueSize = i);
        let r, s, a;
        switch (t) {
          case "quaternion":
            (r = this._slerp),
              (s = this._slerpAdditive),
              (a = this._setAdditiveIdentityQuaternion),
              (this.buffer = new Float64Array(i * 6)),
              (this._workIndex = 5);
            break;
          case "string":
          case "bool":
            (r = this._select),
              (s = this._select),
              (a = this._setAdditiveIdentityOther),
              (this.buffer = new Array(i * 5));
            break;
          default:
            (r = this._lerp),
              (s = this._lerpAdditive),
              (a = this._setAdditiveIdentityNumeric),
              (this.buffer = new Float64Array(i * 5));
        }
        (this._mixBufferRegion = r),
          (this._mixBufferRegionAdditive = s),
          (this._setIdentity = a),
          (this._origIndex = 3),
          (this._addIndex = 4),
          (this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0),
          (this.useCount = 0),
          (this.referenceCount = 0);
      }
      accumulate(e, t) {
        let i = this.buffer,
          r = this.valueSize,
          s = e * r + r,
          a = this.cumulativeWeight;
        if (a === 0) {
          for (let o = 0; o !== r; ++o) i[s + o] = i[o];
          a = t;
        } else {
          a += t;
          let o = t / a;
          this._mixBufferRegion(i, s, 0, o, r);
        }
        this.cumulativeWeight = a;
      }
      accumulateAdditive(e) {
        let t = this.buffer,
          i = this.valueSize,
          r = i * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
          this._mixBufferRegionAdditive(t, r, 0, e, i),
          (this.cumulativeWeightAdditive += e);
      }
      apply(e) {
        let t = this.valueSize,
          i = this.buffer,
          r = e * t + t,
          s = this.cumulativeWeight,
          a = this.cumulativeWeightAdditive,
          o = this.binding;
        if (
          ((this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0),
          s < 1)
        ) {
          let l = t * this._origIndex;
          this._mixBufferRegion(i, r, l, 1 - s, t);
        }
        a > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
        for (let l = t, c = t + t; l !== c; ++l)
          if (i[l] !== i[l + t]) {
            o.setValue(i, r);
            break;
          }
      }
      saveOriginalState() {
        let e = this.binding,
          t = this.buffer,
          i = this.valueSize,
          r = i * this._origIndex;
        e.getValue(t, r);
        for (let s = i, a = r; s !== a; ++s) t[s] = t[r + (s % i)];
        this._setIdentity(),
          (this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0);
      }
      restoreOriginalState() {
        let e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e);
      }
      _setAdditiveIdentityNumeric() {
        let e = this._addIndex * this.valueSize,
          t = e + this.valueSize;
        for (let i = e; i < t; i++) this.buffer[i] = 0;
      }
      _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
          (this.buffer[this._addIndex * this.valueSize + 3] = 1);
      }
      _setAdditiveIdentityOther() {
        let e = this._origIndex * this.valueSize,
          t = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++)
          this.buffer[t + i] = this.buffer[e + i];
      }
      _select(e, t, i, r, s) {
        if (r >= 0.5) for (let a = 0; a !== s; ++a) e[t + a] = e[i + a];
      }
      _slerp(e, t, i, r) {
        In.slerpFlat(e, t, e, t, e, i, r);
      }
      _slerpAdditive(e, t, i, r, s) {
        let a = this._workIndex * s;
        In.multiplyQuaternionsFlat(e, a, e, t, e, i),
          In.slerpFlat(e, t, e, t, e, a, r);
      }
      _lerp(e, t, i, r, s) {
        let a = 1 - r;
        for (let o = 0; o !== s; ++o) {
          let l = t + o;
          e[l] = e[l] * a + e[i + o] * r;
        }
      }
      _lerpAdditive(e, t, i, r, s) {
        for (let a = 0; a !== s; ++a) {
          let o = t + a;
          e[o] = e[o] + e[i + a] * r;
        }
      }
    },
    Lx = "\\[\\]\\.:\\/",
    kG = new RegExp("[" + Lx + "]", "g"),
    Rx = "[^" + Lx + "]",
    FG = "[^" + Lx.replace("\\.", "") + "]",
    BG = /((?:WC+[\/:])*)/.source.replace("WC", Rx),
    zG = /(WCOD+)?/.source.replace("WCOD", FG),
    UG = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Rx),
    VG = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Rx),
    GG = new RegExp("^" + BG + zG + UG + VG + "$"),
    HG = ["material", "materials", "bones", "map"],
    VC = class {
      constructor(e, t, i) {
        let r = i || di.parseTrackName(t);
        (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
      }
      getValue(e, t) {
        this.bind();
        let i = this._targetGroup.nCachedObjects_,
          r = this._bindings[i];
        r !== void 0 && r.getValue(e, t);
      }
      setValue(e, t) {
        let i = this._bindings;
        for (
          let r = this._targetGroup.nCachedObjects_, s = i.length;
          r !== s;
          ++r
        )
          i[r].setValue(e, t);
      }
      bind() {
        let e = this._bindings;
        for (
          let t = this._targetGroup.nCachedObjects_, i = e.length;
          t !== i;
          ++t
        )
          e[t].bind();
      }
      unbind() {
        let e = this._bindings;
        for (
          let t = this._targetGroup.nCachedObjects_, i = e.length;
          t !== i;
          ++t
        )
          e[t].unbind();
      }
    },
    di = class {
      constructor(e, t, i) {
        (this.path = t),
          (this.parsedPath = i || di.parseTrackName(t)),
          (this.node = di.findNode(e, this.parsedPath.nodeName) || e),
          (this.rootNode = e),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
      static create(e, t, i) {
        return e && e.isAnimationObjectGroup
          ? new di.Composite(e, t, i)
          : new di(e, t, i);
      }
      static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(kG, "");
      }
      static parseTrackName(e) {
        let t = GG.exec(e);
        if (t === null)
          throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        let i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6],
          },
          r = i.nodeName && i.nodeName.lastIndexOf(".");
        if (r !== void 0 && r !== -1) {
          let s = i.nodeName.substring(r + 1);
          HG.indexOf(s) !== -1 &&
            ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
        }
        if (i.propertyName === null || i.propertyName.length === 0)
          throw new Error(
            "PropertyBinding: can not parse propertyName from trackName: " + e
          );
        return i;
      }
      static findNode(e, t) {
        if (
          t === void 0 ||
          t === "" ||
          t === "." ||
          t === -1 ||
          t === e.name ||
          t === e.uuid
        )
          return e;
        if (e.skeleton) {
          let i = e.skeleton.getBoneByName(t);
          if (i !== void 0) return i;
        }
        if (e.children) {
          let i = function (s) {
              for (let a = 0; a < s.length; a++) {
                let o = s[a];
                if (o.name === t || o.uuid === t) return o;
                let l = i(o.children);
                if (l) return l;
              }
              return null;
            },
            r = i(e.children);
          if (r) return r;
        }
        return null;
      }
      _getValue_unavailable() {}
      _setValue_unavailable() {}
      _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName];
      }
      _getValue_array(e, t) {
        let i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
      }
      _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t);
      }
      _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t];
      }
      _setValue_direct_setNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_array(e, t) {
        let i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
      }
      _setValue_array_setNeedsUpdate(e, t) {
        let i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
        this.targetObject.needsUpdate = !0;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        let i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
      _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t];
      }
      _setValue_arrayElement_setNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t);
      }
      _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t);
      }
      _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t);
      }
      bind() {
        let e = this.node,
          t = this.parsedPath,
          i = t.objectName,
          r = t.propertyName,
          s = t.propertyIndex;
        if (
          (e ||
            ((e = di.findNode(this.rootNode, t.nodeName) || this.rootNode),
            (this.node = e)),
          (this.getValue = this._getValue_unavailable),
          (this.setValue = this._setValue_unavailable),
          !e)
        ) {
          console.error(
            "THREE.PropertyBinding: Trying to update node for track: " +
              this.path +
              " but it wasn't found."
          );
          return;
        }
        if (i) {
          let c = t.objectIndex;
          switch (i) {
            case "materials":
              if (!e.material) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
                return;
              }
              if (!e.material.materials) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this
                );
                return;
              }
              e = e.material.materials;
              break;
            case "bones":
              if (!e.skeleton) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                  this
                );
                return;
              }
              e = e.skeleton.bones;
              for (let u = 0; u < e.length; u++)
                if (e[u].name === c) {
                  c = u;
                  break;
                }
              break;
            case "map":
              if ("map" in e) {
                e = e.map;
                break;
              }
              if (!e.material) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
                return;
              }
              if (!e.material.map) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                  this
                );
                return;
              }
              e = e.material.map;
              break;
            default:
              if (e[i] === void 0) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                  this
                );
                return;
              }
              e = e[i];
          }
          if (c !== void 0) {
            if (e[c] === void 0) {
              console.error(
                "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                this,
                e
              );
              return;
            }
            e = e[c];
          }
        }
        let a = e[r];
        if (a === void 0) {
          let c = t.nodeName;
          console.error(
            "THREE.PropertyBinding: Trying to update property for track: " +
              c +
              "." +
              r +
              " but it wasn't found.",
            e
          );
          return;
        }
        let o = this.Versioning.None;
        (this.targetObject = e),
          e.needsUpdate !== void 0
            ? (o = this.Versioning.NeedsUpdate)
            : e.matrixWorldNeedsUpdate !== void 0 &&
              (o = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
          if (r === "morphTargetInfluences") {
            if (!e.geometry) {
              console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                this
              );
              return;
            }
            if (!e.geometry.morphAttributes) {
              console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                this
              );
              return;
            }
            e.morphTargetDictionary[s] !== void 0 &&
              (s = e.morphTargetDictionary[s]);
          }
          (l = this.BindingType.ArrayElement),
            (this.resolvedProperty = a),
            (this.propertyIndex = s);
        } else
          a.fromArray !== void 0 && a.toArray !== void 0
            ? ((l = this.BindingType.HasFromToArray),
              (this.resolvedProperty = a))
            : Array.isArray(a)
            ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = a))
            : (this.propertyName = r);
        (this.getValue = this.GetterByBindingType[l]),
          (this.setValue = this.SetterByBindingTypeAndVersioning[l][o]);
      }
      unbind() {
        (this.node = null),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
    };
  di.Composite = VC;
  di.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3,
  };
  di.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2,
  };
  di.prototype.GetterByBindingType = [
    di.prototype._getValue_direct,
    di.prototype._getValue_array,
    di.prototype._getValue_arrayElement,
    di.prototype._getValue_toArray,
  ];
  di.prototype.SetterByBindingTypeAndVersioning = [
    [
      di.prototype._setValue_direct,
      di.prototype._setValue_direct_setNeedsUpdate,
      di.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
    ],
    [
      di.prototype._setValue_array,
      di.prototype._setValue_array_setNeedsUpdate,
      di.prototype._setValue_array_setMatrixWorldNeedsUpdate,
    ],
    [
      di.prototype._setValue_arrayElement,
      di.prototype._setValue_arrayElement_setNeedsUpdate,
      di.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
    ],
    [
      di.prototype._setValue_fromArray,
      di.prototype._setValue_fromArray_setNeedsUpdate,
      di.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
    ],
  ];
  var GC = class {
      constructor(e, t, i = null, r = t.blendMode) {
        (this._mixer = e),
          (this._clip = t),
          (this._localRoot = i),
          (this.blendMode = r);
        let s = t.tracks,
          a = s.length,
          o = new Array(a),
          l = { endingStart: Sc, endingEnd: Sc };
        for (let c = 0; c !== a; ++c) {
          let u = s[c].createInterpolant(null);
          (o[c] = u), (u.settings = l);
        }
        (this._interpolantSettings = l),
          (this._interpolants = o),
          (this._propertyBindings = new Array(a)),
          (this._cacheIndex = null),
          (this._byClipCacheIndex = null),
          (this._timeScaleInterpolant = null),
          (this._weightInterpolant = null),
          (this.loop = Sz),
          (this._loopCount = -1),
          (this._startTime = null),
          (this.time = 0),
          (this.timeScale = 1),
          (this._effectiveTimeScale = 1),
          (this.weight = 1),
          (this._effectiveWeight = 1),
          (this.repetitions = 1 / 0),
          (this.paused = !1),
          (this.enabled = !0),
          (this.clampWhenFinished = !1),
          (this.zeroSlopeAtStart = !0),
          (this.zeroSlopeAtEnd = !0);
      }
      play() {
        return this._mixer._activateAction(this), this;
      }
      stop() {
        return this._mixer._deactivateAction(this), this.reset();
      }
      reset() {
        return (
          (this.paused = !1),
          (this.enabled = !0),
          (this.time = 0),
          (this._loopCount = -1),
          (this._startTime = null),
          this.stopFading().stopWarping()
        );
      }
      isRunning() {
        return (
          this.enabled &&
          !this.paused &&
          this.timeScale !== 0 &&
          this._startTime === null &&
          this._mixer._isActiveAction(this)
        );
      }
      isScheduled() {
        return this._mixer._isActiveAction(this);
      }
      startAt(e) {
        return (this._startTime = e), this;
      }
      setLoop(e, t) {
        return (this.loop = e), (this.repetitions = t), this;
      }
      setEffectiveWeight(e) {
        return (
          (this.weight = e),
          (this._effectiveWeight = this.enabled ? e : 0),
          this.stopFading()
        );
      }
      getEffectiveWeight() {
        return this._effectiveWeight;
      }
      fadeIn(e) {
        return this._scheduleFading(e, 0, 1);
      }
      fadeOut(e) {
        return this._scheduleFading(e, 1, 0);
      }
      crossFadeFrom(e, t, i) {
        if ((e.fadeOut(t), this.fadeIn(t), i)) {
          let r = this._clip.duration,
            s = e._clip.duration,
            a = s / r,
            o = r / s;
          e.warp(1, a, t), this.warp(o, 1, t);
        }
        return this;
      }
      crossFadeTo(e, t, i) {
        return e.crossFadeFrom(this, t, i);
      }
      stopFading() {
        let e = this._weightInterpolant;
        return (
          e !== null &&
            ((this._weightInterpolant = null),
            this._mixer._takeBackControlInterpolant(e)),
          this
        );
      }
      setEffectiveTimeScale(e) {
        return (
          (this.timeScale = e),
          (this._effectiveTimeScale = this.paused ? 0 : e),
          this.stopWarping()
        );
      }
      getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      }
      setDuration(e) {
        return (this.timeScale = this._clip.duration / e), this.stopWarping();
      }
      syncWith(e) {
        return (
          (this.time = e.time),
          (this.timeScale = e.timeScale),
          this.stopWarping()
        );
      }
      halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e);
      }
      warp(e, t, i) {
        let r = this._mixer,
          s = r.time,
          a = this.timeScale,
          o = this._timeScaleInterpolant;
        o === null &&
          ((o = r._lendControlInterpolant()), (this._timeScaleInterpolant = o));
        let l = o.parameterPositions,
          c = o.sampleValues;
        return (l[0] = s), (l[1] = s + i), (c[0] = e / a), (c[1] = t / a), this;
      }
      stopWarping() {
        let e = this._timeScaleInterpolant;
        return (
          e !== null &&
            ((this._timeScaleInterpolant = null),
            this._mixer._takeBackControlInterpolant(e)),
          this
        );
      }
      getMixer() {
        return this._mixer;
      }
      getClip() {
        return this._clip;
      }
      getRoot() {
        return this._localRoot || this._mixer._root;
      }
      _update(e, t, i, r) {
        if (!this.enabled) {
          this._updateWeight(e);
          return;
        }
        let s = this._startTime;
        if (s !== null) {
          let l = (e - s) * i;
          l < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * l));
        }
        t *= this._updateTimeScale(e);
        let a = this._updateTime(t),
          o = this._updateWeight(e);
        if (o > 0) {
          let l = this._interpolants,
            c = this._propertyBindings;
          switch (this.blendMode) {
            case Mz:
              for (let u = 0, f = l.length; u !== f; ++u)
                l[u].evaluate(a), c[u].accumulateAdditive(o);
              break;
            case lx:
            default:
              for (let u = 0, f = l.length; u !== f; ++u)
                l[u].evaluate(a), c[u].accumulate(r, o);
          }
        }
      }
      _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
          t = this.weight;
          let i = this._weightInterpolant;
          if (i !== null) {
            let r = i.evaluate(e)[0];
            (t *= r),
              e > i.parameterPositions[1] &&
                (this.stopFading(), r === 0 && (this.enabled = !1));
          }
        }
        return (this._effectiveWeight = t), t;
      }
      _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
          t = this.timeScale;
          let i = this._timeScaleInterpolant;
          i !== null &&
            ((t *= i.evaluate(e)[0]),
            e > i.parameterPositions[1] &&
              (this.stopWarping(),
              t === 0 ? (this.paused = !0) : (this.timeScale = t)));
        }
        return (this._effectiveTimeScale = t), t;
      }
      _updateTime(e) {
        let t = this._clip.duration,
          i = this.loop,
          r = this.time + e,
          s = this._loopCount,
          a = i === wz;
        if (e === 0) return s === -1 ? r : a && (s & 1) === 1 ? t - r : r;
        if (i === Tz) {
          s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
          e: {
            if (r >= t) r = t;
            else if (r < 0) r = 0;
            else {
              this.time = r;
              break e;
            }
            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              (this.time = r),
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e < 0 ? -1 : 1,
              });
          }
        } else {
          if (
            (s === -1 &&
              (e >= 0
                ? ((s = 0), this._setEndings(!0, this.repetitions === 0, a))
                : this._setEndings(this.repetitions === 0, !0, a)),
            r >= t || r < 0)
          ) {
            let o = Math.floor(r / t);
            (r -= t * o), (s += Math.abs(o));
            let l = this.repetitions - s;
            if (l <= 0)
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (r = e > 0 ? t : 0),
                (this.time = r),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e > 0 ? 1 : -1,
                });
            else {
              if (l === 1) {
                let c = e < 0;
                this._setEndings(c, !c, a);
              } else this._setEndings(!1, !1, a);
              (this._loopCount = s),
                (this.time = r),
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta: o,
                });
            }
          } else this.time = r;
          if (a && (s & 1) === 1) return t - r;
        }
        return r;
      }
      _setEndings(e, t, i) {
        let r = this._interpolantSettings;
        i
          ? ((r.endingStart = wc), (r.endingEnd = wc))
          : (e
              ? (r.endingStart = this.zeroSlopeAtStart ? wc : Sc)
              : (r.endingStart = gp),
            t
              ? (r.endingEnd = this.zeroSlopeAtEnd ? wc : Sc)
              : (r.endingEnd = gp));
      }
      _scheduleFading(e, t, i) {
        let r = this._mixer,
          s = r.time,
          a = this._weightInterpolant;
        a === null &&
          ((a = r._lendControlInterpolant()), (this._weightInterpolant = a));
        let o = a.parameterPositions,
          l = a.sampleValues;
        return (o[0] = s), (l[0] = t), (o[1] = s + e), (l[1] = i), this;
      }
    },
    $G = new Float32Array(1),
    Bc = class extends Ds {
      constructor(e) {
        super();
        (this._root = e),
          this._initMemoryManager(),
          (this._accuIndex = 0),
          (this.time = 0),
          (this.timeScale = 1);
      }
      _bindAction(e, t) {
        let i = e._localRoot || this._root,
          r = e._clip.tracks,
          s = r.length,
          a = e._propertyBindings,
          o = e._interpolants,
          l = i.uuid,
          c = this._bindingsByRootAndName,
          u = c[l];
        u === void 0 && ((u = {}), (c[l] = u));
        for (let f = 0; f !== s; ++f) {
          let d = r[f],
            m = d.name,
            x = u[m];
          if (x !== void 0) ++x.referenceCount, (a[f] = x);
          else {
            if (((x = a[f]), x !== void 0)) {
              x._cacheIndex === null &&
                (++x.referenceCount, this._addInactiveBinding(x, l, m));
              continue;
            }
            let y = t && t._propertyBindings[f].binding.parsedPath;
            (x = new UC(di.create(i, m, y), d.ValueTypeName, d.getValueSize())),
              ++x.referenceCount,
              this._addInactiveBinding(x, l, m),
              (a[f] = x);
          }
          o[f].resultBuffer = x.buffer;
        }
      }
      _activateAction(e) {
        if (!this._isActiveAction(e)) {
          if (e._cacheIndex === null) {
            let i = (e._localRoot || this._root).uuid,
              r = e._clip.uuid,
              s = this._actionsByClip[r];
            this._bindAction(e, s && s.knownActions[0]),
              this._addInactiveAction(e, r, i);
          }
          let t = e._propertyBindings;
          for (let i = 0, r = t.length; i !== r; ++i) {
            let s = t[i];
            s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
          }
          this._lendAction(e);
        }
      }
      _deactivateAction(e) {
        if (this._isActiveAction(e)) {
          let t = e._propertyBindings;
          for (let i = 0, r = t.length; i !== r; ++i) {
            let s = t[i];
            --s.useCount === 0 &&
              (s.restoreOriginalState(), this._takeBackBinding(s));
          }
          this._takeBackAction(e);
        }
      }
      _initMemoryManager() {
        (this._actions = []),
          (this._nActiveActions = 0),
          (this._actionsByClip = {}),
          (this._bindings = []),
          (this._nActiveBindings = 0),
          (this._bindingsByRootAndName = {}),
          (this._controlInterpolants = []),
          (this._nActiveControlInterpolants = 0);
        let e = this;
        this.stats = {
          actions: {
            get total() {
              return e._actions.length;
            },
            get inUse() {
              return e._nActiveActions;
            },
          },
          bindings: {
            get total() {
              return e._bindings.length;
            },
            get inUse() {
              return e._nActiveBindings;
            },
          },
          controlInterpolants: {
            get total() {
              return e._controlInterpolants.length;
            },
            get inUse() {
              return e._nActiveControlInterpolants;
            },
          },
        };
      }
      _isActiveAction(e) {
        let t = e._cacheIndex;
        return t !== null && t < this._nActiveActions;
      }
      _addInactiveAction(e, t, i) {
        let r = this._actions,
          s = this._actionsByClip,
          a = s[t];
        if (a === void 0)
          (a = { knownActions: [e], actionByRoot: {} }),
            (e._byClipCacheIndex = 0),
            (s[t] = a);
        else {
          let o = a.knownActions;
          (e._byClipCacheIndex = o.length), o.push(e);
        }
        (e._cacheIndex = r.length), r.push(e), (a.actionByRoot[i] = e);
      }
      _removeInactiveAction(e) {
        let t = this._actions,
          i = t[t.length - 1],
          r = e._cacheIndex;
        (i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null);
        let s = e._clip.uuid,
          a = this._actionsByClip,
          o = a[s],
          l = o.knownActions,
          c = l[l.length - 1],
          u = e._byClipCacheIndex;
        (c._byClipCacheIndex = u),
          (l[u] = c),
          l.pop(),
          (e._byClipCacheIndex = null);
        let f = o.actionByRoot,
          d = (e._localRoot || this._root).uuid;
        delete f[d],
          l.length === 0 && delete a[s],
          this._removeInactiveBindingsForAction(e);
      }
      _removeInactiveBindingsForAction(e) {
        let t = e._propertyBindings;
        for (let i = 0, r = t.length; i !== r; ++i) {
          let s = t[i];
          --s.referenceCount === 0 && this._removeInactiveBinding(s);
        }
      }
      _lendAction(e) {
        let t = this._actions,
          i = e._cacheIndex,
          r = this._nActiveActions++,
          s = t[r];
        (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
      }
      _takeBackAction(e) {
        let t = this._actions,
          i = e._cacheIndex,
          r = --this._nActiveActions,
          s = t[r];
        (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
      }
      _addInactiveBinding(e, t, i) {
        let r = this._bindingsByRootAndName,
          s = this._bindings,
          a = r[t];
        a === void 0 && ((a = {}), (r[t] = a)),
          (a[i] = e),
          (e._cacheIndex = s.length),
          s.push(e);
      }
      _removeInactiveBinding(e) {
        let t = this._bindings,
          i = e.binding,
          r = i.rootNode.uuid,
          s = i.path,
          a = this._bindingsByRootAndName,
          o = a[r],
          l = t[t.length - 1],
          c = e._cacheIndex;
        (l._cacheIndex = c),
          (t[c] = l),
          t.pop(),
          delete o[s],
          Object.keys(o).length === 0 && delete a[r];
      }
      _lendBinding(e) {
        let t = this._bindings,
          i = e._cacheIndex,
          r = this._nActiveBindings++,
          s = t[r];
        (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
      }
      _takeBackBinding(e) {
        let t = this._bindings,
          i = e._cacheIndex,
          r = --this._nActiveBindings,
          s = t[r];
        (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
      }
      _lendControlInterpolant() {
        let e = this._controlInterpolants,
          t = this._nActiveControlInterpolants++,
          i = e[t];
        return (
          i === void 0 &&
            ((i = new wx(new Float32Array(2), new Float32Array(2), 1, $G)),
            (i.__cacheIndex = t),
            (e[t] = i)),
          i
        );
      }
      _takeBackControlInterpolant(e) {
        let t = this._controlInterpolants,
          i = e.__cacheIndex,
          r = --this._nActiveControlInterpolants,
          s = t[r];
        (e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s);
      }
      clipAction(e, t, i) {
        let r = t || this._root,
          s = r.uuid,
          a = typeof e == "string" ? gh.findByName(r, e) : e,
          o = a !== null ? a.uuid : e,
          l = this._actionsByClip[o],
          c = null;
        if (
          (i === void 0 && (a !== null ? (i = a.blendMode) : (i = lx)),
          l !== void 0)
        ) {
          let f = l.actionByRoot[s];
          if (f !== void 0 && f.blendMode === i) return f;
          (c = l.knownActions[0]), a === null && (a = c._clip);
        }
        if (a === null) return null;
        let u = new GC(this, a, t, i);
        return this._bindAction(u, c), this._addInactiveAction(u, o, s), u;
      }
      existingAction(e, t) {
        let i = t || this._root,
          r = i.uuid,
          s = typeof e == "string" ? gh.findByName(i, e) : e,
          a = s ? s.uuid : e,
          o = this._actionsByClip[a];
        return (o !== void 0 && o.actionByRoot[r]) || null;
      }
      stopAllAction() {
        let e = this._actions,
          t = this._nActiveActions;
        for (let i = t - 1; i >= 0; --i) e[i].stop();
        return this;
      }
      update(e) {
        e *= this.timeScale;
        let t = this._actions,
          i = this._nActiveActions,
          r = (this.time += e),
          s = Math.sign(e),
          a = (this._accuIndex ^= 1);
        for (let c = 0; c !== i; ++c) t[c]._update(r, e, s, a);
        let o = this._bindings,
          l = this._nActiveBindings;
        for (let c = 0; c !== l; ++c) o[c].apply(a);
        return this;
      }
      setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
          this._actions[t].time = 0;
        return this.update(e);
      }
      getRoot() {
        return this._root;
      }
      uncacheClip(e) {
        let t = this._actions,
          i = e.uuid,
          r = this._actionsByClip,
          s = r[i];
        if (s !== void 0) {
          let a = s.knownActions;
          for (let o = 0, l = a.length; o !== l; ++o) {
            let c = a[o];
            this._deactivateAction(c);
            let u = c._cacheIndex,
              f = t[t.length - 1];
            (c._cacheIndex = null),
              (c._byClipCacheIndex = null),
              (f._cacheIndex = u),
              (t[u] = f),
              t.pop(),
              this._removeInactiveBindingsForAction(c);
          }
          delete r[i];
        }
      }
      uncacheRoot(e) {
        let t = e.uuid,
          i = this._actionsByClip;
        for (let a in i) {
          let o = i[a].actionByRoot,
            l = o[t];
          l !== void 0 &&
            (this._deactivateAction(l), this._removeInactiveAction(l));
        }
        let r = this._bindingsByRootAndName,
          s = r[t];
        if (s !== void 0)
          for (let a in s) {
            let o = s[a];
            o.restoreOriginalState(), this._removeInactiveBinding(o);
          }
      }
      uncacheAction(e, t) {
        let i = this.existingAction(e, t);
        i !== null &&
          (this._deactivateAction(i), this._removeInactiveAction(i));
      }
    };
  var Ap = class {
    constructor(e = 1, t = 0, i = 0) {
      return (this.radius = e), (this.phi = t), (this.theta = i), this;
    }
    set(e, t, i) {
      return (this.radius = e), (this.phi = t), (this.theta = i), this;
    }
    copy(e) {
      return (
        (this.radius = e.radius),
        (this.phi = e.phi),
        (this.theta = e.theta),
        this
      );
    }
    makeSafe() {
      return (
        (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
      );
    }
    setFromVector3(e) {
      return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, i) {
      return (
        (this.radius = Math.sqrt(e * e + t * t + i * i)),
        this.radius === 0
          ? ((this.theta = 0), (this.phi = 0))
          : ((this.theta = Math.atan2(e, i)),
            (this.phi = Math.acos(Dn(t / this.radius, -1, 1)))),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var Ox = class extends Sp {
    constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
      (i = new Bt(i)), (r = new Bt(r));
      let s = t / 2,
        a = e / t,
        o = e / 2,
        l = [],
        c = [];
      for (let d = 0, m = 0, x = -o; d <= t; d++, x += a) {
        l.push(-o, 0, x, o, 0, x), l.push(x, 0, -o, x, 0, o);
        let y = d === s ? i : r;
        y.toArray(c, m),
          (m += 3),
          y.toArray(c, m),
          (m += 3),
          y.toArray(c, m),
          (m += 3),
          y.toArray(c, m),
          (m += 3);
      }
      let u = new qn();
      u.setAttribute("position", new jr(l, 3)),
        u.setAttribute("color", new jr(c, 3));
      let f = new Th({ vertexColors: !0, toneMapped: !1 });
      super(u, f);
      this.type = "GridHelper";
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  };
  typeof __THREE_DEVTOOLS__ != "undefined" &&
    __THREE_DEVTOOLS__.dispatchEvent(
      new CustomEvent("register", { detail: { revision: ax } })
    );
  typeof window != "undefined" &&
    (window.__THREE__
      ? console.warn("WARNING: Multiple instances of Three.js being imported.")
      : (window.__THREE__ = ax));
  var Nx = new WeakMap(),
    kx = class extends ua {
      constructor(e) {
        super(e);
        (this.decoderPath = ""),
          (this.decoderConfig = {}),
          (this.decoderBinary = null),
          (this.decoderPending = null),
          (this.workerLimit = 4),
          (this.workerPool = []),
          (this.workerNextTaskID = 1),
          (this.workerSourceURL = ""),
          (this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD",
          }),
          (this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array",
          });
      }
      setDecoderPath(e) {
        return (this.decoderPath = e), this;
      }
      setDecoderConfig(e) {
        return (this.decoderConfig = e), this;
      }
      setWorkerLimit(e) {
        return (this.workerLimit = e), this;
      }
      load(e, t, i, r) {
        let s = new gl(this.manager);
        s.setPath(this.path),
          s.setResponseType("arraybuffer"),
          s.setRequestHeader(this.requestHeader),
          s.setWithCredentials(this.withCredentials),
          s.load(
            e,
            (a) => {
              this.decodeDracoFile(a, t).catch(r);
            },
            i,
            r
          );
      }
      decodeDracoFile(e, t, i, r) {
        let s = {
          attributeIDs: i || this.defaultAttributeIDs,
          attributeTypes: r || this.defaultAttributeTypes,
          useUniqueIDs: !!i,
        };
        return this.decodeGeometry(e, s).then(t);
      }
      decodeGeometry(e, t) {
        let i = JSON.stringify(t);
        if (Nx.has(e)) {
          let l = Nx.get(e);
          if (l.key === i) return l.promise;
          if (e.byteLength === 0)
            throw new Error(
              "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
            );
        }
        let r,
          s = this.workerNextTaskID++,
          a = e.byteLength,
          o = this._getWorker(s, a)
            .then(
              (l) => (
                (r = l),
                new Promise((c, u) => {
                  (r._callbacks[s] = { resolve: c, reject: u }),
                    r.postMessage(
                      { type: "decode", id: s, taskConfig: t, buffer: e },
                      [e]
                    );
                })
              )
            )
            .then((l) => this._createGeometry(l.geometry));
        return (
          o
            .catch(() => !0)
            .then(() => {
              r && s && this._releaseTask(r, s);
            }),
          Nx.set(e, { key: i, promise: o }),
          o
        );
      }
      _createGeometry(e) {
        let t = new qn();
        e.index && t.setIndex(new en(e.index.array, 1));
        for (let i = 0; i < e.attributes.length; i++) {
          let r = e.attributes[i],
            s = r.name,
            a = r.array,
            o = r.itemSize;
          t.setAttribute(s, new en(a, o));
        }
        return t;
      }
      _loadLibrary(e, t) {
        let i = new gl(this.manager);
        return (
          i.setPath(this.decoderPath),
          i.setResponseType(t),
          i.setWithCredentials(this.withCredentials),
          new Promise((r, s) => {
            i.load(e, r, void 0, s);
          })
        );
      }
      preload() {
        return this._initDecoder(), this;
      }
      _initDecoder() {
        if (this.decoderPending) return this.decoderPending;
        let e =
            typeof WebAssembly != "object" || this.decoderConfig.type === "js",
          t = [];
        return (
          e
            ? t.push(this._loadLibrary("draco_decoder.js", "text"))
            : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
              t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
          (this.decoderPending = Promise.all(t).then((i) => {
            let r = i[0];
            e || (this.decoderConfig.wasmBinary = i[1]);
            let s = WG.toString(),
              a = [
                "/* draco decoder */",
                r,
                "",
                "/* worker */",
                s.substring(s.indexOf("{") + 1, s.lastIndexOf("}")),
              ].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([a]));
          })),
          this.decoderPending
        );
      }
      _getWorker(e, t) {
        return this._initDecoder().then(() => {
          if (this.workerPool.length < this.workerLimit) {
            let r = new Worker(this.workerSourceURL);
            (r._callbacks = {}),
              (r._taskCosts = {}),
              (r._taskLoad = 0),
              r.postMessage({
                type: "init",
                decoderConfig: this.decoderConfig,
              }),
              (r.onmessage = function (s) {
                let a = s.data;
                switch (a.type) {
                  case "decode":
                    r._callbacks[a.id].resolve(a);
                    break;
                  case "error":
                    r._callbacks[a.id].reject(a);
                    break;
                  default:
                    console.error(
                      'THREE.DRACOLoader: Unexpected message, "' + a.type + '"'
                    );
                }
              }),
              this.workerPool.push(r);
          } else
            this.workerPool.sort(function (r, s) {
              return r._taskLoad > s._taskLoad ? -1 : 1;
            });
          let i = this.workerPool[this.workerPool.length - 1];
          return (i._taskCosts[e] = t), (i._taskLoad += t), i;
        });
      }
      _releaseTask(e, t) {
        (e._taskLoad -= e._taskCosts[t]),
          delete e._callbacks[t],
          delete e._taskCosts[t];
      }
      debug() {
        console.log(
          "Task load: ",
          this.workerPool.map((e) => e._taskLoad)
        );
      }
      dispose() {
        for (let e = 0; e < this.workerPool.length; ++e)
          this.workerPool[e].terminate();
        return (this.workerPool.length = 0), this;
      }
    };
  function WG() {
    let n, e;
    onmessage = function (a) {
      let o = a.data;
      switch (o.type) {
        case "init":
          (n = o.decoderConfig),
            (e = new Promise(function (u) {
              (n.onModuleLoaded = function (f) {
                u({ draco: f });
              }),
                DracoDecoderModule(n);
            }));
          break;
        case "decode":
          let l = o.buffer,
            c = o.taskConfig;
          e.then((u) => {
            let f = u.draco,
              d = new f.Decoder(),
              m = new f.DecoderBuffer();
            m.Init(new Int8Array(l), l.byteLength);
            try {
              let x = t(f, d, m, c),
                y = x.attributes.map((g) => g.array.buffer);
              x.index && y.push(x.index.array.buffer),
                self.postMessage({ type: "decode", id: o.id, geometry: x }, y);
            } catch (x) {
              console.error(x),
                self.postMessage({ type: "error", id: o.id, error: x.message });
            } finally {
              f.destroy(m), f.destroy(d);
            }
          });
          break;
      }
    };
    function t(a, o, l, c) {
      let u = c.attributeIDs,
        f = c.attributeTypes,
        d,
        m,
        x = o.GetEncodedGeometryType(l);
      if (x === a.TRIANGULAR_MESH)
        (d = new a.Mesh()), (m = o.DecodeBufferToMesh(l, d));
      else if (x === a.POINT_CLOUD)
        (d = new a.PointCloud()), (m = o.DecodeBufferToPointCloud(l, d));
      else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
      if (!m.ok() || d.ptr === 0)
        throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg());
      let y = { index: null, attributes: [] };
      for (let g in u) {
        let b = self[f[g]],
          _,
          E;
        if (c.useUniqueIDs) (E = u[g]), (_ = o.GetAttributeByUniqueId(d, E));
        else {
          if (((E = o.GetAttributeId(d, a[u[g]])), E === -1)) continue;
          _ = o.GetAttribute(d, E);
        }
        y.attributes.push(r(a, o, d, g, b, _));
      }
      return x === a.TRIANGULAR_MESH && (y.index = i(a, o, d)), a.destroy(d), y;
    }
    function i(a, o, l) {
      let u = l.num_faces() * 3,
        f = u * 4,
        d = a._malloc(f);
      o.GetTrianglesUInt32Array(l, f, d);
      let m = new Uint32Array(a.HEAPF32.buffer, d, u).slice();
      return a._free(d), { array: m, itemSize: 1 };
    }
    function r(a, o, l, c, u, f) {
      let d = f.num_components(),
        x = l.num_points() * d,
        y = x * u.BYTES_PER_ELEMENT,
        g = s(a, u),
        b = a._malloc(y);
      o.GetAttributeDataArrayForAllPoints(l, f, g, y, b);
      let _ = new u(a.HEAPF32.buffer, b, x).slice();
      return a._free(b), { name: c, array: _, itemSize: d };
    }
    function s(a, o) {
      switch (o) {
        case Float32Array:
          return a.DT_FLOAT32;
        case Int8Array:
          return a.DT_INT8;
        case Int16Array:
          return a.DT_INT16;
        case Int32Array:
          return a.DT_INT32;
        case Uint8Array:
          return a.DT_UINT8;
        case Uint16Array:
          return a.DT_UINT16;
        case Uint32Array:
          return a.DT_UINT32;
      }
    }
  }
  var Vx = class extends ua {
    constructor(e) {
      super(e);
      (this.dracoLoader = null),
        (this.ktx2Loader = null),
        (this.meshoptDecoder = null),
        (this.pluginCallbacks = []),
        this.register(function (t) {
          return new ZC(t);
        }),
        this.register(function (t) {
          return new sP(t);
        }),
        this.register(function (t) {
          return new aP(t);
        }),
        this.register(function (t) {
          return new eP(t);
        }),
        this.register(function (t) {
          return new tP(t);
        }),
        this.register(function (t) {
          return new iP(t);
        }),
        this.register(function (t) {
          return new nP(t);
        }),
        this.register(function (t) {
          return new JC(t);
        }),
        this.register(function (t) {
          return new rP(t);
        }),
        this.register(function (t) {
          return new QC(t);
        }),
        this.register(function (t) {
          return new YC(t);
        }),
        this.register(function (t) {
          return new oP(t);
        }),
        this.register(function (t) {
          return new lP(t);
        });
    }
    load(e, t, i, r) {
      let s = this,
        a;
      this.resourcePath !== ""
        ? (a = this.resourcePath)
        : this.path !== ""
        ? (a = this.path)
        : (a = ha.extractUrlBase(e)),
        this.manager.itemStart(e);
      let o = function (c) {
          r ? r(c) : console.error(c),
            s.manager.itemError(e),
            s.manager.itemEnd(e);
        },
        l = new gl(this.manager);
      l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(this.withCredentials),
        l.load(
          e,
          function (c) {
            try {
              s.parse(
                c,
                a,
                function (u) {
                  t(u), s.manager.itemEnd(e);
                },
                o
              );
            } catch (u) {
              o(u);
            }
          },
          i,
          o
        );
    }
    setDRACOLoader(e) {
      return (this.dracoLoader = e), this;
    }
    setDDSLoader() {
      throw new Error(
        'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
      );
    }
    setKTX2Loader(e) {
      return (this.ktx2Loader = e), this;
    }
    setMeshoptDecoder(e) {
      return (this.meshoptDecoder = e), this;
    }
    register(e) {
      return (
        this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
        this
      );
    }
    unregister(e) {
      return (
        this.pluginCallbacks.indexOf(e) !== -1 &&
          this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
      );
    }
    parse(e, t, i, r) {
      let s,
        a = {},
        o = {};
      if (typeof e == "string") s = JSON.parse(e);
      else if (e instanceof ArrayBuffer)
        if (ha.decodeText(new Uint8Array(e, 0, 4)) === cP) {
          try {
            a[fi.KHR_BINARY_GLTF] = new uP(e);
          } catch (u) {
            r && r(u);
            return;
          }
          s = JSON.parse(a[fi.KHR_BINARY_GLTF].content);
        } else s = JSON.parse(ha.decodeText(new Uint8Array(e)));
      else s = e;
      if (s.asset === void 0 || s.asset.version[0] < 2) {
        r &&
          r(
            new Error(
              "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
            )
          );
        return;
      }
      let l = new mP(s, {
        path: t || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder,
      });
      l.fileLoader.setRequestHeader(this.requestHeader);
      for (let c = 0; c < this.pluginCallbacks.length; c++) {
        let u = this.pluginCallbacks[c](l);
        (o[u.name] = u), (a[u.name] = !0);
      }
      if (s.extensionsUsed)
        for (let c = 0; c < s.extensionsUsed.length; ++c) {
          let u = s.extensionsUsed[c],
            f = s.extensionsRequired || [];
          switch (u) {
            case fi.KHR_MATERIALS_UNLIT:
              a[u] = new KC();
              break;
            case fi.KHR_DRACO_MESH_COMPRESSION:
              a[u] = new hP(s, this.dracoLoader);
              break;
            case fi.KHR_TEXTURE_TRANSFORM:
              a[u] = new fP();
              break;
            case fi.KHR_MESH_QUANTIZATION:
              a[u] = new dP();
              break;
            default:
              f.indexOf(u) >= 0 &&
                o[u] === void 0 &&
                console.warn(
                  'THREE.GLTFLoader: Unknown extension "' + u + '".'
                );
          }
        }
      l.setExtensions(a), l.setPlugins(o), l.parse(i, r);
    }
    parseAsync(e, t) {
      let i = this;
      return new Promise(function (r, s) {
        i.parse(e, t, r, s);
      });
    }
  };
  function qG() {
    let n = {};
    return {
      get: function (e) {
        return n[e];
      },
      add: function (e, t) {
        n[e] = t;
      },
      remove: function (e) {
        delete n[e];
      },
      removeAll: function () {
        n = {};
      },
    };
  }
  var fi = {
      KHR_BINARY_GLTF: "KHR_binary_glTF",
      KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
      KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
      KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
      KHR_MATERIALS_IOR: "KHR_materials_ior",
      KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
      KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
      KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
      KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
      KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
      KHR_MATERIALS_VOLUME: "KHR_materials_volume",
      KHR_TEXTURE_BASISU: "KHR_texture_basisu",
      KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
      KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
      KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
      EXT_TEXTURE_WEBP: "EXT_texture_webp",
      EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
      EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
    },
    YC = class {
      constructor(e) {
        (this.parser = e),
          (this.name = fi.KHR_LIGHTS_PUNCTUAL),
          (this.cache = { refs: {}, uses: {} });
      }
      _markDefs() {
        let e = this.parser,
          t = this.parser.json.nodes || [];
        for (let i = 0, r = t.length; i < r; i++) {
          let s = t[i];
          s.extensions &&
            s.extensions[this.name] &&
            s.extensions[this.name].light !== void 0 &&
            e._addNodeRef(this.cache, s.extensions[this.name].light);
        }
      }
      _loadLight(e) {
        let t = this.parser,
          i = "light:" + e,
          r = t.cache.get(i);
        if (r) return r;
        let s = t.json,
          l = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[
            e
          ],
          c,
          u = new Bt(16777215);
        l.color !== void 0 && u.fromArray(l.color);
        let f = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
          case "directional":
            (c = new Dx(u)), c.target.position.set(0, 0, -1), c.add(c.target);
            break;
          case "point":
            (c = new Px(u)), (c.distance = f);
            break;
          case "spot":
            (c = new Cx(u)),
              (c.distance = f),
              (l.spot = l.spot || {}),
              (l.spot.innerConeAngle =
                l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
              (l.spot.outerConeAngle =
                l.spot.outerConeAngle !== void 0
                  ? l.spot.outerConeAngle
                  : Math.PI / 4),
              (c.angle = l.spot.outerConeAngle),
              (c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
              c.target.position.set(0, 0, -1),
              c.add(c.target);
            break;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unexpected light type: " + l.type
            );
        }
        return (
          c.position.set(0, 0, 0),
          (c.decay = 2),
          ao(c, l),
          l.intensity !== void 0 && (c.intensity = l.intensity),
          (c.name = t.createUniqueName(l.name || "light_" + e)),
          (r = Promise.resolve(c)),
          t.cache.add(i, r),
          r
        );
      }
      getDependency(e, t) {
        if (e === "light") return this._loadLight(t);
      }
      createNodeAttachment(e) {
        let t = this,
          i = this.parser,
          s = i.json.nodes[e],
          o = ((s.extensions && s.extensions[this.name]) || {}).light;
        return o === void 0
          ? null
          : this._loadLight(o).then(function (l) {
              return i._getNodeRef(t.cache, o, l);
            });
      }
    },
    KC = class {
      constructor() {
        this.name = fi.KHR_MATERIALS_UNLIT;
      }
      getMaterialType() {
        return oa;
      }
      extendParams(e, t, i) {
        let r = [];
        (e.color = new Bt(1, 1, 1)), (e.opacity = 1);
        let s = t.pbrMetallicRoughness;
        if (s) {
          if (Array.isArray(s.baseColorFactor)) {
            let a = s.baseColorFactor;
            e.color.fromArray(a), (e.opacity = a[3]);
          }
          s.baseColorTexture !== void 0 &&
            r.push(i.assignTexture(e, "map", s.baseColorTexture, oi));
        }
        return Promise.all(r);
      }
    },
    JC = class {
      constructor(e) {
        (this.parser = e), (this.name = fi.KHR_MATERIALS_EMISSIVE_STRENGTH);
      }
      extendMaterialParams(e, t) {
        let r = this.parser.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        let s = r.extensions[this.name].emissiveStrength;
        return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
      }
    },
    ZC = class {
      constructor(e) {
        (this.parser = e), (this.name = fi.KHR_MATERIALS_CLEARCOAT);
      }
      getMaterialType(e) {
        let i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : la;
      }
      extendMaterialParams(e, t) {
        let i = this.parser,
          r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        let s = [],
          a = r.extensions[this.name];
        if (
          (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor),
          a.clearcoatTexture !== void 0 &&
            s.push(i.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
          a.clearcoatRoughnessFactor !== void 0 &&
            (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
          a.clearcoatRoughnessTexture !== void 0 &&
            s.push(
              i.assignTexture(
                t,
                "clearcoatRoughnessMap",
                a.clearcoatRoughnessTexture
              )
            ),
          a.clearcoatNormalTexture !== void 0 &&
            (s.push(
              i.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)
            ),
            a.clearcoatNormalTexture.scale !== void 0))
        ) {
          let o = a.clearcoatNormalTexture.scale;
          t.clearcoatNormalScale = new It(o, o);
        }
        return Promise.all(s);
      }
    },
    QC = class {
      constructor(e) {
        (this.parser = e), (this.name = fi.KHR_MATERIALS_IRIDESCENCE);
      }
      getMaterialType(e) {
        let i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : la;
      }
      extendMaterialParams(e, t) {
        let i = this.parser,
          r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        let s = [],
          a = r.extensions[this.name];
        return (
          a.iridescenceFactor !== void 0 &&
            (t.iridescence = a.iridescenceFactor),
          a.iridescenceTexture !== void 0 &&
            s.push(i.assignTexture(t, "iridescenceMap", a.iridescenceTexture)),
          a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor),
          t.iridescenceThicknessRange === void 0 &&
            (t.iridescenceThicknessRange = [100, 400]),
          a.iridescenceThicknessMinimum !== void 0 &&
            (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum),
          a.iridescenceThicknessMaximum !== void 0 &&
            (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
          a.iridescenceThicknessTexture !== void 0 &&
            s.push(
              i.assignTexture(
                t,
                "iridescenceThicknessMap",
                a.iridescenceThicknessTexture
              )
            ),
          Promise.all(s)
        );
      }
    },
    eP = class {
      constructor(e) {
        (this.parser = e), (this.name = fi.KHR_MATERIALS_SHEEN);
      }
      getMaterialType(e) {
        let i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : la;
      }
      extendMaterialParams(e, t) {
        let i = this.parser,
          r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        let s = [];
        (t.sheenColor = new Bt(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
        let a = r.extensions[this.name];
        return (
          a.sheenColorFactor !== void 0 &&
            t.sheenColor.fromArray(a.sheenColorFactor),
          a.sheenRoughnessFactor !== void 0 &&
            (t.sheenRoughness = a.sheenRoughnessFactor),
          a.sheenColorTexture !== void 0 &&
            s.push(
              i.assignTexture(t, "sheenColorMap", a.sheenColorTexture, oi)
            ),
          a.sheenRoughnessTexture !== void 0 &&
            s.push(
              i.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)
            ),
          Promise.all(s)
        );
      }
    },
    tP = class {
      constructor(e) {
        (this.parser = e), (this.name = fi.KHR_MATERIALS_TRANSMISSION);
      }
      getMaterialType(e) {
        let i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : la;
      }
      extendMaterialParams(e, t) {
        let i = this.parser,
          r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        let s = [],
          a = r.extensions[this.name];
        return (
          a.transmissionFactor !== void 0 &&
            (t.transmission = a.transmissionFactor),
          a.transmissionTexture !== void 0 &&
            s.push(
              i.assignTexture(t, "transmissionMap", a.transmissionTexture)
            ),
          Promise.all(s)
        );
      }
    },
    iP = class {
      constructor(e) {
        (this.parser = e), (this.name = fi.KHR_MATERIALS_VOLUME);
      }
      getMaterialType(e) {
        let i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : la;
      }
      extendMaterialParams(e, t) {
        let i = this.parser,
          r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        let s = [],
          a = r.extensions[this.name];
        (t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0),
          a.thicknessTexture !== void 0 &&
            s.push(i.assignTexture(t, "thicknessMap", a.thicknessTexture)),
          (t.attenuationDistance = a.attenuationDistance || 1 / 0);
        let o = a.attenuationColor || [1, 1, 1];
        return (t.attenuationColor = new Bt(o[0], o[1], o[2])), Promise.all(s);
      }
    },
    nP = class {
      constructor(e) {
        (this.parser = e), (this.name = fi.KHR_MATERIALS_IOR);
      }
      getMaterialType(e) {
        let i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : la;
      }
      extendMaterialParams(e, t) {
        let r = this.parser.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        let s = r.extensions[this.name];
        return (t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve();
      }
    },
    rP = class {
      constructor(e) {
        (this.parser = e), (this.name = fi.KHR_MATERIALS_SPECULAR);
      }
      getMaterialType(e) {
        let i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : la;
      }
      extendMaterialParams(e, t) {
        let i = this.parser,
          r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        let s = [],
          a = r.extensions[this.name];
        (t.specularIntensity =
          a.specularFactor !== void 0 ? a.specularFactor : 1),
          a.specularTexture !== void 0 &&
            s.push(
              i.assignTexture(t, "specularIntensityMap", a.specularTexture)
            );
        let o = a.specularColorFactor || [1, 1, 1];
        return (
          (t.specularColor = new Bt(o[0], o[1], o[2])),
          a.specularColorTexture !== void 0 &&
            s.push(
              i.assignTexture(t, "specularColorMap", a.specularColorTexture, oi)
            ),
          Promise.all(s)
        );
      }
    },
    sP = class {
      constructor(e) {
        (this.parser = e), (this.name = fi.KHR_TEXTURE_BASISU);
      }
      loadTexture(e) {
        let t = this.parser,
          i = t.json,
          r = i.textures[e];
        if (!r.extensions || !r.extensions[this.name]) return null;
        let s = r.extensions[this.name],
          a = t.options.ktx2Loader;
        if (!a) {
          if (
            i.extensionsRequired &&
            i.extensionsRequired.indexOf(this.name) >= 0
          )
            throw new Error(
              "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
            );
          return null;
        }
        return t.loadTextureImage(e, s.source, a);
      }
    },
    aP = class {
      constructor(e) {
        (this.parser = e),
          (this.name = fi.EXT_TEXTURE_WEBP),
          (this.isSupported = null);
      }
      loadTexture(e) {
        let t = this.name,
          i = this.parser,
          r = i.json,
          s = r.textures[e];
        if (!s.extensions || !s.extensions[t]) return null;
        let a = s.extensions[t],
          o = r.images[a.source],
          l = i.textureLoader;
        if (o.uri) {
          let c = i.options.manager.getHandler(o.uri);
          c !== null && (l = c);
        }
        return this.detectSupport().then(function (c) {
          if (c) return i.loadTextureImage(e, a.source, l);
          if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
            throw new Error(
              "THREE.GLTFLoader: WebP required by asset but unsupported."
            );
          return i.loadTexture(e);
        });
      }
      detectSupport() {
        return (
          this.isSupported ||
            (this.isSupported = new Promise(function (e) {
              let t = new Image();
              (t.src =
                "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                (t.onload = t.onerror =
                  function () {
                    e(t.height === 1);
                  });
            })),
          this.isSupported
        );
      }
    },
    oP = class {
      constructor(e) {
        (this.name = fi.EXT_MESHOPT_COMPRESSION), (this.parser = e);
      }
      loadBufferView(e) {
        let t = this.parser.json,
          i = t.bufferViews[e];
        if (i.extensions && i.extensions[this.name]) {
          let r = i.extensions[this.name],
            s = this.parser.getDependency("buffer", r.buffer),
            a = this.parser.options.meshoptDecoder;
          if (!a || !a.supported) {
            if (
              t.extensionsRequired &&
              t.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
              );
            return null;
          }
          return s.then(function (o) {
            let l = r.byteOffset || 0,
              c = r.byteLength || 0,
              u = r.count,
              f = r.byteStride,
              d = new Uint8Array(o, l, c);
            return a.decodeGltfBufferAsync
              ? a
                  .decodeGltfBufferAsync(u, f, d, r.mode, r.filter)
                  .then(function (m) {
                    return m.buffer;
                  })
              : a.ready.then(function () {
                  let m = new ArrayBuffer(u * f);
                  return (
                    a.decodeGltfBuffer(
                      new Uint8Array(m),
                      u,
                      f,
                      d,
                      r.mode,
                      r.filter
                    ),
                    m
                  );
                });
          });
        } else return null;
      }
    },
    lP = class {
      constructor(e) {
        (this.name = fi.EXT_MESH_GPU_INSTANCING), (this.parser = e);
      }
      createNodeMesh(e) {
        let t = this.parser.json,
          i = t.nodes[e];
        if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
          return null;
        let r = t.meshes[i.mesh];
        for (let c of r.primitives)
          if (
            c.mode !== Yr.TRIANGLES &&
            c.mode !== Yr.TRIANGLE_STRIP &&
            c.mode !== Yr.TRIANGLE_FAN &&
            c.mode !== void 0
          )
            return null;
        let a = i.extensions[this.name].attributes,
          o = [],
          l = {};
        for (let c in a)
          o.push(
            this.parser
              .getDependency("accessor", a[c])
              .then((u) => ((l[c] = u), l[c]))
          );
        return o.length < 1
          ? null
          : (o.push(this.parser.createNodeMesh(e)),
            Promise.all(o).then((c) => {
              let u = c.pop(),
                f = u.isGroup ? u.children : [u],
                d = c[0].count,
                m = [];
              for (let x of f) {
                let y = new Wt(),
                  g = new le(),
                  b = new In(),
                  _ = new le(1, 1, 1),
                  E = new Ex(x.geometry, x.material, d);
                for (let w = 0; w < d; w++)
                  l.TRANSLATION && g.fromBufferAttribute(l.TRANSLATION, w),
                    l.ROTATION && b.fromBufferAttribute(l.ROTATION, w),
                    l.SCALE && _.fromBufferAttribute(l.SCALE, w),
                    E.setMatrixAt(w, y.compose(g, b, _));
                for (let w in l)
                  w !== "TRANSLATION" &&
                    w !== "ROTATION" &&
                    w !== "SCALE" &&
                    x.geometry.setAttribute(w, l[w]);
                Ai.prototype.copy.call(E, x),
                  (E.frustumCulled = !1),
                  this.parser.assignFinalMaterial(E),
                  m.push(E);
              }
              return u.isGroup ? (u.clear(), u.add(...m), u) : m[0];
            }));
      }
    },
    cP = "glTF",
    Ph = 12,
    HC = { JSON: 1313821514, BIN: 5130562 },
    uP = class {
      constructor(e) {
        (this.name = fi.KHR_BINARY_GLTF),
          (this.content = null),
          (this.body = null);
        let t = new DataView(e, 0, Ph);
        if (
          ((this.header = {
            magic: ha.decodeText(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0),
          }),
          this.header.magic !== cP)
        )
          throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
          throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        let i = this.header.length - Ph,
          r = new DataView(e, Ph),
          s = 0;
        for (; s < i; ) {
          let a = r.getUint32(s, !0);
          s += 4;
          let o = r.getUint32(s, !0);
          if (((s += 4), o === HC.JSON)) {
            let l = new Uint8Array(e, Ph + s, a);
            this.content = ha.decodeText(l);
          } else if (o === HC.BIN) {
            let l = Ph + s;
            this.body = e.slice(l, l + a);
          }
          s += a;
        }
        if (this.content === null)
          throw new Error("THREE.GLTFLoader: JSON content not found.");
      }
    },
    hP = class {
      constructor(e, t) {
        if (!t)
          throw new Error(
            "THREE.GLTFLoader: No DRACOLoader instance provided."
          );
        (this.name = fi.KHR_DRACO_MESH_COMPRESSION),
          (this.json = e),
          (this.dracoLoader = t),
          this.dracoLoader.preload();
      }
      decodePrimitive(e, t) {
        let i = this.json,
          r = this.dracoLoader,
          s = e.extensions[this.name].bufferView,
          a = e.extensions[this.name].attributes,
          o = {},
          l = {},
          c = {};
        for (let u in a) {
          let f = zx[u] || u.toLowerCase();
          o[f] = a[u];
        }
        for (let u in e.attributes) {
          let f = zx[u] || u.toLowerCase();
          if (a[u] !== void 0) {
            let d = i.accessors[e.attributes[u]],
              m = zc[d.componentType];
            (c[f] = m.name), (l[f] = d.normalized === !0);
          }
        }
        return t.getDependency("bufferView", s).then(function (u) {
          return new Promise(function (f) {
            r.decodeDracoFile(
              u,
              function (d) {
                for (let m in d.attributes) {
                  let x = d.attributes[m],
                    y = l[m];
                  y !== void 0 && (x.normalized = y);
                }
                f(d);
              },
              o,
              c
            );
          });
        });
      }
    },
    fP = class {
      constructor() {
        this.name = fi.KHR_TEXTURE_TRANSFORM;
      }
      extendTexture(e, t) {
        return (
          t.texCoord !== void 0 &&
            console.warn(
              'THREE.GLTFLoader: Custom UV sets in "' +
                this.name +
                '" extension not yet supported.'
            ),
          (t.offset === void 0 &&
            t.rotation === void 0 &&
            t.scale === void 0) ||
            ((e = e.clone()),
            t.offset !== void 0 && e.offset.fromArray(t.offset),
            t.rotation !== void 0 && (e.rotation = t.rotation),
            t.scale !== void 0 && e.repeat.fromArray(t.scale),
            (e.needsUpdate = !0)),
          e
        );
      }
    },
    dP = class {
      constructor() {
        this.name = fi.KHR_MESH_QUANTIZATION;
      }
    },
    Gx = class extends dl {
      constructor(e, t, i, r) {
        super(e, t, i, r);
      }
      copySampleValue_(e) {
        let t = this.resultBuffer,
          i = this.sampleValues,
          r = this.valueSize,
          s = e * r * 3 + r;
        for (let a = 0; a !== r; a++) t[a] = i[s + a];
        return t;
      }
      interpolate_(e, t, i, r) {
        let s = this.resultBuffer,
          a = this.sampleValues,
          o = this.valueSize,
          l = o * 2,
          c = o * 3,
          u = r - t,
          f = (i - t) / u,
          d = f * f,
          m = d * f,
          x = e * c,
          y = x - c,
          g = -2 * m + 3 * d,
          b = m - d,
          _ = 1 - g,
          E = b - d + f;
        for (let w = 0; w !== o; w++) {
          let P = a[y + w + o],
            L = a[y + w + l] * u,
            I = a[x + w + o],
            M = a[x + w] * u;
          s[w] = _ * P + E * L + g * I + b * M;
        }
        return s;
      }
    },
    jG = new In(),
    pP = class extends Gx {
      interpolate_(e, t, i, r) {
        let s = super.interpolate_(e, t, i, r);
        return jG.fromArray(s).normalize().toArray(s), s;
      }
    },
    Yr = {
      FLOAT: 5126,
      FLOAT_MAT3: 35675,
      FLOAT_MAT4: 35676,
      FLOAT_VEC2: 35664,
      FLOAT_VEC3: 35665,
      FLOAT_VEC4: 35666,
      LINEAR: 9729,
      REPEAT: 10497,
      SAMPLER_2D: 35678,
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6,
      UNSIGNED_BYTE: 5121,
      UNSIGNED_SHORT: 5123,
    },
    zc = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array,
    },
    $C = { 9728: un, 9729: Wn, 9984: mp, 9985: ox, 9986: oh, 9987: eo },
    WC = { 33071: xr, 33648: hh, 10497: rl },
    Fx = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
    zx = {
      POSITION: "position",
      NORMAL: "normal",
      TANGENT: "tangent",
      TEXCOORD_0: "uv",
      TEXCOORD_1: "uv2",
      COLOR_0: "color",
      WEIGHTS_0: "skinWeight",
      JOINTS_0: "skinIndex",
    },
    so = {
      scale: "scale",
      translation: "position",
      rotation: "quaternion",
      weights: "morphTargetInfluences",
    },
    XG = { CUBICSPLINE: void 0, LINEAR: al, STEP: Lc },
    Bx = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
  function YG(n) {
    return (
      n.DefaultMaterial === void 0 &&
        (n.DefaultMaterial = new wh({
          color: 16777215,
          emissive: 0,
          metalness: 1,
          roughness: 1,
          transparent: !1,
          depthTest: !0,
          side: aa,
        })),
      n.DefaultMaterial
    );
  }
  function Dh(n, e, t) {
    for (let i in t.extensions)
      n[i] === void 0 &&
        ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
        (e.userData.gltfExtensions[i] = t.extensions[i]));
  }
  function ao(n, e) {
    e.extras !== void 0 &&
      (typeof e.extras == "object"
        ? Object.assign(n.userData, e.extras)
        : console.warn(
            "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
          ));
  }
  function KG(n, e, t) {
    let i = !1,
      r = !1,
      s = !1;
    for (let c = 0, u = e.length; c < u; c++) {
      let f = e[c];
      if (
        (f.POSITION !== void 0 && (i = !0),
        f.NORMAL !== void 0 && (r = !0),
        f.COLOR_0 !== void 0 && (s = !0),
        i && r && s)
      )
        break;
    }
    if (!i && !r && !s) return Promise.resolve(n);
    let a = [],
      o = [],
      l = [];
    for (let c = 0, u = e.length; c < u; c++) {
      let f = e[c];
      if (i) {
        let d =
          f.POSITION !== void 0
            ? t.getDependency("accessor", f.POSITION)
            : n.attributes.position;
        a.push(d);
      }
      if (r) {
        let d =
          f.NORMAL !== void 0
            ? t.getDependency("accessor", f.NORMAL)
            : n.attributes.normal;
        o.push(d);
      }
      if (s) {
        let d =
          f.COLOR_0 !== void 0
            ? t.getDependency("accessor", f.COLOR_0)
            : n.attributes.color;
        l.push(d);
      }
    }
    return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then(
      function (c) {
        let u = c[0],
          f = c[1],
          d = c[2];
        return (
          i && (n.morphAttributes.position = u),
          r && (n.morphAttributes.normal = f),
          s && (n.morphAttributes.color = d),
          (n.morphTargetsRelative = !0),
          n
        );
      }
    );
  }
  function JG(n, e) {
    if ((n.updateMorphTargets(), e.weights !== void 0))
      for (let t = 0, i = e.weights.length; t < i; t++)
        n.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
      let t = e.extras.targetNames;
      if (n.morphTargetInfluences.length === t.length) {
        n.morphTargetDictionary = {};
        for (let i = 0, r = t.length; i < r; i++)
          n.morphTargetDictionary[t[i]] = i;
      } else
        console.warn(
          "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
        );
    }
  }
  function ZG(n) {
    let e = n.extensions && n.extensions[fi.KHR_DRACO_MESH_COMPRESSION],
      t;
    return (
      e
        ? (t =
            "draco:" + e.bufferView + ":" + e.indices + ":" + qC(e.attributes))
        : (t = n.indices + ":" + qC(n.attributes) + ":" + n.mode),
      t
    );
  }
  function qC(n) {
    let e = "",
      t = Object.keys(n).sort();
    for (let i = 0, r = t.length; i < r; i++) e += t[i] + ":" + n[t[i]] + ";";
    return e;
  }
  function Ux(n) {
    switch (n) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error(
          "THREE.GLTFLoader: Unsupported normalized accessor component type."
        );
    }
  }
  function QG(n) {
    return n.search(/\.jpe?g($|\?)/i) > 0 ||
      n.search(/^data\:image\/jpeg/) === 0
      ? "image/jpeg"
      : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
      ? "image/webp"
      : "image/png";
  }
  var eH = new Wt(),
    mP = class {
      constructor(e = {}, t = {}) {
        (this.json = e),
          (this.extensions = {}),
          (this.plugins = {}),
          (this.options = t),
          (this.cache = new qG()),
          (this.associations = new Map()),
          (this.primitiveCache = {}),
          (this.meshCache = { refs: {}, uses: {} }),
          (this.cameraCache = { refs: {}, uses: {} }),
          (this.lightCache = { refs: {}, uses: {} }),
          (this.sourceCache = {}),
          (this.textureCache = {}),
          (this.nodeNamesUsed = {});
        let i = !1,
          r = !1,
          s = -1;
        typeof navigator != "undefined" &&
          ((i =
            /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
          (r = navigator.userAgent.indexOf("Firefox") > -1),
          (s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
          typeof createImageBitmap == "undefined" || i || (r && s < 98)
            ? (this.textureLoader = new Ax(this.options.manager))
            : (this.textureLoader = new Ix(this.options.manager)),
          this.textureLoader.setCrossOrigin(this.options.crossOrigin),
          this.textureLoader.setRequestHeader(this.options.requestHeader),
          (this.fileLoader = new gl(this.options.manager)),
          this.fileLoader.setResponseType("arraybuffer"),
          this.options.crossOrigin === "use-credentials" &&
            this.fileLoader.setWithCredentials(!0);
      }
      setExtensions(e) {
        this.extensions = e;
      }
      setPlugins(e) {
        this.plugins = e;
      }
      parse(e, t) {
        let i = this,
          r = this.json,
          s = this.extensions;
        this.cache.removeAll(),
          this._invokeAll(function (a) {
            return a._markDefs && a._markDefs();
          }),
          Promise.all(
            this._invokeAll(function (a) {
              return a.beforeRoot && a.beforeRoot();
            })
          )
            .then(function () {
              return Promise.all([
                i.getDependencies("scene"),
                i.getDependencies("animation"),
                i.getDependencies("camera"),
              ]);
            })
            .then(function (a) {
              let o = {
                scene: a[0][r.scene || 0],
                scenes: a[0],
                animations: a[1],
                cameras: a[2],
                asset: r.asset,
                parser: i,
                userData: {},
              };
              Dh(s, o, r),
                ao(o, r),
                Promise.all(
                  i._invokeAll(function (l) {
                    return l.afterRoot && l.afterRoot(o);
                  })
                ).then(function () {
                  e(o);
                });
            })
            .catch(t);
      }
      _markDefs() {
        let e = this.json.nodes || [],
          t = this.json.skins || [],
          i = this.json.meshes || [];
        for (let r = 0, s = t.length; r < s; r++) {
          let a = t[r].joints;
          for (let o = 0, l = a.length; o < l; o++) e[a[o]].isBone = !0;
        }
        for (let r = 0, s = e.length; r < s; r++) {
          let a = e[r];
          a.mesh !== void 0 &&
            (this._addNodeRef(this.meshCache, a.mesh),
            a.skin !== void 0 && (i[a.mesh].isSkinnedMesh = !0)),
            a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
        }
      }
      _addNodeRef(e, t) {
        t !== void 0 &&
          (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
      }
      _getNodeRef(e, t, i) {
        if (e.refs[t] <= 1) return i;
        let r = i.clone(),
          s = (a, o) => {
            let l = this.associations.get(a);
            l != null && this.associations.set(o, l);
            for (let [c, u] of a.children.entries()) s(u, o.children[c]);
          };
        return s(i, r), (r.name += "_instance_" + e.uses[t]++), r;
      }
      _invokeOne(e) {
        let t = Object.values(this.plugins);
        t.push(this);
        for (let i = 0; i < t.length; i++) {
          let r = e(t[i]);
          if (r) return r;
        }
        return null;
      }
      _invokeAll(e) {
        let t = Object.values(this.plugins);
        t.unshift(this);
        let i = [];
        for (let r = 0; r < t.length; r++) {
          let s = e(t[r]);
          s && i.push(s);
        }
        return i;
      }
      getDependency(e, t) {
        let i = e + ":" + t,
          r = this.cache.get(i);
        if (!r) {
          switch (e) {
            case "scene":
              r = this.loadScene(t);
              break;
            case "node":
              r = this._invokeOne(function (s) {
                return s.loadNode && s.loadNode(t);
              });
              break;
            case "mesh":
              r = this._invokeOne(function (s) {
                return s.loadMesh && s.loadMesh(t);
              });
              break;
            case "accessor":
              r = this.loadAccessor(t);
              break;
            case "bufferView":
              r = this._invokeOne(function (s) {
                return s.loadBufferView && s.loadBufferView(t);
              });
              break;
            case "buffer":
              r = this.loadBuffer(t);
              break;
            case "material":
              r = this._invokeOne(function (s) {
                return s.loadMaterial && s.loadMaterial(t);
              });
              break;
            case "texture":
              r = this._invokeOne(function (s) {
                return s.loadTexture && s.loadTexture(t);
              });
              break;
            case "skin":
              r = this.loadSkin(t);
              break;
            case "animation":
              r = this._invokeOne(function (s) {
                return s.loadAnimation && s.loadAnimation(t);
              });
              break;
            case "camera":
              r = this.loadCamera(t);
              break;
            default:
              if (
                ((r = this._invokeOne(function (s) {
                  return s != this && s.getDependency && s.getDependency(e, t);
                })),
                !r)
              )
                throw new Error("Unknown type: " + e);
              break;
          }
          this.cache.add(i, r);
        }
        return r;
      }
      getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
          let i = this,
            r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
          (t = Promise.all(
            r.map(function (s, a) {
              return i.getDependency(e, a);
            })
          )),
            this.cache.add(e, t);
        }
        return t;
      }
      loadBuffer(e) {
        let t = this.json.buffers[e],
          i = this.fileLoader;
        if (t.type && t.type !== "arraybuffer")
          throw new Error(
            "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
          );
        if (t.uri === void 0 && e === 0)
          return Promise.resolve(this.extensions[fi.KHR_BINARY_GLTF].body);
        let r = this.options;
        return new Promise(function (s, a) {
          i.load(ha.resolveURL(t.uri, r.path), s, void 0, function () {
            a(
              new Error(
                'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
              )
            );
          });
        });
      }
      loadBufferView(e) {
        let t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function (i) {
          let r = t.byteLength || 0,
            s = t.byteOffset || 0;
          return i.slice(s, s + r);
        });
      }
      loadAccessor(e) {
        let t = this,
          i = this.json,
          r = this.json.accessors[e];
        if (r.bufferView === void 0 && r.sparse === void 0) {
          let a = Fx[r.type],
            o = zc[r.componentType],
            l = r.normalized === !0,
            c = new o(r.count * a);
          return Promise.resolve(new en(c, a, l));
        }
        let s = [];
        return (
          r.bufferView !== void 0
            ? s.push(this.getDependency("bufferView", r.bufferView))
            : s.push(null),
          r.sparse !== void 0 &&
            (s.push(
              this.getDependency("bufferView", r.sparse.indices.bufferView)
            ),
            s.push(
              this.getDependency("bufferView", r.sparse.values.bufferView)
            )),
          Promise.all(s).then(function (a) {
            let o = a[0],
              l = Fx[r.type],
              c = zc[r.componentType],
              u = c.BYTES_PER_ELEMENT,
              f = u * l,
              d = r.byteOffset || 0,
              m =
                r.bufferView !== void 0
                  ? i.bufferViews[r.bufferView].byteStride
                  : void 0,
              x = r.normalized === !0,
              y,
              g;
            if (m && m !== f) {
              let b = Math.floor(d / m),
                _ =
                  "InterleavedBuffer:" +
                  r.bufferView +
                  ":" +
                  r.componentType +
                  ":" +
                  b +
                  ":" +
                  r.count,
                E = t.cache.get(_);
              E ||
                ((y = new c(o, b * m, (r.count * m) / u)),
                (E = new bx(y, m / u)),
                t.cache.add(_, E)),
                (g = new _h(E, l, (d % m) / u, x));
            } else o === null ? (y = new c(r.count * l)) : (y = new c(o, d, r.count * l)), (g = new en(y, l, x));
            if (r.sparse !== void 0) {
              let b = Fx.SCALAR,
                _ = zc[r.sparse.indices.componentType],
                E = r.sparse.indices.byteOffset || 0,
                w = r.sparse.values.byteOffset || 0,
                P = new _(a[1], E, r.sparse.count * b),
                L = new c(a[2], w, r.sparse.count * l);
              o !== null &&
                (g = new en(g.array.slice(), g.itemSize, g.normalized));
              for (let I = 0, M = P.length; I < M; I++) {
                let R = P[I];
                if (
                  (g.setX(R, L[I * l]),
                  l >= 2 && g.setY(R, L[I * l + 1]),
                  l >= 3 && g.setZ(R, L[I * l + 2]),
                  l >= 4 && g.setW(R, L[I * l + 3]),
                  l >= 5)
                )
                  throw new Error(
                    "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                  );
              }
            }
            return g;
          })
        );
      }
      loadTexture(e) {
        let t = this.json,
          i = this.options,
          s = t.textures[e].source,
          a = t.images[s],
          o = this.textureLoader;
        if (a.uri) {
          let l = i.manager.getHandler(a.uri);
          l !== null && (o = l);
        }
        return this.loadTextureImage(e, s, o);
      }
      loadTextureImage(e, t, i) {
        let r = this,
          s = this.json,
          a = s.textures[e],
          o = s.images[t],
          l = (o.uri || o.bufferView) + ":" + a.sampler;
        if (this.textureCache[l]) return this.textureCache[l];
        let c = this.loadImageSource(t, i)
          .then(function (u) {
            (u.flipY = !1), (u.name = a.name || o.name || "");
            let d = (s.samplers || {})[a.sampler] || {};
            return (
              (u.magFilter = $C[d.magFilter] || Wn),
              (u.minFilter = $C[d.minFilter] || eo),
              (u.wrapS = WC[d.wrapS] || rl),
              (u.wrapT = WC[d.wrapT] || rl),
              r.associations.set(u, { textures: e }),
              u
            );
          })
          .catch(function () {
            return null;
          });
        return (this.textureCache[l] = c), c;
      }
      loadImageSource(e, t) {
        let i = this,
          r = this.json,
          s = this.options;
        if (this.sourceCache[e] !== void 0)
          return this.sourceCache[e].then((f) => f.clone());
        let a = r.images[e],
          o = self.URL || self.webkitURL,
          l = a.uri || "",
          c = !1;
        if (a.bufferView !== void 0)
          l = i.getDependency("bufferView", a.bufferView).then(function (f) {
            c = !0;
            let d = new Blob([f], { type: a.mimeType });
            return (l = o.createObjectURL(d)), l;
          });
        else if (a.uri === void 0)
          throw new Error(
            "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
          );
        let u = Promise.resolve(l)
          .then(function (f) {
            return new Promise(function (d, m) {
              let x = d;
              t.isImageBitmapLoader === !0 &&
                (x = function (y) {
                  let g = new hn(y);
                  (g.needsUpdate = !0), d(g);
                }),
                t.load(ha.resolveURL(f, s.path), x, void 0, m);
            });
          })
          .then(function (f) {
            return (
              c === !0 && o.revokeObjectURL(l),
              (f.userData.mimeType = a.mimeType || QG(a.uri)),
              f
            );
          })
          .catch(function (f) {
            throw (
              (console.error("THREE.GLTFLoader: Couldn't load texture", l), f)
            );
          });
        return (this.sourceCache[e] = u), u;
      }
      assignTexture(e, t, i, r) {
        let s = this;
        return this.getDependency("texture", i.index).then(function (a) {
          if (!a) return null;
          if (
            (i.texCoord !== void 0 &&
              i.texCoord != 0 &&
              !(t === "aoMap" && i.texCoord == 1) &&
              console.warn(
                "THREE.GLTFLoader: Custom UV set " +
                  i.texCoord +
                  " for texture " +
                  t +
                  " not yet supported."
              ),
            s.extensions[fi.KHR_TEXTURE_TRANSFORM])
          ) {
            let o =
              i.extensions !== void 0
                ? i.extensions[fi.KHR_TEXTURE_TRANSFORM]
                : void 0;
            if (o) {
              let l = s.associations.get(a);
              (a = s.extensions[fi.KHR_TEXTURE_TRANSFORM].extendTexture(a, o)),
                s.associations.set(a, l);
            }
          }
          return r !== void 0 && (a.encoding = r), (e[t] = a), a;
        });
      }
      assignFinalMaterial(e) {
        let t = e.geometry,
          i = e.material,
          r = t.attributes.tangent === void 0,
          s = t.attributes.color !== void 0,
          a = t.attributes.normal === void 0;
        if (e.isPoints) {
          let o = "PointsMaterial:" + i.uuid,
            l = this.cache.get(o);
          l ||
            ((l = new wp()),
            Xr.prototype.copy.call(l, i),
            l.color.copy(i.color),
            (l.map = i.map),
            (l.sizeAttenuation = !1),
            this.cache.add(o, l)),
            (i = l);
        } else if (e.isLine) {
          let o = "LineBasicMaterial:" + i.uuid,
            l = this.cache.get(o);
          l ||
            ((l = new Th()),
            Xr.prototype.copy.call(l, i),
            l.color.copy(i.color),
            this.cache.add(o, l)),
            (i = l);
        }
        if (r || s || a) {
          let o = "ClonedMaterial:" + i.uuid + ":";
          r && (o += "derivative-tangents:"),
            s && (o += "vertex-colors:"),
            a && (o += "flat-shading:");
          let l = this.cache.get(o);
          l ||
            ((l = i.clone()),
            s && (l.vertexColors = !0),
            a && (l.flatShading = !0),
            r &&
              (l.normalScale && (l.normalScale.y *= -1),
              l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
            this.cache.add(o, l),
            this.associations.set(l, this.associations.get(i))),
            (i = l);
        }
        i.aoMap &&
          t.attributes.uv2 === void 0 &&
          t.attributes.uv !== void 0 &&
          t.setAttribute("uv2", t.attributes.uv),
          (e.material = i);
      }
      getMaterialType() {
        return wh;
      }
      loadMaterial(e) {
        let t = this,
          i = this.json,
          r = this.extensions,
          s = i.materials[e],
          a,
          o = {},
          l = s.extensions || {},
          c = [];
        if (l[fi.KHR_MATERIALS_UNLIT]) {
          let f = r[fi.KHR_MATERIALS_UNLIT];
          (a = f.getMaterialType()), c.push(f.extendParams(o, s, t));
        } else {
          let f = s.pbrMetallicRoughness || {};
          if (
            ((o.color = new Bt(1, 1, 1)),
            (o.opacity = 1),
            Array.isArray(f.baseColorFactor))
          ) {
            let d = f.baseColorFactor;
            o.color.fromArray(d), (o.opacity = d[3]);
          }
          f.baseColorTexture !== void 0 &&
            c.push(t.assignTexture(o, "map", f.baseColorTexture, oi)),
            (o.metalness = f.metallicFactor !== void 0 ? f.metallicFactor : 1),
            (o.roughness =
              f.roughnessFactor !== void 0 ? f.roughnessFactor : 1),
            f.metallicRoughnessTexture !== void 0 &&
              (c.push(
                t.assignTexture(o, "metalnessMap", f.metallicRoughnessTexture)
              ),
              c.push(
                t.assignTexture(o, "roughnessMap", f.metallicRoughnessTexture)
              )),
            (a = this._invokeOne(function (d) {
              return d.getMaterialType && d.getMaterialType(e);
            })),
            c.push(
              Promise.all(
                this._invokeAll(function (d) {
                  return d.extendMaterialParams && d.extendMaterialParams(e, o);
                })
              )
            );
        }
        s.doubleSided === !0 && (o.side = vh);
        let u = s.alphaMode || Bx.OPAQUE;
        if (
          (u === Bx.BLEND
            ? ((o.transparent = !0), (o.depthWrite = !1))
            : ((o.transparent = !1),
              u === Bx.MASK &&
                (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
          s.normalTexture !== void 0 &&
            a !== oa &&
            (c.push(t.assignTexture(o, "normalMap", s.normalTexture)),
            (o.normalScale = new It(1, 1)),
            s.normalTexture.scale !== void 0))
        ) {
          let f = s.normalTexture.scale;
          o.normalScale.set(f, f);
        }
        return (
          s.occlusionTexture !== void 0 &&
            a !== oa &&
            (c.push(t.assignTexture(o, "aoMap", s.occlusionTexture)),
            s.occlusionTexture.strength !== void 0 &&
              (o.aoMapIntensity = s.occlusionTexture.strength)),
          s.emissiveFactor !== void 0 &&
            a !== oa &&
            (o.emissive = new Bt().fromArray(s.emissiveFactor)),
          s.emissiveTexture !== void 0 &&
            a !== oa &&
            c.push(t.assignTexture(o, "emissiveMap", s.emissiveTexture, oi)),
          Promise.all(c).then(function () {
            let f = new a(o);
            return (
              s.name && (f.name = s.name),
              ao(f, s),
              t.associations.set(f, { materials: e }),
              s.extensions && Dh(r, f, s),
              f
            );
          })
        );
      }
      createUniqueName(e) {
        let t = di.sanitizeNodeName(e || ""),
          i = t;
        for (let r = 1; this.nodeNamesUsed[i]; ++r) i = t + "_" + r;
        return (this.nodeNamesUsed[i] = !0), i;
      }
      loadGeometries(e) {
        let t = this,
          i = this.extensions,
          r = this.primitiveCache;
        function s(o) {
          return i[fi.KHR_DRACO_MESH_COMPRESSION]
            .decodePrimitive(o, t)
            .then(function (l) {
              return jC(l, o, t);
            });
        }
        let a = [];
        for (let o = 0, l = e.length; o < l; o++) {
          let c = e[o],
            u = ZG(c),
            f = r[u];
          if (f) a.push(f.promise);
          else {
            let d;
            c.extensions && c.extensions[fi.KHR_DRACO_MESH_COMPRESSION]
              ? (d = s(c))
              : (d = jC(new qn(), c, t)),
              (r[u] = { primitive: c, promise: d }),
              a.push(d);
          }
        }
        return Promise.all(a);
      }
      loadMesh(e) {
        let t = this,
          i = this.json,
          r = this.extensions,
          s = i.meshes[e],
          a = s.primitives,
          o = [];
        for (let l = 0, c = a.length; l < c; l++) {
          let u =
            a[l].material === void 0
              ? YG(this.cache)
              : this.getDependency("material", a[l].material);
          o.push(u);
        }
        return (
          o.push(t.loadGeometries(a)),
          Promise.all(o).then(function (l) {
            let c = l.slice(0, l.length - 1),
              u = l[l.length - 1],
              f = [];
            for (let m = 0, x = u.length; m < x; m++) {
              let y = u[m],
                g = a[m],
                b,
                _ = c[m];
              if (
                g.mode === Yr.TRIANGLES ||
                g.mode === Yr.TRIANGLE_STRIP ||
                g.mode === Yr.TRIANGLE_FAN ||
                g.mode === void 0
              )
                (b = s.isSkinnedMesh === !0 ? new _x(y, _) : new ar(y, _)),
                  b.isSkinnedMesh === !0 &&
                    !b.geometry.attributes.skinWeight.normalized &&
                    b.normalizeSkinWeights(),
                  g.mode === Yr.TRIANGLE_STRIP
                    ? (b.geometry = XC(b.geometry, iC))
                    : g.mode === Yr.TRIANGLE_FAN &&
                      (b.geometry = XC(b.geometry, cx));
              else if (g.mode === Yr.LINES) b = new Sp(y, _);
              else if (g.mode === Yr.LINE_STRIP) b = new Sh(y, _);
              else if (g.mode === Yr.LINE_LOOP) b = new Tx(y, _);
              else if (g.mode === Yr.POINTS) b = new Sx(y, _);
              else
                throw new Error(
                  "THREE.GLTFLoader: Primitive mode unsupported: " + g.mode
                );
              Object.keys(b.geometry.morphAttributes).length > 0 && JG(b, s),
                (b.name = t.createUniqueName(s.name || "mesh_" + e)),
                ao(b, s),
                g.extensions && Dh(r, b, g),
                t.assignFinalMaterial(b),
                f.push(b);
            }
            for (let m = 0, x = f.length; m < x; m++)
              t.associations.set(f[m], { meshes: e, primitives: m });
            if (f.length === 1) return f[0];
            let d = new br();
            t.associations.set(d, { meshes: e });
            for (let m = 0, x = f.length; m < x; m++) d.add(f[m]);
            return d;
          })
        );
      }
      loadCamera(e) {
        let t,
          i = this.json.cameras[e],
          r = i[i.type];
        if (!r) {
          console.warn("THREE.GLTFLoader: Missing camera parameters.");
          return;
        }
        return (
          i.type === "perspective"
            ? (t = new yn(
                sC.radToDeg(r.yfov),
                r.aspectRatio || 1,
                r.znear || 1,
                r.zfar || 2e6
              ))
            : i.type === "orthographic" &&
              (t = new fl(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)),
          i.name && (t.name = this.createUniqueName(i.name)),
          ao(t, i),
          Promise.resolve(t)
        );
      }
      loadSkin(e) {
        let t = this.json.skins[e],
          i = [];
        for (let r = 0, s = t.joints.length; r < s; r++)
          i.push(this.getDependency("node", t.joints[r]));
        return (
          t.inverseBindMatrices !== void 0
            ? i.push(this.getDependency("accessor", t.inverseBindMatrices))
            : i.push(null),
          Promise.all(i).then(function (r) {
            let s = r.pop(),
              a = r,
              o = [],
              l = [];
            for (let c = 0, u = a.length; c < u; c++) {
              let f = a[c];
              if (f) {
                o.push(f);
                let d = new Wt();
                s !== null && d.fromArray(s.array, c * 16), l.push(d);
              } else
                console.warn(
                  'THREE.GLTFLoader: Joint "%s" could not be found.',
                  t.joints[c]
                );
            }
            return new Eh(o, l);
          })
        );
      }
      loadAnimation(e) {
        let i = this.json.animations[e],
          r = [],
          s = [],
          a = [],
          o = [],
          l = [];
        for (let c = 0, u = i.channels.length; c < u; c++) {
          let f = i.channels[c],
            d = i.samplers[f.sampler],
            m = f.target,
            x = m.node,
            y = i.parameters !== void 0 ? i.parameters[d.input] : d.input,
            g = i.parameters !== void 0 ? i.parameters[d.output] : d.output;
          r.push(this.getDependency("node", x)),
            s.push(this.getDependency("accessor", y)),
            a.push(this.getDependency("accessor", g)),
            o.push(d),
            l.push(m);
        }
        return Promise.all([
          Promise.all(r),
          Promise.all(s),
          Promise.all(a),
          Promise.all(o),
          Promise.all(l),
        ]).then(function (c) {
          let u = c[0],
            f = c[1],
            d = c[2],
            m = c[3],
            x = c[4],
            y = [];
          for (let b = 0, _ = u.length; b < _; b++) {
            let E = u[b],
              w = f[b],
              P = d[b],
              L = m[b],
              I = x[b];
            if (E === void 0) continue;
            E.updateMatrix();
            let M;
            switch (so[I.path]) {
              case so.weights:
                M = ll;
                break;
              case so.rotation:
                M = ca;
                break;
              case so.position:
              case so.scale:
              default:
                M = cl;
                break;
            }
            let R = E.name ? E.name : E.uuid,
              O = L.interpolation !== void 0 ? XG[L.interpolation] : al,
              U = [];
            so[I.path] === so.weights
              ? E.traverse(function ($) {
                  $.morphTargetInfluences && U.push($.name ? $.name : $.uuid);
                })
              : U.push(R);
            let X = P.array;
            if (P.normalized) {
              let $ = Ux(X.constructor),
                W = new Float32Array(X.length);
              for (let ue = 0, ae = X.length; ue < ae; ue++) W[ue] = X[ue] * $;
              X = W;
            }
            for (let $ = 0, W = U.length; $ < W; $++) {
              let ue = new M(U[$] + "." + so[I.path], w.array, X, O);
              L.interpolation === "CUBICSPLINE" &&
                ((ue.createInterpolant = function (he) {
                  let ce = this instanceof ca ? pP : Gx;
                  return new ce(
                    this.times,
                    this.values,
                    this.getValueSize() / 3,
                    he
                  );
                }),
                (ue.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                  !0)),
                y.push(ue);
            }
          }
          let g = i.name ? i.name : "animation_" + e;
          return new gh(g, void 0, y);
        });
      }
      createNodeMesh(e) {
        let t = this.json,
          i = this,
          r = t.nodes[e];
        return r.mesh === void 0
          ? null
          : i.getDependency("mesh", r.mesh).then(function (s) {
              let a = i._getNodeRef(i.meshCache, r.mesh, s);
              return (
                r.weights !== void 0 &&
                  a.traverse(function (o) {
                    if (!!o.isMesh)
                      for (let l = 0, c = r.weights.length; l < c; l++)
                        o.morphTargetInfluences[l] = r.weights[l];
                  }),
                a
              );
            });
      }
      loadNode(e) {
        let t = this.json,
          i = this.extensions,
          r = this,
          s = t.nodes[e],
          a = s.name ? r.createUniqueName(s.name) : "";
        return (function () {
          let o = [],
            l = r._invokeOne(function (d) {
              return d.createNodeMesh && d.createNodeMesh(e);
            });
          l && o.push(l),
            s.camera !== void 0 &&
              o.push(
                r.getDependency("camera", s.camera).then(function (d) {
                  return r._getNodeRef(r.cameraCache, s.camera, d);
                })
              ),
            r
              ._invokeAll(function (d) {
                return d.createNodeAttachment && d.createNodeAttachment(e);
              })
              .forEach(function (d) {
                o.push(d);
              });
          let c = [],
            u = s.children || [];
          for (let d = 0, m = u.length; d < m; d++)
            c.push(r.getDependency("node", u[d]));
          let f =
            s.skin === void 0
              ? Promise.resolve(null)
              : r.getDependency("skin", s.skin);
          return Promise.all([Promise.all(o), Promise.all(c), f]);
        })().then(function (o) {
          let l = o[0],
            c = o[1],
            u = o[2],
            f;
          if (
            (s.isBone === !0
              ? (f = new Tp())
              : l.length > 1
              ? (f = new br())
              : l.length === 1
              ? (f = l[0])
              : (f = new Ai()),
            f !== l[0])
          )
            for (let d = 0, m = l.length; d < m; d++) f.add(l[d]);
          if (
            (s.name && ((f.userData.name = s.name), (f.name = a)),
            ao(f, s),
            s.extensions && Dh(i, f, s),
            s.matrix !== void 0)
          ) {
            let d = new Wt();
            d.fromArray(s.matrix), f.applyMatrix4(d);
          } else s.translation !== void 0 && f.position.fromArray(s.translation), s.rotation !== void 0 && f.quaternion.fromArray(s.rotation), s.scale !== void 0 && f.scale.fromArray(s.scale);
          r.associations.has(f) || r.associations.set(f, {}),
            (r.associations.get(f).nodes = e),
            u !== null &&
              f.traverse(function (d) {
                !d.isSkinnedMesh || d.bind(u, eH);
              });
          for (let d = 0, m = c.length; d < m; d++) f.add(c[d]);
          return f;
        });
      }
      loadScene(e) {
        let t = this.extensions,
          i = this.json.scenes[e],
          r = this,
          s = new br();
        i.name && (s.name = r.createUniqueName(i.name)),
          ao(s, i),
          i.extensions && Dh(t, s, i);
        let a = i.nodes || [],
          o = [];
        for (let l = 0, c = a.length; l < c; l++)
          o.push(r.getDependency("node", a[l]));
        return Promise.all(o).then(function (l) {
          for (let u = 0, f = l.length; u < f; u++) s.add(l[u]);
          let c = (u) => {
            let f = new Map();
            for (let [d, m] of r.associations)
              (d instanceof Xr || d instanceof hn) && f.set(d, m);
            return (
              u.traverse((d) => {
                let m = r.associations.get(d);
                m != null && f.set(d, m);
              }),
              f
            );
          };
          return (r.associations = c(s)), s;
        });
      }
    };
  function tH(n, e, t) {
    let i = e.attributes,
      r = new no();
    if (i.POSITION !== void 0) {
      let o = t.json.accessors[i.POSITION],
        l = o.min,
        c = o.max;
      if (l !== void 0 && c !== void 0) {
        if (
          (r.set(new le(l[0], l[1], l[2]), new le(c[0], c[1], c[2])),
          o.normalized)
        ) {
          let u = Ux(zc[o.componentType]);
          r.min.multiplyScalar(u), r.max.multiplyScalar(u);
        }
      } else {
        console.warn(
          "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
        );
        return;
      }
    } else return;
    let s = e.targets;
    if (s !== void 0) {
      let o = new le(),
        l = new le();
      for (let c = 0, u = s.length; c < u; c++) {
        let f = s[c];
        if (f.POSITION !== void 0) {
          let d = t.json.accessors[f.POSITION],
            m = d.min,
            x = d.max;
          if (m !== void 0 && x !== void 0) {
            if (
              (l.setX(Math.max(Math.abs(m[0]), Math.abs(x[0]))),
              l.setY(Math.max(Math.abs(m[1]), Math.abs(x[1]))),
              l.setZ(Math.max(Math.abs(m[2]), Math.abs(x[2]))),
              d.normalized)
            ) {
              let y = Ux(zc[d.componentType]);
              l.multiplyScalar(y);
            }
            o.max(l);
          } else
            console.warn(
              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
            );
        }
      }
      r.expandByVector(o);
    }
    n.boundingBox = r;
    let a = new ro();
    r.getCenter(a.center),
      (a.radius = r.min.distanceTo(r.max) / 2),
      (n.boundingSphere = a);
  }
  function jC(n, e, t) {
    let i = e.attributes,
      r = [];
    function s(a, o) {
      return t.getDependency("accessor", a).then(function (l) {
        n.setAttribute(o, l);
      });
    }
    for (let a in i) {
      let o = zx[a] || a.toLowerCase();
      o in n.attributes || r.push(s(i[a], o));
    }
    if (e.indices !== void 0 && !n.index) {
      let a = t.getDependency("accessor", e.indices).then(function (o) {
        n.setIndex(o);
      });
      r.push(a);
    }
    return (
      ao(n, e),
      tH(n, e, t),
      Promise.all(r).then(function () {
        return e.targets !== void 0 ? KG(n, e.targets, t) : n;
      })
    );
  }
  function XC(n, e) {
    let t = n.getIndex();
    if (t === null) {
      let a = [],
        o = n.getAttribute("position");
      if (o !== void 0) {
        for (let l = 0; l < o.count; l++) a.push(l);
        n.setIndex(a), (t = n.getIndex());
      } else
        return (
          console.error(
            "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          n
        );
    }
    let i = t.count - 2,
      r = [];
    if (e === cx)
      for (let a = 1; a <= i; a++)
        r.push(t.getX(0)), r.push(t.getX(a)), r.push(t.getX(a + 1));
    else
      for (let a = 0; a < i; a++)
        a % 2 === 0
          ? (r.push(t.getX(a)), r.push(t.getX(a + 1)), r.push(t.getX(a + 2)))
          : (r.push(t.getX(a + 2)), r.push(t.getX(a + 1)), r.push(t.getX(a)));
    r.length / 3 !== i &&
      console.error(
        "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    let s = n.clone();
    return s.setIndex(r), s;
  }
  var Ih = new Vx(),
    gP = new kx();
  gP.setDecoderPath(
    "https://unpkg.com/three@0.139.2/examples/js/libs/draco/gltf/"
  );
  Ih.setDRACOLoader(gP);
  var yP = { type: "change" },
    Hx = { type: "start" },
    vP = { type: "end" },
    Lh = class extends Ds {
      constructor(e, t) {
        super();
        (this.object = e),
          (this.domElement = t),
          (this.domElement.style.touchAction = "none"),
          (this.enabled = !0),
          (this.target = new le()),
          (this.minDistance = 0),
          (this.maxDistance = 1 / 0),
          (this.minZoom = 0),
          (this.maxZoom = 1 / 0),
          (this.minPolarAngle = 0),
          (this.maxPolarAngle = Math.PI),
          (this.minAzimuthAngle = -1 / 0),
          (this.maxAzimuthAngle = 1 / 0),
          (this.enableDamping = !1),
          (this.dampingFactor = 0.05),
          (this.enableZoom = !0),
          (this.zoomSpeed = 1),
          (this.enableRotate = !0),
          (this.rotateSpeed = 1),
          (this.enablePan = !0),
          (this.panSpeed = 1),
          (this.screenSpacePanning = !0),
          (this.keyPanSpeed = 7),
          (this.autoRotate = !1),
          (this.autoRotateSpeed = 2),
          (this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown",
          }),
          (this.mouseButtons = {
            LEFT: ul.ROTATE,
            MIDDLE: ul.DOLLY,
            RIGHT: ul.PAN,
          }),
          (this.touches = { ONE: hl.ROTATE, TWO: hl.DOLLY_PAN }),
          (this.target0 = this.target.clone()),
          (this.position0 = this.object.position.clone()),
          (this.zoom0 = this.object.zoom),
          (this._domElementKeyEvents = null),
          (this.getPolarAngle = function () {
            return o.phi;
          }),
          (this.getAzimuthalAngle = function () {
            return o.theta;
          }),
          (this.getDistance = function () {
            return this.object.position.distanceTo(this.target);
          }),
          (this.listenToKeyEvents = function (A) {
            A.addEventListener("keydown", He), (this._domElementKeyEvents = A);
          }),
          (this.saveState = function () {
            i.target0.copy(i.target),
              i.position0.copy(i.object.position),
              (i.zoom0 = i.object.zoom);
          }),
          (this.reset = function () {
            i.target.copy(i.target0),
              i.object.position.copy(i.position0),
              (i.object.zoom = i.zoom0),
              i.object.updateProjectionMatrix(),
              i.dispatchEvent(yP),
              i.update(),
              (s = r.NONE);
          }),
          (this.update = (function () {
            let A = new le(),
              D = new In().setFromUnitVectors(e.up, new le(0, 1, 0)),
              V = D.clone().invert(),
              Q = new le(),
              ee = new In(),
              _e = 2 * Math.PI;
            return function () {
              let Ee = i.object.position;
              A.copy(Ee).sub(i.target),
                A.applyQuaternion(D),
                o.setFromVector3(A),
                i.autoRotate && s === r.NONE && R(I()),
                i.enableDamping
                  ? ((o.theta += l.theta * i.dampingFactor),
                    (o.phi += l.phi * i.dampingFactor))
                  : ((o.theta += l.theta), (o.phi += l.phi));
              let Se = i.minAzimuthAngle,
                st = i.maxAzimuthAngle;
              return (
                isFinite(Se) &&
                  isFinite(st) &&
                  (Se < -Math.PI ? (Se += _e) : Se > Math.PI && (Se -= _e),
                  st < -Math.PI ? (st += _e) : st > Math.PI && (st -= _e),
                  Se <= st
                    ? (o.theta = Math.max(Se, Math.min(st, o.theta)))
                    : (o.theta =
                        o.theta > (Se + st) / 2
                          ? Math.max(Se, o.theta)
                          : Math.min(st, o.theta))),
                (o.phi = Math.max(
                  i.minPolarAngle,
                  Math.min(i.maxPolarAngle, o.phi)
                )),
                o.makeSafe(),
                (o.radius *= c),
                (o.radius = Math.max(
                  i.minDistance,
                  Math.min(i.maxDistance, o.radius)
                )),
                i.enableDamping === !0
                  ? i.target.addScaledVector(u, i.dampingFactor)
                  : i.target.add(u),
                A.setFromSpherical(o),
                A.applyQuaternion(V),
                Ee.copy(i.target).add(A),
                i.object.lookAt(i.target),
                i.enableDamping === !0
                  ? ((l.theta *= 1 - i.dampingFactor),
                    (l.phi *= 1 - i.dampingFactor),
                    u.multiplyScalar(1 - i.dampingFactor))
                  : (l.set(0, 0, 0), u.set(0, 0, 0)),
                (c = 1),
                f ||
                Q.distanceToSquared(i.object.position) > a ||
                8 * (1 - ee.dot(i.object.quaternion)) > a
                  ? (i.dispatchEvent(yP),
                    Q.copy(i.object.position),
                    ee.copy(i.object.quaternion),
                    (f = !1),
                    !0)
                  : !1
              );
            };
          })()),
          (this.dispose = function () {
            i.domElement.removeEventListener("contextmenu", re),
              i.domElement.removeEventListener("pointerdown", ie),
              i.domElement.removeEventListener("pointercancel", De),
              i.domElement.removeEventListener("wheel", Ve),
              i.domElement.removeEventListener("pointermove", ye),
              i.domElement.removeEventListener("pointerup", Pe),
              i._domElementKeyEvents !== null &&
                i._domElementKeyEvents.removeEventListener("keydown", He);
          });
        let i = this,
          r = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6,
          },
          s = r.NONE,
          a = 1e-6,
          o = new Ap(),
          l = new Ap(),
          c = 1,
          u = new le(),
          f = !1,
          d = new It(),
          m = new It(),
          x = new It(),
          y = new It(),
          g = new It(),
          b = new It(),
          _ = new It(),
          E = new It(),
          w = new It(),
          P = [],
          L = {};
        function I() {
          return ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed;
        }
        function M() {
          return Math.pow(0.95, i.zoomSpeed);
        }
        function R(A) {
          l.theta -= A;
        }
        function O(A) {
          l.phi -= A;
        }
        let U = (function () {
            let A = new le();
            return function (V, Q) {
              A.setFromMatrixColumn(Q, 0), A.multiplyScalar(-V), u.add(A);
            };
          })(),
          X = (function () {
            let A = new le();
            return function (V, Q) {
              i.screenSpacePanning === !0
                ? A.setFromMatrixColumn(Q, 1)
                : (A.setFromMatrixColumn(Q, 0), A.crossVectors(i.object.up, A)),
                A.multiplyScalar(V),
                u.add(A);
            };
          })(),
          $ = (function () {
            let A = new le();
            return function (V, Q) {
              let ee = i.domElement;
              if (i.object.isPerspectiveCamera) {
                let _e = i.object.position;
                A.copy(_e).sub(i.target);
                let Re = A.length();
                (Re *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
                  U((2 * V * Re) / ee.clientHeight, i.object.matrix),
                  X((2 * Q * Re) / ee.clientHeight, i.object.matrix);
              } else
                i.object.isOrthographicCamera
                  ? (U(
                      (V * (i.object.right - i.object.left)) /
                        i.object.zoom /
                        ee.clientWidth,
                      i.object.matrix
                    ),
                    X(
                      (Q * (i.object.top - i.object.bottom)) /
                        i.object.zoom /
                        ee.clientHeight,
                      i.object.matrix
                    ))
                  : (console.warn(
                      "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                    ),
                    (i.enablePan = !1));
            };
          })();
        function W(A) {
          i.object.isPerspectiveCamera
            ? (c /= A)
            : i.object.isOrthographicCamera
            ? ((i.object.zoom = Math.max(
                i.minZoom,
                Math.min(i.maxZoom, i.object.zoom * A)
              )),
              i.object.updateProjectionMatrix(),
              (f = !0))
            : (console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
              ),
              (i.enableZoom = !1));
        }
        function ue(A) {
          i.object.isPerspectiveCamera
            ? (c *= A)
            : i.object.isOrthographicCamera
            ? ((i.object.zoom = Math.max(
                i.minZoom,
                Math.min(i.maxZoom, i.object.zoom / A)
              )),
              i.object.updateProjectionMatrix(),
              (f = !0))
            : (console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
              ),
              (i.enableZoom = !1));
        }
        function ae(A) {
          d.set(A.clientX, A.clientY);
        }
        function he(A) {
          _.set(A.clientX, A.clientY);
        }
        function ce(A) {
          y.set(A.clientX, A.clientY);
        }
        function te(A) {
          m.set(A.clientX, A.clientY),
            x.subVectors(m, d).multiplyScalar(i.rotateSpeed);
          let D = i.domElement;
          R((2 * Math.PI * x.x) / D.clientHeight),
            O((2 * Math.PI * x.y) / D.clientHeight),
            d.copy(m),
            i.update();
        }
        function Me(A) {
          E.set(A.clientX, A.clientY),
            w.subVectors(E, _),
            w.y > 0 ? W(M()) : w.y < 0 && ue(M()),
            _.copy(E),
            i.update();
        }
        function ge(A) {
          g.set(A.clientX, A.clientY),
            b.subVectors(g, y).multiplyScalar(i.panSpeed),
            $(b.x, b.y),
            y.copy(g),
            i.update();
        }
        function pe(A) {
          A.deltaY < 0 ? ue(M()) : A.deltaY > 0 && W(M()), i.update();
        }
        function We(A) {
          let D = !1;
          switch (A.code) {
            case i.keys.UP:
              A.ctrlKey || A.metaKey || A.shiftKey
                ? O((2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
                : $(0, i.keyPanSpeed),
                (D = !0);
              break;
            case i.keys.BOTTOM:
              A.ctrlKey || A.metaKey || A.shiftKey
                ? O((-2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
                : $(0, -i.keyPanSpeed),
                (D = !0);
              break;
            case i.keys.LEFT:
              A.ctrlKey || A.metaKey || A.shiftKey
                ? R((2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
                : $(i.keyPanSpeed, 0),
                (D = !0);
              break;
            case i.keys.RIGHT:
              A.ctrlKey || A.metaKey || A.shiftKey
                ? R((-2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
                : $(-i.keyPanSpeed, 0),
                (D = !0);
              break;
          }
          D && (A.preventDefault(), i.update());
        }
        function Fe() {
          if (P.length === 1) d.set(P[0].pageX, P[0].pageY);
          else {
            let A = 0.5 * (P[0].pageX + P[1].pageX),
              D = 0.5 * (P[0].pageY + P[1].pageY);
            d.set(A, D);
          }
        }
        function Be() {
          if (P.length === 1) y.set(P[0].pageX, P[0].pageY);
          else {
            let A = 0.5 * (P[0].pageX + P[1].pageX),
              D = 0.5 * (P[0].pageY + P[1].pageY);
            y.set(A, D);
          }
        }
        function be() {
          let A = P[0].pageX - P[1].pageX,
            D = P[0].pageY - P[1].pageY,
            V = Math.sqrt(A * A + D * D);
          _.set(0, V);
        }
        function ut() {
          i.enableZoom && be(), i.enablePan && Be();
        }
        function Ye() {
          i.enableZoom && be(), i.enableRotate && Fe();
        }
        function _t(A) {
          if (P.length == 1) m.set(A.pageX, A.pageY);
          else {
            let V = j(A),
              Q = 0.5 * (A.pageX + V.x),
              ee = 0.5 * (A.pageY + V.y);
            m.set(Q, ee);
          }
          x.subVectors(m, d).multiplyScalar(i.rotateSpeed);
          let D = i.domElement;
          R((2 * Math.PI * x.x) / D.clientHeight),
            O((2 * Math.PI * x.y) / D.clientHeight),
            d.copy(m);
        }
        function Ze(A) {
          if (P.length === 1) g.set(A.pageX, A.pageY);
          else {
            let D = j(A),
              V = 0.5 * (A.pageX + D.x),
              Q = 0.5 * (A.pageY + D.y);
            g.set(V, Q);
          }
          b.subVectors(g, y).multiplyScalar(i.panSpeed), $(b.x, b.y), y.copy(g);
        }
        function kt(A) {
          let D = j(A),
            V = A.pageX - D.x,
            Q = A.pageY - D.y,
            ee = Math.sqrt(V * V + Q * Q);
          E.set(0, ee),
            w.set(0, Math.pow(E.y / _.y, i.zoomSpeed)),
            W(w.y),
            _.copy(E);
        }
        function Et(A) {
          i.enableZoom && kt(A), i.enablePan && Ze(A);
        }
        function Y(A) {
          i.enableZoom && kt(A), i.enableRotate && _t(A);
        }
        function ie(A) {
          i.enabled !== !1 &&
            (P.length === 0 &&
              (i.domElement.setPointerCapture(A.pointerId),
              i.domElement.addEventListener("pointermove", ye),
              i.domElement.addEventListener("pointerup", Pe)),
            ve(A),
            A.pointerType === "touch" ? B(A) : Ie(A));
        }
        function ye(A) {
          i.enabled !== !1 && (A.pointerType === "touch" ? F(A) : Ue(A));
        }
        function Pe(A) {
          Te(A),
            P.length === 0 &&
              (i.domElement.releasePointerCapture(A.pointerId),
              i.domElement.removeEventListener("pointermove", ye),
              i.domElement.removeEventListener("pointerup", Pe)),
            i.dispatchEvent(vP),
            (s = r.NONE);
        }
        function De(A) {
          Te(A);
        }
        function Ie(A) {
          let D;
          switch (A.button) {
            case 0:
              D = i.mouseButtons.LEFT;
              break;
            case 1:
              D = i.mouseButtons.MIDDLE;
              break;
            case 2:
              D = i.mouseButtons.RIGHT;
              break;
            default:
              D = -1;
          }
          switch (D) {
            case ul.DOLLY:
              if (i.enableZoom === !1) return;
              he(A), (s = r.DOLLY);
              break;
            case ul.ROTATE:
              if (A.ctrlKey || A.metaKey || A.shiftKey) {
                if (i.enablePan === !1) return;
                ce(A), (s = r.PAN);
              } else {
                if (i.enableRotate === !1) return;
                ae(A), (s = r.ROTATE);
              }
              break;
            case ul.PAN:
              if (A.ctrlKey || A.metaKey || A.shiftKey) {
                if (i.enableRotate === !1) return;
                ae(A), (s = r.ROTATE);
              } else {
                if (i.enablePan === !1) return;
                ce(A), (s = r.PAN);
              }
              break;
            default:
              s = r.NONE;
          }
          s !== r.NONE && i.dispatchEvent(Hx);
        }
        function Ue(A) {
          switch (s) {
            case r.ROTATE:
              if (i.enableRotate === !1) return;
              te(A);
              break;
            case r.DOLLY:
              if (i.enableZoom === !1) return;
              Me(A);
              break;
            case r.PAN:
              if (i.enablePan === !1) return;
              ge(A);
              break;
          }
        }
        function Ve(A) {
          i.enabled === !1 ||
            i.enableZoom === !1 ||
            s !== r.NONE ||
            (A.preventDefault(),
            i.dispatchEvent(Hx),
            pe(A),
            i.dispatchEvent(vP));
        }
        function He(A) {
          i.enabled === !1 || i.enablePan === !1 || We(A);
        }
        function B(A) {
          switch ((q(A), P.length)) {
            case 1:
              switch (i.touches.ONE) {
                case hl.ROTATE:
                  if (i.enableRotate === !1) return;
                  Fe(), (s = r.TOUCH_ROTATE);
                  break;
                case hl.PAN:
                  if (i.enablePan === !1) return;
                  Be(), (s = r.TOUCH_PAN);
                  break;
                default:
                  s = r.NONE;
              }
              break;
            case 2:
              switch (i.touches.TWO) {
                case hl.DOLLY_PAN:
                  if (i.enableZoom === !1 && i.enablePan === !1) return;
                  ut(), (s = r.TOUCH_DOLLY_PAN);
                  break;
                case hl.DOLLY_ROTATE:
                  if (i.enableZoom === !1 && i.enableRotate === !1) return;
                  Ye(), (s = r.TOUCH_DOLLY_ROTATE);
                  break;
                default:
                  s = r.NONE;
              }
              break;
            default:
              s = r.NONE;
          }
          s !== r.NONE && i.dispatchEvent(Hx);
        }
        function F(A) {
          switch ((q(A), s)) {
            case r.TOUCH_ROTATE:
              if (i.enableRotate === !1) return;
              _t(A), i.update();
              break;
            case r.TOUCH_PAN:
              if (i.enablePan === !1) return;
              Ze(A), i.update();
              break;
            case r.TOUCH_DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return;
              Et(A), i.update();
              break;
            case r.TOUCH_DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return;
              Y(A), i.update();
              break;
            default:
              s = r.NONE;
          }
        }
        function re(A) {
          i.enabled !== !1 && A.preventDefault();
        }
        function ve(A) {
          P.push(A);
        }
        function Te(A) {
          delete L[A.pointerId];
          for (let D = 0; D < P.length; D++)
            if (P[D].pointerId == A.pointerId) {
              P.splice(D, 1);
              return;
            }
        }
        function q(A) {
          let D = L[A.pointerId];
          D === void 0 && ((D = new It()), (L[A.pointerId] = D)),
            D.set(A.pageX, A.pageY);
        }
        function j(A) {
          let D = A.pointerId === P[0].pointerId ? P[1] : P[0];
          return L[D.pointerId];
        }
        i.domElement.addEventListener("contextmenu", re),
          i.domElement.addEventListener("pointerdown", ie),
          i.domElement.addEventListener("pointercancel", De),
          i.domElement.addEventListener("wheel", Ve, { passive: !1 }),
          this.update();
      }
    };
  function xP(n) {
    let e = new Map(),
      t = new Map(),
      i = n.clone();
    return (
      bP(n, i, function (r, s) {
        e.set(s, r), t.set(r, s);
      }),
      i.traverse(function (r) {
        if (!r.isSkinnedMesh) return;
        let s = r,
          a = e.get(r),
          o = a.skeleton.bones;
        (s.skeleton = a.skeleton.clone()),
          s.bindMatrix.copy(a.bindMatrix),
          (s.skeleton.bones = o.map(function (l) {
            return t.get(l);
          })),
          s.bind(s.skeleton, s.bindMatrix);
      }),
      i
    );
  }
  function bP(n, e, t) {
    t(n, e);
    for (let i = 0; i < n.children.length; i++)
      bP(n.children[i], e.children[i], t);
  }
  var iH = 0.845,
    $x = 17,
    _P = class {
      constructor(e, t, i, r = 0) {
        (this.wrapper = new Ai()),
          (this.wrapper.position.x = t),
          (this.direction = Math.round(Math.random()) * 2 - 1),
          (this.wrapper.rotation.y = this.direction == 1 ? Math.PI : 0),
          this.load(e).then(() => {
            this.destroyed || (this.setScene(e), this.animate(r, i));
          });
      }
      animate(e, t = () => {}) {
        (this.tw = yt.fromTo(
          this.wrapper.position,
          { z: $x * this.direction },
          {
            z: $x * -this.direction,
            duration: $x / iH,
            ease: "none",
            onComplete: t,
          }
        )),
          this.tw.progress(e);
      }
      setScene(e) {
        (this.scene = xP(Dt[e].glb.scene)), (this.mixer = new Bc(this.scene));
        let t = Dt[e].glb.animations.find((i) => i.name == "walking");
        t && ((this.clip = this.mixer.clipAction(t)), this.clip.play()),
          this.scene.scale.set(1, 1, 1),
          this.wrapper.add(this.scene);
      }
      load(e) {
        return new Promise((t, i) => {
          if (!Dt[e])
            Dt[e] = { glb: null, usdz: null, isLoaded: !1, onLoad: t };
          else {
            Dt[e].isLoaded ? t() : (Dt[e].onLoad = t);
            return;
          }
          Ih.load(e, (r) => {
            if (((Dt[e].glb = r), (Dt[e].isLoaded = !0), r.animations.length)) {
              (Dt[e].mixer = new Bc(r.scene)),
                r.scene.traverse(function (s) {
                  s.frustumCulled = !1;
                }),
                (Dt[e].animations = []);
              for (let s = 0; s < r.animations.length; s++) {
                let a = r.animations[s].name;
                Dt[e].animations[r.animations[s].name] && (a += s),
                  (Dt[e].animations[a] = Dt[e].mixer.clipAction(
                    r.animations[s]
                  ));
              }
            }
            Dt[e].onLoad();
          });
        });
      }
      destroy() {
        var e, t;
        (this.destroyed = !0),
          (t = (e = this.tw) == null ? void 0 : e.kill) == null || t.call(e);
      }
    },
    Wx = class extends St {
      constructor(n) {
        super(n);
        (this.modelsQty = 12),
          (this.rowsQty = Math.max(this.modelsQty + 1, 20)),
          (this.rowsUsed = []),
          (this.modelsUsed = []),
          (this.canvas = this.el),
          (this.models = mr(this.getData("models").split(","))),
          (this.characters = []),
          this.resize(),
          (this.resizeBind = this.resize.bind(this)),
          window.addEventListener("resize", this.resizeBind);
      }
      init() {
        !oc || (this.initRenderer(), this.initScene(), this.render());
      }
      initRenderer() {
        (this.renderer = new xh({
          canvas: this.canvas,
          alpha: !0,
          antialias: !0,
          preserveDrawingBuffer: !0,
        })),
          (this.renderer.shadowMap.enabled = !0),
          (this.renderer.shadowMap.type = yh),
          (this.renderer.outputEncoding = oi),
          this.renderer.setSize(this.sizes.width, this.sizes.height),
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
          (this.clock = new Ch()),
          (this.previousTime = 0);
      }
      initScene() {
        this.scene = new bh();
        let n = new Ah(16777215, 2);
        this.scene.add(n),
          (this.aspect = this.sizes.width / this.sizes.height),
          this.setFrustumSize(),
          (this.camera = new fl(
            (this.frustumSize * this.aspect) / -2,
            (this.frustumSize * this.aspect) / 2,
            this.frustumSize / 2,
            this.frustumSize / -2,
            0,
            40
          )),
          this.camera.position.set(10, 7, 10),
          this.scene.add(this.camera),
          (this.controls = new Lh(this.camera, this.canvas)),
          this.controls.target.set(0, 0, 0),
          (this.controls.enableDamping = !0),
          (this.controls.enablePan = !1),
          (this.controls.maxPolarAngle = this.controls.minPolarAngle =
            this.controls.getPolarAngle()),
          (this.wrapper = new br()),
          this.wrapper.position.set(0, 0, 0),
          this.scene.add(this.wrapper);
        let e = new Ox(100, 100, 13421772, 13421772);
        this.wrapper.add(e);
        for (let t = 0; t < this.modelsQty; t++) this.spawn(Math.random());
      }
      setFrustumSize() {
        this.frustumSize =
          this.aspect > 16 / 9 ? (1 - (this.aspect - 16 / 9) * 0.2) * 10 : 10;
      }
      pickRow() {
        let n;
        for (; !n || this.rowsUsed.includes(n); )
          n = Math.floor(Math.random() * this.rowsQty - this.rowsQty / 2);
        return this.rowsUsed.push(n), n;
      }
      pickModel() {
        let n;
        for (; !n || this.modelsUsed.includes(n); )
          n = this.models[Math.floor(Math.random() * this.models.length)];
        return this.modelsUsed.push(n), n;
      }
      spawn(n = 0) {
        let e = this.pickRow(),
          t = this.pickModel(),
          i = new _P(
            t,
            e,
            () => {
              i.destroy(),
                this.wrapper.remove(i.wrapper),
                this.characters.splice(this.characters.indexOf(i), 1),
                this.rowsUsed.splice(this.rowsUsed.indexOf(e), 1),
                this.modelsUsed.splice(this.modelsUsed.indexOf(t), 1),
                this.spawn();
            },
            n
          );
        this.wrapper.add(i.wrapper), this.characters.push(i);
      }
      resize() {
        (this.BCR = this.el.getBoundingClientRect()),
          (this.sizes = { width: this.BCR.width, height: this.BCR.height }),
          this.renderer &&
            this.renderer.setSize(this.sizes.width, this.sizes.height),
          this.camera &&
            ((this.aspect = this.sizes.width / this.sizes.height),
            this.setFrustumSize(),
            (this.camera.left = (this.frustumSize * this.aspect) / -2),
            (this.camera.right = (this.frustumSize * this.aspect) / 2),
            (this.camera.top = this.frustumSize / 2),
            (this.camera.bottom = this.frustumSize / -2),
            this.camera.updateProjectionMatrix()),
          this.renderer &&
            (this.renderer.setSize(this.sizes.width, this.sizes.height),
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)));
      }
      render() {
        var e, t;
        let n = this.clock.getElapsedTime();
        (this.deltaTime = n - this.previousTime),
          (this.previousTime = n),
          this.controls.update(),
          this.renderer.render(this.scene, this.camera);
        for (let i of this.characters)
          (t = (e = i.mixer) == null ? void 0 : e.setTime) == null ||
            t.call(e, n);
        this.wrapper.rotation.set(
          0,
          this.wrapper.rotation.y + (0.001 * this.deltaTime) / (1 / 60),
          0
        ),
          (this.raf = window.requestAnimationFrame(this.render.bind(this)));
      }
      destroy() {
        var n;
        for (let e of this.characters) (n = e.destroy) == null || n.call(e);
        window.removeEventListener("resize", this.resizeBind),
          window.cancelAnimationFrame(this.raf),
          (this.scene = this.renderer = null);
      }
    };
  var Ir = {};
  ld(Ir, { compile: () => uO });
  var SY = bn(Yc()),
    zf = bn(Yc());
  qi(Ir, bn(Yc()));
  var cO = bn(CE()),
    Da = bn(lo());
  var lO = Object.create(null);
  function uO(n, e) {
    if (!(0, Da.isString)(n))
      if (n.nodeType) n = n.innerHTML;
      else return Da.NOOP;
    let t = n,
      i = lO[t];
    if (i) return i;
    if (n[0] === "#") {
      let o = document.querySelector(n);
      n = o ? o.innerHTML : "";
    }
    let { code: r } = (0, cO.compile)(
      n,
      (0, Da.extend)({ hoistStatic: !0, onError: void 0, onWarn: Da.NOOP }, e)
    );
    function s(o, l = !1) {
      let c = l ? o.message : `Template compilation error: ${o.message}`,
        u =
          o.loc &&
          (0, Da.generateCodeFrame)(n, o.loc.start.offset, o.loc.end.offset);
      (0, zf.warn)(
        u
          ? `${c}
${u}`
          : c
      );
    }
    let a = new Function("Vue", r)(SY);
    return (a._rc = !0), (lO[t] = a);
  }
  (0, zf.registerRuntimeCompiler)(uO);
  var hO = {
    delimiters: ["{(", ")}"],
    props: {
      step: { type: Object, required: !0 },
      stepSlug: { type: String, required: !0 },
      showStepContent: { type: Boolean, required: !0 },
      muted: { type: Boolean, required: !0 },
      locale: { type: String, required: !0 },
    },
    data() {
      return { lisaUserData: Lr, sentenceSlug: null };
    },
    computed: {
      sentence() {
        if (this.step.dialog.useContext) {
          let { list: n } = this.step.dialog,
            e = {};
          if (this.hasContext) {
            let s = {};
            for (let a of Object.keys(n.context)) {
              let o = a + "." + Ia.tod + "." + Ia.weatherIdent;
              n.context[a][o] && (s[o] = n.context[a][o]);
            }
            Object.assign(e, s);
          }
          Object.assign(e, n.generic);
          let t = Object.keys(e),
            i = t[Math.floor(t.length * Math.random())],
            r = e[i];
          if (
            this.hasContext &&
            Math.random() > 0.5 &&
            n[Ia.weatherIdent] &&
            Object.keys(n[Ia.weatherIdent]).length
          ) {
            let s = n[Ia.weatherIdent],
              a = Object.keys(s);
            (i = a[Math.floor(Math.random() * a.length)]), (r = s[i]);
          }
          return (this.sentenceSlug = i), r;
        } else if (this.step.dialog.key) {
          let { key: n, keyMode: e, list: t } = this.step.dialog;
          if (e == "random") {
            let i = Object.keys(t[Lr[n].value]),
              r = i[Math.floor(i.length * Math.random())];
            return (this.sentenceSlug = r), t[Lr[n].value][r];
          } else if (e == "concat") {
            let i = Object.keys(t),
              r = i[Math.floor(i.length * Math.random())],
              s = r + "." + Lr[n].value;
            return (this.sentenceSlug = s), t[r][s];
          } else return "Error: Unknown keyMode";
        } else if (this.step.dialog.list) {
          let { list: n } = this.step.dialog,
            e = Object.keys(n),
            t = e[Math.floor(e.length * Math.random())];
          return (this.sentenceSlug = t), this.step.dialog.list[t];
        } else
          console.warn("No dialog list given"), console.log(this.step.dialog);
      },
      hasContext() {
        return Object.keys(Ia).length > 0;
      },
      slotGiven() {
        return this.$slots.default;
      },
      availableChoices() {
        return this.step.choices
          ? this.step.choices.key
            ? this.step.choices.value[Lr[this.step.choices.key].value]
            : this.step.choices
          : !1;
      },
    },
    methods: {
      skip() {
        this.$refs.dialog.skip();
      },
      next() {
        this.$emit("next");
      },
      choose(n) {
        let e = n.target,
          { key: t, value: i, target: r, href: s } = e.dataset,
          a = e.innerText;
        t && i && (Lr[t] = { label: a, value: i }),
          r && this.$emit("goToStep", r),
          s && this.$emit("navigateTo", s);
      },
      completeIntro() {
        this.$emit("stepIntroUpdate", !0);
      },
      copyToClipboard(n) {
        n.preventDefault(), n.stopPropagation(), hd(n.target);
      },
    },
    watch: {
      sentenceSlug() {
        this.$nextTick(() => {
          this.muted ||
            this.$emit(
              "playAudio",
              "/assets/lisa/" + this.locale + "/" + this.sentenceSlug + ".mp3"
            ),
            this.$emit("stepIntroUpdate", !1);
        });
      },
    },
  };
  yt.registerPlugin(Ss);
  var fO = {
    delimiters: ["{(", ")}"],
    props: { sentence: { type: [String], required: !0 } },
    data() {
      return {};
    },
    mounted() {
      this.splitText(), this.animate();
    },
    methods: {
      splitText() {
        this.split = new Ss(this.$refs.output, {
          type: "chars, words",
          tag: "div",
        });
      },
      animate() {
        (this.tw = yt.timeline({
          onComplete: () => {
            (this.showContentAfterCta = !0),
              this.$emit("completed"),
              this.tw.kill();
          },
        })),
          this.tw.from(
            this.split.chars,
            { rotationX: 90, force3D: !0, stagger: 0.01, duration: 0.05 },
            0
          ),
          this.tw.add(() => {}, "+=1.5");
      },
      skip() {
        this.tw && this.tw.progress(1);
      },
    },
    watch: {
      sentence(n) {
        (this.showContentAfterCta = !1),
          this.$nextTick(() => {
            this.splitText(), this.animate();
          });
      },
    },
    template: `
        <div>
            <span ref="output" v-html="sentence"></span>
        </div>
    `,
  };
  var MO = bn(bO(), 1),
    AO = bn(_O(), 1),
    CO = bn(EO(), 1);
  var an = {};
  ld(an, {
    Vue: () => ji,
    Vue2: () => DY,
    compile: () => TO,
    del: () => RY,
    install: () => IY,
    isVue2: () => CY,
    isVue3: () => PY,
    set: () => LY,
  });
  var ji = {};
  ld(ji, { compile: () => TO });
  qi(ji, bn(Yc()));
  var TO = () => {};
  qi(an, ji);
  var CY = !1,
    PY = !0,
    DY = void 0;
  function IY() {}
  function LY(n, e, t) {
    return Array.isArray(n)
      ? ((n.length = Math.max(n.length, e)), n.splice(e, 1, t), t)
      : ((n[e] = t), t);
  }
  function RY(n, e) {
    if (Array.isArray(n)) {
      n.splice(e, 1);
      return;
    }
    delete n[e];
  }
  function RE() {
    return (
      (RE = Object.assign
        ? Object.assign.bind()
        : function (n) {
            for (var e = 1; e < arguments.length; e++) {
              var t = arguments[e];
              for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
            }
            return n;
          }),
      RE.apply(this, arguments)
    );
  }
  var OY = function () {
      var e = !1,
        t = [],
        i = function () {
          if (!e) {
            e = !0;
            for (var o = 0, l = t.length; o < l; o++) t[o]();
          }
        },
        r = function (o) {
          if (!e) {
            t.push(o);
            return;
          }
          o();
        },
        s = {
          resolved: function () {
            return e;
          },
          resolve: i,
          promise: { then: r },
        };
      return s;
    },
    SO = Object.prototype.hasOwnProperty;
  function NY() {
    var n = OY();
    return {
      notify: function () {
        n.resolve();
      },
      wait: function () {
        return n.promise;
      },
      render: function (t, i, r) {
        this.wait().then(function () {
          r(window.grecaptcha.render(t, i));
        });
      },
      reset: function (t) {
        typeof t != "undefined" &&
          (this.assertLoaded(),
          this.wait().then(function () {
            return window.grecaptcha.reset(t);
          }));
      },
      execute: function (t) {
        typeof t != "undefined" &&
          (this.assertLoaded(),
          this.wait().then(function () {
            return window.grecaptcha.execute(t);
          }));
      },
      checkRecaptchaLoad: function () {
        SO.call(window, "grecaptcha") &&
          SO.call(window.grecaptcha, "render") &&
          this.notify();
      },
      assertLoaded: function () {
        if (!n.resolved()) throw new Error("ReCAPTCHA has not been loaded");
      },
    };
  }
  var Uf = NY();
  typeof window != "undefined" && (window.vueRecaptchaApiLoaded = Uf.notify);
  var wO = (0, an.defineComponent)({
    name: "VueRecaptcha",
    props: {
      sitekey: { type: String, required: !0 },
      theme: { type: String },
      badge: { type: String },
      type: { type: String },
      size: { type: String },
      tabindex: { type: String },
      loadRecaptchaScript: { type: Boolean, default: !0 },
      recaptchaScriptId: { type: String, default: "__RECAPTCHA_SCRIPT" },
      recaptchaHost: { type: String, default: "www.google.com" },
      language: { type: String, default: "" },
    },
    emits: ["render", "verify", "expired", "error"],
    setup: function (e, t) {
      var i = t.slots,
        r = t.emit,
        s = (0, an.ref)(null),
        a = (0, an.ref)(null),
        o = function (f) {
          r("verify", f);
        },
        l = function () {
          r("expired");
        },
        c = function () {
          r("error");
        };
      return (
        (0, an.onMounted)(function () {
          if (
            (Uf.checkRecaptchaLoad(),
            e.loadRecaptchaScript &&
              !document.getElementById(e.recaptchaScriptId))
          ) {
            var u = document.createElement("script");
            (u.id = e.recaptchaScriptId),
              (u.src =
                "https://" +
                e.recaptchaHost +
                "/recaptcha/api.js?onload=vueRecaptchaApiLoaded&render=explicit&hl=" +
                e.language),
              (u.async = !0),
              (u.defer = !0),
              document.head.appendChild(u);
          }
          var f = RE({}, e, {
              callback: o,
              "expired-callback": l,
              "error-callback": c,
            }),
            d = s.value,
            m = i.default ? d.children[0] : d;
          Uf.render(m, f, function (x) {
            (a.value = x), r("render", x);
          });
        }),
        {
          root: s,
          widgetId: a,
          reset: function () {
            Uf.reset(a.value);
          },
          execute: function () {
            Uf.execute(a.value);
          },
        }
      );
    },
    render: function () {
      var e = this.$slots.default,
        t;
      return (
        typeof e == "function" ? (t = e()) : (t = e),
        (0, an.h)("div", { ref: "root" }, t)
      );
    },
  });
  var kY = MO.default.default(AO.default, CO.default),
    PO = {
      delimiters: ["{(", ")}"],
      components: { FilePond: kY, VueRecaptcha: wO },
      data() {
        return {
          lisaUserData: Lr,
          endpoints: { goal: "/api/" },
          loading: !1,
          errors: [],
        };
      },
      methods: {
        onCaptchaVerified: function (n) {
          this.formData.append("g-recaptcha-response", n),
            this.sendData(),
            this.$refs.recaptcha.reset();
        },
        onCaptchaExpired: function () {
          this.$refs.recaptcha.reset();
        },
        submit(n) {
          (this.formAction = this.getEndpoint(this.lisaUserData.goal.value)),
            (this.formData = new FormData(n.target)),
            (this.loading = !0),
            this.$refs.recaptcha.execute();
        },
        getEndpoint(n) {
          switch (n) {
            case "rfp":
              return "/api/rfp-enquiries";
            case "job":
              return "/api/job-enquiries";
            case "internship":
              return "/api/internship-enquiries";
            case "quickwork":
            default:
              return "/api/general-enquiries";
          }
        },
        sendData() {
          this.errors = [];
          let n = {};
          this.formData.forEach((e, t) => {
            n[t] ? (n[t] += "|" + e) : (n[t] = e);
          }),
            (this.formDataJSON = JSON.stringify(n)),
            fetch(this.formAction, {
              body: this.formDataJSON,
              method: "POST",
              headers: { "Content-Type": "application/json" },
            })
              .then((e) => e.json())
              .then((e) => {
                var t, i;
                e.success
                  ? ((i = this.$refs.recaptcha) == null || i.reset(),
                    window.gtag &&
                      gtag("event", "submit_form", {
                        event_category: "lisa",
                        event_label: this.formAction,
                      }),
                    this.$emit("success"))
                  : (console.error(e.message),
                    this.errors.push(e.message),
                    (t = this.$refs.recaptcha) == null || t.reset());
              })
              .catch(() => {})
              .finally(() => {
                this.loading = !1;
              });
        },
      },
    };
  var DO = {
    data() {
      return {
        position: { x: 0, y: 0 },
        speed: {
          x: Math.random() < 0.5 ? -2 : 2,
          y: Math.random() < 0.5 ? -2 : 2,
        },
        boundings: null,
        labelBoundings: null,
      };
    },
    mounted() {
      this.setBoundings(),
        this.render(),
        window.addEventListener("resize", this.setBoundings);
    },
    methods: {
      setBoundings() {
        yt.set(this.$refs.label, { clearProps: "all" }),
          (this.boundings = this.$el.getBoundingClientRect()),
          (this.labelBoundings = this.$refs.label.getBoundingClientRect());
      },
      render() {
        (this.position.x += this.speed.x),
          (this.position.y += this.speed.y),
          this.labelBoundings.left + this.position.x < 0 &&
            this.speed.x < 0 &&
            (this.speed.x *= -1),
          this.labelBoundings.right -
            this.labelBoundings.width -
            this.position.x <
            0 &&
            this.speed.x > 0 &&
            (this.speed.x *= -1),
          this.labelBoundings.top + this.position.y < this.boundings.top &&
            this.speed.y < 0 &&
            (this.speed.y *= -1),
          this.labelBoundings.bottom -
            this.labelBoundings.height -
            this.position.y <
            this.boundings.top &&
            this.speed.y > 0 &&
            (this.speed.y *= -1),
          yt.set(this.$refs.label, {
            x: this.position.x,
            y: this.position.y,
            force3D: !0,
          }),
          (this.raf = requestAnimationFrame(this.render));
      },
    },
    unmounted() {
      cancelAnimationFrame(this.raf),
        window.removeEventListener("resize", this.setBoundings);
    },
    template: `
        <div class="c-lisa_disclaimer">
            <div ref="label"><span class="c-lisa_disclaimer_click-cta">CLICK</span> ANYWHERE TO INITIATE <br>[<span class="c-lisa_disclaimer_procedure">CONTACT PROCEDURE</span>]</div>
        </div>
    `,
  };
  var Tg = bn(FO(), 1),
    Eg = (0, Tg.default)({
      colormap: [
        { index: 0, rgb: [49, 46, 251] },
        { index: 0.4, rgb: [49, 46, 251] },
        { index: 0.5, rgb: [255, 255, 255] },
        { index: 1, rgb: [255, 255, 255] },
      ],
      nshades: 255,
      format: "rgba",
    }),
    BO = {
      delimiters: ["{(", ")}"],
      data() {
        return { fpsCap: 30 };
      },
      mounted() {
        (this.audio = this.$parent.$refs.audio),
          (this.audioCtx = new AudioContext()),
          (this.analyser = this.audioCtx.createAnalyser()),
          (this.stream = this.audioCtx.createMediaElementSource(this.audio)),
          (this.analyser.fftSize = 2048),
          (this.frequencyData = new Uint8Array(
            this.analyser.frequencyBinCount
          )),
          this.stream.connect(this.analyser),
          this.analyser.connect(this.audioCtx.destination),
          (this.ctx2d = this.$refs.canvas.getContext("2d")),
          this.resize(),
          (this.fpsInterval = 1e3 / this.fpsCap),
          (this.then = window.performance.now()),
          (this.startTime = this.then),
          this.render(),
          window.addEventListener("resize", this.resize);
      },
      unmounted() {
        window.removeEventListener("resize", this.resize),
          cancelAnimationFrame(this.raf),
          this.audioCtx.close();
      },
      methods: {
        resize() {
          this.ctx2d.canvas.width != window.innerWidth &&
            ((this.ctx2d.canvas.width = window.innerWidth),
            (this.ctx2d.canvas.height = Math.ceil(
              (this.analyser.fftSize / 2) * 0.85
            )));
        },
        render(n) {
          if (
            ((this.now = n),
            (this.elapsed = this.now - this.then),
            this.elapsed > this.fpsInterval)
          ) {
            (this.then = this.now - (this.elapsed % this.fpsInterval)),
              this.analyser.getByteFrequencyData(this.frequencyData);
            let e = 4,
              t = this.ctx2d.canvas.width,
              i = this.ctx2d.canvas.height,
              r = this.ctx2d.getImageData(e, 0, t / 2, i);
            (rightData = this.ctx2d.getImageData(t / 2, 0, t / 2 - e, i)),
              this.ctx2d.clearRect(0, 0, t, i),
              this.ctx2d.putImageData(r, 0, 0),
              this.ctx2d.putImageData(rightData, t / 2 + e, 0),
              this.ctx2d.clearRect(t / 2 - e / 2, 0, e, i);
            let s = t / 2;
            for (let a = 0; a < this.frequencyData.length; a++) {
              let o =
                Eg[this.frequencyData[i - a]] || Eg[Tg.default.length - 1];
              (this.ctx2d.fillStyle = `rgba(${o[0]},${o[1]},${o[2]},${ty(
                this.frequencyData[i - a],
                0,
                256,
                0,
                1
              )})`),
                this.ctx2d.fillRect(s, a - i / 2, e / 2, 1),
                (o = Eg[this.frequencyData[a]] || Eg[Tg.default.length - 1]),
                (this.ctx2d.fillStyle = `rgba(${o[0]},${o[1]},${o[2]},${ty(
                  this.frequencyData[a],
                  0,
                  256,
                  0,
                  1
                )})`),
                this.ctx2d.fillRect(s, a + i / 2, e / 2, 1);
            }
          }
          this.raf = requestAnimationFrame(this.render);
        },
      },
      template: `
        <div class="c-lisa_visualizer">
            <canvas ref="canvas"></canvas>
        </div>
    `,
    };
  var zO = bn(Yu(), 1),
    Lr = (0, ji.reactive)({}),
    Ia = (0, ji.reactive)({}),
    OE = class extends St {
      constructor(n) {
        super(n);
      }
      init() {
        let n = this;
        fetch("/api/weather-forecast")
          .then((e) => e.json())
          .then((e) => {
            Object.assign(Ia, e);
          }),
          (this.app = (0, Ir.createApp)({
            delimiters: ["{(", ")}"],
            components: {
              LisaVisualizer: BO,
              LisaDisclaimer: DO,
              LisaStep: s0(Ki({}, hO), {
                components: {
                  LisaDialog: fO,
                  LisaForm: s0(Ki({}, PO), {
                    template: document.getElementById("lisa-template-form"),
                  }),
                },
                template: document.getElementById("lisa-template-step"),
              }),
            },
            data() {
              return {
                showDebug: !1,
                showAudioDisclaimer: !0,
                muted: !1,
                speaking: !1,
                stepIntroDone: !1,
                lisaContent: JSON.parse(n.getData("content")),
                lisaWeatherContext: Ia,
                lisaUserData: Lr,
                currentStepSlug: "intro",
                history: [],
              };
            },
            mounted() {
              localStorage.getItem("lisa-muted") == "true" && (this.muted = !0),
                !this.muted && this.$refs.audio
                  ? this.$refs.audio
                      .play()
                      .then(() => {
                        this.showAudioDisclaimer = !1;
                      })
                      .catch((s) => {
                        console.error(s), (this.showAudioDisclaimer = !0);
                      })
                  : (this.showAudioDisclaimer = !1),
                this.history.push(this.currentStepSlug);
              let t = location.hash.substring(1),
                i = {
                  rfp: "project",
                  job: "team",
                  internship: "reference",
                  "quick-word": "reference",
                },
                r = [];
              i[t] && ((Lr.goal = t), (this.introNextStep = i[t])),
                n.el.addEventListener("click", this.skip);
            },
            computed: {
              currentStep() {
                return this.lisaContent[this.currentStepSlug];
              },
              canGoBack() {
                return (
                  this.history.length > 2 &&
                  this.currentStepSlug != "confirmation"
                );
              },
              showStepContent() {
                return (
                  ((!this.muted && !this.speaking) || this.muted) &&
                  this.stepIntroDone
                );
              },
              progress() {
                return this.currentStep.progress || 0;
              },
            },
            methods: {
              next() {
                let e = this.currentStep.next;
                this.currentStepSlug == "intro" &&
                  this.introNextStep &&
                  (this.history.push("greeting"),
                  (e = this.introNextStep),
                  (this.introNextStep = null),
                  history.pushState(
                    "",
                    document.title,
                    window.location.pathname + window.location.search
                  )),
                  e && this.goToStep(e);
              },
              back() {
                this.history.length != 1 &&
                  requestAnimationFrame(() => {
                    this.history.pop(), this.goToStep(this.history.pop());
                  });
              },
              goToStep(e) {
                if (!this.lisaContent[e]) throw "Step does not exist";
                (this.currentStepSlug = e),
                  this.history.push(this.currentStepSlug);
              },
              navigateTo(e) {
                zO.default.go(e);
              },
              playAudio(e) {
                this.$refs.visualizer.audioCtx.resume(),
                  e && (this.$refs.audio.src = e),
                  (this.$refs.audio.currentTime = 0),
                  this.$refs.audio.play();
              },
              skip(e) {
                if (e.target == this.$refs.backbtn) {
                  this.speaking &&
                    ((this.stepIntroDone = !1), this.$refs.audio.pause());
                  return;
                } else
                  this.showAudioDisclaimer
                    ? this.acceptAudio()
                    : this.speaking &&
                      (this.$refs.audio.pause(),
                      this.$refs.step.skip(),
                      (this.stepIntroDone = !0));
              },
              sentenceEnded() {
                this.speaking = !1;
              },
              updateStepIntro(e) {
                this.stepIntroDone = e;
              },
              acceptAudio() {
                requestAnimationFrame(() => {
                  var e, t, i;
                  (i =
                    (t =
                      (e = this.$refs.visualizer) == null
                        ? void 0
                        : e.audioCtx) == null
                      ? void 0
                      : t.resume) == null || i.call(t),
                    (this.showAudioDisclaimer = !1),
                    (this.muted = !1),
                    this.playAudio();
                });
              },
              muteToggle() {
                (this.muted = !this.muted),
                  (this.$refs.audio.muted = this.muted),
                  this.muted && this.$refs.audio.pause();
              },
            },
            watch: {
              muted() {
                localStorage.setItem("lisa-muted", this.muted);
              },
              currentStepSlug() {
                if (
                  ((this.stepIntroDone = !1),
                  setTimeout(() => {
                    document.documentElement.scrollTop = 0;
                  }, 300),
                  this.currentStepSlug == "greeting")
                ) {
                  for (let e in Lr) delete Lr[e];
                  this.history.splice(this.history.indexOf("greeting") + 1);
                }
                this.currentStepSlug == "greeting" ||
                this.currentStepSlug == "confirmation"
                  ? (window.confirmPageChange = !1)
                  : requestAnimationFrame(() => {
                      window.confirmPageChange = {
                        message: n.getData("confirm-quit-label"),
                      };
                    });
              },
              showStepContent() {
                this.muted && this.sentenceEnded(),
                  this.currentStep.next && this.next();
              },
            },
          })),
          this.app.mount(this.el);
      }
      destroy() {
        (window.confirmPageChange = !1), this.app && this.app.unmount();
      }
    };
  var La = class extends St {
    constructor(n) {
      super(n);
      (this.canvas = this.el),
        (this.autoplayAnimations = !0),
        (this.defaultAnimation = !1),
        (this.currentModel = this.getData("file") ? this.getData("file") : !1),
        this.resize(),
        (this.resizeBind = this.resize.bind(this)),
        window.addEventListener("resize", this.resizeBind);
    }
    init() {
      !oc ||
        (this.initRenderer(),
        this.initScene(),
        this.initLoaders(),
        this.render(),
        this.currentModel && this.loadModel());
    }
    initRenderer() {
      (this.renderer = new xh({
        canvas: this.canvas,
        alpha: !0,
        antialias: !0,
        preserveDrawingBuffer: !0,
      })),
        (this.renderer.shadowMap.enabled = !0),
        (this.renderer.shadowMap.type = yh),
        (this.renderer.outputEncoding = oi),
        this.renderer.setSize(this.sizes.width, this.sizes.height),
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
        (this.clock = new Ch()),
        (this.previousTime = 0);
    }
    initScene() {
      this.scene = new bh();
      let n = new Ah(16777215, 2);
      this.scene.add(n),
        (this.camera = new yn(
          30,
          this.sizes.width / this.sizes.height,
          0.01,
          100
        )),
        this.camera.position.set(1, 1, 1),
        this.scene.add(this.camera),
        (this.controls = new Lh(this.camera, this.canvas)),
        this.controls.target.set(0, 0.25, 0),
        (this.controls.enableDamping = !0),
        (this.wrapper = new br()),
        this.wrapper.position.set(0, 0, 0),
        this.scene.add(this.wrapper);
    }
    initLoaders() {
      (this.supportsQuickLook = !1),
        document.createElement("a").relList.supports("ar") &&
          (this.supportsQuickLook = !0);
    }
    resize() {
      (this.BCR = this.el.getBoundingClientRect()),
        (this.sizes = { width: this.BCR.width, height: this.BCR.height }),
        this.renderer &&
          this.renderer.setSize(this.sizes.width, this.sizes.height),
        this.camera &&
          ((this.camera.aspect = this.sizes.width / this.sizes.height),
          this.camera.updateProjectionMatrix()),
        this.renderer &&
          (this.renderer.setSize(this.sizes.width, this.sizes.height),
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)));
    }
    render() {
      let n = this.clock.getElapsedTime();
      (this.deltaTime = n - this.previousTime),
        (this.previousTime = n),
        this.controls.update(),
        this.renderer.render(this.scene, this.camera),
        this.currentModel &&
          Dt[this.currentModel] &&
          Dt[this.currentModel].mixer &&
          Dt[this.currentModel].mixer.setTime(n),
        (this.raf = window.requestAnimationFrame(this.render.bind(this)));
    }
    loadModel(n = this.currentModel) {
      return new Promise((e, t) => {
        if (!Dt[n])
          Dt[n] = { glb: null, usdz: null, isLoaded: !1, onLoad: () => {} };
        else {
          e();
          return;
        }
        Ih.load(n, (i) => {
          if (((Dt[n].glb = i), (Dt[n].isLoaded = !0), i.animations.length)) {
            (Dt[n].mixer = new Bc(i.scene)),
              i.scene.traverse(function (r) {
                r.frustumCulled = !1;
              }),
              (Dt[n].animations = []);
            for (let r = 0; r < i.animations.length; r++) {
              let s = i.animations[r].name;
              Dt[n].animations[i.animations[r].name] && (s += r),
                (Dt[n].animations[s] = Dt[n].mixer.clipAction(i.animations[r]));
            }
          }
          i.scene.scale.set(1, 1, 1),
            (i.scene.visible = n === this.currentModel),
            this.wrapper.add(i.scene),
            Dt[n].onLoad(),
            e();
        });
      });
    }
    setModel(n) {
      if (!oc) return;
      window.cancelAnimationFrame(this.raf),
        this.wrapper.clear(),
        this.el.dispatchEvent(new CustomEvent("hideUsdz")),
        (this.currentModel = n);
      let e,
        t = () => {
          if (this.currentModel === n) {
            for (let r of Object.keys(Dt[this.currentModel].animations))
              Dt[n].animations[r].isRunning() && (e = r),
                Dt[n].animations[r].stop();
            if (this.autoplayAnimations)
              if (
                this.defaultAnimation &&
                Dt[n].animations[this.defaultAnimation]
              )
                Dt[n].animations[this.defaultAnimation].play();
              else {
                let r;
                for (; !r || r == e; )
                  r = Object.keys(Dt[n].animations)[
                    Math.floor(
                      Math.random() * Object.keys(Dt[n].animations).length
                    )
                  ];
                Dt[n].animations[r].play();
              }
          }
        },
        i = () => {
          this.currentModel === n &&
            (t(),
            (Dt[n].glb.scene.visible = !0),
            this.supportsQuickLook &&
              Dt[n].usdz &&
              this.el.dispatchEvent(
                new CustomEvent("usdzReady", { detail: { usdz: Dt[n].usdz } })
              ),
            this.render());
        };
      if (this.currentModel == !1) {
        this.render();
        return;
      } else
        Dt[n]
          ? Dt[n].isLoaded
            ? (this.wrapper.children.includes(Dt[n].glb.scene) ||
                this.wrapper.add(Dt[n].glb.scene),
              i())
            : (Dt[n].onLoad = () => {
                this.wrapper.children.includes(Dt[n].glb.scene) ||
                  this.wrapper.add(Dt[n].glb.scene),
                  i();
              })
          : (this.loadModel(n), (Dt[n].onLoad = i));
    }
    destroy() {
      window.removeEventListener("resize", this.resizeBind),
        window.cancelAnimationFrame(this.raf),
        (this.scene = this.renderer = null);
    }
  };
  var NE = class extends St {
    constructor(n) {
      super(n);
      (this.formSuccessMessage = this.getData("success")),
        (this.formErrorMessage = this.getData("error")),
        (this.$form = this.$("form")[0]),
        (this.$input = this.$("input")[0]),
        (this.$feedback = this.$("feedback")[0]),
        (this.events = {
          click: { close: "hide" },
          submit: { form: "onSubmit" },
        });
    }
    init() {
      this.focusTrap = ws(this.el, {
        onDeactivate: this.hide.bind(this),
        clickOutsideDeactivates: !0,
        initialFocus: this.$input,
      });
    }
    show() {
      this.el.classList.add("is-opened"),
        this.focusTrap.activate(),
        this.call(
          "scrollTo",
          { target: this.el, options: { offset: -80 } },
          "Scroll"
        );
    }
    hide() {
      this.el.classList.remove("is-opened"),
        this.call("close", null, "NewsletterToggler"),
        this.focusTrap.deactivate(),
        this.$form.reset();
    }
    onSubmit(n) {
      n.preventDefault(),
        this.clearStates(),
        this.$form.classList.add("is-loading");
      let e = n.target,
        t = e.action,
        i = {};
      new FormData(e).forEach((a, o) => (i[o] = a));
      let s = JSON.stringify(i);
      fetch(t, {
        body: s,
        method: "POST",
        headers: { "Content-Type": "application/json" },
      })
        .then(
          (a) => (
            a.status !== 200 &&
              a.status !== 202 &&
              (this.$form.classList.add("is-error"),
              (this.$feedback.innerHTML = this.formErrorMessage)),
            a.json()
          )
        )
        .then((a) => {
          a.success
            ? (this.$form.classList.add("is-success"),
              a.message
                ? (this.$feedback.innerHTML = a.message)
                : (this.$feedback.innerHTML = this.formSuccessMessage),
              setTimeout(() => {
                this.hide();
              }, 3e3))
            : (this.$form.classList.add("is-error"),
              (this.$feedback.innerHTML = this.formErrorMessage));
        })
        .catch(() => {})
        .finally(() => {
          this.$form.classList.remove("is-loading");
        });
    }
    clearStates() {
      this.$form.classList.remove("is-loading", "is-error", "is-success"),
        (this.$feedback.innerHTML = "");
    }
    destroy() {
      super.destroy(), this.focusTrap.deactivate();
    }
  };
  var kE = class extends St {
    constructor(n) {
      super(n);
      this.events = { click: "onClick" };
    }
    init() {}
    onClick(n) {
      this.show();
    }
    show() {
      this.el.setAttribute("aria-expanded", "true"),
        this.call("show", null, "NewsletterModal");
    }
    close() {
      this.el.setAttribute("aria-expanded", "false");
    }
  };
  var UO = 1,
    FE = class extends St {
      constructor(n) {
        super(n);
      }
      init() {
        (this.delta = UO),
          (this.reversed = this.getData("reversed") != null),
          (this.viewportSensitive = this.getData("viewport-sensitive") != null),
          (this.originalHTML = this.el.innerHTML),
          this.compute(),
          (this.renderBind = this.render.bind(this)),
          this.viewportSensitive || this.render(),
          (this.checkResizeBind = this.checkResize.bind(this)),
          window.addEventListener("resize", this.checkResizeBind);
      }
      checkResize() {
        this.resizeTick ||
          ((this.resizeTick = !0),
          requestAnimationFrame(() => {
            this.viewportWidth != window.innerWidth && this.compute(),
              (this.resizeTick = !1);
          }));
      }
      compute() {
        if (
          ((this.el.innerHTML = this.originalHTML),
          (this.viewportWidth = window.innerWidth),
          (this.$outer = this.$("outer")[0]),
          (this.contentWidth =
            this.$outer.children[0].getBoundingClientRect().width),
          !this.contentWidth)
        )
          return console.error("[Rail] content is empty"), !1;
        if (this.contentWidth < this.viewportWidth) {
          let n = Math.floor(this.viewportWidth / this.contentWidth);
          for (let e = 0; e <= n; e++) {
            let t = this.$outer.children[0].cloneNode(!0);
            this.$outer.appendChild(t);
          }
        }
        this.el.appendChild(this.$outer.cloneNode(!0)),
          (this.currentOffset = 0),
          (this.$outer = this.$("outer")),
          this.call("update", null, "Scroll");
      }
      render() {
        window.scroll.velocity &&
          ((this.delta = UO * (window.scroll.velocity > 0 ? 1 : -1)),
          (this.delta += window.scroll.velocity * 0.2),
          this.reversed && (this.delta *= -1)),
          (this.currentOffset += this.delta),
          this.delta > 0
            ? this.currentOffset >= 0 &&
              (this.currentOffset -= this.contentWidth)
            : this.currentOffset < -this.contentWidth &&
              (this.currentOffset += this.contentWidth),
          yt.set(this.$outer, { x: this.currentOffset, force3D: !0 });
      }
      inview(n) {
        let { target: e, way: t } = n;
        e == this.el &&
          (!this.active && t == "enter"
            ? (yt.ticker.add(this.renderBind), (this.active = !0))
            : this.active &&
              t == "leave" &&
              (yt.ticker.remove(this.renderBind), (this.active = !1)));
      }
      destroy() {
        yt.ticker.remove(this.renderBind),
          window.removeEventListener("resize", this.checkResizeBind);
      }
    };
  var $O = bn(VO(), 1),
    WO = bn(GO(), 1);
  function Vf() {
    return (
      (Vf = Object.assign
        ? Object.assign.bind()
        : function (n) {
            for (var e = 1; e < arguments.length; e++) {
              var t = arguments[e];
              for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
            }
            return n;
          }),
      Vf.apply(this, arguments)
    );
  }
  function HO(n, e) {
    let t = n % e;
    return ((e > 0 && t < 0) || (e < 0 && t > 0)) && (t += e), t;
  }
  var GY = ["duration", "easing"],
    qO = class {
      to(e, t = {}) {
        let { duration: i = 1, easing: r = (a) => a } = t,
          s = (function (a, o) {
            if (a == null) return {};
            var l,
              c,
              u = {},
              f = Object.keys(a);
            for (c = 0; c < f.length; c++)
              o.indexOf((l = f[c])) >= 0 || (u[l] = a[l]);
            return u;
          })(t, GY);
        (this.target = e),
          (this.fromKeys = Vf({}, s)),
          (this.toKeys = Vf({}, s)),
          (this.keys = Object.keys(Vf({}, s))),
          this.keys.forEach((a) => {
            this.fromKeys[a] = e[a];
          }),
          (this.duration = i),
          (this.easing = r),
          (this.currentTime = 0),
          (this.isRunning = !0);
      }
      stop() {
        this.isRunning = !1;
      }
      raf(e) {
        if (!this.isRunning) return;
        this.currentTime = Math.min(this.currentTime + e, this.duration);
        let t = this.progress >= 1 ? 1 : this.easing(this.progress);
        this.keys.forEach((i) => {
          let r = this.fromKeys[i];
          this.target[i] = r + (this.toKeys[i] - r) * t;
        }),
          t === 1 && this.stop();
      }
      get progress() {
        return this.currentTime / this.duration;
      }
    },
    GE = class extends $O.TinyEmitter {
      constructor({
        duration: e = 1.2,
        easing: t = (d) => Math.min(1, 1.001 - Math.pow(2, -10 * d)),
        smooth: i = !0,
        mouseMultiplier: r = 1,
        smoothTouch: s = !1,
        touchMultiplier: a = 2,
        direction: o = "vertical",
        gestureDirection: l = "vertical",
        infinite: c = !1,
        wrapper: u = window,
        content: f = document.body,
      } = {}) {
        var d, m, x;
        super(),
          (this.onWindowResize = () => {
            (this.wrapperWidth = window.innerWidth),
              (this.wrapperHeight = window.innerHeight);
          }),
          (this.onWrapperResize = ([g]) => {
            if (g) {
              let b = g.contentRect;
              (this.wrapperWidth = b.width), (this.wrapperHeight = b.height);
            }
          }),
          (this.onContentResize = ([g]) => {
            if (g) {
              let b = g.contentRect;
              (this.contentWidth = b.width), (this.contentHeight = b.height);
            }
          }),
          (this.onVirtualScroll = ({
            deltaY: g,
            deltaX: b,
            originalEvent: _,
          }) => {
            if (
              (this.gestureDirection === "vertical" && g === 0) ||
              (this.gestureDirection === "horizontal" && b === 0)
            )
              return;
            let E = !!_.composedPath().find(
              (P) => P.hasAttribute && P.hasAttribute("data-lenis-prevent")
            );
            if (_.ctrlKey || E) return;
            if (
              ((this.smooth = _.changedTouches
                ? this.smoothTouch
                : this.options.smooth),
              this.stopped)
            )
              return void _.preventDefault();
            if (!this.smooth || _.buttons === 4) return;
            this.smooth && _.preventDefault();
            let w = 0;
            (w =
              this.gestureDirection === "both"
                ? b + g
                : this.gestureDirection === "horizontal"
                ? b
                : g),
              (this.targetScroll -= w),
              this.scrollTo(this.targetScroll);
          }),
          (this.onScroll = (g) => {
            (this.isScrolling && this.smooth) ||
              ((this.targetScroll =
                this.scroll =
                this.lastScroll =
                  this.wrapperNode[this.scrollProperty]),
              this.notify());
          }),
          (window.lenisVersion = "0.2.28"),
          (this.options = {
            duration: e,
            easing: t,
            smooth: i,
            mouseMultiplier: r,
            smoothTouch: s,
            touchMultiplier: a,
            direction: o,
            gestureDirection: l,
            infinite: c,
            wrapper: u,
            content: f,
          }),
          (this.duration = e),
          (this.easing = t),
          (this.smooth = i),
          (this.mouseMultiplier = r),
          (this.smoothTouch = s),
          (this.touchMultiplier = a),
          (this.direction = o),
          (this.gestureDirection = l),
          (this.infinite = c),
          (this.wrapperNode = u),
          (this.contentNode = f),
          this.wrapperNode.addEventListener("scroll", this.onScroll),
          this.wrapperNode === window
            ? (this.wrapperNode.addEventListener("resize", this.onWindowResize),
              this.onWindowResize())
            : ((this.wrapperHeight = this.wrapperNode.offsetHeight),
              (this.wrapperWidth = this.wrapperNode.offsetWidth),
              (this.wrapperObserver = new ResizeObserver(this.onWrapperResize)),
              this.wrapperObserver.observe(this.wrapperNode)),
          (this.contentHeight = this.contentNode.offsetHeight),
          (this.contentWidth = this.contentNode.offsetWidth),
          (this.contentObserver = new ResizeObserver(this.onContentResize)),
          this.contentObserver.observe(this.contentNode),
          (this.targetScroll =
            this.scroll =
            this.lastScroll =
              this.wrapperNode[this.scrollProperty]),
          (this.animate = new qO());
        let y =
          ((d = navigator) == null || (m = d.userAgentData) == null
            ? void 0
            : m.platform) ||
          ((x = navigator) == null ? void 0 : x.platform) ||
          "unknown";
        (this.virtualScroll = new WO.default({
          el: this.wrapperNode,
          firefoxMultiplier: 50,
          mouseMultiplier:
            this.mouseMultiplier *
            (y.includes("Win") || y.includes("Linux") ? 0.84 : 0.4),
          touchMultiplier: this.touchMultiplier,
          passive: !1,
          useKeyboard: !1,
          useTouch: !0,
        })),
          this.virtualScroll.on(this.onVirtualScroll);
      }
      get scrollProperty() {
        let e;
        return (
          (e =
            this.wrapperNode === window
              ? this.direction === "horizontal"
                ? "scrollX"
                : "scrollY"
              : this.direction === "horizontal"
              ? "scrollLeft"
              : "scrollTop"),
          e
        );
      }
      start() {
        let e = this.wrapperNode;
        this.wrapperNode === window && (e = document.documentElement),
          e.classList.remove("lenis-stopped"),
          (this.stopped = !1);
      }
      stop() {
        let e = this.wrapperNode;
        this.wrapperNode === window && (e = document.documentElement),
          e.classList.add("lenis-stopped"),
          (this.stopped = !0),
          this.animate.stop();
      }
      destroy() {
        var e;
        this.wrapperNode === window &&
          this.wrapperNode.removeEventListener("resize", this.onWindowResize),
          this.wrapperNode.removeEventListener("scroll", this.onScroll),
          this.virtualScroll.destroy(),
          (e = this.wrapperObserver) == null || e.disconnect(),
          this.contentObserver.disconnect();
      }
      get limit() {
        return this.direction === "horizontal"
          ? this.contentWidth - this.wrapperWidth
          : this.contentHeight - this.wrapperHeight;
      }
      raf(e) {
        let t = e - (this.now || 0);
        (this.now = e),
          !this.stopped &&
            this.smooth &&
            ((this.lastScroll = this.scroll),
            this.animate.raf(0.001 * t),
            this.scroll === this.targetScroll &&
              (this.lastScroll = this.scroll),
            this.isScrolling && (this.setScroll(this.scroll), this.notify()),
            (this.isScrolling = this.scroll !== this.targetScroll));
      }
      get velocity() {
        return this.scroll - this.lastScroll;
      }
      setScroll(e) {
        let t = this.infinite ? HO(e, this.limit) : e;
        this.direction === "horizontal"
          ? this.wrapperNode.scrollTo(t, 0)
          : this.wrapperNode.scrollTo(0, t);
      }
      notify() {
        let e = this.infinite ? HO(this.scroll, this.limit) : this.scroll;
        this.emit("scroll", {
          scroll: e,
          limit: this.limit,
          velocity: this.velocity,
          direction: this.velocity === 0 ? 0 : this.velocity > 0 ? 1 : -1,
          progress: e / this.limit,
        });
      }
      scrollTo(
        e,
        {
          offset: t = 0,
          immediate: i = !1,
          duration: r = this.duration,
          easing: s = this.easing,
        } = {}
      ) {
        if (e == null || this.stopped) return;
        let a;
        if (typeof e == "number") a = e;
        else if (e === "top" || e === "#top") a = 0;
        else if (e === "bottom") a = this.limit;
        else {
          let o;
          if (typeof e == "string") o = document.querySelector(e);
          else {
            if (e == null || !e.nodeType) return;
            o = e;
          }
          if (!o) return;
          let l = 0;
          if (this.wrapperNode !== window) {
            let u = this.wrapperNode.getBoundingClientRect();
            l = this.direction === "horizontal" ? u.left : u.top;
          }
          let c = o.getBoundingClientRect();
          a =
            (this.direction === "horizontal" ? c.left : c.top) +
            this.scroll -
            l;
        }
        (a += t),
          (this.targetScroll = this.infinite
            ? a
            : Math.max(0, Math.min(a, this.limit))),
          !this.smooth || i
            ? (this.animate.stop(),
              (this.scroll = this.lastScroll = this.targetScroll),
              this.setScroll(this.targetScroll))
            : this.animate.to(this, {
                duration: r,
                easing: s,
                scroll: this.targetScroll,
              });
      }
    };
  var Gf = class {
    constructor({
      scrollElements: e,
      rootMargin: t = "-1px -1px -1px -1px",
      IORaf: i,
    }) {
      (this.scrollElements = e),
        (this.rootMargin = t),
        (this.IORaf = i),
        (this.isFirstObserve = !0),
        this._init();
    }
    _init() {
      let e = { rootMargin: this.rootMargin },
        t = (i) => {
          i.forEach((r) => {
            r.isIntersecting
              ? this._setInview(r)
              : this.isFirstObserve || this._setOutOfView(r);
          }),
            (this.isFirstObserve = !1);
        };
      this.observer = new IntersectionObserver(t, e);
      for (let i of this.scrollElements) {
        let r = i.$el;
        this.observe(r);
      }
    }
    destroy() {
      this.observer.disconnect();
    }
    observe(e) {
      !e || this.observer.observe(e);
    }
    unobserve(e) {
      !e || this.observer.unobserve(e);
    }
    _setInview(e) {
      let t = this.scrollElements.find((i) => i.$el === e.target);
      this.IORaf && (t == null || t.setInteractivityOn()),
        !this.IORaf && (t == null || t.setInview());
    }
    _setOutOfView(e) {
      let t = this.scrollElements.find((i) => i.$el === e.target);
      this.IORaf && (t == null || t.setInteractivityOff()),
        !this.IORaf && (t == null || t.setOutOfView()),
        !(t != null && t.attributes.scrollRepeat) &&
          !this.IORaf &&
          this.unobserve(e.target);
    }
  };
  function jO(n, e, t) {
    return t < n ? n : t > e ? e : t;
  }
  function HY(n, e, t, i, r) {
    let s = e - n,
      a = i - t;
    return t + (((r - n) / s) * a || 0);
  }
  function XO(n, e, t) {
    return HY(n, e, 0, 1, t);
  }
  function HE(n, e) {
    return n.reduce((t, i) => (Math.abs(i - e) < Math.abs(t - e) ? i : t));
  }
  var $Y = "is-inview",
    WY = "--progress",
    qY = "onScrollProgress",
    Sg = class {
      constructor({
        $el: e,
        id: t,
        modularInstance: i,
        subscribeElementUpdateFn: r,
        unsubscribeElementUpdateFn: s,
        needRaf: a,
        scrollDirection: o,
      }) {
        var l, c, u, f, d;
        (this.$el = e),
          (this.id = t),
          (this.needRaf = a),
          (this.scrollDirection = o),
          (this.modularInstance = i),
          (this.subscribeElementUpdateFn = r),
          (this.unsubscribeElementUpdateFn = s),
          (this.attributes = {
            scrollClass:
              (l = this.$el.dataset.scrollClass) !== null && l !== void 0
                ? l
                : $Y,
            scrollOffset:
              (c = this.$el.dataset.scrollOffset) !== null && c !== void 0
                ? c
                : "0,0",
            scrollPosition:
              (u = this.$el.dataset.scrollPosition) !== null && u !== void 0
                ? u
                : "start,end",
            scrollModuleProgress: this.$el.dataset.scrollModuleProgress != null,
            scrollCssProgress: this.$el.dataset.scrollCssProgress != null,
            scrollEventProgress:
              (f = this.$el.dataset.scrollEventProgress) !== null &&
              f !== void 0
                ? f
                : null,
            scrollSpeed:
              this.$el.dataset.scrollSpeed != null
                ? parseFloat(this.$el.dataset.scrollSpeed)
                : null,
            scrollRepeat: this.$el.dataset.scrollRepeat != null,
            scrollCall:
              (d = this.$el.dataset.scrollCall) !== null && d !== void 0
                ? d
                : null,
            scrollIgnoreFold: this.$el.dataset.scrollIgnoreFold != null,
            scrollEnableTouchSpeed:
              this.$el.dataset.scrollEnableTouchSpeed != null,
          }),
          (this.intersection = { start: 0, end: 0 }),
          (this.metrics = { offsetStart: 0, offsetEnd: 0, bcr: {} }),
          (this.currentScroll =
            this.scrollDirection === "vertical"
              ? window.scrollY
              : window.scrollX),
          (this.translateValue = 0),
          (this.lastProgress = null),
          (this.progressModularModules = []),
          (this.isInview = !1),
          (this.isInteractive = !1),
          (this.isInFold = !1),
          (this.isFirstResize = !0),
          this._init();
      }
      _init() {
        !this.needRaf ||
          (this.modularInstance &&
            this.attributes.scrollModuleProgress &&
            this._getProgressModularModules(),
          this._resize());
      }
      onResize({ currentScroll: e }) {
        (this.currentScroll = e), this._resize();
      }
      onRender({ currentScroll: e, smooth: t }) {
        let i =
            this.scrollDirection === "vertical"
              ? window.innerHeight
              : window.innerWidth,
          r =
            this.scrollDirection === "vertical"
              ? this.metrics.bcr.height
              : this.metrics.bcr.width;
        (this.currentScroll = e),
          this._computeProgress(),
          this.attributes.scrollSpeed &&
            !isNaN(this.attributes.scrollSpeed) &&
            (!this.attributes.scrollEnableTouchSpeed && !t
              ? (this.translateValue &&
                  (this.$el.style.transform = "translate3d(0, 0, 0)"),
                (this.translateValue = 0))
              : (this.isInFold
                  ? (this.translateValue = e * this.attributes.scrollSpeed * -1)
                  : (this.translateValue =
                      (e - this.metrics.offsetStart + i * 0.5 - r * 0.5) *
                      this.attributes.scrollSpeed *
                      -1),
                (this.$el.style.transform =
                  this.scrollDirection === "vertical"
                    ? `translate3d(0, ${this.translateValue}px, 0)`
                    : `translate3d(${this.translateValue}px, 0, 0)`)));
      }
      setInview() {
        if (this.isInview) return;
        (this.isInview = !0),
          this.$el.classList.add(this.attributes.scrollClass);
        let e = "enter",
          t = this._getScrollCallFrom();
        this.attributes.scrollCall && this._dispatchCall(e, t);
      }
      setOutOfView() {
        if (!(this.isInview && this.attributes.scrollRepeat)) return;
        (this.isInview = !1),
          this.$el.classList.remove(this.attributes.scrollClass);
        let e = "leave",
          t = this._getScrollCallFrom();
        this.attributes.scrollCall && this._dispatchCall(e, t);
      }
      setInteractivityOn() {
        this.isInteractive ||
          ((this.isInteractive = !0), this.subscribeElementUpdateFn(this));
      }
      setInteractivityOff() {
        !this.isInteractive ||
          ((this.isInteractive = !1),
          this.unsubscribeElementUpdateFn(this),
          this.lastProgress != null &&
            this._computeProgress(HE([0, 1], this.lastProgress)));
      }
      _resize() {
        (this.metrics.bcr = this.$el.getBoundingClientRect()),
          this._computeMetrics(),
          this._computeIntersection(),
          this.isFirstResize &&
            ((this.isFirstResize = !1), this.isInFold && this.setInview());
      }
      _computeMetrics() {
        let { top: e, left: t, height: i, width: r } = this.metrics.bcr,
          s =
            this.scrollDirection === "vertical"
              ? window.innerHeight
              : window.innerWidth,
          a = this.scrollDirection === "vertical" ? e : t,
          o = this.scrollDirection === "vertical" ? i : r;
        (this.metrics.offsetStart =
          this.currentScroll + a - this.translateValue),
          (this.metrics.offsetEnd = this.metrics.offsetStart + o),
          this.metrics.offsetStart < s && !this.attributes.scrollIgnoreFold
            ? (this.isInFold = !0)
            : (this.isInFold = !1);
      }
      _computeIntersection() {
        let e =
            this.scrollDirection === "vertical"
              ? window.innerHeight
              : window.innerWidth,
          t =
            this.scrollDirection === "vertical"
              ? this.metrics.bcr.height
              : this.metrics.bcr.width,
          i = this.attributes.scrollOffset.split(","),
          r = i[0] != null ? i[0].trim() : "0",
          s = i[1] != null ? i[1].trim() : "0",
          a = this.attributes.scrollPosition.split(","),
          o = a[0] != null ? a[0].trim() : "start",
          l = a[1] != null ? a[1].trim() : "end",
          c = r.includes("%")
            ? e * parseInt(r.replace("%", "").trim()) * 0.01
            : parseInt(r),
          u = s.includes("%")
            ? e * parseInt(s.replace("%", "").trim()) * 0.01
            : parseInt(s);
        switch ((this.isInFold && (o = "fold"), o)) {
          case "start":
            this.intersection.start = this.metrics.offsetStart - e + c;
            break;
          case "middle":
            this.intersection.start =
              this.metrics.offsetStart - e + c + t * 0.5;
            break;
          case "end":
            this.intersection.start = this.metrics.offsetStart - e + c + t;
            break;
          case "fold":
            this.intersection.start = 0;
            break;
          default:
            this.intersection.start = this.metrics.offsetStart - e + c;
            break;
        }
        switch (l) {
          case "start":
            this.intersection.end = this.metrics.offsetStart - u;
            break;
          case "middle":
            this.intersection.end = this.metrics.offsetStart - u + t * 0.5;
            break;
          case "end":
            this.intersection.end = this.metrics.offsetStart - u + t;
            break;
          default:
            this.intersection.end = this.metrics.offsetStart - u + t;
            break;
        }
        if (this.intersection.end <= this.intersection.start)
          switch (l) {
            case "start":
              this.intersection.end = this.intersection.start + 1;
              break;
            case "middle":
              this.intersection.end = this.intersection.start + t * 0.5;
              break;
            case "end":
              this.intersection.end = this.intersection.start + t;
              break;
            default:
              this.intersection.end = this.intersection.start + 1;
              break;
          }
      }
      _computeProgress(e) {
        let t =
          e != null
            ? e
            : jO(
                0,
                1,
                XO(
                  this.intersection.start,
                  this.intersection.end,
                  this.currentScroll
                )
              );
        if (t != this.lastProgress) {
          if (
            ((this.lastProgress = t),
            this.attributes.scrollCssProgress && this._setCssProgress(t),
            this.attributes.scrollEventProgress &&
              this._setCustomEventProgress(t),
            this.attributes.scrollModuleProgress)
          )
            for (let i of this.progressModularModules)
              this.modularInstance &&
                this.modularInstance.call(qY, t, i.moduleName, i.moduleId);
          t > 0 && t < 1 && this.setInview(),
            t === 0 && this.setOutOfView(),
            t === 1 && this.setOutOfView();
        }
      }
      _setCssProgress(e = 0) {
        this.$el.style.setProperty(WY, e.toString());
      }
      _setCustomEventProgress(e = 0) {
        let t = this.attributes.scrollEventProgress;
        if (!t) return;
        let i = new CustomEvent(t, {
          detail: { target: this.$el, progress: e },
        });
        window.dispatchEvent(i);
      }
      _getProgressModularModules() {
        if (!this.modularInstance) return;
        let e = Object.keys(this.$el.dataset).filter((i) =>
            i.includes("module")
          ),
          t = Object.entries(this.modularInstance.modules);
        if (!!e.length)
          for (let i of e) {
            let r = this.$el.dataset[i];
            if (!r) return;
            for (let s of t) {
              let [a, o] = s;
              r in o &&
                this.progressModularModules.push({
                  moduleName: a,
                  moduleId: r,
                });
            }
          }
      }
      _getScrollCallFrom() {
        let e = HE(
          [this.intersection.start, this.intersection.end],
          this.currentScroll
        );
        return this.intersection.start === e ? "start" : "end";
      }
      _dispatchCall(e, t) {
        var i;
        let r =
          (i = this.attributes.scrollCall) === null || i === void 0
            ? void 0
            : i.split(",");
        if (r && r.length > 1) {
          let [s, a, o] = r;
          this.modularInstance &&
            this.modularInstance.call(
              s.trim(),
              { target: this.$el, way: e, from: t },
              a.trim(),
              o == null ? void 0 : o.trim()
            );
        } else if (r) {
          let [s] = r,
            a = new CustomEvent(s, {
              detail: { target: this.$el, way: e, from: t },
            });
          window.dispatchEvent(a);
        }
      }
    };
  var jY = [
      "scrollOffset",
      "scrollPosition",
      "scrollModuleProgress",
      "scrollCssProgress",
      "scrollSpeed",
    ],
    XY = "-1px -1px -1px -1px",
    YY = "100% 100% 100% 100%",
    wg = class {
      constructor({
        $el: e,
        modularInstance: t,
        triggerRootMargin: i,
        rafRootMargin: r,
        scrollDirection: s,
      }) {
        if (!e) {
          console.error("Please provide a DOM Element as scrollContainer");
          return;
        }
        (this.$scrollContainer = e),
          (this.modularInstance = t),
          (this.scrollDirection = s),
          (this.triggerRootMargin = i != null ? i : XY),
          (this.rafRootMargin = r != null ? r : YY),
          (this.scrollElements = []),
          (this.triggeredScrollElements = []),
          (this.RAFScrollElements = []),
          (this.scrollElementsToUpdate = []),
          this._init();
      }
      _init() {
        let e = this.$scrollContainer.querySelectorAll("[data-scroll]");
        this._subscribeScrollElements([...e]),
          (this.IOTriggerInstance = new Gf({
            scrollElements: [...this.triggeredScrollElements],
            rootMargin: this.triggerRootMargin,
            IORaf: !1,
          })),
          (this.IORafInstance = new Gf({
            scrollElements: [...this.RAFScrollElements],
            rootMargin: this.rafRootMargin,
            IORaf: !0,
          }));
      }
      destroy() {
        this.IOTriggerInstance.destroy(),
          this.IORafInstance.destroy(),
          this._unsubscribeAllScrollElements();
      }
      onResize({ currentScroll: e }) {
        for (let t of this.RAFScrollElements) t.onResize({ currentScroll: e });
      }
      onRender({ currentScroll: e, smooth: t }) {
        for (let i of this.scrollElementsToUpdate)
          i.onRender({ currentScroll: e, smooth: t });
      }
      update() {
        for (let t of this.triggeredScrollElements)
          this.IOTriggerInstance.unobserve(t.$el);
        for (let t of this.RAFScrollElements)
          this.IORafInstance.unobserve(t.$el);
        this._unsubscribeAllScrollElements();
        let e = this.$scrollContainer.querySelectorAll("[data-scroll]");
        this._subscribeScrollElements([...e]),
          (this.IOTriggerInstance.scrollElements = [
            ...this.triggeredScrollElements,
          ]);
        for (let t of this.triggeredScrollElements)
          this.IOTriggerInstance.observe(t.$el);
        this.IORafInstance.scrollElements = [...this.RAFScrollElements];
        for (let t of this.RAFScrollElements) this.IORafInstance.observe(t.$el);
      }
      _subscribeScrollElements(e) {
        for (let [t, i] of e.entries()) {
          let r = this._checkRafNeeded(i),
            s = new Sg({
              $el: i,
              id: t,
              scrollDirection: this.scrollDirection,
              modularInstance: this.modularInstance,
              subscribeElementUpdateFn: this._subscribeElementUpdate.bind(this),
              unsubscribeElementUpdateFn:
                this._unsubscribeElementUpdate.bind(this),
              needRaf: r,
            });
          this.scrollElements.push(s),
            r
              ? this.RAFScrollElements.push(s)
              : this.triggeredScrollElements.push(s);
        }
      }
      _unsubscribeAllScrollElements() {
        (this.scrollElements = []),
          (this.RAFScrollElements = []),
          (this.triggeredScrollElements = []),
          (this.scrollElementsToUpdate = []);
      }
      _subscribeElementUpdate(e) {
        this.scrollElementsToUpdate.push(e);
      }
      _unsubscribeElementUpdate(e) {
        this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(
          (t) => t.id != e.id
        );
      }
      _checkRafNeeded(e) {
        let t = [...jY],
          i = (r) => {
            t = t.filter((s) => s != r);
          };
        if (e.dataset.scrollOffset) {
          if (
            e.dataset.scrollOffset
              .split(",")
              .map((s) => s.replace("%", "").trim())
              .join(",") != "0,0"
          )
            return !0;
          i("scrollOffset");
        } else i("scrollOffset");
        if (e.dataset.scrollPosition) {
          if (e.dataset.scrollPosition.trim() != "top,bottom") return !0;
          i("scrollPosition");
        } else i("scrollPosition");
        if (e.dataset.scrollSpeed && !isNaN(parseFloat(e.dataset.scrollSpeed)))
          return !0;
        i("scrollSpeed");
        for (let r of t) if (r in e.dataset) return !0;
        return !1;
      }
    };
  var Mg = class {
    constructor({ resizeElements: e, resizeCallback: t = () => {} }) {
      (this.$resizeElements = e),
        (this.resizeCallback = t),
        (this.isFirstObserve = !0),
        this._init();
    }
    _init() {
      let e = (t) => {
        var i;
        !this.isFirstObserve &&
          ((i = this.resizeCallback) === null || i === void 0 || i.call(this)),
          (this.isFirstObserve = !1);
      };
      this.observer = new ResizeObserver(e);
      for (let t of this.$resizeElements) this.observer.observe(t);
    }
    destroy() {
      this.observer.disconnect();
    }
  };
  var YO = {
      duration: 1.2,
      direction: "vertical",
      gestureDirection: "vertical",
      smooth: !0,
      mouseMultiplier: 1,
      smoothTouch: !1,
      touchMultiplier: 2,
      infinite: !1,
      easing: (n) => Math.min(1, 1.001 - Math.pow(2, -10 * n)),
    },
    Ag = class {
      constructor({
        lenisOptions: e = {},
        modularInstance: t,
        triggerRootMargin: i,
        rafRootMargin: r,
        autoResize: s = !0,
        scrollCallback: a = () => {},
        initCustomTicker: o,
        destroyCustomTicker: l,
      } = {}) {
        (this.lenisOptions = Ki(Ki({}, YO), e)),
          Object.assign(this, {
            lenisOptions: e,
            modularInstance: t,
            triggerRootMargin: i,
            rafRootMargin: r,
            autoResize: s,
            scrollCallback: a,
            initCustomTicker: o,
            destroyCustomTicker: l,
          }),
          (this._onRenderBind = this._onRender.bind(this)),
          (this._onScrollToBind = this._onScrollTo.bind(this)),
          (this._onResizeBind = this._onResize.bind(this)),
          (this.rafPlaying = !1),
          this._init();
      }
      _init() {
        var e;
        (this.lenisInstance = new GE({
          duration: this.lenisOptions.duration,
          direction: this.lenisOptions.direction,
          gestureDirection: this.lenisOptions.gestureDirection,
          smooth: this.lenisOptions.smooth,
          mouseMultiplier: this.lenisOptions.mouseMultiplier,
          smoothTouch: this.lenisOptions.smoothTouch,
          touchMultiplier: this.lenisOptions.touchMultiplier,
          infinite: this.lenisOptions.infinite,
          easing: this.lenisOptions.easing,
        })),
          (e = this.lenisInstance) === null ||
            e === void 0 ||
            e.on("scroll", this.scrollCallback),
          document.documentElement.setAttribute(
            "data-scroll-direction",
            this.lenisInstance.direction
          ),
          requestAnimationFrame(() => {
            (this.coreInstance = new wg({
              $el: this.lenisInstance.contentNode,
              modularInstance: this.modularInstance,
              triggerRootMargin: this.triggerRootMargin,
              rafRootMargin: this.rafRootMargin,
              scrollDirection: this.lenisInstance.direction,
            })),
              this._bindEvents(),
              this.initCustomTicker && !this.destroyCustomTicker
                ? console.warn(
                    "initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble."
                  )
                : !this.initCustomTicker &&
                  this.destroyCustomTicker &&
                  console.warn(
                    "destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble."
                  ),
              this.start();
          });
      }
      destroy() {
        this.stop(),
          this._unbindEvents(),
          this.lenisInstance.destroy(),
          this.coreInstance.destroy();
      }
      _bindEvents() {
        var e, t;
        (this.$scrollToElements =
          (e = this.lenisInstance.contentNode) === null || e === void 0
            ? void 0
            : e.querySelectorAll("[data-scroll-to]")),
          !((t = this.$scrollToElements) === null || t === void 0) &&
            t.length &&
            this.$scrollToElements.forEach((i) => {
              i.addEventListener("click", this._onScrollToBind, !1);
            }),
          this.autoResize &&
            ("ResizeObserver" in window
              ? (this.ROInstance = new Mg({
                  resizeElements: [document.body],
                  resizeCallback: this._onResizeBind,
                }))
              : window.addEventListener("resize", this._onResizeBind));
      }
      _unbindEvents() {
        var e;
        !((e = this.$scrollToElements) === null || e === void 0) &&
          e.length &&
          this.$scrollToElements.forEach((t) => {
            t.removeEventListener("click", this._onScrollToBind, !1);
          }),
          this.autoResize &&
            ("ResizeObserver" in window
              ? this.ROInstance && this.ROInstance.destroy()
              : window.removeEventListener("resize", this._onResizeBind));
      }
      _onResize() {
        requestAnimationFrame(() => {
          var e;
          (e = this.coreInstance) === null ||
            e === void 0 ||
            e.onResize({ currentScroll: this.lenisInstance.scroll });
        });
      }
      _onRender() {
        var e, t;
        (e = this.lenisInstance) === null || e === void 0 || e.raf(Date.now()),
          (t = this.coreInstance) === null ||
            t === void 0 ||
            t.onRender({
              currentScroll: this.lenisInstance.scroll,
              smooth: this.lenisInstance.smooth,
            });
      }
      _onScrollTo(e) {
        var t;
        e.preventDefault();
        let i = (t = e.currentTarget) !== null && t !== void 0 ? t : null;
        if (!i) return;
        let r = i.getAttribute("data-scroll-to-href") || i.getAttribute("href"),
          s = i.getAttribute("data-scroll-to-offset") || 0,
          a =
            i.getAttribute("data-scroll-to-duration") ||
            this.lenisOptions.duration ||
            YO.duration;
        r &&
          this.scrollTo(r, {
            offset: typeof s == "string" ? parseInt(s) : s,
            duration: typeof a == "string" ? parseInt(a) : a,
          });
      }
      start() {
        this.rafPlaying ||
          ((this.rafPlaying = !0),
          this.initCustomTicker
            ? this.initCustomTicker(this._onRenderBind)
            : this._raf());
      }
      stop() {
        !this.rafPlaying ||
          ((this.rafPlaying = !1),
          this.destroyCustomTicker
            ? this.destroyCustomTicker(this._onRenderBind)
            : this.rafInstance && cancelAnimationFrame(this.rafInstance));
      }
      update() {
        var e;
        (e = this.coreInstance) === null || e === void 0 || e.update();
      }
      resize() {
        this._onResizeBind();
      }
      scrollTo(e, t) {
        var i;
        (i = this.lenisInstance) === null ||
          i === void 0 ||
          i.scrollTo(e, {
            offset: t == null ? void 0 : t.offset,
            duration: t == null ? void 0 : t.duration,
            easing: t == null ? void 0 : t.easing,
            immediate: t == null ? void 0 : t.immediate,
          });
      }
      _raf() {
        this._onRenderBind(),
          (this.rafInstance = requestAnimationFrame(() => this._raf()));
      }
    };
  var $E = class extends St {
    constructor(n) {
      super(n);
      (this.onScrollBind = this.onScroll.bind(this)),
        (this.scrollDirection = 1),
        (this.lastProgress = 0),
        (this.lastDirectionChange = 0);
    }
    init() {
      Gt.scrollTop < 80
        ? Gt.classList.add("is-top")
        : Gt.classList.remove("is-top"),
        (this.locolenisInstance = new Ag({
          lenisOptions: {},
          scrollCallback: this.onScrollBind,
          modularInstance: this,
          initCustomTicker: (n) => {
            yt.ticker.add(n);
          },
          destroyCustomTicker: (n) => {
            yt.ticker.remove(n);
          },
        })),
        this.locolenisInstance.start();
    }
    destroy() {
      var n;
      (n = this.locolenisInstance) == null || n.destroy(),
        Gt.classList.remove("is-scrolling-up");
    }
    onScroll({ scroll: n, limit: e, velocity: t, direction: i, progress: r }) {
      r > this.lastProgress
        ? this.scrollDirection != 1 &&
          ((this.lastDirectionChange = n),
          (this.scrollDirection = 1),
          Gt.style.setProperty("--scroll-direction", this.scrollDirection),
          Gt.classList.remove("is-scrolling-up"))
        : this.scrollDirection != -1 &&
          ((this.lastDirectionChange = n),
          (this.scrollDirection = -1),
          Gt.style.setProperty("--scroll-direction", this.scrollDirection),
          Gt.classList.add("is-scrolling-up")),
        n < 80 ? Gt.classList.add("is-top") : Gt.classList.remove("is-top"),
        (window.scroll = {
          scroll: n,
          limit: e,
          velocity: t,
          direction: this.scrollDirection,
          progress: r,
        }),
        (this.lastProgress = r);
    }
    scrollTo(n) {
      var i;
      let { target: e, options: t } = n;
      (i = this.locolenisInstance) == null || i.scrollTo(e, t);
    }
    update() {
      var n;
      (n = this.locolenisInstance) == null || n.update();
    }
    lazyLoad(n) {
      Es(n.target, null, () => {
        n.target.dataset.depixelate != null && rr(n.target);
      });
    }
  };
  var WE = class extends La {
    constructor(n) {
      super(n);
      (this.defaultAnimation = "idle-1"),
        (this.models = this.getData("models").split(","));
    }
    init() {
      super.init();
      let n, e;
      (this.onClickStart = (t) => {
        (n = Date.now()),
          (e = {
            x: t.touches ? t.touches[0].screenX : t.screenX,
            y: t.touches ? t.touches[0].screenY : t.screenY,
          }),
          (this.interacting = !0);
      }),
        (this.onClickEnd = (t) => {
          this.interacting = !1;
          let i = Date.now() - n,
            r = {
              x: t.changedTouches ? t.changedTouches[0].screenX : t.screenX,
              y: t.changedTouches ? t.changedTouches[0].screenY : t.screenY,
            },
            s = Math.abs(
              Math.sqrt(Math.pow(e.x - r.x, 2) + Math.pow(e.y - r.y, 2))
            );
          i < 250 &&
            s < 10 &&
            this.setModel(
              this.models[Math.floor(this.models.length * Math.random())]
            );
        }),
        this.el.addEventListener("pointerdown", this.onClickStart),
        this.el.addEventListener("pointerup", this.onClickEnd);
    }
    onInview(n) {
      n.target == this.el &&
        n.way == "enter" &&
        this.setModel(
          this.models[Math.floor(this.models.length * Math.random())]
        );
    }
    render() {
      super.render(),
        this.interacting ||
          this.wrapper.rotation.set(
            0,
            this.wrapper.rotation.y + (0.02 * this.deltaTime) / (1 / 60),
            0
          );
    }
    initScene() {
      super.initScene(),
        this.camera.position.set(1, 3, 5),
        this.controls.target.set(0, 0.9, 0),
        this.wrapper.scale.set(1.2, 1.2, 1.2),
        (this.controls.maxPolarAngle = Math.PI * 0.6),
        (this.controls.minPolarAngle = Math.PI * 0.3),
        (this.controls.enableZoom = !1),
        (this.controls.enablePan = !1),
        (this.controls.touches = {}),
        (this.el.style.touchAction = "");
    }
    destroy() {
      this.el.removeEventListener("pointerdown", this.onClickStart),
        this.el.removeEventListener("pointerup", this.onClickEnd),
        super.destroy();
    }
  };
  var qE = class extends St {
    constructor(n) {
      super(n);
      (this.events = { click: { item: "onItemClick" } }),
        (this.$items = this.$("item"));
    }
    init() {
      (this.touchStartBind = () => {
        this.isTouch = !0;
      }),
        this.el.addEventListener("touchstart", this.touchStartBind, {
          once: !0,
        }),
        (this.leave = (n) => {
          this.isTouch || this.call("setModel", !1, "TeamListCanvas");
        }),
        (this.enter = (n) => {
          if (this.isTouch) return;
          let e = JSON.parse(this.getData("infos", n.currentTarget));
          this.call("setModel", e.model, "TeamListCanvas");
        });
      for (let n of this.$items)
        n.addEventListener("focusout", this.leave),
          n.addEventListener("mouseleave", this.leave),
          n.addEventListener("mouseenter", this.enter),
          n.addEventListener("focusin", (e) => {
            e.target.classList.contains("focus-visible") && this.enter(e);
          });
    }
    onItemClick(n) {
      let e = n.curTarget;
      this.call("setModel", !1, "TeamListCanvas"),
        this.call("show", JSON.parse(this.getData("infos", e)), "TeamModal");
    }
    destroy() {
      this.el.removeEventListener("touchstart", this.touchStartBind);
      for (let n of this.$items)
        n.removeEventListener("focusout", this.leave),
          n.removeEventListener("mouseleave", this.leave),
          n.removeEventListener("mouseenter", this.enter),
          n.removeEventListener("focusin", this.enter);
    }
  };
  var jE = class extends La {
    constructor(n) {
      super(n);
      this.defaultAnimation = "walking";
    }
    init() {
      super.init();
    }
    render() {
      super.render(),
        this.wrapper.rotation.set(
          0,
          this.wrapper.rotation.y + (0.02 * this.deltaTime) / (1 / 60),
          0
        );
    }
    initScene() {
      super.initScene(),
        this.camera.position.set(1, 3, 5),
        this.controls.target.set(0, 0.75, 0),
        this.wrapper.scale.set(0.75, 0.75, 0.75);
    }
  };
  var KY = Object.prototype.toString,
    xu =
      Array.isArray ||
      function (e) {
        return KY.call(e) === "[object Array]";
      };
  function YE(n) {
    return typeof n == "function";
  }
  function JY(n) {
    return xu(n) ? "array" : typeof n;
  }
  function XE(n) {
    return n.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }
  function KO(n, e) {
    return n != null && typeof n == "object" && e in n;
  }
  function ZY(n, e) {
    return (
      n != null &&
      typeof n != "object" &&
      n.hasOwnProperty &&
      n.hasOwnProperty(e)
    );
  }
  var QY = RegExp.prototype.test;
  function eK(n, e) {
    return QY.call(n, e);
  }
  var tK = /\S/;
  function iK(n) {
    return !eK(tK, n);
  }
  var nK = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;",
    "`": "&#x60;",
    "=": "&#x3D;",
  };
  function rK(n) {
    return String(n).replace(/[&<>"'`=\/]/g, function (t) {
      return nK[t];
    });
  }
  var sK = /\s*/,
    aK = /\s+/,
    JO = /\s*=/,
    oK = /\s*\}/,
    lK = /#|\^|\/|>|\{|&|=|!/;
  function cK(n, e) {
    if (!n) return [];
    var t = !1,
      i = [],
      r = [],
      s = [],
      a = !1,
      o = !1,
      l = "",
      c = 0;
    function u() {
      if (a && !o) for (; s.length; ) delete r[s.pop()];
      else s = [];
      (a = !1), (o = !1);
    }
    var f, d, m;
    function x(M) {
      if (
        (typeof M == "string" && (M = M.split(aK, 2)), !xu(M) || M.length !== 2)
      )
        throw new Error("Invalid tags: " + M);
      (f = new RegExp(XE(M[0]) + "\\s*")),
        (d = new RegExp("\\s*" + XE(M[1]))),
        (m = new RegExp("\\s*" + XE("}" + M[1])));
    }
    x(e || is.tags);
    for (var y = new $f(n), g, b, _, E, w, P; !y.eos(); ) {
      if (((g = y.pos), (_ = y.scanUntil(f)), _))
        for (var L = 0, I = _.length; L < I; ++L)
          (E = _.charAt(L)),
            iK(E)
              ? (s.push(r.length), (l += E))
              : ((o = !0), (t = !0), (l += " ")),
            r.push(["text", E, g, g + 1]),
            (g += 1),
            E ===
              `
` && (u(), (l = ""), (c = 0), (t = !1));
      if (!y.scan(f)) break;
      if (
        ((a = !0),
        (b = y.scan(lK) || "name"),
        y.scan(sK),
        b === "="
          ? ((_ = y.scanUntil(JO)), y.scan(JO), y.scanUntil(d))
          : b === "{"
          ? ((_ = y.scanUntil(m)), y.scan(oK), y.scanUntil(d), (b = "&"))
          : (_ = y.scanUntil(d)),
        !y.scan(d))
      )
        throw new Error("Unclosed tag at " + y.pos);
      if (
        (b == ">" ? (w = [b, _, g, y.pos, l, c, t]) : (w = [b, _, g, y.pos]),
        c++,
        r.push(w),
        b === "#" || b === "^")
      )
        i.push(w);
      else if (b === "/") {
        if (((P = i.pop()), !P))
          throw new Error('Unopened section "' + _ + '" at ' + g);
        if (P[1] !== _)
          throw new Error('Unclosed section "' + P[1] + '" at ' + g);
      } else
        b === "name" || b === "{" || b === "&" ? (o = !0) : b === "=" && x(_);
    }
    if ((u(), (P = i.pop()), P))
      throw new Error('Unclosed section "' + P[1] + '" at ' + y.pos);
    return hK(uK(r));
  }
  function uK(n) {
    for (var e = [], t, i, r = 0, s = n.length; r < s; ++r)
      (t = n[r]),
        t &&
          (t[0] === "text" && i && i[0] === "text"
            ? ((i[1] += t[1]), (i[3] = t[3]))
            : (e.push(t), (i = t)));
    return e;
  }
  function hK(n) {
    for (var e = [], t = e, i = [], r, s, a = 0, o = n.length; a < o; ++a)
      switch (((r = n[a]), r[0])) {
        case "#":
        case "^":
          t.push(r), i.push(r), (t = r[4] = []);
          break;
        case "/":
          (s = i.pop()),
            (s[5] = r[2]),
            (t = i.length > 0 ? i[i.length - 1][4] : e);
          break;
        default:
          t.push(r);
      }
    return e;
  }
  function $f(n) {
    (this.string = n), (this.tail = n), (this.pos = 0);
  }
  $f.prototype.eos = function () {
    return this.tail === "";
  };
  $f.prototype.scan = function (e) {
    var t = this.tail.match(e);
    if (!t || t.index !== 0) return "";
    var i = t[0];
    return (
      (this.tail = this.tail.substring(i.length)), (this.pos += i.length), i
    );
  };
  $f.prototype.scanUntil = function (e) {
    var t = this.tail.search(e),
      i;
    switch (t) {
      case -1:
        (i = this.tail), (this.tail = "");
        break;
      case 0:
        i = "";
        break;
      default:
        (i = this.tail.substring(0, t)), (this.tail = this.tail.substring(t));
    }
    return (this.pos += i.length), i;
  };
  function vu(n, e) {
    (this.view = n), (this.cache = { ".": this.view }), (this.parent = e);
  }
  vu.prototype.push = function (e) {
    return new vu(e, this);
  };
  vu.prototype.lookup = function (e) {
    var t = this.cache,
      i;
    if (t.hasOwnProperty(e)) i = t[e];
    else {
      for (var r = this, s, a, o, l = !1; r; ) {
        if (e.indexOf(".") > 0)
          for (s = r.view, a = e.split("."), o = 0; s != null && o < a.length; )
            o === a.length - 1 && (l = KO(s, a[o]) || ZY(s, a[o])),
              (s = s[a[o++]]);
        else (s = r.view[e]), (l = KO(r.view, e));
        if (l) {
          i = s;
          break;
        }
        r = r.parent;
      }
      t[e] = i;
    }
    return YE(i) && (i = i.call(this.view)), i;
  };
  function Kn() {
    this.templateCache = {
      _cache: {},
      set: function (e, t) {
        this._cache[e] = t;
      },
      get: function (e) {
        return this._cache[e];
      },
      clear: function () {
        this._cache = {};
      },
    };
  }
  Kn.prototype.clearCache = function () {
    typeof this.templateCache != "undefined" && this.templateCache.clear();
  };
  Kn.prototype.parse = function (e, t) {
    var i = this.templateCache,
      r = e + ":" + (t || is.tags).join(":"),
      s = typeof i != "undefined",
      a = s ? i.get(r) : void 0;
    return a == null && ((a = cK(e, t)), s && i.set(r, a)), a;
  };
  Kn.prototype.render = function (e, t, i, r) {
    var s = this.getConfigTags(r),
      a = this.parse(e, s),
      o = t instanceof vu ? t : new vu(t, void 0);
    return this.renderTokens(a, o, i, e, r);
  };
  Kn.prototype.renderTokens = function (e, t, i, r, s) {
    for (var a = "", o, l, c, u = 0, f = e.length; u < f; ++u)
      (c = void 0),
        (o = e[u]),
        (l = o[0]),
        l === "#"
          ? (c = this.renderSection(o, t, i, r, s))
          : l === "^"
          ? (c = this.renderInverted(o, t, i, r, s))
          : l === ">"
          ? (c = this.renderPartial(o, t, i, s))
          : l === "&"
          ? (c = this.unescapedValue(o, t))
          : l === "name"
          ? (c = this.escapedValue(o, t, s))
          : l === "text" && (c = this.rawValue(o)),
        c !== void 0 && (a += c);
    return a;
  };
  Kn.prototype.renderSection = function (e, t, i, r, s) {
    var a = this,
      o = "",
      l = t.lookup(e[1]);
    function c(d) {
      return a.render(d, t, i, s);
    }
    if (!!l) {
      if (xu(l))
        for (var u = 0, f = l.length; u < f; ++u)
          o += this.renderTokens(e[4], t.push(l[u]), i, r, s);
      else if (
        typeof l == "object" ||
        typeof l == "string" ||
        typeof l == "number"
      )
        o += this.renderTokens(e[4], t.push(l), i, r, s);
      else if (YE(l)) {
        if (typeof r != "string")
          throw new Error(
            "Cannot use higher-order sections without the original template"
          );
        (l = l.call(t.view, r.slice(e[3], e[5]), c)), l != null && (o += l);
      } else o += this.renderTokens(e[4], t, i, r, s);
      return o;
    }
  };
  Kn.prototype.renderInverted = function (e, t, i, r, s) {
    var a = t.lookup(e[1]);
    if (!a || (xu(a) && a.length === 0))
      return this.renderTokens(e[4], t, i, r, s);
  };
  Kn.prototype.indentPartial = function (e, t, i) {
    for (
      var r = t.replace(/[^ \t]/g, ""),
        s = e.split(`
`),
        a = 0;
      a < s.length;
      a++
    )
      s[a].length && (a > 0 || !i) && (s[a] = r + s[a]);
    return s.join(`
`);
  };
  Kn.prototype.renderPartial = function (e, t, i, r) {
    if (!!i) {
      var s = this.getConfigTags(r),
        a = YE(i) ? i(e[1]) : i[e[1]];
      if (a != null) {
        var o = e[6],
          l = e[5],
          c = e[4],
          u = a;
        l == 0 && c && (u = this.indentPartial(a, c, o));
        var f = this.parse(u, s);
        return this.renderTokens(f, t, i, u, r);
      }
    }
  };
  Kn.prototype.unescapedValue = function (e, t) {
    var i = t.lookup(e[1]);
    if (i != null) return i;
  };
  Kn.prototype.escapedValue = function (e, t, i) {
    var r = this.getConfigEscape(i) || is.escape,
      s = t.lookup(e[1]);
    if (s != null)
      return typeof s == "number" && r === is.escape ? String(s) : r(s);
  };
  Kn.prototype.rawValue = function (e) {
    return e[1];
  };
  Kn.prototype.getConfigTags = function (e) {
    return xu(e) ? e : e && typeof e == "object" ? e.tags : void 0;
  };
  Kn.prototype.getConfigEscape = function (e) {
    if (e && typeof e == "object" && !xu(e)) return e.escape;
  };
  var is = {
      name: "mustache.js",
      version: "4.2.0",
      tags: ["{{", "}}"],
      clearCache: void 0,
      escape: void 0,
      parse: void 0,
      render: void 0,
      Scanner: void 0,
      Context: void 0,
      Writer: void 0,
      set templateCache(n) {
        Hf.templateCache = n;
      },
      get templateCache() {
        return Hf.templateCache;
      },
    },
    Hf = new Kn();
  is.clearCache = function () {
    return Hf.clearCache();
  };
  is.parse = function (e, t) {
    return Hf.parse(e, t);
  };
  is.render = function (e, t, i, r) {
    if (typeof e != "string")
      throw new TypeError(
        'Invalid template! Template should be a "string" but "' +
          JY(e) +
          '" was given as the first argument for mustache#render(template, view, partials)'
      );
    return Hf.render(e, t, i, r);
  };
  is.escape = rK;
  is.Scanner = $f;
  is.Context = vu;
  is.Writer = Kn;
  var ZO = is;
  var fK = `
    <div class="c-team-modal_title || c-heading -h1">
        {{fancy-name}}
    </div>

    <div class="c-team-modal_infos">
        <dl class="c-team-modal_specs">
            {{# hasProjects }}
            <dt>{{ labels.projects }}</dt>
            <dd>
                <ul>
                    {{# projects }}
                    <li><a href="{{ url }}">{{ title }}</a></li>
                    {{/ projects }}
                </ul>
            </dd>
            {{/ hasProjects }}
            <dt>{{ labels.role }}</dt>
            <dd>{{ position }}</dd>
            <dt>{{ labels.since }}</dt>
            <dd>{{ arrival-year }}</dd>
        </dl>
    </div>
`,
    KE = class extends St {
      constructor(n) {
        super(n);
        (this.$infos = this.$("infos")[0]),
          (this.$canvas = this.$("canvas")[0]),
          (this.$dropdown = this.$("dropdown")[0]),
          (this.$dropdownLabel = this.$("dropdown-label")[0]),
          (this.members = Array.from(this.$("member"))),
          (this.labels = {
            role: this.getData("role-label"),
            since: this.getData("since-label"),
            projects: this.getData("projects-label"),
          }),
          (this.events = {
            click: { member: "setMemberByEl", close: "hide" },
            change: { dropdown: "setMemberByDropdown" },
          });
      }
      init() {
        (this.usdzReadyBind = (n) => {
          this.quickLookBtn ||
            ((this.quickLookBtn = document.createElement("a")),
            (this.quickLookBtn.rel = "ar"),
            (this.quickLookBtn.download = "asset.usdz"),
            this.quickLookBtn.classList.add("c-team-modal_ar-btn"),
            (this.quickLookBtn.innerHTML =
              '<img src="https://threejs.org/examples/files/arkit.png">'),
            this.el.appendChild(this.quickLookBtn)),
            (this.quickLookBtn.style.display = ""),
            (this.quickLookBtn.href = n.detail.usdz);
        }),
          (this.hideUsdz = () => {
            this.quickLookBtn && (this.quickLookBtn.style.display = "none");
          }),
          this.$canvas.addEventListener("usdzReady", this.usdzReadyBind),
          this.$canvas.addEventListener("hideUsdz", this.hideUsdz),
          window.addEventListener(
            "keydown",
            (this.onKeyDown = (n) => {
              n.keyCode === 27 &&
                this.el.classList.contains("-active") &&
                this.hide();
            })
          ),
          (this.focusTrap = ws(this.el));
      }
      show(n) {
        n && this.setMember(n),
          this.el.classList.add("-active"),
          this.call("resize", null, "TeamModalCanvas"),
          this.focusTrap.activate(),
          window.gtag &&
            gtag("event", "click", {
              event_category: "team_modal",
              event_label: "open",
            });
      }
      hide() {
        this.el.classList.remove("-active"),
          this.focusTrap.deactivate(),
          this.call("setModel", !1, "TeamModalCanvas");
      }
      setMember(n) {
        n["fancy-name"] || (n["fancy-name"] = n.name),
          (n.hasProjects = n.projects && n.projects.length > 0),
          (n.labels = this.labels),
          (this.$infos.innerHTML = ZO.render(fK, n)),
          (this.$dropdown.value = n.id),
          (this.$dropdownLabel.innerText = n["fancy-name"] || n.name);
        let e = this.members.find((i) => i.classList.contains("-active"));
        e && e.classList.remove("-active");
        let t = this.members.find((i) => i.dataset.teamModalId == n.id);
        t && t.classList.add("-active"),
          this.call("setModel", n.model, "TeamModalCanvas");
      }
      setMemberByEl(n) {
        let e = JSON.parse(this.getData("infos", n.currentTarget));
        this.setMember(e);
      }
      setMemberByDropdown(n) {
        let e = n.curTarget;
        this.setMember(
          JSON.parse(e.options[e.selectedIndex].dataset.teamModalInfos)
        );
      }
      destroy() {
        super.destroy(),
          this.$canvas.removeEventListener("usdzReady", this.usdzReadyBind),
          this.$canvas.removeEventListener("hideUsdz", this.hideUsdz),
          this.focusTrap.deactivate();
      }
    };
  var JE = class extends La {
    constructor(n) {
      super(n);
    }
    init() {
      super.init();
      let n, e;
      (this.onClickStart = (t) => {
        (n = Date.now()),
          (e = {
            x: t.touches ? t.touches[0].screenX : t.screenX,
            y: t.touches ? t.touches[0].screenY : t.screenY,
          });
      }),
        (this.onClickEnd = (t) => {
          let i = Date.now() - n,
            r = {
              x: t.changedTouches ? t.changedTouches[0].screenX : t.screenX,
              y: t.changedTouches ? t.changedTouches[0].screenY : t.screenY,
            },
            s = Math.abs(
              Math.sqrt(Math.pow(e.x - r.x, 2) + Math.pow(e.y - r.y, 2))
            );
          i < 250 &&
            s < 10 &&
            (this.setModel(this.currentModel),
            window.gtag &&
              gtag("event", "click", {
                event_category: "team_modal",
                event_label: "change_dance",
              }));
        }),
        this.el.addEventListener("pointerdown", this.onClickStart),
        this.el.addEventListener("pointerup", this.onClickEnd);
    }
    initRenderer() {
      super.initRenderer();
    }
    initScene() {
      super.initScene(),
        this.camera.position.set(-2, 2, 2.9),
        this.controls.target.set(0, 0.9, 0),
        (this.controls.zoomSpeed = 0.5),
        (this.controls.minDistance = 1),
        (this.controls.maxDistance = 5),
        (this.controls.maxPolarAngle = Math.PI * 0.6),
        (this.controls.minPolarAngle = Math.PI * 0.3);
      var n = new le(-1, -1, -1),
        e = new le(1, 2, 1),
        t = new le();
      (this.onControlsChange = () => {
        t.copy(this.controls.target),
          this.controls.target.clamp(n, e),
          t.sub(this.controls.target),
          this.camera.position.sub(t);
      }),
        this.controls.addEventListener("change", this.onControlsChange);
    }
    render() {
      super.render();
    }
    destroy() {
      this.controls.removeEventListener("change", this.onControlsChange),
        this.el.removeEventListener("pointerdown", this.onClickStart),
        this.el.removeEventListener("pointerup", this.onClickEnd),
        super.destroy();
    }
  };
  var ZE = class extends St {
    constructor(n) {
      super(n);
    }
    init() {
      !this.el.src.length &&
        this.el.dataset.src &&
        this.el.dataset.srcMobile &&
        this.computeSrc(),
        (this.onResize = this.computeSrc.bind(this)),
        window.addEventListener("resize", this.onResize);
    }
    computeSrc() {
      if (this.el.dataset.srcMobile) {
        let n;
        if (
          (window.matchMedia("(max-aspect-ratio: 1/1) and (max-width: 700px)")
            .matches
            ? (n = this.el.dataset.srcMobile)
            : (n = this.el.dataset.src),
          n != this.el.src)
        ) {
          let e = !this.el.paused;
          (this.el.src = n), e && this.el.play();
        }
      }
    }
    toggle(n) {
      n.target == this.el &&
        (n.way === "enter"
          ? this.el.paused &&
            (this.timeout = setTimeout(() => {
              this.el.play();
            }, 200))
          : this.el.paused || (clearTimeout(this.timeout), this.el.pause()));
    }
    destroy() {
      window.removeEventListener("resize", this.onResize);
    }
  };
  var QE = class extends St {
    constructor(n) {
      super(n);
      (this.events = { click: { close: "hide" } }),
        (this.inner = this.$("inner")[0]);
    }
    init() {
      this.focusTrap = ws(this.el, {
        onDeactivate: this.hide.bind(this),
        clickOutsideDeactivates: !0,
      });
    }
    toggle(n) {
      this.el.classList.contains("is-active") ? this.hide() : this.show(n);
    }
    show(n) {
      this.emptyTimeout && clearTimeout(this.emptyTimeout),
        (this.appendDelay = setTimeout(() => {
          switch (n.platform) {
            case "youtube":
              (this.videoUrl = `https://www.youtube.com/embed/${n.id}?&autoplay=1`),
                (this.inner.innerHTML = `<iframe src="https://www.youtube.com/embed/${n.id}?&autoplay=1" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>`);
              break;
            case "vimeo":
              (this.videoUrl = `https://player.vimeo.com/video/${n.id}?autoplay=1&loop=1&autopause=0`),
                (this.inner.innerHTML = `<iframe src="https://player.vimeo.com/video/${n.id}?autoplay=1&autopause=0" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>`);
              break;
            default:
              break;
          }
          requestAnimationFrame(() => {
            var e;
            (e = this.focusTrap) == null || e.activate();
          });
        }, 500)),
        this.el.classList.add("is-active");
    }
    hide() {
      var n;
      clearTimeout(this.appendDelay),
        this.el.classList.remove("is-active"),
        (n = this.focusTrap) == null || n.deactivate(),
        (this.emptyTimeout = setTimeout(() => {
          this.inner.innerHTML = "";
        }, 250));
    }
    destroy() {
      super.destroy();
    }
  };
  var eT = class extends St {
    constructor(n) {
      super(n);
      this.events = { click: "onClick" };
    }
    init() {}
    onClick() {
      let n = this.getData("id"),
        e = this.getData("platform");
      window.gtag &&
        gtag("event", "click", {
          event_category: "video_modal",
          event_label: "open",
          value: n,
        }),
        this.call("toggle", { id: n, platform: e }, "VideoModal");
    }
  };
  var QO = bn(Yu(), 1),
    tT = class extends St {
      constructor(n) {
        super(n);
        (this.$select = this.$("select")[0]),
          (this.$content = this.$("content")[0]),
          (this.$toggler = this.$("toggler")[0]),
          (this.$togglerOpenLabel = this.$("toggler-open-label")[0]),
          (this.$togglerCloseLabel = this.$("toggler-close-label")[0]),
          (this.$currentCategoryName = this.$("currentCategoryName")[0]),
          (this.$currentCategoryQty = this.$("currentCategoryQty")[0]),
          (this.events = {
            click: { toggler: "toggle", "category-button": "onCategoryClick" },
            change: { select: "onSelectChange" },
          });
      }
      init() {
        this.focusTrap = ws(this.el, {
          onDeactivate: this.hide.bind(this),
          clickOutsideDeactivates: !0,
        });
      }
      toggle() {
        this.isOpened() ? this.hide() : this.show();
      }
      isOpened() {
        return this.el.classList.contains("is-opened");
      }
      show() {
        this.el.classList.add("is-opened"),
          this.$toggler.setAttribute("aria-expanded", "true"),
          this.$togglerOpenLabel.classList.add("-hidden"),
          this.$togglerCloseLabel.classList.remove("-hidden"),
          this.focusTrap.activate();
      }
      hide() {
        this.el.classList.remove("is-opened"),
          this.$toggler.setAttribute("aria-expanded", "false"),
          this.$togglerOpenLabel.classList.remove("-hidden"),
          this.$togglerCloseLabel.classList.add("-hidden"),
          this.focusTrap.deactivate();
      }
      onSelectChange(n) {
        let e = n.curTarget;
        this.filterByEl(e.options[e.selectedIndex]);
      }
      onCategoryClick(n) {
        this.filterByEl(n.curTarget), this.hide();
      }
      filterByEl(n) {
        let e = JSON.parse(n.dataset.workFiltersData);
        (this.$select.value = e.slug),
          (this.$currentCategoryName.innerText = e.name),
          (this.$currentCategoryQty.innerText = (e.qty + "").padStart(2, "0"));
        let t = window.location.pathname + "?category=" + e.slug,
          i = document.createElement("a");
        (i.href = t),
          i.setAttribute("data-load-transition", "work-list"),
          QO.default.go(t, i);
      }
      destroy() {
        super.destroy(), this.focusTrap.deactivate();
      }
    };
  var iT = class extends St {
    constructor(n) {
      super(n);
      (this.slides = Array.from(this.$("slide"))), (this.count = 0);
    }
    init() {
      this.el.addEventListener("mouseenter", () => {
        this.compute(),
          clearInterval(this.interval),
          this.changeSlide(),
          (this.interval = setInterval(this.changeSlide.bind(this), 500));
      }),
        this.el.addEventListener("mouseleave", () => {
          clearInterval(this.interval);
        });
    }
    changeSlide() {
      this.count++,
        yt.set(this.slides, { opacity: 0 }),
        yt.set(this.slides[this.count % this.slides.length], { opacity: 1 });
    }
    compute() {
      this.BCR = this.el.getBoundingClientRect();
    }
  };
  var nT = class extends St {
    constructor(n) {
      super(n);
      (this.$toggler = this.$("toggler")[0]),
        (this.$content = this.$("content")[0]),
        (this.$contentInner = this.$("content-inner")[0]),
        (this.list = this.getData("list")),
        (this.animationOpenDuration = 0.5),
        (this.animationCloseDuration = 0.3),
        (this.$preview = this.$("preview")[0]),
        (this.$previewTarget = this.$("preview-target")[0]),
        (this.images = Array.from(this.$("image"))),
        (this.events = { click: { toggler: "toggle" } }),
        this.compute();
    }
    init() {
      (this.computeBind = this.compute.bind(this)),
        window.addEventListener("resize", this.computeBind),
        (this.touchStartBind = () => {
          this.isTouch = !0;
        }),
        this.el.addEventListener("touchstart", this.touchStartBind, {
          once: !0,
        }),
        (this.enter = (n) => {
          if (this.isTouch || !this.$preview) return;
          let e = this.$preview.querySelector("img");
          this.$preview.classList.contains("-loaded")
            ? rr(e)
            : Es(e, null, () => {
                rr(e);
              });
        }),
        this.el.addEventListener("mouseenter", this.enter),
        this.el.addEventListener("focusin", this.enter);
    }
    toggle(n) {
      this.isOpened() ? this.close() : this.open();
    }
    isOpened() {
      return this.el.classList.contains("is-opened");
    }
    compute() {
      (this.isMobile = window.innerWidth < 700),
        (this.canHover = window.matchMedia("(hover: hover)").matches),
        (this.canAnimatePreview = this.canHover && !this.isMobile);
    }
    open() {
      let n = {
        el: document.body.querySelector(
          "[data-module-work-list-item].is-opened"
        ),
      };
      n.el &&
        ((n.content = this.$("content", n.el)[0]),
        (n.contentBCR = n.content.getBoundingClientRect())),
        this.call("close", this.list, "WorkListItem"),
        this.$toggler.setAttribute("aria-expanded", "true"),
        this.getData("label-close", this.$toggler) &&
          (this.$toggler.children[0].innerText = this.getData(
            "label-close",
            this.$toggler
          )),
        this.el.classList.add("is-opened"),
        yt.set(this.$content, { display: "block" });
      let e =
          parseFloat(
            getComputedStyle(document.documentElement).getPropertyValue(
              "--header-height"
            )
          ) * parseFloat(getComputedStyle(document.documentElement).fontSize),
        t = this.$contentInner.getBoundingClientRect(),
        i = -e;
      this.el.previousElementSibling != n.el &&
        n.contentBCR &&
        n.contentBCR.top < t.top &&
        (i -= n.contentBCR.height),
        this.call(
          "scrollTo",
          {
            target: this.el.previousElementSibling
              ? this.el.previousElementSibling
              : this.el,
            options: { offset: i, duration: this.animationOpenDuration },
          },
          "Scroll"
        );
      for (let o of [...this.images, this.$previewTarget]) {
        if (!o) continue;
        let l = o.querySelector("img");
        Es(l, null, () => {
          this.canAnimatePreview
            ? o.dataset.workListItem != "preview-target" && rr(l)
            : rr(l);
        });
      }
      this.tw && this.tw.kill && this.tw.kill(),
        yt.set(this.$preview, { clearProps: "all" }),
        this.canAnimatePreview &&
          (yt.set(this.$preview, { opacity: 1 }),
          yt.set(this.$previewTarget, { opacity: 0 }));
      let r = this.$preview.getBoundingClientRect(),
        s = this.$previewTarget.getBoundingClientRect(),
        a = {
          top: s.top - r.top + r.height / 2,
          left: s.left - r.left,
          scale: s.width / r.width,
        };
      (this.tw = yt.timeline({
        onComplete: () => {
          this.canAnimatePreview &&
            (yt.set([this.$preview, this.$previewTarget], {
              clearProps: "all",
            }),
            yt.set(this.$preview, { opacity: 0 }));
        },
      })),
        this.canAnimatePreview &&
          this.tw.to(
            this.$preview,
            {
              duration: this.animationOpenDuration,
              x: a.left,
              y: a.top,
              scale: a.scale,
              ease: "power4.out",
              force3D: !0,
            },
            0
          ),
        this.tw.fromTo(
          this.$content,
          { opacity: 0 },
          { duration: (this.animationOpenDuration * 2) / 3, opacity: 1 },
          (this.animationOpenDuration * 1) / 3
        ),
        this.tw.to(
          this.$content,
          { duration: this.animationOpenDuration, height: t.height },
          0
        ),
        window.gtag &&
          gtag("event", "click", {
            event_category: "work_accordions",
            event_label: "open",
          });
    }
    close(n = void 0) {
      if ((n && n != this.list) || !this.el.classList.contains("is-opened"))
        return;
      this.$toggler.setAttribute("aria-expanded", "false"),
        this.getData("label-open", this.$toggler) &&
          (this.$toggler.children[0].innerText = this.getData(
            "label-open",
            this.$toggler
          )),
        this.el.classList.remove("is-opened"),
        this.tw && this.tw.kill && this.tw.kill(),
        yt.set(this.$preview, { clearProps: "all" }, 0),
        this.canAnimatePreview && yt.set(this.$previewTarget, { opacity: 0 });
      let e = this.$preview.getBoundingClientRect(),
        t = this.$previewTarget.getBoundingClientRect(),
        i = {
          top: t.top - e.top + e.height / 2,
          left: t.left - e.left,
          scale: t.width / e.width,
        };
      (this.tw = yt.timeline({
        onComplete: () => {
          yt.set(this.$content, { clearProps: "display" }),
            this.canAnimatePreview &&
              yt.set([this.$preview, this.$previewTarget], {
                clearProps: "all",
              });
        },
      })),
        this.canAnimatePreview &&
          this.tw.from(
            this.$preview,
            {
              duration: this.animationCloseDuration,
              x: i.left,
              y: i.top,
              scale: i.scale,
              ease: "power4.out",
              force3D: !0,
            },
            0
          ),
        this.tw.to(
          this.$content,
          { duration: this.animationCloseDuration, height: 0, opacity: 0 },
          0
        );
    }
    inview(n) {
      if (
        n.target == this.el &&
        !this.canAnimatePreview &&
        this.isMobile &&
        !this.$preview.classList.contains("-loaded")
      ) {
        let e = this.$preview.querySelector("img");
        Es(e, null, () => {
          this.canAnimatePreview
            ? image.dataset.workListItem != "preview-target" && rr(e)
            : rr(e);
        });
      }
    }
    destroy() {
      window.removeEventListener("resize", this.computeBind),
        this.el.removeEventListener("mouseenter", this.enter),
        this.el.removeEventListener("focusin", this.enter);
    }
  };
  var Do = bn(Yu(), 1),
    rT = class extends St {
      constructor(n) {
        super(n);
        (this.$link = this.$("link")[0]), (this.$image = this.$("image")[0]);
      }
      init() {
        let n = this.$link.href;
        Do.default.cache.has(n)
          ? Do.default.cache.update(n, { action: "prefetch" })
          : Do.default.cache.set(
              n,
              Do.default
                .request(
                  n,
                  Do.default.timeout,
                  Do.default.onRequestError.bind(Do.default, "barba")
                )
                .catch((e) => {
                  console.error(e);
                }),
              "prefetch"
            ),
          (this.timeline = yt.timeline({
            onComplete: () => {
              console.log("onComplete"),
                this.call("manualGo", this.$link, "Load");
            },
          })),
          this.timeline.from(this.$image, { y: "100%", duration: 0.75 }, 0.25),
          this.timeline.add(() => {}, 1),
          this.timeline.pause();
      }
      onScrollProgress(n) {
        var e;
        (e = this.timeline) == null || e.progress(n);
      }
    };
  var sT = class extends St {
    constructor(n) {
      super(n);
      (this.$gridBottom = this.$("grid-bottom")[0]),
        (this.$title = this.$("title")[0]);
    }
    init() {
      this.compute(),
        (this.checkResizeBind = this.checkResize.bind(this)),
        window.addEventListener("resize", this.checkResizeBind);
    }
    checkResize() {
      this.resizeTick ||
        ((this.resizeTick = !0),
        requestAnimationFrame(() => {
          this.compute(), (this.resizeTick = !1);
        }));
    }
    compute() {
      this.$gridBottom.style.setProperty("--first-row-size", "");
      let n = this.$gridBottom.getBoundingClientRect(),
        e = this.$title.getBoundingClientRect();
      this.$gridBottom.style.setProperty(
        "--first-row-size",
        `max(${e.height}px, calc(${n.height}px - var(--second-row-size) - var(--grid-gutter) * 2))`
      );
    }
    destroy() {
      window.removeEventListener("resize", this.checkResizeBind);
    }
  };
  var iN = bn(tN(), 1);
  function nN() {
    (0, iN.default)();
    let n =
      /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
        navigator.userAgent
      ) ||
      (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
    (window.isMobile = n), window.isMobile && Gt.classList.add("is-mobile");
    let e = Gt.dataset.debug == "true";
    (window.isDebug = e), window.isDebug && Gt.classList.add("is-debug");
    let t = window.innerWidth;
    Gt.style.setProperty("--vh", `${window.innerHeight * 0.01}px`),
      window.addEventListener("resize", () => {
        window.innerWidth != t &&
          window.matchMedia("(hover: none)") &&
          ((t = window.innerWidth),
          Gt.style.setProperty("--vh", `${window.innerHeight * 0.01}px`));
      });
  }
  yt.registerPlugin(Ss);
  function rN() {
    let n = document.getElementById("preloader"),
      e = document.getElementById("preloaderHead"),
      t = document.getElementById("preloaderContent"),
      i = document.getElementById("preloaderLogo"),
      r = 0.01,
      s = 0.5,
      a =
        "!@#$%&+=qertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM\\/{}][-_()<>?".split(
          ""
        ),
      o = yt.timeline({
        onComplete: () => {
          setTimeout(() => {
            n.remove();
          }, 1e3);
        },
      });
    if (sessionStorage.getItem("locomotive.quickpreload") == "true") {
      let l = mr(Array.from(i.children));
      o.set(l, { opacity: 0, stagger: 0.025 }, 0),
        o.add(window.preloaderPromiseResolve, 0.1);
    } else {
      sessionStorage.setItem("locomotive.quickpreload", "true"),
        yt.set([t], { clearProps: "display" });
      let l = [];
      for (let u of t.children) l.push(new Ss(u, { type: "chars, lines" }));
      let c = mr(Array.from(i.children));
      o.set(c, { opacity: 0, stagger: 0.05 }, 0.25);
      for (let u = 0; u < l.length; u++) {
        let f = l[u];
        for (let d = 0; d < f.chars.length; d++) {
          let m = f.chars[d];
          o.set(m, { opacity: 0 }, 0),
            o.set(m, { opacity: 1 }, u * 0.25 + d * r),
            o.add(() => {
              let y = m.innerText;
              for (let g = 0; g < 5; g++)
                setTimeout(() => {
                  m.innerText = a[Math.floor(Math.random() * a.length)];
                }, g * 16);
              setTimeout(() => {
                m.innerText = y;
              }, 5 * 16);
            }, u * 0.25 + d * r);
          let x = u * 0.25 + d * r + s;
          m.parentNode == f.lines[f.lines.length - 1] &&
            (x = u * 0.25 + d * r + s + 1),
            o.add(() => {
              for (let y = 0; y < 5; y++)
                setTimeout(() => {
                  m.innerText = a[Math.floor(Math.random() * a.length)];
                }, y * 16);
              setTimeout(() => {
                yt.set(m, { opacity: 0 }),
                  m.parentNode == f.lines[f.lines.length - 1] &&
                    window.preloaderPromiseResolve();
              }, 5 * 16);
            }, x);
        }
      }
    }
  }
  var sN = new FS({ modules: aT });
  window.onload = (n) => {
    let e = document.getElementById("main-css");
    e
      ? e.isLoaded
        ? aN()
        : e.addEventListener("load", (t) => {
            aN();
          })
      : console.warn('The "main-css" stylesheet not found');
  };
  function aN() {
    Gt.classList.remove("has-no-js"),
      nN(),
      sN.init(sN),
      window.preloaderEnterPromise.then(() => {
        rN();
      }),
      window.preloaderPromise.then(() => {
        Gt.classList.add("is-loaded"),
          Gt.classList.add("is-ready"),
          Gt.classList.remove("is-first-loading"),
          Gt.classList.remove("is-loading");
      });
  }
})();
/*!
 * CSSPlugin 3.11.3
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
/*!
 * FilePond 4.30.4
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
/*!
 * FilePondPluginFileValidateSize 2.2.7
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
/*!
 * FilePondPluginFileValidateType 1.2.8
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
/*!
 * GSAP 3.11.3
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
/*!
 * SplitText: 3.11.3
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
/*!
 * strings: 3.11.3
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
/*!
 * vue-filepond v7.0.3
 * A handy FilePond adapter component for Vue
 *
 * Copyright (c) 2022 PQINA
 * https://pqina.nl/filepond
 *
 * Licensed under the MIT license.
 */
/*!
 * focus-trap 7.0.0
 * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
 */
/*!
 * tabbable 6.0.0
 * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
 */
/*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody */
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
//# sourceMappingURL=app.js.map
